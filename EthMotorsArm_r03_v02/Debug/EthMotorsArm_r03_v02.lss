
EthMotorsArm_r03_v02.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000c80c  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000074  20000000  0000c80c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  00020074  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  00020074  2**0
                  CONTENTS
  4 .bss          00009574  20000080  0000c8a0  00020080  2**5
                  ALLOC
  5 .stack        00010004  200095f4  00015e14  00020080  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  00020074  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  000200a2  2**0
                  CONTENTS, READONLY
  8 .debug_info   0005bad2  00000000  00000000  000200fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00008f0b  00000000  00000000  0007bbcd  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000204c4  00000000  00000000  00084ad8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00001710  00000000  00000000  000a4f9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001f50  00000000  00000000  000a66ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0003c3dc  00000000  00000000  000a85fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000267f4  00000000  00000000  000e49d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00112ea4  00000000  00000000  0010b1cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00004714  00000000  00000000  0021e070  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	f8 95 01 20 f1 02 00 00 ed 02 00 00 ed 02 00 00     ... ............
      10:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
      2c:	ed 02 00 00 ed 02 00 00 00 00 00 00 ed 02 00 00     ................
      3c:	1d 98 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      4c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      5c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      6c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      7c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      8c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      9c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      ac:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      bc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      cc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      dc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
      f4:	91 20 00 00 95 2a 00 00 a9 2a 00 00 bd 2a 00 00     . ...*...*...*..
     104:	d1 2a 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     .*..............
     114:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     124:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     134:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     144:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     154:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     164:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     174:	ed 02 00 00 00 00 00 00 00 00 00 00 ed 02 00 00     ................
     184:	ed 02 00 00 ed 02 00 00 ed 02 00 00 f9 1a 00 00     ................
     194:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1a4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1b4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1c4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1d4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1e4:	ed 02 00 00 ed 02 00 00 59 2d 00 00 ed 02 00 00     ........Y-......
     1f4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     204:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     214:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     224:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     234:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     244:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     254:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................

00000264 <__do_global_dtors_aux>:
     264:	b510      	push	{r4, lr}
     266:	4c05      	ldr	r4, [pc, #20]	; (27c <__do_global_dtors_aux+0x18>)
     268:	7823      	ldrb	r3, [r4, #0]
     26a:	b933      	cbnz	r3, 27a <__do_global_dtors_aux+0x16>
     26c:	4b04      	ldr	r3, [pc, #16]	; (280 <__do_global_dtors_aux+0x1c>)
     26e:	b113      	cbz	r3, 276 <__do_global_dtors_aux+0x12>
     270:	4804      	ldr	r0, [pc, #16]	; (284 <__do_global_dtors_aux+0x20>)
     272:	f3af 8000 	nop.w
     276:	2301      	movs	r3, #1
     278:	7023      	strb	r3, [r4, #0]
     27a:	bd10      	pop	{r4, pc}
     27c:	20000080 	.word	0x20000080
     280:	00000000 	.word	0x00000000
     284:	0000c80c 	.word	0x0000c80c

00000288 <frame_dummy>:
     288:	4b0c      	ldr	r3, [pc, #48]	; (2bc <frame_dummy+0x34>)
     28a:	b143      	cbz	r3, 29e <frame_dummy+0x16>
     28c:	480c      	ldr	r0, [pc, #48]	; (2c0 <frame_dummy+0x38>)
     28e:	490d      	ldr	r1, [pc, #52]	; (2c4 <frame_dummy+0x3c>)
     290:	b510      	push	{r4, lr}
     292:	f3af 8000 	nop.w
     296:	480c      	ldr	r0, [pc, #48]	; (2c8 <frame_dummy+0x40>)
     298:	6803      	ldr	r3, [r0, #0]
     29a:	b923      	cbnz	r3, 2a6 <frame_dummy+0x1e>
     29c:	bd10      	pop	{r4, pc}
     29e:	480a      	ldr	r0, [pc, #40]	; (2c8 <frame_dummy+0x40>)
     2a0:	6803      	ldr	r3, [r0, #0]
     2a2:	b933      	cbnz	r3, 2b2 <frame_dummy+0x2a>
     2a4:	4770      	bx	lr
     2a6:	4b09      	ldr	r3, [pc, #36]	; (2cc <frame_dummy+0x44>)
     2a8:	2b00      	cmp	r3, #0
     2aa:	d0f7      	beq.n	29c <frame_dummy+0x14>
     2ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     2b0:	4718      	bx	r3
     2b2:	4b06      	ldr	r3, [pc, #24]	; (2cc <frame_dummy+0x44>)
     2b4:	2b00      	cmp	r3, #0
     2b6:	d0f5      	beq.n	2a4 <frame_dummy+0x1c>
     2b8:	4718      	bx	r3
     2ba:	bf00      	nop
     2bc:	00000000 	.word	0x00000000
     2c0:	0000c80c 	.word	0x0000c80c
     2c4:	20000084 	.word	0x20000084
     2c8:	0000c80c 	.word	0x0000c80c
     2cc:	00000000 	.word	0x00000000

000002d0 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     2d0:	b508      	push	{r3, lr}
	system_init();
     2d2:	4b03      	ldr	r3, [pc, #12]	; (2e0 <atmel_start_init+0x10>)
     2d4:	4798      	blx	r3
	ethernet_phys_init();
     2d6:	4b03      	ldr	r3, [pc, #12]	; (2e4 <atmel_start_init+0x14>)
     2d8:	4798      	blx	r3
	stdio_redirect_init();
     2da:	4b03      	ldr	r3, [pc, #12]	; (2e8 <atmel_start_init+0x18>)
     2dc:	4798      	blx	r3
     2de:	bd08      	pop	{r3, pc}
     2e0:	000006f5 	.word	0x000006f5
     2e4:	00000dcd 	.word	0x00000dcd
     2e8:	00009f29 	.word	0x00009f29

000002ec <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     2ec:	e7fe      	b.n	2ec <Dummy_Handler>
	...

000002f0 <Reset_Handler>:
{
     2f0:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
     2f2:	4b1c      	ldr	r3, [pc, #112]	; (364 <Reset_Handler+0x74>)
     2f4:	4a1c      	ldr	r2, [pc, #112]	; (368 <Reset_Handler+0x78>)
     2f6:	429a      	cmp	r2, r3
     2f8:	d010      	beq.n	31c <Reset_Handler+0x2c>
                for (; pDest < &_erelocate;) {
     2fa:	4b1c      	ldr	r3, [pc, #112]	; (36c <Reset_Handler+0x7c>)
     2fc:	4a19      	ldr	r2, [pc, #100]	; (364 <Reset_Handler+0x74>)
     2fe:	429a      	cmp	r2, r3
     300:	d20c      	bcs.n	31c <Reset_Handler+0x2c>
     302:	3b01      	subs	r3, #1
     304:	1a9b      	subs	r3, r3, r2
     306:	f023 0303 	bic.w	r3, r3, #3
     30a:	3304      	adds	r3, #4
     30c:	4413      	add	r3, r2
     30e:	4916      	ldr	r1, [pc, #88]	; (368 <Reset_Handler+0x78>)
                        *pDest++ = *pSrc++;
     310:	f851 0b04 	ldr.w	r0, [r1], #4
     314:	f842 0b04 	str.w	r0, [r2], #4
                for (; pDest < &_erelocate;) {
     318:	429a      	cmp	r2, r3
     31a:	d1f9      	bne.n	310 <Reset_Handler+0x20>
        for (pDest = &_szero; pDest < &_ezero;) {
     31c:	4b14      	ldr	r3, [pc, #80]	; (370 <Reset_Handler+0x80>)
     31e:	4a15      	ldr	r2, [pc, #84]	; (374 <Reset_Handler+0x84>)
     320:	429a      	cmp	r2, r3
     322:	d20a      	bcs.n	33a <Reset_Handler+0x4a>
     324:	3b01      	subs	r3, #1
     326:	1a9b      	subs	r3, r3, r2
     328:	f023 0303 	bic.w	r3, r3, #3
     32c:	3304      	adds	r3, #4
     32e:	4413      	add	r3, r2
                *pDest++ = 0;
     330:	2100      	movs	r1, #0
     332:	f842 1b04 	str.w	r1, [r2], #4
        for (pDest = &_szero; pDest < &_ezero;) {
     336:	4293      	cmp	r3, r2
     338:	d1fb      	bne.n	332 <Reset_Handler+0x42>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     33a:	4b0f      	ldr	r3, [pc, #60]	; (378 <Reset_Handler+0x88>)
     33c:	4a0f      	ldr	r2, [pc, #60]	; (37c <Reset_Handler+0x8c>)
     33e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
     342:	609a      	str	r2, [r3, #8]
        SCB->CPACR |=  (0xFu << 20);
     344:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
     348:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
     34c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
     350:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     354:	f3bf 8f6f 	isb	sy
        __libc_init_array();
     358:	4b09      	ldr	r3, [pc, #36]	; (380 <Reset_Handler+0x90>)
     35a:	4798      	blx	r3
        main();
     35c:	4b09      	ldr	r3, [pc, #36]	; (384 <Reset_Handler+0x94>)
     35e:	4798      	blx	r3
     360:	e7fe      	b.n	360 <Reset_Handler+0x70>
     362:	bf00      	nop
     364:	20000000 	.word	0x20000000
     368:	0000c80c 	.word	0x0000c80c
     36c:	20000074 	.word	0x20000074
     370:	200095f4 	.word	0x200095f4
     374:	20000080 	.word	0x20000080
     378:	e000ed00 	.word	0xe000ed00
     37c:	00000000 	.word	0x00000000
     380:	00009f49 	.word	0x00009f49
     384:	00009bed 	.word	0x00009bed

00000388 <USART_1_CLOCK_init>:
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     388:	4b05      	ldr	r3, [pc, #20]	; (3a0 <USART_1_CLOCK_init+0x18>)
     38a:	2242      	movs	r2, #66	; 0x42
     38c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
     390:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBAMASK_SERCOM0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM0;
     394:	4a03      	ldr	r2, [pc, #12]	; (3a4 <USART_1_CLOCK_init+0x1c>)
     396:	6953      	ldr	r3, [r2, #20]
     398:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
     39c:	6153      	str	r3, [r2, #20]
     39e:	4770      	bx	lr
     3a0:	40001c00 	.word	0x40001c00
     3a4:	40000800 	.word	0x40000800

000003a8 <USART_1_PORT_init>:
static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     3a8:	4b10      	ldr	r3, [pc, #64]	; (3ec <USART_1_PORT_init+0x44>)
     3aa:	f893 2151 	ldrb.w	r2, [r3, #337]	; 0x151
	tmp &= ~PORT_PINCFG_PMUXEN;
     3ae:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     3b2:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3b6:	f883 2151 	strb.w	r2, [r3, #337]	; 0x151
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     3ba:	f893 2138 	ldrb.w	r2, [r3, #312]	; 0x138
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     3be:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     3c2:	f042 0230 	orr.w	r2, r2, #48	; 0x30
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     3c6:	f883 2138 	strb.w	r2, [r3, #312]	; 0x138
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     3ca:	f893 2150 	ldrb.w	r2, [r3, #336]	; 0x150
	tmp &= ~PORT_PINCFG_PMUXEN;
     3ce:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     3d2:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3d6:	f883 2150 	strb.w	r2, [r3, #336]	; 0x150
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     3da:	f893 2138 	ldrb.w	r2, [r3, #312]	; 0x138
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     3de:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     3e2:	f042 0203 	orr.w	r2, r2, #3
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     3e6:	f883 2138 	strb.w	r2, [r3, #312]	; 0x138
     3ea:	4770      	bx	lr
     3ec:	41008000 	.word	0x41008000

000003f0 <USART_1_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_1_init(void)
{
     3f0:	b510      	push	{r4, lr}
     3f2:	b082      	sub	sp, #8
	USART_1_CLOCK_init();
     3f4:	4b07      	ldr	r3, [pc, #28]	; (414 <USART_1_init+0x24>)
     3f6:	4798      	blx	r3
	usart_async_init(&USART_1, SERCOM0, USART_1_buffer, USART_1_BUFFER_SIZE, (void *)NULL);
     3f8:	2300      	movs	r3, #0
     3fa:	9300      	str	r3, [sp, #0]
     3fc:	f44f 7380 	mov.w	r3, #256	; 0x100
     400:	4a05      	ldr	r2, [pc, #20]	; (418 <USART_1_init+0x28>)
     402:	4906      	ldr	r1, [pc, #24]	; (41c <USART_1_init+0x2c>)
     404:	4806      	ldr	r0, [pc, #24]	; (420 <USART_1_init+0x30>)
     406:	4c07      	ldr	r4, [pc, #28]	; (424 <USART_1_init+0x34>)
     408:	47a0      	blx	r4
	USART_1_PORT_init();
     40a:	4b07      	ldr	r3, [pc, #28]	; (428 <USART_1_init+0x38>)
     40c:	4798      	blx	r3
}
     40e:	b002      	add	sp, #8
     410:	bd10      	pop	{r4, pc}
     412:	bf00      	nop
     414:	00000389 	.word	0x00000389
     418:	2000009c 	.word	0x2000009c
     41c:	40003000 	.word	0x40003000
     420:	200081fc 	.word	0x200081fc
     424:	00001599 	.word	0x00001599
     428:	000003a9 	.word	0x000003a9

0000042c <USART_0_PORT_init>:
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     42c:	4b10      	ldr	r3, [pc, #64]	; (470 <USART_0_PORT_init+0x44>)
     42e:	f893 215b 	ldrb.w	r2, [r3, #347]	; 0x15b
	tmp &= ~PORT_PINCFG_PMUXEN;
     432:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     436:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     43a:	f883 215b 	strb.w	r2, [r3, #347]	; 0x15b
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     43e:	f893 213d 	ldrb.w	r2, [r3, #317]	; 0x13d
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     442:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     446:	f042 0220 	orr.w	r2, r2, #32
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     44a:	f883 213d 	strb.w	r2, [r3, #317]	; 0x13d
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     44e:	f893 215c 	ldrb.w	r2, [r3, #348]	; 0x15c
	tmp &= ~PORT_PINCFG_PMUXEN;
     452:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     456:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     45a:	f883 215c 	strb.w	r2, [r3, #348]	; 0x15c
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     45e:	f893 213e 	ldrb.w	r2, [r3, #318]	; 0x13e
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     462:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     466:	f042 0202 	orr.w	r2, r2, #2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     46a:	f883 213e 	strb.w	r2, [r3, #318]	; 0x13e
     46e:	4770      	bx	lr
     470:	41008000 	.word	0x41008000

00000474 <USART_0_CLOCK_init>:
     474:	4b05      	ldr	r3, [pc, #20]	; (48c <USART_0_CLOCK_init+0x18>)
     476:	2242      	movs	r2, #66	; 0x42
     478:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
     47c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBAMASK_SERCOM1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM1;
     480:	4a03      	ldr	r2, [pc, #12]	; (490 <USART_0_CLOCK_init+0x1c>)
     482:	6953      	ldr	r3, [r2, #20]
     484:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
     488:	6153      	str	r3, [r2, #20]
     48a:	4770      	bx	lr
     48c:	40001c00 	.word	0x40001c00
     490:	40000800 	.word	0x40000800

00000494 <USART_0_init>:

	hri_mclk_set_APBAMASK_SERCOM1_bit(MCLK);
}

void USART_0_init(void)
{
     494:	b508      	push	{r3, lr}
	USART_0_CLOCK_init();
     496:	4b05      	ldr	r3, [pc, #20]	; (4ac <USART_0_init+0x18>)
     498:	4798      	blx	r3
	usart_sync_init(&USART_0, SERCOM1, (void *)NULL);
     49a:	2200      	movs	r2, #0
     49c:	4904      	ldr	r1, [pc, #16]	; (4b0 <USART_0_init+0x1c>)
     49e:	4805      	ldr	r0, [pc, #20]	; (4b4 <USART_0_init+0x20>)
     4a0:	4b05      	ldr	r3, [pc, #20]	; (4b8 <USART_0_init+0x24>)
     4a2:	4798      	blx	r3
	USART_0_PORT_init();
     4a4:	4b05      	ldr	r3, [pc, #20]	; (4bc <USART_0_init+0x28>)
     4a6:	4798      	blx	r3
     4a8:	bd08      	pop	{r3, pc}
     4aa:	bf00      	nop
     4ac:	00000475 	.word	0x00000475
     4b0:	40003400 	.word	0x40003400
     4b4:	200081f0 	.word	0x200081f0
     4b8:	000017c5 	.word	0x000017c5
     4bc:	0000042d 	.word	0x0000042d

000004c0 <I2C_0_PORT_init>:
}

static inline void hri_port_clear_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     4c0:	4b16      	ldr	r3, [pc, #88]	; (51c <I2C_0_PORT_init+0x5c>)
     4c2:	f893 2056 	ldrb.w	r2, [r3, #86]	; 0x56
     4c6:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     4ca:	f883 2056 	strb.w	r2, [r3, #86]	; 0x56
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     4ce:	f893 2056 	ldrb.w	r2, [r3, #86]	; 0x56
	tmp &= ~PORT_PINCFG_PMUXEN;
     4d2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     4d6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     4da:	f883 2056 	strb.w	r2, [r3, #86]	; 0x56
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     4de:	f893 203b 	ldrb.w	r2, [r3, #59]	; 0x3b
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     4e2:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     4e6:	f042 0202 	orr.w	r2, r2, #2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     4ea:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     4ee:	f893 2057 	ldrb.w	r2, [r3, #87]	; 0x57
     4f2:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     4f6:	f883 2057 	strb.w	r2, [r3, #87]	; 0x57
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     4fa:	f893 2057 	ldrb.w	r2, [r3, #87]	; 0x57
	tmp &= ~PORT_PINCFG_PMUXEN;
     4fe:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     502:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     506:	f883 2057 	strb.w	r2, [r3, #87]	; 0x57
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     50a:	f893 203b 	ldrb.w	r2, [r3, #59]	; 0x3b
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     50e:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     512:	f042 0220 	orr.w	r2, r2, #32
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     516:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
     51a:	4770      	bx	lr
     51c:	41008000 	.word	0x41008000

00000520 <I2C_0_CLOCK_init>:
     520:	4b06      	ldr	r3, [pc, #24]	; (53c <I2C_0_CLOCK_init+0x1c>)
     522:	2240      	movs	r2, #64	; 0x40
     524:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
     528:	2242      	movs	r2, #66	; 0x42
     52a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBBMASK_SERCOM3_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM3;
     52e:	4a04      	ldr	r2, [pc, #16]	; (540 <I2C_0_CLOCK_init+0x20>)
     530:	6993      	ldr	r3, [r2, #24]
     532:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
     536:	6193      	str	r3, [r2, #24]
     538:	4770      	bx	lr
     53a:	bf00      	nop
     53c:	40001c00 	.word	0x40001c00
     540:	40000800 	.word	0x40000800

00000544 <I2C_0_init>:

	hri_mclk_set_APBBMASK_SERCOM3_bit(MCLK);
}

void I2C_0_init(void)
{
     544:	b508      	push	{r3, lr}
	I2C_0_CLOCK_init();
     546:	4b04      	ldr	r3, [pc, #16]	; (558 <I2C_0_init+0x14>)
     548:	4798      	blx	r3
	i2c_m_sync_init(&I2C_0, SERCOM3);
     54a:	4904      	ldr	r1, [pc, #16]	; (55c <I2C_0_init+0x18>)
     54c:	4804      	ldr	r0, [pc, #16]	; (560 <I2C_0_init+0x1c>)
     54e:	4b05      	ldr	r3, [pc, #20]	; (564 <I2C_0_init+0x20>)
     550:	4798      	blx	r3
	I2C_0_PORT_init();
     552:	4b05      	ldr	r3, [pc, #20]	; (568 <I2C_0_init+0x24>)
     554:	4798      	blx	r3
     556:	bd08      	pop	{r3, pc}
     558:	00000521 	.word	0x00000521
     55c:	41014000 	.word	0x41014000
     560:	2000824c 	.word	0x2000824c
     564:	00000f51 	.word	0x00000f51
     568:	000004c1 	.word	0x000004c1

0000056c <ETHERNET_MAC_0_PORT_init>:
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     56c:	4b50      	ldr	r3, [pc, #320]	; (6b0 <ETHERNET_MAC_0_PORT_init+0x144>)
     56e:	f893 214b 	ldrb.w	r2, [r3, #331]	; 0x14b
	tmp &= ~PORT_PINCFG_PMUXEN;
     572:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     576:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     57a:	f883 214b 	strb.w	r2, [r3, #331]	; 0x14b
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     57e:	f893 2135 	ldrb.w	r2, [r3, #309]	; 0x135
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     582:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     586:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     58a:	f883 2135 	strb.w	r2, [r3, #309]	; 0x135
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     58e:	f893 214c 	ldrb.w	r2, [r3, #332]	; 0x14c
	tmp &= ~PORT_PINCFG_PMUXEN;
     592:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     596:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     59a:	f883 214c 	strb.w	r2, [r3, #332]	; 0x14c
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     59e:	f893 2136 	ldrb.w	r2, [r3, #310]	; 0x136
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     5a2:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     5a6:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5aa:	f883 2136 	strb.w	r2, [r3, #310]	; 0x136
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5ae:	f893 204d 	ldrb.w	r2, [r3, #77]	; 0x4d
	tmp &= ~PORT_PINCFG_PMUXEN;
     5b2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5b6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5ba:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5be:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     5c2:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     5c6:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5ca:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5ce:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
	tmp &= ~PORT_PINCFG_PMUXEN;
     5d2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5d6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5da:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5de:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     5e2:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     5e6:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5ea:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5ee:	f893 2154 	ldrb.w	r2, [r3, #340]	; 0x154
	tmp &= ~PORT_PINCFG_PMUXEN;
     5f2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5f6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5fa:	f883 2154 	strb.w	r2, [r3, #340]	; 0x154
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5fe:	f893 213a 	ldrb.w	r2, [r3, #314]	; 0x13a
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     602:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     606:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     60a:	f883 213a 	strb.w	r2, [r3, #314]	; 0x13a
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     60e:	f893 204f 	ldrb.w	r2, [r3, #79]	; 0x4f
	tmp &= ~PORT_PINCFG_PMUXEN;
     612:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     616:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     61a:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     61e:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     622:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     626:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     62a:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     62e:	f893 2052 	ldrb.w	r2, [r3, #82]	; 0x52
	tmp &= ~PORT_PINCFG_PMUXEN;
     632:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     636:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     63a:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     63e:	f893 2039 	ldrb.w	r2, [r3, #57]	; 0x39
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     642:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     646:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     64a:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     64e:	f893 2053 	ldrb.w	r2, [r3, #83]	; 0x53
	tmp &= ~PORT_PINCFG_PMUXEN;
     652:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     656:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     65a:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     65e:	f893 2039 	ldrb.w	r2, [r3, #57]	; 0x39
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     662:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     666:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     66a:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     66e:	f893 204e 	ldrb.w	r2, [r3, #78]	; 0x4e
	tmp &= ~PORT_PINCFG_PMUXEN;
     672:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     676:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     67a:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     67e:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     682:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     686:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     68a:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     68e:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
	tmp &= ~PORT_PINCFG_PMUXEN;
     692:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     696:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     69a:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     69e:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     6a2:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     6a6:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     6aa:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
     6ae:	4770      	bx	lr
     6b0:	41008000 	.word	0x41008000

000006b4 <ETHERNET_MAC_0_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_GMAC;
     6b4:	4b04      	ldr	r3, [pc, #16]	; (6c8 <ETHERNET_MAC_0_CLOCK_init+0x14>)
     6b6:	691a      	ldr	r2, [r3, #16]
     6b8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
     6bc:	611a      	str	r2, [r3, #16]
}

static inline void hri_mclk_set_APBCMASK_GMAC_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_GMAC;
     6be:	69da      	ldr	r2, [r3, #28]
     6c0:	f042 0204 	orr.w	r2, r2, #4
     6c4:	61da      	str	r2, [r3, #28]
     6c6:	4770      	bx	lr
     6c8:	40000800 	.word	0x40000800

000006cc <ETHERNET_MAC_0_init>:
	hri_mclk_set_AHBMASK_GMAC_bit(MCLK);
	hri_mclk_set_APBCMASK_GMAC_bit(MCLK);
}

void ETHERNET_MAC_0_init(void)
{
     6cc:	b508      	push	{r3, lr}
	ETHERNET_MAC_0_CLOCK_init();
     6ce:	4b04      	ldr	r3, [pc, #16]	; (6e0 <ETHERNET_MAC_0_init+0x14>)
     6d0:	4798      	blx	r3
	mac_async_init(&ETHERNET_MAC_0, GMAC);
     6d2:	4904      	ldr	r1, [pc, #16]	; (6e4 <ETHERNET_MAC_0_init+0x18>)
     6d4:	4804      	ldr	r0, [pc, #16]	; (6e8 <ETHERNET_MAC_0_init+0x1c>)
     6d6:	4b05      	ldr	r3, [pc, #20]	; (6ec <ETHERNET_MAC_0_init+0x20>)
     6d8:	4798      	blx	r3
	ETHERNET_MAC_0_PORT_init();
     6da:	4b05      	ldr	r3, [pc, #20]	; (6f0 <ETHERNET_MAC_0_init+0x24>)
     6dc:	4798      	blx	r3
     6de:	bd08      	pop	{r3, pc}
     6e0:	000006b5 	.word	0x000006b5
     6e4:	42000800 	.word	0x42000800
     6e8:	2000826c 	.word	0x2000826c
     6ec:	00001005 	.word	0x00001005
     6f0:	0000056d 	.word	0x0000056d

000006f4 <system_init>:
	mac_async_enable(&ETHERNET_MAC_0);
	mac_async_write(&ETHERNET_MAC_0, (uint8_t *)"Hello World!", 12);
}

void system_init(void)
{
     6f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     6f8:	4be2      	ldr	r3, [pc, #904]	; (a84 <system_init+0x390>)
     6fa:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     6fc:	4be2      	ldr	r3, [pc, #904]	; (a88 <system_init+0x394>)
     6fe:	2210      	movs	r2, #16
     700:	615a      	str	r2, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     702:	609a      	str	r2, [r3, #8]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     704:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     708:	629a      	str	r2, [r3, #40]	; 0x28
     70a:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
     70e:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     710:	f893 1044 	ldrb.w	r1, [r3, #68]	; 0x44
	tmp &= ~PORT_PINCFG_PMUXEN;
     714:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     718:	f883 1044 	strb.w	r1, [r3, #68]	; 0x44
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     71c:	2120      	movs	r1, #32
     71e:	6159      	str	r1, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     720:	6099      	str	r1, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     722:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
     726:	6299      	str	r1, [r3, #40]	; 0x28
     728:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     72a:	f893 1045 	ldrb.w	r1, [r3, #69]	; 0x45
	tmp &= ~PORT_PINCFG_PMUXEN;
     72e:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     732:	f883 1045 	strb.w	r1, [r3, #69]	; 0x45
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     736:	f04f 0a40 	mov.w	sl, #64	; 0x40
     73a:	f8c3 a014 	str.w	sl, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     73e:	f8c3 a008 	str.w	sl, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     742:	49d2      	ldr	r1, [pc, #840]	; (a8c <system_init+0x398>)
     744:	6299      	str	r1, [r3, #40]	; 0x28
     746:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     748:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	tmp &= ~PORT_PINCFG_PMUXEN;
     74c:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     750:	f883 1046 	strb.w	r1, [r3, #70]	; 0x46
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     754:	f04f 0980 	mov.w	r9, #128	; 0x80
     758:	f8c3 9014 	str.w	r9, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     75c:	f8c3 9008 	str.w	r9, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     760:	49cb      	ldr	r1, [pc, #812]	; (a90 <system_init+0x39c>)
     762:	6299      	str	r1, [r3, #40]	; 0x28
     764:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     766:	f893 1047 	ldrb.w	r1, [r3, #71]	; 0x47
	tmp &= ~PORT_PINCFG_PMUXEN;
     76a:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     76e:	f883 1047 	strb.w	r1, [r3, #71]	; 0x47
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     772:	f44f 7880 	mov.w	r8, #256	; 0x100
     776:	f8c3 8014 	str.w	r8, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     77a:	f8c3 8008 	str.w	r8, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     77e:	49c5      	ldr	r1, [pc, #788]	; (a94 <system_init+0x3a0>)
     780:	6299      	str	r1, [r3, #40]	; 0x28
     782:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     784:	f893 1048 	ldrb.w	r1, [r3, #72]	; 0x48
	tmp &= ~PORT_PINCFG_PMUXEN;
     788:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     78c:	f883 1048 	strb.w	r1, [r3, #72]	; 0x48
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     790:	f44f 7c00 	mov.w	ip, #512	; 0x200
     794:	f8c3 c014 	str.w	ip, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     798:	f8c3 c008 	str.w	ip, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     79c:	49be      	ldr	r1, [pc, #760]	; (a98 <system_init+0x3a4>)
     79e:	6299      	str	r1, [r3, #40]	; 0x28
     7a0:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     7a2:	f893 1049 	ldrb.w	r1, [r3, #73]	; 0x49
	tmp &= ~PORT_PINCFG_PMUXEN;
     7a6:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     7aa:	f883 1049 	strb.w	r1, [r3, #73]	; 0x49
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     7ae:	f44f 6e80 	mov.w	lr, #1024	; 0x400
     7b2:	f8c3 e014 	str.w	lr, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     7b6:	f8c3 e008 	str.w	lr, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     7ba:	49b8      	ldr	r1, [pc, #736]	; (a9c <system_init+0x3a8>)
     7bc:	6299      	str	r1, [r3, #40]	; 0x28
     7be:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     7c0:	f893 104a 	ldrb.w	r1, [r3, #74]	; 0x4a
	tmp &= ~PORT_PINCFG_PMUXEN;
     7c4:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     7c8:	f883 104a 	strb.w	r1, [r3, #74]	; 0x4a
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     7cc:	f44f 6700 	mov.w	r7, #2048	; 0x800
     7d0:	615f      	str	r7, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     7d2:	609f      	str	r7, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     7d4:	49b2      	ldr	r1, [pc, #712]	; (aa0 <system_init+0x3ac>)
     7d6:	6299      	str	r1, [r3, #40]	; 0x28
     7d8:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     7da:	f893 104b 	ldrb.w	r1, [r3, #75]	; 0x4b
	tmp &= ~PORT_PINCFG_PMUXEN;
     7de:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     7e2:	f883 104b 	strb.w	r1, [r3, #75]	; 0x4b
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     7e6:	f44f 1680 	mov.w	r6, #1048576	; 0x100000
     7ea:	615e      	str	r6, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     7ec:	609e      	str	r6, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     7ee:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
     7f2:	6299      	str	r1, [r3, #40]	; 0x28
     7f4:	48ab      	ldr	r0, [pc, #684]	; (aa4 <system_init+0x3b0>)
     7f6:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     7f8:	f893 0054 	ldrb.w	r0, [r3, #84]	; 0x54
	tmp &= ~PORT_PINCFG_PMUXEN;
     7fc:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     800:	f883 0054 	strb.w	r0, [r3, #84]	; 0x54
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     804:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
     808:	6158      	str	r0, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     80a:	6098      	str	r0, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     80c:	6299      	str	r1, [r3, #40]	; 0x28
     80e:	48a6      	ldr	r0, [pc, #664]	; (aa8 <system_init+0x3b4>)
     810:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     812:	f893 0055 	ldrb.w	r0, [r3, #85]	; 0x55
	tmp &= ~PORT_PINCFG_PMUXEN;
     816:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     81a:	f883 0055 	strb.w	r0, [r3, #85]	; 0x55
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     81e:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
     822:	615c      	str	r4, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     824:	609c      	str	r4, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     826:	6299      	str	r1, [r3, #40]	; 0x28
     828:	48a0      	ldr	r0, [pc, #640]	; (aac <system_init+0x3b8>)
     82a:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     82c:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
	tmp &= ~PORT_PINCFG_PMUXEN;
     830:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     834:	f883 0058 	strb.w	r0, [r3, #88]	; 0x58
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     838:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
     83c:	6158      	str	r0, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     83e:	6098      	str	r0, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     840:	6299      	str	r1, [r3, #40]	; 0x28
     842:	4d9b      	ldr	r5, [pc, #620]	; (ab0 <system_init+0x3bc>)
     844:	629d      	str	r5, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     846:	f893 b059 	ldrb.w	fp, [r3, #89]	; 0x59
	tmp &= ~PORT_PINCFG_PMUXEN;
     84a:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     84e:	f883 b059 	strb.w	fp, [r3, #89]	; 0x59
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     852:	f04f 0b01 	mov.w	fp, #1
     856:	f8c3 b094 	str.w	fp, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     85a:	f8c3 b088 	str.w	fp, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     85e:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
     862:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     866:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     86a:	f893 b0c0 	ldrb.w	fp, [r3, #192]	; 0xc0
	tmp &= ~PORT_PINCFG_PMUXEN;
     86e:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     872:	f883 b0c0 	strb.w	fp, [r3, #192]	; 0xc0
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     876:	f04f 0b02 	mov.w	fp, #2
     87a:	f8c3 b094 	str.w	fp, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     87e:	f8c3 b088 	str.w	fp, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     882:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
     886:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     88a:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     88e:	f893 b0c1 	ldrb.w	fp, [r3, #193]	; 0xc1
	tmp &= ~PORT_PINCFG_PMUXEN;
     892:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     896:	f883 b0c1 	strb.w	fp, [r3, #193]	; 0xc1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     89a:	f04f 0b04 	mov.w	fp, #4
     89e:	f8c3 b094 	str.w	fp, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     8a2:	f8c3 b088 	str.w	fp, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     8a6:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
     8aa:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     8ae:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8b2:	f893 b0c2 	ldrb.w	fp, [r3, #194]	; 0xc2
	tmp &= ~PORT_PINCFG_PMUXEN;
     8b6:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8ba:	f883 b0c2 	strb.w	fp, [r3, #194]	; 0xc2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     8be:	f04f 0b08 	mov.w	fp, #8
     8c2:	f8c3 b094 	str.w	fp, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     8c6:	f8c3 b088 	str.w	fp, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     8ca:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
     8ce:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     8d2:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8d6:	f893 b0c3 	ldrb.w	fp, [r3, #195]	; 0xc3
	tmp &= ~PORT_PINCFG_PMUXEN;
     8da:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8de:	f883 b0c3 	strb.w	fp, [r3, #195]	; 0xc3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     8e2:	f8c3 a094 	str.w	sl, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     8e6:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     8ea:	4d68      	ldr	r5, [pc, #416]	; (a8c <system_init+0x398>)
     8ec:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     8f0:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8f4:	f893 a0c6 	ldrb.w	sl, [r3, #198]	; 0xc6
	tmp &= ~PORT_PINCFG_PMUXEN;
     8f8:	f00a 0afe 	and.w	sl, sl, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8fc:	f883 a0c6 	strb.w	sl, [r3, #198]	; 0xc6
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     900:	f8c3 9094 	str.w	r9, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     904:	f8c3 9088 	str.w	r9, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     908:	3540      	adds	r5, #64	; 0x40
     90a:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     90e:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     912:	f893 90c7 	ldrb.w	r9, [r3, #199]	; 0xc7
	tmp &= ~PORT_PINCFG_PMUXEN;
     916:	f009 09fe 	and.w	r9, r9, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     91a:	f883 90c7 	strb.w	r9, [r3, #199]	; 0xc7
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     91e:	f8c3 8094 	str.w	r8, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     922:	f8c3 8088 	str.w	r8, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     926:	3580      	adds	r5, #128	; 0x80
     928:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     92c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     930:	f893 80c8 	ldrb.w	r8, [r3, #200]	; 0xc8
	tmp &= ~PORT_PINCFG_PMUXEN;
     934:	f008 08fe 	and.w	r8, r8, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     938:	f883 80c8 	strb.w	r8, [r3, #200]	; 0xc8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     93c:	f8c3 c094 	str.w	ip, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     940:	f8c3 c088 	str.w	ip, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     944:	f505 7580 	add.w	r5, r5, #256	; 0x100
     948:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     94c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     950:	f893 c0c9 	ldrb.w	ip, [r3, #201]	; 0xc9
	tmp &= ~PORT_PINCFG_PMUXEN;
     954:	f00c 0cfe 	and.w	ip, ip, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     958:	f883 c0c9 	strb.w	ip, [r3, #201]	; 0xc9
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     95c:	f8c3 e094 	str.w	lr, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     960:	f8c3 e088 	str.w	lr, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     964:	f505 7500 	add.w	r5, r5, #512	; 0x200
     968:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     96c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     970:	f893 e0ca 	ldrb.w	lr, [r3, #202]	; 0xca
	tmp &= ~PORT_PINCFG_PMUXEN;
     974:	f00e 0efe 	and.w	lr, lr, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     978:	f883 e0ca 	strb.w	lr, [r3, #202]	; 0xca
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     97c:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     980:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     984:	f505 6580 	add.w	r5, r5, #1024	; 0x400
     988:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     98c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     990:	f893 70cb 	ldrb.w	r7, [r3, #203]	; 0xcb
	tmp &= ~PORT_PINCFG_PMUXEN;
     994:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     998:	f883 70cb 	strb.w	r7, [r3, #203]	; 0xcb
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     99c:	f44f 5780 	mov.w	r7, #4096	; 0x1000
     9a0:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     9a4:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     9a8:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
     9ac:	f8c3 70a8 	str.w	r7, [r3, #168]	; 0xa8
     9b0:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     9b4:	f893 70cc 	ldrb.w	r7, [r3, #204]	; 0xcc
	tmp &= ~PORT_PINCFG_PMUXEN;
     9b8:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     9bc:	f883 70cc 	strb.w	r7, [r3, #204]	; 0xcc
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     9c0:	f44f 5700 	mov.w	r7, #8192	; 0x2000
     9c4:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     9c8:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     9cc:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
     9d0:	f8c3 70a8 	str.w	r7, [r3, #168]	; 0xa8
     9d4:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     9d8:	f893 70cd 	ldrb.w	r7, [r3, #205]	; 0xcd
	tmp &= ~PORT_PINCFG_PMUXEN;
     9dc:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     9e0:	f883 70cd 	strb.w	r7, [r3, #205]	; 0xcd
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     9e4:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
     9e8:	f8c3 c094 	str.w	ip, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     9ec:	f8c3 c088 	str.w	ip, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     9f0:	f04f 2b40 	mov.w	fp, #1073758208	; 0x40004000
     9f4:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     9f8:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     9fc:	f893 70ce 	ldrb.w	r7, [r3, #206]	; 0xce
	tmp &= ~PORT_PINCFG_PMUXEN;
     a00:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a04:	f883 70ce 	strb.w	r7, [r3, #206]	; 0xce
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a08:	f44f 3780 	mov.w	r7, #65536	; 0x10000
     a0c:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a10:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a14:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     a18:	4f26      	ldr	r7, [pc, #152]	; (ab4 <system_init+0x3c0>)
     a1a:	f8c3 70a8 	str.w	r7, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a1e:	f893 70d0 	ldrb.w	r7, [r3, #208]	; 0xd0
	tmp &= ~PORT_PINCFG_PMUXEN;
     a22:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a26:	f883 70d0 	strb.w	r7, [r3, #208]	; 0xd0
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a2a:	f44f 3700 	mov.w	r7, #131072	; 0x20000
     a2e:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a32:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a36:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     a3a:	4f1f      	ldr	r7, [pc, #124]	; (ab8 <system_init+0x3c4>)
     a3c:	f8c3 70a8 	str.w	r7, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a40:	f893 70d1 	ldrb.w	r7, [r3, #209]	; 0xd1
	tmp &= ~PORT_PINCFG_PMUXEN;
     a44:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a48:	f883 70d1 	strb.w	r7, [r3, #209]	; 0xd1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a4c:	f44f 2e80 	mov.w	lr, #262144	; 0x40000
     a50:	f8c3 e094 	str.w	lr, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a54:	f8c3 e088 	str.w	lr, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a58:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     a5c:	f8df a05c 	ldr.w	sl, [pc, #92]	; abc <system_init+0x3c8>
     a60:	f8c3 a0a8 	str.w	sl, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a64:	f893 70d2 	ldrb.w	r7, [r3, #210]	; 0xd2
	tmp &= ~PORT_PINCFG_PMUXEN;
     a68:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a6c:	f883 70d2 	strb.w	r7, [r3, #210]	; 0xd2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a70:	f44f 2700 	mov.w	r7, #524288	; 0x80000
     a74:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a78:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a7c:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     a80:	e01e      	b.n	ac0 <system_init+0x3cc>
     a82:	bf00      	nop
     a84:	00001a41 	.word	0x00001a41
     a88:	41008000 	.word	0x41008000
     a8c:	40000040 	.word	0x40000040
     a90:	40000080 	.word	0x40000080
     a94:	40000100 	.word	0x40000100
     a98:	40000200 	.word	0x40000200
     a9c:	40000400 	.word	0x40000400
     aa0:	40000800 	.word	0x40000800
     aa4:	c0000010 	.word	0xc0000010
     aa8:	c0000020 	.word	0xc0000020
     aac:	c0000100 	.word	0xc0000100
     ab0:	c0000200 	.word	0xc0000200
     ab4:	c0000001 	.word	0xc0000001
     ab8:	c0000002 	.word	0xc0000002
     abc:	c0000004 	.word	0xc0000004
     ac0:	f8df 918c 	ldr.w	r9, [pc, #396]	; c50 <system_init+0x55c>
     ac4:	f8c3 90a8 	str.w	r9, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     ac8:	f893 80d3 	ldrb.w	r8, [r3, #211]	; 0xd3
	tmp &= ~PORT_PINCFG_PMUXEN;
     acc:	f008 08fe 	and.w	r8, r8, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     ad0:	f883 80d3 	strb.w	r8, [r3, #211]	; 0xd3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     ad4:	f8c3 6094 	str.w	r6, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     ad8:	f8c3 6088 	str.w	r6, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     adc:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     ae0:	4d4d      	ldr	r5, [pc, #308]	; (c18 <system_init+0x524>)
     ae2:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     ae6:	f893 60d4 	ldrb.w	r6, [r3, #212]	; 0xd4
	tmp &= ~PORT_PINCFG_PMUXEN;
     aea:	f006 06fe 	and.w	r6, r6, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     aee:	f883 60d4 	strb.w	r6, [r3, #212]	; 0xd4
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     af2:	f44f 1500 	mov.w	r5, #2097152	; 0x200000
     af6:	f8c3 5094 	str.w	r5, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     afa:	f8c3 5088 	str.w	r5, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     afe:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     b02:	4d46      	ldr	r5, [pc, #280]	; (c1c <system_init+0x528>)
     b04:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b08:	f893 50d5 	ldrb.w	r5, [r3, #213]	; 0xd5
	tmp &= ~PORT_PINCFG_PMUXEN;
     b0c:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b10:	f883 50d5 	strb.w	r5, [r3, #213]	; 0xd5
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b14:	f8c3 4094 	str.w	r4, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b18:	f8c3 4088 	str.w	r4, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b1c:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     b20:	4d3f      	ldr	r5, [pc, #252]	; (c20 <system_init+0x52c>)
     b22:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b26:	f893 50d8 	ldrb.w	r5, [r3, #216]	; 0xd8
	tmp &= ~PORT_PINCFG_PMUXEN;
     b2a:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b2e:	f883 50d8 	strb.w	r5, [r3, #216]	; 0xd8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b32:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b36:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b3a:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     b3e:	4d39      	ldr	r5, [pc, #228]	; (c24 <system_init+0x530>)
     b40:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b44:	f893 50d9 	ldrb.w	r5, [r3, #217]	; 0xd9
	tmp &= ~PORT_PINCFG_PMUXEN;
     b48:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b4c:	f883 50d9 	strb.w	r5, [r3, #217]	; 0xd9
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     b50:	f8c3 c118 	str.w	ip, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b54:	f8c3 c108 	str.w	ip, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b58:	f8c3 b128 	str.w	fp, [r3, #296]	; 0x128
     b5c:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b60:	f893 214e 	ldrb.w	r2, [r3, #334]	; 0x14e
	tmp &= ~PORT_PINCFG_PMUXEN;
     b64:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b68:	f883 214e 	strb.w	r2, [r3, #334]	; 0x14e
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b6c:	f8c3 e114 	str.w	lr, [r3, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b70:	f8c3 e108 	str.w	lr, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b74:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
     b78:	f8c3 a128 	str.w	sl, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b7c:	f893 2152 	ldrb.w	r2, [r3, #338]	; 0x152
	tmp &= ~PORT_PINCFG_PMUXEN;
     b80:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b84:	f883 2152 	strb.w	r2, [r3, #338]	; 0x152
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b88:	f8c3 7114 	str.w	r7, [r3, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b8c:	f8c3 7108 	str.w	r7, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b90:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
     b94:	f8c3 9128 	str.w	r9, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b98:	f893 2153 	ldrb.w	r2, [r3, #339]	; 0x153
	tmp &= ~PORT_PINCFG_PMUXEN;
     b9c:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     ba0:	f883 2153 	strb.w	r2, [r3, #339]	; 0x153
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     ba4:	f8c3 4114 	str.w	r4, [r3, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     ba8:	f8c3 4108 	str.w	r4, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     bac:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
     bb0:	4a1b      	ldr	r2, [pc, #108]	; (c20 <system_init+0x52c>)
     bb2:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bb6:	f893 2158 	ldrb.w	r2, [r3, #344]	; 0x158
	tmp &= ~PORT_PINCFG_PMUXEN;
     bba:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bbe:	f883 2158 	strb.w	r2, [r3, #344]	; 0x158
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     bc2:	f8c3 0114 	str.w	r0, [r3, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     bc6:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     bca:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
     bce:	4a15      	ldr	r2, [pc, #84]	; (c24 <system_init+0x530>)
     bd0:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bd4:	f893 2159 	ldrb.w	r2, [r3, #345]	; 0x159
	tmp &= ~PORT_PINCFG_PMUXEN;
     bd8:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bdc:	f883 2159 	strb.w	r2, [r3, #345]	; 0x159
	// Set pin direction to output
	gpio_set_pin_direction(PC25, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(PC25, GPIO_PIN_FUNCTION_OFF);

	USART_1_init();
     be0:	4b11      	ldr	r3, [pc, #68]	; (c28 <system_init+0x534>)
     be2:	4798      	blx	r3

	USART_0_init();
     be4:	4b11      	ldr	r3, [pc, #68]	; (c2c <system_init+0x538>)
     be6:	4798      	blx	r3

	I2C_0_init();
     be8:	4b11      	ldr	r3, [pc, #68]	; (c30 <system_init+0x53c>)
     bea:	4798      	blx	r3
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC0;
     bec:	4b11      	ldr	r3, [pc, #68]	; (c34 <system_init+0x540>)
     bee:	695b      	ldr	r3, [r3, #20]
     bf0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
     bf4:	4a0f      	ldr	r2, [pc, #60]	; (c34 <system_init+0x540>)
     bf6:	6153      	str	r3, [r2, #20]
     bf8:	2242      	movs	r2, #66	; 0x42
     bfa:	4b0f      	ldr	r3, [pc, #60]	; (c38 <system_init+0x544>)
     bfc:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
	timer_init(&TIMER_0, TC0, _tc_get_timer());
     c00:	4b0e      	ldr	r3, [pc, #56]	; (c3c <system_init+0x548>)
     c02:	4798      	blx	r3
     c04:	4602      	mov	r2, r0
     c06:	490e      	ldr	r1, [pc, #56]	; (c40 <system_init+0x54c>)
     c08:	480e      	ldr	r0, [pc, #56]	; (c44 <system_init+0x550>)
     c0a:	4b0f      	ldr	r3, [pc, #60]	; (c48 <system_init+0x554>)
     c0c:	4798      	blx	r3

	TIMER_0_init();
	ETHERNET_MAC_0_init();
     c0e:	4b0f      	ldr	r3, [pc, #60]	; (c4c <system_init+0x558>)
     c10:	4798      	blx	r3
     c12:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
     c16:	bf00      	nop
     c18:	c0000010 	.word	0xc0000010
     c1c:	c0000020 	.word	0xc0000020
     c20:	c0000100 	.word	0xc0000100
     c24:	c0000200 	.word	0xc0000200
     c28:	000003f1 	.word	0x000003f1
     c2c:	00000495 	.word	0x00000495
     c30:	00000545 	.word	0x00000545
     c34:	40000800 	.word	0x40000800
     c38:	40001c00 	.word	0x40001c00
     c3c:	00002d13 	.word	0x00002d13
     c40:	40003800 	.word	0x40003800
     c44:	20008288 	.word	0x20008288
     c48:	000012c9 	.word	0x000012c9
     c4c:	000006cd 	.word	0x000006cd
     c50:	c0000008 	.word	0xc0000008

00000c54 <ethernet_phy_init>:
/**
 * \brief Perform a HW initialization to the PHY
 */
int32_t ethernet_phy_init(struct ethernet_phy_descriptor *const descr, struct mac_async_descriptor *const mac,
                          uint16_t addr)
{
     c54:	b570      	push	{r4, r5, r6, lr}
     c56:	460d      	mov	r5, r1
     c58:	4616      	mov	r6, r2
	ASSERT(descr && mac && (addr <= 0x1F));
     c5a:	4604      	mov	r4, r0
     c5c:	b160      	cbz	r0, c78 <ethernet_phy_init+0x24>
     c5e:	b169      	cbz	r1, c7c <ethernet_phy_init+0x28>
     c60:	2a1f      	cmp	r2, #31
     c62:	bf8c      	ite	hi
     c64:	2000      	movhi	r0, #0
     c66:	2001      	movls	r0, #1
     c68:	222a      	movs	r2, #42	; 0x2a
     c6a:	4905      	ldr	r1, [pc, #20]	; (c80 <ethernet_phy_init+0x2c>)
     c6c:	4b05      	ldr	r3, [pc, #20]	; (c84 <ethernet_phy_init+0x30>)
     c6e:	4798      	blx	r3

	descr->mac  = mac;
     c70:	6025      	str	r5, [r4, #0]
	descr->addr = addr;
     c72:	80a6      	strh	r6, [r4, #4]
	return ERR_NONE;
}
     c74:	2000      	movs	r0, #0
     c76:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && mac && (addr <= 0x1F));
     c78:	2000      	movs	r0, #0
     c7a:	e7f5      	b.n	c68 <ethernet_phy_init+0x14>
     c7c:	2000      	movs	r0, #0
     c7e:	e7f3      	b.n	c68 <ethernet_phy_init+0x14>
     c80:	0000b0b8 	.word	0x0000b0b8
     c84:	00001861 	.word	0x00001861

00000c88 <ethernet_phy_set_reg_bit>:

/**
 * \brief Setting bit for a PHY Register
 */
int32_t ethernet_phy_set_reg_bit(struct ethernet_phy_descriptor *const descr, uint16_t reg, uint16_t ofst)
{
     c88:	b5f0      	push	{r4, r5, r6, r7, lr}
     c8a:	b083      	sub	sp, #12
     c8c:	460d      	mov	r5, r1
     c8e:	4616      	mov	r6, r2
	int32_t  rst;
	uint16_t val;

	ASSERT(descr && descr->mac && (reg <= 0x1F));
     c90:	4604      	mov	r4, r0
     c92:	b1a8      	cbz	r0, cc0 <ethernet_phy_set_reg_bit+0x38>
     c94:	6803      	ldr	r3, [r0, #0]
     c96:	b1ab      	cbz	r3, cc4 <ethernet_phy_set_reg_bit+0x3c>
     c98:	291f      	cmp	r1, #31
     c9a:	bf8c      	ite	hi
     c9c:	2000      	movhi	r0, #0
     c9e:	2001      	movls	r0, #1
     ca0:	2257      	movs	r2, #87	; 0x57
     ca2:	490f      	ldr	r1, [pc, #60]	; (ce0 <ethernet_phy_set_reg_bit+0x58>)
     ca4:	4b0f      	ldr	r3, [pc, #60]	; (ce4 <ethernet_phy_set_reg_bit+0x5c>)
     ca6:	4798      	blx	r3

	rst = mac_async_read_phy_reg(descr->mac, descr->addr, reg, &val);
     ca8:	f10d 0306 	add.w	r3, sp, #6
     cac:	462a      	mov	r2, r5
     cae:	88a1      	ldrh	r1, [r4, #4]
     cb0:	6820      	ldr	r0, [r4, #0]
     cb2:	4f0d      	ldr	r7, [pc, #52]	; (ce8 <ethernet_phy_set_reg_bit+0x60>)
     cb4:	47b8      	blx	r7
	if (rst == ERR_NONE) {
     cb6:	4603      	mov	r3, r0
     cb8:	b130      	cbz	r0, cc8 <ethernet_phy_set_reg_bit+0x40>
		val |= ofst;
		rst = mac_async_write_phy_reg(descr->mac, descr->addr, reg, val);
	}
	return rst;
}
     cba:	4618      	mov	r0, r3
     cbc:	b003      	add	sp, #12
     cbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ASSERT(descr && descr->mac && (reg <= 0x1F));
     cc0:	2000      	movs	r0, #0
     cc2:	e7ed      	b.n	ca0 <ethernet_phy_set_reg_bit+0x18>
     cc4:	2000      	movs	r0, #0
     cc6:	e7eb      	b.n	ca0 <ethernet_phy_set_reg_bit+0x18>
		val |= ofst;
     cc8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
     ccc:	4333      	orrs	r3, r6
     cce:	f8ad 3006 	strh.w	r3, [sp, #6]
		rst = mac_async_write_phy_reg(descr->mac, descr->addr, reg, val);
     cd2:	462a      	mov	r2, r5
     cd4:	88a1      	ldrh	r1, [r4, #4]
     cd6:	6820      	ldr	r0, [r4, #0]
     cd8:	4c04      	ldr	r4, [pc, #16]	; (cec <ethernet_phy_set_reg_bit+0x64>)
     cda:	47a0      	blx	r4
     cdc:	4603      	mov	r3, r0
	return rst;
     cde:	e7ec      	b.n	cba <ethernet_phy_set_reg_bit+0x32>
     ce0:	0000b0b8 	.word	0x0000b0b8
     ce4:	00001861 	.word	0x00001861
     ce8:	000011b9 	.word	0x000011b9
     cec:	00001185 	.word	0x00001185

00000cf0 <ethernet_phy_restart_autoneg>:

/**
 * \brief Restart an auto negotiation of the PHY.
 */
int32_t ethernet_phy_restart_autoneg(struct ethernet_phy_descriptor *const descr)
{
     cf0:	b510      	push	{r4, lr}
	ASSERT(descr);
     cf2:	4604      	mov	r4, r0
     cf4:	2290      	movs	r2, #144	; 0x90
     cf6:	4906      	ldr	r1, [pc, #24]	; (d10 <ethernet_phy_restart_autoneg+0x20>)
     cf8:	3000      	adds	r0, #0
     cfa:	bf18      	it	ne
     cfc:	2001      	movne	r0, #1
     cfe:	4b05      	ldr	r3, [pc, #20]	; (d14 <ethernet_phy_restart_autoneg+0x24>)
     d00:	4798      	blx	r3
	return ethernet_phy_set_reg_bit(descr, MDIO_REG0_BMCR, MDIO_REG0_BIT_RESTART_AUTONEG);
     d02:	f44f 7200 	mov.w	r2, #512	; 0x200
     d06:	2100      	movs	r1, #0
     d08:	4620      	mov	r0, r4
     d0a:	4b03      	ldr	r3, [pc, #12]	; (d18 <ethernet_phy_restart_autoneg+0x28>)
     d0c:	4798      	blx	r3
}
     d0e:	bd10      	pop	{r4, pc}
     d10:	0000b0b8 	.word	0x0000b0b8
     d14:	00001861 	.word	0x00001861
     d18:	00000c89 	.word	0x00000c89

00000d1c <ethernet_phy_get_link_status>:

/**
 * \brief Get PHY link status
 */
int32_t ethernet_phy_get_link_status(struct ethernet_phy_descriptor *const descr, bool *status)
{
     d1c:	b530      	push	{r4, r5, lr}
     d1e:	b083      	sub	sp, #12
     d20:	460d      	mov	r5, r1
	int32_t  rst;
	uint16_t val;

	ASSERT(descr && descr->mac && status);
     d22:	4604      	mov	r4, r0
     d24:	b1c8      	cbz	r0, d5a <ethernet_phy_get_link_status+0x3e>
     d26:	6803      	ldr	r3, [r0, #0]
     d28:	b1cb      	cbz	r3, d5e <ethernet_phy_get_link_status+0x42>
     d2a:	1c08      	adds	r0, r1, #0
     d2c:	bf18      	it	ne
     d2e:	2001      	movne	r0, #1
     d30:	22a9      	movs	r2, #169	; 0xa9
     d32:	490c      	ldr	r1, [pc, #48]	; (d64 <ethernet_phy_get_link_status+0x48>)
     d34:	4b0c      	ldr	r3, [pc, #48]	; (d68 <ethernet_phy_get_link_status+0x4c>)
     d36:	4798      	blx	r3
	rst = mac_async_read_phy_reg(descr->mac, descr->addr, MDIO_REG1_BMSR, &val);
     d38:	f10d 0306 	add.w	r3, sp, #6
     d3c:	2201      	movs	r2, #1
     d3e:	88a1      	ldrh	r1, [r4, #4]
     d40:	6820      	ldr	r0, [r4, #0]
     d42:	4c0a      	ldr	r4, [pc, #40]	; (d6c <ethernet_phy_get_link_status+0x50>)
     d44:	47a0      	blx	r4
	if (rst == ERR_NONE) {
     d46:	4602      	mov	r2, r0
     d48:	b920      	cbnz	r0, d54 <ethernet_phy_get_link_status+0x38>
		*status = (val & MDIO_REG1_BIT_LINK_STATUS) ? true : false;
     d4a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
     d4e:	f3c3 0380 	ubfx	r3, r3, #2, #1
     d52:	702b      	strb	r3, [r5, #0]
	}
	return rst;
}
     d54:	4610      	mov	r0, r2
     d56:	b003      	add	sp, #12
     d58:	bd30      	pop	{r4, r5, pc}
	ASSERT(descr && descr->mac && status);
     d5a:	2000      	movs	r0, #0
     d5c:	e7e8      	b.n	d30 <ethernet_phy_get_link_status+0x14>
     d5e:	2000      	movs	r0, #0
     d60:	e7e6      	b.n	d30 <ethernet_phy_get_link_status+0x14>
     d62:	bf00      	nop
     d64:	0000b0b8 	.word	0x0000b0b8
     d68:	00001861 	.word	0x00001861
     d6c:	000011b9 	.word	0x000011b9

00000d70 <ETHERNET_PHY_0_init>:
#include <atmel_start_pins.h>

struct ethernet_phy_descriptor ETHERNET_PHY_0_desc;

void ETHERNET_PHY_0_init(void)
{
     d70:	b510      	push	{r4, lr}
	mac_async_enable(&ETHERNET_MAC_0);
     d72:	4c05      	ldr	r4, [pc, #20]	; (d88 <ETHERNET_PHY_0_init+0x18>)
     d74:	4620      	mov	r0, r4
     d76:	4b05      	ldr	r3, [pc, #20]	; (d8c <ETHERNET_PHY_0_init+0x1c>)
     d78:	4798      	blx	r3
	ethernet_phy_init(&ETHERNET_PHY_0_desc, &ETHERNET_MAC_0, CONF_ETHERNET_PHY_0_IEEE8023_MII_PHY_ADDRESS);
     d7a:	2200      	movs	r2, #0
     d7c:	4621      	mov	r1, r4
     d7e:	4804      	ldr	r0, [pc, #16]	; (d90 <ETHERNET_PHY_0_init+0x20>)
     d80:	4b04      	ldr	r3, [pc, #16]	; (d94 <ETHERNET_PHY_0_init+0x24>)
     d82:	4798      	blx	r3
     d84:	bd10      	pop	{r4, pc}
     d86:	bf00      	nop
     d88:	2000826c 	.word	0x2000826c
     d8c:	00001035 	.word	0x00001035
     d90:	200081e8 	.word	0x200081e8
     d94:	00000c55 	.word	0x00000c55

00000d98 <ETHERNET_PHY_0_example>:
	ethernet_phy_write_reg(&ETHERNET_PHY_0_desc, MDIO_REG0_BMCR, CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0);
#endif /* CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0_SETTING */
}

void ETHERNET_PHY_0_example(void)
{
     d98:	b530      	push	{r4, r5, lr}
     d9a:	b083      	sub	sp, #12
	bool    link_state;
	int32_t rst;
	/* Restart an auto-negotiation */
	rst = ethernet_phy_restart_autoneg(&ETHERNET_PHY_0_desc);
     d9c:	4808      	ldr	r0, [pc, #32]	; (dc0 <ETHERNET_PHY_0_example+0x28>)
     d9e:	4b09      	ldr	r3, [pc, #36]	; (dc4 <ETHERNET_PHY_0_example+0x2c>)
     da0:	4798      	blx	r3
	while (rst != ERR_NONE) {
     da2:	b100      	cbz	r0, da6 <ETHERNET_PHY_0_example+0xe>
     da4:	e7fe      	b.n	da4 <ETHERNET_PHY_0_example+0xc>
	}

	/* Wait for PHY link up */
	do {
		rst = ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_state);
     da6:	4d06      	ldr	r5, [pc, #24]	; (dc0 <ETHERNET_PHY_0_example+0x28>)
     da8:	4c07      	ldr	r4, [pc, #28]	; (dc8 <ETHERNET_PHY_0_example+0x30>)
     daa:	f10d 0107 	add.w	r1, sp, #7
     dae:	4628      	mov	r0, r5
     db0:	47a0      	blx	r4
	} while (rst == ERR_NONE && link_state == false);  //tph true
     db2:	b918      	cbnz	r0, dbc <ETHERNET_PHY_0_example+0x24>
     db4:	f89d 3007 	ldrb.w	r3, [sp, #7]
     db8:	2b00      	cmp	r3, #0
     dba:	d0f6      	beq.n	daa <ETHERNET_PHY_0_example+0x12>
}
     dbc:	b003      	add	sp, #12
     dbe:	bd30      	pop	{r4, r5, pc}
     dc0:	200081e8 	.word	0x200081e8
     dc4:	00000cf1 	.word	0x00000cf1
     dc8:	00000d1d 	.word	0x00000d1d

00000dcc <ethernet_phys_init>:


void ethernet_phys_init(void)
{
     dcc:	b508      	push	{r3, lr}
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     dce:	4b0d      	ldr	r3, [pc, #52]	; (e04 <ethernet_phys_init+0x38>)
     dd0:	f44f 4280 	mov.w	r2, #16384	; 0x4000
     dd4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     dd8:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
     ddc:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
     de0:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
     de4:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     de8:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     dec:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     df0:	f8c3 0128 	str.w	r0, [r3, #296]	; 0x128
     df4:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     df8:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
//not needed to use as regular gpio?	gpio_set_pin_function(PA14, PINMUX_PA18L_GMAC_GTX0);

	gpio_set_pin_direction(PHY_YELLOW_LED_PIN,GPIO_DIRECTION_OUT);
	gpio_set_pin_level(PHY_YELLOW_LED_PIN,true);

	ETHERNET_PHY_0_init();
     dfc:	4b02      	ldr	r3, [pc, #8]	; (e08 <ethernet_phys_init+0x3c>)
     dfe:	4798      	blx	r3
     e00:	bd08      	pop	{r3, pc}
     e02:	bf00      	nop
     e04:	41008000 	.word	0x41008000
     e08:	00000d71 	.word	0x00000d71

00000e0c <LWIP_MACIF_stack_init>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 * @return ERR_OK  if the loopif is initialized
 */
err_t LWIP_MACIF_stack_init(struct netif *netif)
{
     e0c:	b508      	push	{r3, lr}
	LWIP_ASSERT("netif != NULL", (netif != NULL));
	LWIP_ASSERT("netif->state != NULL", (netif->state != NULL));

	netif->output     = etharp_output;
     e0e:	4a0e      	ldr	r2, [pc, #56]	; (e48 <LWIP_MACIF_stack_init+0x3c>)
     e10:	6142      	str	r2, [r0, #20]
	netif->linkoutput = mac_low_level_output;
     e12:	4a0e      	ldr	r2, [pc, #56]	; (e4c <LWIP_MACIF_stack_init+0x40>)
     e14:	6182      	str	r2, [r0, #24]

	/* device capabilities */
	LWIP_MACIF_desc.flags = CONF_LWIP_MACIF_FLAG;
     e16:	4b0e      	ldr	r3, [pc, #56]	; (e50 <LWIP_MACIF_stack_init+0x44>)
     e18:	226a      	movs	r2, #106	; 0x6a
     e1a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
	LWIP_MACIF_desc.mtu   = CONF_LWIP_MACIF_MTU;
     e1e:	f44f 62c0 	mov.w	r2, #1536	; 0x600
     e22:	859a      	strh	r2, [r3, #44]	; 0x2c

	/* set MAC hardware address length */
	memcpy(LWIP_MACIF_desc.hwaddr, LWIP_MACIF_hwaddr, NETIF_MAX_HWADDR_LEN);
     e24:	4a0b      	ldr	r2, [pc, #44]	; (e54 <LWIP_MACIF_stack_init+0x48>)
     e26:	6811      	ldr	r1, [r2, #0]
     e28:	f8c3 102f 	str.w	r1, [r3, #47]	; 0x2f
     e2c:	8892      	ldrh	r2, [r2, #4]
     e2e:	f8a3 2033 	strh.w	r2, [r3, #51]	; 0x33
	LWIP_MACIF_desc.hwaddr_len = ETHARP_HWADDR_LEN;
     e32:	2206      	movs	r2, #6
     e34:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

#if LWIP_NETIF_HOSTNAME
	/* Initialize interface hostname */
	LWIP_MACIF_desc.hostname = CONF_LWIP_MACIF_HOSTNAME;
#endif
	memcpy(LWIP_MACIF_desc.name, CONF_LWIP_MACIF_HOSTNAME_ABBR, 2);
     e38:	f646 6265 	movw	r2, #28261	; 0x6e65
     e3c:	86da      	strh	r2, [r3, #54]	; 0x36

	/* initialize the mac hardware */
	mac_low_level_init(netif);
     e3e:	4b06      	ldr	r3, [pc, #24]	; (e58 <LWIP_MACIF_stack_init+0x4c>)
     e40:	4798      	blx	r3

	return ERR_OK;
}
     e42:	2000      	movs	r0, #0
     e44:	bd08      	pop	{r3, pc}
     e46:	bf00      	nop
     e48:	00009305 	.word	0x00009305
     e4c:	00002da5 	.word	0x00002da5
     e50:	200082ac 	.word	0x200082ac
     e54:	200082a4 	.word	0x200082a4
     e58:	00002d79 	.word	0x00002d79

00000e5c <LWIP_MACIF_init>:
void LWIP_MACIF_init(u8_t hwaddr[6])
{
     e5c:	b510      	push	{r4, lr}
     e5e:	b088      	sub	sp, #32
	struct ip_addr ip;
	struct ip_addr nm;
	struct ip_addr gw;
#if CONF_LWIP_MACIF_DHCP
	ip_addr_set_zero(&ip);
     e60:	2200      	movs	r2, #0
     e62:	9207      	str	r2, [sp, #28]
	ip_addr_set_zero(&nm);
     e64:	9206      	str	r2, [sp, #24]
	ip_addr_set_zero(&gw);
     e66:	ab08      	add	r3, sp, #32
     e68:	f843 2d0c 	str.w	r2, [r3, #-12]!
#else
	ipaddr_aton(CONF_LWIP_MACIF_IP, &ip);
	ipaddr_aton(CONF_LWIP_MACIF_NETMASK, &nm);
	ipaddr_aton(CONF_LWIP_MACIF_GATEWAY, &gw);
#endif
	memcpy(LWIP_MACIF_hwaddr, hwaddr, 6);
     e6c:	4a08      	ldr	r2, [pc, #32]	; (e90 <LWIP_MACIF_init+0x34>)
     e6e:	6801      	ldr	r1, [r0, #0]
     e70:	6011      	str	r1, [r2, #0]
     e72:	8881      	ldrh	r1, [r0, #4]
     e74:	8091      	strh	r1, [r2, #4]

	netif_add(&LWIP_MACIF_desc, &ip, &nm, &gw, (void *)&ETHERNET_MAC_0, LWIP_MACIF_stack_init, ethernet_input);
     e76:	4a07      	ldr	r2, [pc, #28]	; (e94 <LWIP_MACIF_init+0x38>)
     e78:	9202      	str	r2, [sp, #8]
     e7a:	4a07      	ldr	r2, [pc, #28]	; (e98 <LWIP_MACIF_init+0x3c>)
     e7c:	9201      	str	r2, [sp, #4]
     e7e:	4a07      	ldr	r2, [pc, #28]	; (e9c <LWIP_MACIF_init+0x40>)
     e80:	9200      	str	r2, [sp, #0]
     e82:	aa06      	add	r2, sp, #24
     e84:	a907      	add	r1, sp, #28
     e86:	4806      	ldr	r0, [pc, #24]	; (ea0 <LWIP_MACIF_init+0x44>)
     e88:	4c06      	ldr	r4, [pc, #24]	; (ea4 <LWIP_MACIF_init+0x48>)
     e8a:	47a0      	blx	r4
}
     e8c:	b008      	add	sp, #32
     e8e:	bd10      	pop	{r4, pc}
     e90:	200082a4 	.word	0x200082a4
     e94:	00009425 	.word	0x00009425
     e98:	00000e0d 	.word	0x00000e0d
     e9c:	2000826c 	.word	0x2000826c
     ea0:	200082ac 	.word	0x200082ac
     ea4:	00005a6d 	.word	0x00005a6d

00000ea8 <eth_ipstack_init>:

void eth_ipstack_init(void)
{
     ea8:	b508      	push	{r3, lr}
	lwip_init();
     eaa:	4b01      	ldr	r3, [pc, #4]	; (eb0 <eth_ipstack_init+0x8>)
     eac:	4798      	blx	r3
     eae:	bd08      	pop	{r3, pc}
     eb0:	000047c1 	.word	0x000047c1

00000eb4 <atomic_enter_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
     eb4:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
     eb8:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
     eba:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
     ebc:	f3bf 8f5f 	dmb	sy
     ec0:	4770      	bx	lr

00000ec2 <atomic_leave_critical>:
     ec2:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
     ec6:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
     ec8:	f383 8810 	msr	PRIMASK, r3
     ecc:	4770      	bx	lr
	...

00000ed0 <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
     ed0:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
     ed2:	4b04      	ldr	r3, [pc, #16]	; (ee4 <delay_ms+0x14>)
     ed4:	681c      	ldr	r4, [r3, #0]
     ed6:	4b04      	ldr	r3, [pc, #16]	; (ee8 <delay_ms+0x18>)
     ed8:	4798      	blx	r3
     eda:	4601      	mov	r1, r0
     edc:	4620      	mov	r0, r4
     ede:	4b03      	ldr	r3, [pc, #12]	; (eec <delay_ms+0x1c>)
     ee0:	4798      	blx	r3
     ee2:	bd10      	pop	{r4, pc}
     ee4:	2000019c 	.word	0x2000019c
     ee8:	00001a19 	.word	0x00001a19
     eec:	00001a39 	.word	0x00001a39

00000ef0 <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
     ef0:	b510      	push	{r4, lr}
     ef2:	b084      	sub	sp, #16
     ef4:	4614      	mov	r4, r2
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
     ef6:	8903      	ldrh	r3, [r0, #8]
     ef8:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
     efc:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP;
     efe:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     f02:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = (uint8_t *)buf;
     f06:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     f08:	a901      	add	r1, sp, #4
     f0a:	3814      	subs	r0, #20
     f0c:	4b03      	ldr	r3, [pc, #12]	; (f1c <i2c_m_sync_write+0x2c>)
     f0e:	4798      	blx	r3
	if (ret) {
		return ret;
	}

	return n;
}
     f10:	2800      	cmp	r0, #0
     f12:	bf08      	it	eq
     f14:	4620      	moveq	r0, r4
     f16:	b004      	add	sp, #16
     f18:	bd10      	pop	{r4, pc}
     f1a:	bf00      	nop
     f1c:	00002579 	.word	0x00002579

00000f20 <i2c_m_sync_read>:
{
     f20:	b510      	push	{r4, lr}
     f22:	b084      	sub	sp, #16
     f24:	4614      	mov	r4, r2
	msg.addr   = i2c->slave_addr;
     f26:	8903      	ldrh	r3, [r0, #8]
     f28:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
     f2c:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
     f2e:	f248 0301 	movw	r3, #32769	; 0x8001
     f32:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = buf;
     f36:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     f38:	a901      	add	r1, sp, #4
     f3a:	3814      	subs	r0, #20
     f3c:	4b03      	ldr	r3, [pc, #12]	; (f4c <i2c_m_sync_read+0x2c>)
     f3e:	4798      	blx	r3
}
     f40:	2800      	cmp	r0, #0
     f42:	bf08      	it	eq
     f44:	4620      	moveq	r0, r4
     f46:	b004      	add	sp, #16
     f48:	bd10      	pop	{r4, pc}
     f4a:	bf00      	nop
     f4c:	00002579 	.word	0x00002579

00000f50 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
     f50:	b538      	push	{r3, r4, r5, lr}
     f52:	460d      	mov	r5, r1
	int32_t init_status;
	ASSERT(i2c);
     f54:	4604      	mov	r4, r0
     f56:	225e      	movs	r2, #94	; 0x5e
     f58:	4908      	ldr	r1, [pc, #32]	; (f7c <i2c_m_sync_init+0x2c>)
     f5a:	3000      	adds	r0, #0
     f5c:	bf18      	it	ne
     f5e:	2001      	movne	r0, #1
     f60:	4b07      	ldr	r3, [pc, #28]	; (f80 <i2c_m_sync_init+0x30>)
     f62:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
     f64:	4629      	mov	r1, r5
     f66:	4620      	mov	r0, r4
     f68:	4b06      	ldr	r3, [pc, #24]	; (f84 <i2c_m_sync_init+0x34>)
     f6a:	4798      	blx	r3
	if (init_status) {
     f6c:	4603      	mov	r3, r0
     f6e:	b918      	cbnz	r0, f78 <i2c_m_sync_init+0x28>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
     f70:	4a05      	ldr	r2, [pc, #20]	; (f88 <i2c_m_sync_init+0x38>)
     f72:	61a2      	str	r2, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
     f74:	4a05      	ldr	r2, [pc, #20]	; (f8c <i2c_m_sync_init+0x3c>)
     f76:	6162      	str	r2, [r4, #20]

	return ERR_NONE;
}
     f78:	4618      	mov	r0, r3
     f7a:	bd38      	pop	{r3, r4, r5, pc}
     f7c:	0000b0d8 	.word	0x0000b0d8
     f80:	00001861 	.word	0x00001861
     f84:	00002549 	.word	0x00002549
     f88:	00000f21 	.word	0x00000f21
     f8c:	00000ef1 	.word	0x00000ef1

00000f90 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     f90:	b570      	push	{r4, r5, r6, lr}
     f92:	460d      	mov	r5, r1
     f94:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
     f96:	4604      	mov	r4, r0
     f98:	b160      	cbz	r0, fb4 <io_write+0x24>
     f9a:	1c08      	adds	r0, r1, #0
     f9c:	bf18      	it	ne
     f9e:	2001      	movne	r0, #1
     fa0:	2234      	movs	r2, #52	; 0x34
     fa2:	4905      	ldr	r1, [pc, #20]	; (fb8 <io_write+0x28>)
     fa4:	4b05      	ldr	r3, [pc, #20]	; (fbc <io_write+0x2c>)
     fa6:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
     fa8:	6823      	ldr	r3, [r4, #0]
     faa:	4632      	mov	r2, r6
     fac:	4629      	mov	r1, r5
     fae:	4620      	mov	r0, r4
     fb0:	4798      	blx	r3
}
     fb2:	bd70      	pop	{r4, r5, r6, pc}
     fb4:	2000      	movs	r0, #0
     fb6:	e7f3      	b.n	fa0 <io_write+0x10>
     fb8:	0000b0f4 	.word	0x0000b0f4
     fbc:	00001861 	.word	0x00001861

00000fc0 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
     fc0:	b570      	push	{r4, r5, r6, lr}
     fc2:	460d      	mov	r5, r1
     fc4:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
     fc6:	4604      	mov	r4, r0
     fc8:	b160      	cbz	r0, fe4 <io_read+0x24>
     fca:	1c08      	adds	r0, r1, #0
     fcc:	bf18      	it	ne
     fce:	2001      	movne	r0, #1
     fd0:	223d      	movs	r2, #61	; 0x3d
     fd2:	4905      	ldr	r1, [pc, #20]	; (fe8 <io_read+0x28>)
     fd4:	4b05      	ldr	r3, [pc, #20]	; (fec <io_read+0x2c>)
     fd6:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
     fd8:	6863      	ldr	r3, [r4, #4]
     fda:	4632      	mov	r2, r6
     fdc:	4629      	mov	r1, r5
     fde:	4620      	mov	r0, r4
     fe0:	4798      	blx	r3
}
     fe2:	bd70      	pop	{r4, r5, r6, pc}
     fe4:	2000      	movs	r0, #0
     fe6:	e7f3      	b.n	fd0 <io_read+0x10>
     fe8:	0000b0f4 	.word	0x0000b0f4
     fec:	00001861 	.word	0x00001861

00000ff0 <mac_read_cb>:
 * \internal data receivced handler
 *
 * \param[in] dev The pointer to MAC device structure
 */
static void mac_read_cb(struct _mac_async_device *dev)
{
     ff0:	b508      	push	{r3, lr}
	struct mac_async_descriptor *const descr = CONTAINER_OF(dev, struct mac_async_descriptor, dev);

	if (descr->cb.receive) {
     ff2:	6943      	ldr	r3, [r0, #20]
     ff4:	b103      	cbz	r3, ff8 <mac_read_cb+0x8>
		descr->cb.receive(descr);
     ff6:	4798      	blx	r3
     ff8:	bd08      	pop	{r3, pc}

00000ffa <mac_write_cb>:
 * \internal data transmit handler
 *
 * \param[in] dev The pointer to MAC device structure
 */
static void mac_write_cb(struct _mac_async_device *dev)
{
     ffa:	b508      	push	{r3, lr}
	struct mac_async_descriptor *const descr = CONTAINER_OF(dev, struct mac_async_descriptor, dev);

	if (descr->cb.transmit) {
     ffc:	6983      	ldr	r3, [r0, #24]
     ffe:	b103      	cbz	r3, 1002 <mac_write_cb+0x8>
		descr->cb.transmit(descr);
    1000:	4798      	blx	r3
    1002:	bd08      	pop	{r3, pc}

00001004 <mac_async_init>:
{
    1004:	b538      	push	{r3, r4, r5, lr}
    1006:	460c      	mov	r4, r1
	ASSERT(descr && hw);
    1008:	4605      	mov	r5, r0
    100a:	b158      	cbz	r0, 1024 <mac_async_init+0x20>
    100c:	1c08      	adds	r0, r1, #0
    100e:	bf18      	it	ne
    1010:	2001      	movne	r0, #1
    1012:	2231      	movs	r2, #49	; 0x31
    1014:	4904      	ldr	r1, [pc, #16]	; (1028 <mac_async_init+0x24>)
    1016:	4b05      	ldr	r3, [pc, #20]	; (102c <mac_async_init+0x28>)
    1018:	4798      	blx	r3
	return _mac_async_init(&descr->dev, hw);
    101a:	4621      	mov	r1, r4
    101c:	4628      	mov	r0, r5
    101e:	4b04      	ldr	r3, [pc, #16]	; (1030 <mac_async_init+0x2c>)
    1020:	4798      	blx	r3
}
    1022:	bd38      	pop	{r3, r4, r5, pc}
    1024:	2000      	movs	r0, #0
    1026:	e7f4      	b.n	1012 <mac_async_init+0xe>
    1028:	0000b108 	.word	0x0000b108
    102c:	00001861 	.word	0x00001861
    1030:	00001b55 	.word	0x00001b55

00001034 <mac_async_enable>:
{
    1034:	b510      	push	{r4, lr}
	ASSERT(descr);
    1036:	4604      	mov	r4, r0
    1038:	2245      	movs	r2, #69	; 0x45
    103a:	4905      	ldr	r1, [pc, #20]	; (1050 <mac_async_enable+0x1c>)
    103c:	3000      	adds	r0, #0
    103e:	bf18      	it	ne
    1040:	2001      	movne	r0, #1
    1042:	4b04      	ldr	r3, [pc, #16]	; (1054 <mac_async_enable+0x20>)
    1044:	4798      	blx	r3
	return _mac_async_enable(&descr->dev);
    1046:	4620      	mov	r0, r4
    1048:	4b03      	ldr	r3, [pc, #12]	; (1058 <mac_async_enable+0x24>)
    104a:	4798      	blx	r3
}
    104c:	bd10      	pop	{r4, pc}
    104e:	bf00      	nop
    1050:	0000b108 	.word	0x0000b108
    1054:	00001861 	.word	0x00001861
    1058:	00001c1d 	.word	0x00001c1d

0000105c <mac_async_write>:
{
    105c:	b570      	push	{r4, r5, r6, lr}
    105e:	460c      	mov	r4, r1
    1060:	4615      	mov	r5, r2
	ASSERT(descr && buf && len);
    1062:	4606      	mov	r6, r0
    1064:	b168      	cbz	r0, 1082 <mac_async_write+0x26>
    1066:	b171      	cbz	r1, 1086 <mac_async_write+0x2a>
    1068:	1c10      	adds	r0, r2, #0
    106a:	bf18      	it	ne
    106c:	2001      	movne	r0, #1
    106e:	2257      	movs	r2, #87	; 0x57
    1070:	4906      	ldr	r1, [pc, #24]	; (108c <mac_async_write+0x30>)
    1072:	4b07      	ldr	r3, [pc, #28]	; (1090 <mac_async_write+0x34>)
    1074:	4798      	blx	r3
	return _mac_async_write(&descr->dev, buf, len);
    1076:	462a      	mov	r2, r5
    1078:	4621      	mov	r1, r4
    107a:	4630      	mov	r0, r6
    107c:	4b05      	ldr	r3, [pc, #20]	; (1094 <mac_async_write+0x38>)
    107e:	4798      	blx	r3
}
    1080:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && len);
    1082:	2000      	movs	r0, #0
    1084:	e7f3      	b.n	106e <mac_async_write+0x12>
    1086:	2000      	movs	r0, #0
    1088:	e7f1      	b.n	106e <mac_async_write+0x12>
    108a:	bf00      	nop
    108c:	0000b108 	.word	0x0000b108
    1090:	00001861 	.word	0x00001861
    1094:	00001c2d 	.word	0x00001c2d

00001098 <mac_async_read>:
{
    1098:	b570      	push	{r4, r5, r6, lr}
    109a:	460d      	mov	r5, r1
    109c:	4616      	mov	r6, r2
	ASSERT(descr);
    109e:	4604      	mov	r4, r0
    10a0:	2261      	movs	r2, #97	; 0x61
    10a2:	4906      	ldr	r1, [pc, #24]	; (10bc <mac_async_read+0x24>)
    10a4:	3000      	adds	r0, #0
    10a6:	bf18      	it	ne
    10a8:	2001      	movne	r0, #1
    10aa:	4b05      	ldr	r3, [pc, #20]	; (10c0 <mac_async_read+0x28>)
    10ac:	4798      	blx	r3
	return _mac_async_read(&descr->dev, buf, len);
    10ae:	4632      	mov	r2, r6
    10b0:	4629      	mov	r1, r5
    10b2:	4620      	mov	r0, r4
    10b4:	4b03      	ldr	r3, [pc, #12]	; (10c4 <mac_async_read+0x2c>)
    10b6:	4798      	blx	r3
}
    10b8:	bd70      	pop	{r4, r5, r6, pc}
    10ba:	bf00      	nop
    10bc:	0000b108 	.word	0x0000b108
    10c0:	00001861 	.word	0x00001861
    10c4:	00001d65 	.word	0x00001d65

000010c8 <mac_async_read_len>:
{
    10c8:	b510      	push	{r4, lr}
	ASSERT(descr);
    10ca:	4604      	mov	r4, r0
    10cc:	226b      	movs	r2, #107	; 0x6b
    10ce:	4905      	ldr	r1, [pc, #20]	; (10e4 <mac_async_read_len+0x1c>)
    10d0:	3000      	adds	r0, #0
    10d2:	bf18      	it	ne
    10d4:	2001      	movne	r0, #1
    10d6:	4b04      	ldr	r3, [pc, #16]	; (10e8 <mac_async_read_len+0x20>)
    10d8:	4798      	blx	r3
	return _mac_async_read_len(&descr->dev);
    10da:	4620      	mov	r0, r4
    10dc:	4b03      	ldr	r3, [pc, #12]	; (10ec <mac_async_read_len+0x24>)
    10de:	4798      	blx	r3
}
    10e0:	bd10      	pop	{r4, pc}
    10e2:	bf00      	nop
    10e4:	0000b108 	.word	0x0000b108
    10e8:	00001861 	.word	0x00001861
    10ec:	00001e99 	.word	0x00001e99

000010f0 <mac_async_register_callback>:
{
    10f0:	b570      	push	{r4, r5, r6, lr}
    10f2:	460c      	mov	r4, r1
    10f4:	4616      	mov	r6, r2
	ASSERT(descr);
    10f6:	4605      	mov	r5, r0
    10f8:	2289      	movs	r2, #137	; 0x89
    10fa:	4910      	ldr	r1, [pc, #64]	; (113c <mac_async_register_callback+0x4c>)
    10fc:	3000      	adds	r0, #0
    10fe:	bf18      	it	ne
    1100:	2001      	movne	r0, #1
    1102:	4b0f      	ldr	r3, [pc, #60]	; (1140 <mac_async_register_callback+0x50>)
    1104:	4798      	blx	r3
	switch (type) {
    1106:	b124      	cbz	r4, 1112 <mac_async_register_callback+0x22>
    1108:	2c01      	cmp	r4, #1
    110a:	d00c      	beq.n	1126 <mac_async_register_callback+0x36>
		return ERR_INVALID_ARG;
    110c:	f06f 000c 	mvn.w	r0, #12
}
    1110:	bd70      	pop	{r4, r5, r6, pc}
		descr->cb.receive = (mac_async_cb_t)func;
    1112:	616e      	str	r6, [r5, #20]
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_read_cb);
    1114:	2e00      	cmp	r6, #0
    1116:	4a0b      	ldr	r2, [pc, #44]	; (1144 <mac_async_register_callback+0x54>)
    1118:	bf08      	it	eq
    111a:	2200      	moveq	r2, #0
    111c:	2100      	movs	r1, #0
    111e:	4628      	mov	r0, r5
    1120:	4b09      	ldr	r3, [pc, #36]	; (1148 <mac_async_register_callback+0x58>)
    1122:	4798      	blx	r3
    1124:	bd70      	pop	{r4, r5, r6, pc}
		descr->cb.transmit = (mac_async_cb_t)func;
    1126:	61ae      	str	r6, [r5, #24]
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_write_cb);
    1128:	2e00      	cmp	r6, #0
    112a:	4a08      	ldr	r2, [pc, #32]	; (114c <mac_async_register_callback+0x5c>)
    112c:	bf08      	it	eq
    112e:	2200      	moveq	r2, #0
    1130:	2101      	movs	r1, #1
    1132:	4628      	mov	r0, r5
    1134:	4b04      	ldr	r3, [pc, #16]	; (1148 <mac_async_register_callback+0x58>)
    1136:	4798      	blx	r3
    1138:	bd70      	pop	{r4, r5, r6, pc}
    113a:	bf00      	nop
    113c:	0000b108 	.word	0x0000b108
    1140:	00001861 	.word	0x00001861
    1144:	00000ff1 	.word	0x00000ff1
    1148:	00001f01 	.word	0x00001f01
    114c:	00000ffb 	.word	0x00000ffb

00001150 <mac_async_set_filter>:
{
    1150:	b570      	push	{r4, r5, r6, lr}
    1152:	460e      	mov	r6, r1
    1154:	4614      	mov	r4, r2
	ASSERT(descr && filter);
    1156:	4605      	mov	r5, r0
    1158:	b160      	cbz	r0, 1174 <mac_async_set_filter+0x24>
    115a:	1c10      	adds	r0, r2, #0
    115c:	bf18      	it	ne
    115e:	2001      	movne	r0, #1
    1160:	229b      	movs	r2, #155	; 0x9b
    1162:	4905      	ldr	r1, [pc, #20]	; (1178 <mac_async_set_filter+0x28>)
    1164:	4b05      	ldr	r3, [pc, #20]	; (117c <mac_async_set_filter+0x2c>)
    1166:	4798      	blx	r3
	return _mac_async_set_filter(&descr->dev, index, filter);
    1168:	4622      	mov	r2, r4
    116a:	4631      	mov	r1, r6
    116c:	4628      	mov	r0, r5
    116e:	4b04      	ldr	r3, [pc, #16]	; (1180 <mac_async_set_filter+0x30>)
    1170:	4798      	blx	r3
}
    1172:	bd70      	pop	{r4, r5, r6, pc}
    1174:	2000      	movs	r0, #0
    1176:	e7f3      	b.n	1160 <mac_async_set_filter+0x10>
    1178:	0000b108 	.word	0x0000b108
    117c:	00001861 	.word	0x00001861
    1180:	00001f31 	.word	0x00001f31

00001184 <mac_async_write_phy_reg>:
{
    1184:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1186:	460d      	mov	r5, r1
    1188:	4616      	mov	r6, r2
    118a:	461f      	mov	r7, r3
	ASSERT(descr);
    118c:	4604      	mov	r4, r0
    118e:	22af      	movs	r2, #175	; 0xaf
    1190:	4906      	ldr	r1, [pc, #24]	; (11ac <mac_async_write_phy_reg+0x28>)
    1192:	3000      	adds	r0, #0
    1194:	bf18      	it	ne
    1196:	2001      	movne	r0, #1
    1198:	4b05      	ldr	r3, [pc, #20]	; (11b0 <mac_async_write_phy_reg+0x2c>)
    119a:	4798      	blx	r3
	return _mac_async_write_phy_reg(&descr->dev, addr, reg, val);
    119c:	463b      	mov	r3, r7
    119e:	4632      	mov	r2, r6
    11a0:	4629      	mov	r1, r5
    11a2:	4620      	mov	r0, r4
    11a4:	4c03      	ldr	r4, [pc, #12]	; (11b4 <mac_async_write_phy_reg+0x30>)
    11a6:	47a0      	blx	r4
}
    11a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    11aa:	bf00      	nop
    11ac:	0000b108 	.word	0x0000b108
    11b0:	00001861 	.word	0x00001861
    11b4:	00001f79 	.word	0x00001f79

000011b8 <mac_async_read_phy_reg>:
{
    11b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    11ba:	460e      	mov	r6, r1
    11bc:	4617      	mov	r7, r2
    11be:	461c      	mov	r4, r3
	ASSERT(descr && val);
    11c0:	4605      	mov	r5, r0
    11c2:	b168      	cbz	r0, 11e0 <mac_async_read_phy_reg+0x28>
    11c4:	1c18      	adds	r0, r3, #0
    11c6:	bf18      	it	ne
    11c8:	2001      	movne	r0, #1
    11ca:	22b8      	movs	r2, #184	; 0xb8
    11cc:	4905      	ldr	r1, [pc, #20]	; (11e4 <mac_async_read_phy_reg+0x2c>)
    11ce:	4b06      	ldr	r3, [pc, #24]	; (11e8 <mac_async_read_phy_reg+0x30>)
    11d0:	4798      	blx	r3
	return _mac_async_read_phy_reg(&descr->dev, addr, reg, val);
    11d2:	4623      	mov	r3, r4
    11d4:	463a      	mov	r2, r7
    11d6:	4631      	mov	r1, r6
    11d8:	4628      	mov	r0, r5
    11da:	4c04      	ldr	r4, [pc, #16]	; (11ec <mac_async_read_phy_reg+0x34>)
    11dc:	47a0      	blx	r4
}
    11de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    11e0:	2000      	movs	r0, #0
    11e2:	e7f2      	b.n	11ca <mac_async_read_phy_reg+0x12>
    11e4:	0000b108 	.word	0x0000b108
    11e8:	00001861 	.word	0x00001861
    11ec:	00001fb9 	.word	0x00001fb9

000011f0 <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
    11f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    11f2:	4684      	mov	ip, r0
 * \return A pointer to the head of the given list or NULL if the list is
 * empty
 */
static inline void *list_get_head(const struct list_descriptor *const list)
{
	return (void *)list->head;
    11f4:	6807      	ldr	r7, [r0, #0]
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);

	if (!head) {
    11f6:	b12f      	cbz	r7, 1204 <timer_add_timer_task+0x14>
		if (it->time_label <= time) {
			time_left = it->interval - (time - it->time_label);
		} else {
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
		}
		if (time_left >= new_task->interval)
    11f8:	688d      	ldr	r5, [r1, #8]
    11fa:	463c      	mov	r4, r7
    11fc:	2600      	movs	r6, #0
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    11fe:	f1c2 0e01 	rsb	lr, r2, #1
    1202:	e00b      	b.n	121c <timer_add_timer_task+0x2c>
		list_insert_as_head(list, new_task);
    1204:	4b0e      	ldr	r3, [pc, #56]	; (1240 <timer_add_timer_task+0x50>)
    1206:	4798      	blx	r3
		return;
    1208:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    120a:	4473      	add	r3, lr
    120c:	68a0      	ldr	r0, [r4, #8]
    120e:	4403      	add	r3, r0
		if (time_left >= new_task->interval)
    1210:	42ab      	cmp	r3, r5
    1212:	d20a      	bcs.n	122a <timer_add_timer_task+0x3a>
 * \return A pointer to the next list element or NULL if there is not next
 * element
 */
static inline void *list_get_next_element(const void *const element)
{
	return element ? ((struct list_element *)element)->next : NULL;
    1214:	6823      	ldr	r3, [r4, #0]
    1216:	4626      	mov	r6, r4
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
    1218:	b153      	cbz	r3, 1230 <timer_add_timer_task+0x40>
    121a:	461c      	mov	r4, r3
		if (it->time_label <= time) {
    121c:	6863      	ldr	r3, [r4, #4]
    121e:	4293      	cmp	r3, r2
    1220:	d8f3      	bhi.n	120a <timer_add_timer_task+0x1a>
			time_left = it->interval - (time - it->time_label);
    1222:	68a0      	ldr	r0, [r4, #8]
    1224:	4403      	add	r3, r0
    1226:	1a9b      	subs	r3, r3, r2
    1228:	e7f2      	b.n	1210 <timer_add_timer_task+0x20>
			break;
		prev = it;
	}

	if (it == head) {
    122a:	42a7      	cmp	r7, r4
    122c:	d004      	beq.n	1238 <timer_add_timer_task+0x48>
    122e:	4634      	mov	r4, r6
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
    1230:	4620      	mov	r0, r4
    1232:	4b04      	ldr	r3, [pc, #16]	; (1244 <timer_add_timer_task+0x54>)
    1234:	4798      	blx	r3
    1236:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		list_insert_as_head(list, new_task);
    1238:	4660      	mov	r0, ip
    123a:	4b01      	ldr	r3, [pc, #4]	; (1240 <timer_add_timer_task+0x50>)
    123c:	4798      	blx	r3
    123e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1240:	00001889 	.word	0x00001889
    1244:	000018b5 	.word	0x000018b5

00001248 <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
    1248:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return (void *)list->head;
    124c:	6944      	ldr	r4, [r0, #20]
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
    124e:	6907      	ldr	r7, [r0, #16]
    1250:	3701      	adds	r7, #1
    1252:	6107      	str	r7, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    1254:	7e03      	ldrb	r3, [r0, #24]
    1256:	f013 0f01 	tst.w	r3, #1
    125a:	d113      	bne.n	1284 <timer_process_counted+0x3c>
    125c:	7e03      	ldrb	r3, [r0, #24]
    125e:	f013 0f02 	tst.w	r3, #2
    1262:	d10f      	bne.n	1284 <timer_process_counted+0x3c>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
		return;
	}

	while (it && ((time - it->time_label) >= it->interval)) {
    1264:	b354      	cbz	r4, 12bc <timer_process_counted+0x74>
    1266:	6863      	ldr	r3, [r4, #4]
    1268:	1afb      	subs	r3, r7, r3
    126a:	68a2      	ldr	r2, [r4, #8]
    126c:	4293      	cmp	r3, r2
    126e:	d307      	bcc.n	1280 <timer_process_counted+0x38>
    1270:	4606      	mov	r6, r0
		struct timer_task *tmp = it;

		list_remove_head(&timer->tasks);
    1272:	f100 0814 	add.w	r8, r0, #20
    1276:	f8df 9048 	ldr.w	r9, [pc, #72]	; 12c0 <timer_process_counted+0x78>
		if (TIMER_TASK_REPEAT == tmp->mode) {
			tmp->time_label = time;
			timer_add_timer_task(&timer->tasks, tmp, time);
    127a:	f8df a048 	ldr.w	sl, [pc, #72]	; 12c4 <timer_process_counted+0x7c>
    127e:	e012      	b.n	12a6 <timer_process_counted+0x5e>
    1280:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
    1284:	7e03      	ldrb	r3, [r0, #24]
    1286:	f043 0302 	orr.w	r3, r3, #2
    128a:	7603      	strb	r3, [r0, #24]
		return;
    128c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1290:	6975      	ldr	r5, [r6, #20]
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);

		tmp->cb(tmp);
    1292:	68e3      	ldr	r3, [r4, #12]
    1294:	4620      	mov	r0, r4
    1296:	4798      	blx	r3
	while (it && ((time - it->time_label) >= it->interval)) {
    1298:	b185      	cbz	r5, 12bc <timer_process_counted+0x74>
		it = (struct timer_task *)list_get_head(&timer->tasks);
    129a:	462c      	mov	r4, r5
	while (it && ((time - it->time_label) >= it->interval)) {
    129c:	686b      	ldr	r3, [r5, #4]
    129e:	1afb      	subs	r3, r7, r3
    12a0:	68aa      	ldr	r2, [r5, #8]
    12a2:	4293      	cmp	r3, r2
    12a4:	d30a      	bcc.n	12bc <timer_process_counted+0x74>
		list_remove_head(&timer->tasks);
    12a6:	4640      	mov	r0, r8
    12a8:	47c8      	blx	r9
		if (TIMER_TASK_REPEAT == tmp->mode) {
    12aa:	7c23      	ldrb	r3, [r4, #16]
    12ac:	2b01      	cmp	r3, #1
    12ae:	d1ef      	bne.n	1290 <timer_process_counted+0x48>
			tmp->time_label = time;
    12b0:	6067      	str	r7, [r4, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
    12b2:	463a      	mov	r2, r7
    12b4:	4621      	mov	r1, r4
    12b6:	4640      	mov	r0, r8
    12b8:	47d0      	blx	sl
    12ba:	e7e9      	b.n	1290 <timer_process_counted+0x48>
    12bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    12c0:	000018bd 	.word	0x000018bd
    12c4:	000011f1 	.word	0x000011f1

000012c8 <timer_init>:
{
    12c8:	b538      	push	{r3, r4, r5, lr}
    12ca:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    12cc:	4604      	mov	r4, r0
    12ce:	b178      	cbz	r0, 12f0 <timer_init+0x28>
    12d0:	1c08      	adds	r0, r1, #0
    12d2:	bf18      	it	ne
    12d4:	2001      	movne	r0, #1
    12d6:	223b      	movs	r2, #59	; 0x3b
    12d8:	4906      	ldr	r1, [pc, #24]	; (12f4 <timer_init+0x2c>)
    12da:	4b07      	ldr	r3, [pc, #28]	; (12f8 <timer_init+0x30>)
    12dc:	4798      	blx	r3
	_timer_init(&descr->device, hw);
    12de:	4629      	mov	r1, r5
    12e0:	4620      	mov	r0, r4
    12e2:	4b06      	ldr	r3, [pc, #24]	; (12fc <timer_init+0x34>)
    12e4:	4798      	blx	r3
	descr->time                           = 0;
    12e6:	2000      	movs	r0, #0
    12e8:	6120      	str	r0, [r4, #16]
	descr->device.timer_cb.period_expired = timer_process_counted;
    12ea:	4b05      	ldr	r3, [pc, #20]	; (1300 <timer_init+0x38>)
    12ec:	6023      	str	r3, [r4, #0]
}
    12ee:	bd38      	pop	{r3, r4, r5, pc}
    12f0:	2000      	movs	r0, #0
    12f2:	e7f0      	b.n	12d6 <timer_init+0xe>
    12f4:	0000b124 	.word	0x0000b124
    12f8:	00001861 	.word	0x00001861
    12fc:	00002b45 	.word	0x00002b45
    1300:	00001249 	.word	0x00001249

00001304 <timer_start>:
{
    1304:	b510      	push	{r4, lr}
	ASSERT(descr);
    1306:	4604      	mov	r4, r0
    1308:	2253      	movs	r2, #83	; 0x53
    130a:	4909      	ldr	r1, [pc, #36]	; (1330 <timer_start+0x2c>)
    130c:	3000      	adds	r0, #0
    130e:	bf18      	it	ne
    1310:	2001      	movne	r0, #1
    1312:	4b08      	ldr	r3, [pc, #32]	; (1334 <timer_start+0x30>)
    1314:	4798      	blx	r3
	if (_timer_is_started(&descr->device)) {
    1316:	4620      	mov	r0, r4
    1318:	4b07      	ldr	r3, [pc, #28]	; (1338 <timer_start+0x34>)
    131a:	4798      	blx	r3
    131c:	b920      	cbnz	r0, 1328 <timer_start+0x24>
	_timer_start(&descr->device);
    131e:	4620      	mov	r0, r4
    1320:	4b06      	ldr	r3, [pc, #24]	; (133c <timer_start+0x38>)
    1322:	4798      	blx	r3
	return ERR_NONE;
    1324:	2000      	movs	r0, #0
    1326:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    1328:	f06f 0010 	mvn.w	r0, #16
}
    132c:	bd10      	pop	{r4, pc}
    132e:	bf00      	nop
    1330:	0000b124 	.word	0x0000b124
    1334:	00001861 	.word	0x00001861
    1338:	00002d01 	.word	0x00002d01
    133c:	00002ced 	.word	0x00002ced

00001340 <timer_add_task>:
{
    1340:	b570      	push	{r4, r5, r6, lr}
    1342:	b082      	sub	sp, #8
    1344:	460d      	mov	r5, r1
	ASSERT(descr && task);
    1346:	4604      	mov	r4, r0
    1348:	b318      	cbz	r0, 1392 <timer_add_task+0x52>
    134a:	1c08      	adds	r0, r1, #0
    134c:	bf18      	it	ne
    134e:	2001      	movne	r0, #1
    1350:	227a      	movs	r2, #122	; 0x7a
    1352:	491e      	ldr	r1, [pc, #120]	; (13cc <timer_add_task+0x8c>)
    1354:	4b1e      	ldr	r3, [pc, #120]	; (13d0 <timer_add_task+0x90>)
    1356:	4798      	blx	r3
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    1358:	7e23      	ldrb	r3, [r4, #24]
    135a:	f043 0301 	orr.w	r3, r3, #1
    135e:	7623      	strb	r3, [r4, #24]
	if (is_list_element(&descr->tasks, task)) {
    1360:	f104 0614 	add.w	r6, r4, #20
    1364:	4629      	mov	r1, r5
    1366:	4630      	mov	r0, r6
    1368:	4b1a      	ldr	r3, [pc, #104]	; (13d4 <timer_add_task+0x94>)
    136a:	4798      	blx	r3
    136c:	b998      	cbnz	r0, 1396 <timer_add_task+0x56>
	task->time_label = descr->time;
    136e:	6923      	ldr	r3, [r4, #16]
    1370:	606b      	str	r3, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    1372:	6922      	ldr	r2, [r4, #16]
    1374:	4629      	mov	r1, r5
    1376:	4630      	mov	r0, r6
    1378:	4b17      	ldr	r3, [pc, #92]	; (13d8 <timer_add_task+0x98>)
    137a:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    137c:	7e23      	ldrb	r3, [r4, #24]
    137e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    1382:	7623      	strb	r3, [r4, #24]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
    1384:	7e23      	ldrb	r3, [r4, #24]
    1386:	f013 0f02 	tst.w	r3, #2
    138a:	d110      	bne.n	13ae <timer_add_task+0x6e>
	return ERR_NONE;
    138c:	2000      	movs	r0, #0
}
    138e:	b002      	add	sp, #8
    1390:	bd70      	pop	{r4, r5, r6, pc}
    1392:	2000      	movs	r0, #0
    1394:	e7dc      	b.n	1350 <timer_add_task+0x10>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    1396:	7e23      	ldrb	r3, [r4, #24]
    1398:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    139c:	7623      	strb	r3, [r4, #24]
		ASSERT(false);
    139e:	227f      	movs	r2, #127	; 0x7f
    13a0:	490a      	ldr	r1, [pc, #40]	; (13cc <timer_add_task+0x8c>)
    13a2:	2000      	movs	r0, #0
    13a4:	4b0a      	ldr	r3, [pc, #40]	; (13d0 <timer_add_task+0x90>)
    13a6:	4798      	blx	r3
		return ERR_ALREADY_INITIALIZED;
    13a8:	f06f 0011 	mvn.w	r0, #17
    13ac:	e7ef      	b.n	138e <timer_add_task+0x4e>
		CRITICAL_SECTION_ENTER()
    13ae:	a801      	add	r0, sp, #4
    13b0:	4b0a      	ldr	r3, [pc, #40]	; (13dc <timer_add_task+0x9c>)
    13b2:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    13b4:	7e23      	ldrb	r3, [r4, #24]
    13b6:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    13ba:	7623      	strb	r3, [r4, #24]
		_timer_set_irq(&descr->device);
    13bc:	4620      	mov	r0, r4
    13be:	4b08      	ldr	r3, [pc, #32]	; (13e0 <timer_add_task+0xa0>)
    13c0:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
    13c2:	a801      	add	r0, sp, #4
    13c4:	4b07      	ldr	r3, [pc, #28]	; (13e4 <timer_add_task+0xa4>)
    13c6:	4798      	blx	r3
	return ERR_NONE;
    13c8:	2000      	movs	r0, #0
    13ca:	e7e0      	b.n	138e <timer_add_task+0x4e>
    13cc:	0000b124 	.word	0x0000b124
    13d0:	00001861 	.word	0x00001861
    13d4:	00001867 	.word	0x00001867
    13d8:	000011f1 	.word	0x000011f1
    13dc:	00000eb5 	.word	0x00000eb5
    13e0:	00002d19 	.word	0x00002d19
    13e4:	00000ec3 	.word	0x00000ec3

000013e8 <usart_transmission_complete>:
 * \brief Process completion of data sending
 *
 * \param[in] device The pointer to device structure
 */
static void usart_transmission_complete(struct _usart_async_device *device)
{
    13e8:	b508      	push	{r3, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
    13ea:	2300      	movs	r3, #0
    13ec:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.tx_done) {
    13ee:	69c3      	ldr	r3, [r0, #28]
    13f0:	b11b      	cbz	r3, 13fa <usart_transmission_complete+0x12>
    13f2:	f1a0 0208 	sub.w	r2, r0, #8
		descr->usart_cb.tx_done(descr);
    13f6:	4610      	mov	r0, r2
    13f8:	4798      	blx	r3
    13fa:	bd08      	pop	{r3, pc}

000013fc <usart_error>:
 * \brief Process error interrupt
 *
 * \param[in] device The pointer to device structure
 */
static void usart_error(struct _usart_async_device *device)
{
    13fc:	b508      	push	{r3, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
    13fe:	2300      	movs	r3, #0
    1400:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.error) {
    1402:	6a43      	ldr	r3, [r0, #36]	; 0x24
    1404:	b11b      	cbz	r3, 140e <usart_error+0x12>
    1406:	f1a0 0208 	sub.w	r2, r0, #8
		descr->usart_cb.error(descr);
    140a:	4610      	mov	r0, r2
    140c:	4798      	blx	r3
    140e:	bd08      	pop	{r3, pc}

00001410 <usart_fill_rx_buffer>:
{
    1410:	b538      	push	{r3, r4, r5, lr}
    1412:	4604      	mov	r4, r0
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
    1414:	f1a0 0508 	sub.w	r5, r0, #8
	ringbuffer_put(&descr->rx, data);
    1418:	302c      	adds	r0, #44	; 0x2c
    141a:	4b03      	ldr	r3, [pc, #12]	; (1428 <usart_fill_rx_buffer+0x18>)
    141c:	4798      	blx	r3
	if (descr->usart_cb.rx_done) {
    141e:	6a23      	ldr	r3, [r4, #32]
    1420:	b10b      	cbz	r3, 1426 <usart_fill_rx_buffer+0x16>
		descr->usart_cb.rx_done(descr);
    1422:	4628      	mov	r0, r5
    1424:	4798      	blx	r3
    1426:	bd38      	pop	{r3, r4, r5, pc}
    1428:	0000195d 	.word	0x0000195d

0000142c <usart_async_write>:
{
    142c:	b570      	push	{r4, r5, r6, lr}
    142e:	460e      	mov	r6, r1
    1430:	4615      	mov	r5, r2
	ASSERT(descr && buf && length);
    1432:	4604      	mov	r4, r0
    1434:	b1e0      	cbz	r0, 1470 <usart_async_write+0x44>
    1436:	b1e9      	cbz	r1, 1474 <usart_async_write+0x48>
    1438:	1c10      	adds	r0, r2, #0
    143a:	bf18      	it	ne
    143c:	2001      	movne	r0, #1
    143e:	f240 123b 	movw	r2, #315	; 0x13b
    1442:	490f      	ldr	r1, [pc, #60]	; (1480 <usart_async_write+0x54>)
    1444:	4b0f      	ldr	r3, [pc, #60]	; (1484 <usart_async_write+0x58>)
    1446:	4798      	blx	r3
	if (descr->tx_por != descr->tx_buffer_length) {
    1448:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
    144c:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
    1450:	429a      	cmp	r2, r3
    1452:	d111      	bne.n	1478 <usart_async_write+0x4c>
	descr->tx_buffer        = (uint8_t *)buf;
    1454:	64a6      	str	r6, [r4, #72]	; 0x48
	descr->tx_buffer_length = length;
    1456:	f8a4 504c 	strh.w	r5, [r4, #76]	; 0x4c
	descr->tx_por           = 0;
    145a:	2300      	movs	r3, #0
    145c:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	descr->stat             = USART_ASYNC_STATUS_BUSY;
    1460:	2301      	movs	r3, #1
    1462:	6323      	str	r3, [r4, #48]	; 0x30
	_usart_async_enable_byte_sent_irq(&descr->device);
    1464:	f104 0008 	add.w	r0, r4, #8
    1468:	4b07      	ldr	r3, [pc, #28]	; (1488 <usart_async_write+0x5c>)
    146a:	4798      	blx	r3
	return (int32_t)length;
    146c:	4628      	mov	r0, r5
    146e:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && length);
    1470:	2000      	movs	r0, #0
    1472:	e7e4      	b.n	143e <usart_async_write+0x12>
    1474:	2000      	movs	r0, #0
    1476:	e7e2      	b.n	143e <usart_async_write+0x12>
		return ERR_NO_RESOURCE;
    1478:	f06f 001b 	mvn.w	r0, #27
}
    147c:	bd70      	pop	{r4, r5, r6, pc}
    147e:	bf00      	nop
    1480:	0000b13c 	.word	0x0000b13c
    1484:	00001861 	.word	0x00001861
    1488:	000024cb 	.word	0x000024cb

0000148c <usart_process_byte_sent>:
{
    148c:	b510      	push	{r4, lr}
    148e:	4604      	mov	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
    1490:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
    1492:	f8b0 2044 	ldrh.w	r2, [r0, #68]	; 0x44
    1496:	429a      	cmp	r2, r3
    1498:	d009      	beq.n	14ae <usart_process_byte_sent+0x22>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
    149a:	6c02      	ldr	r2, [r0, #64]	; 0x40
    149c:	1c59      	adds	r1, r3, #1
    149e:	8781      	strh	r1, [r0, #60]	; 0x3c
    14a0:	5cd1      	ldrb	r1, [r2, r3]
    14a2:	4b04      	ldr	r3, [pc, #16]	; (14b4 <usart_process_byte_sent+0x28>)
    14a4:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
    14a6:	4620      	mov	r0, r4
    14a8:	4b03      	ldr	r3, [pc, #12]	; (14b8 <usart_process_byte_sent+0x2c>)
    14aa:	4798      	blx	r3
    14ac:	bd10      	pop	{r4, pc}
		_usart_async_enable_tx_done_irq(&descr->device);
    14ae:	4b03      	ldr	r3, [pc, #12]	; (14bc <usart_process_byte_sent+0x30>)
    14b0:	4798      	blx	r3
    14b2:	bd10      	pop	{r4, pc}
    14b4:	0000249f 	.word	0x0000249f
    14b8:	000024cb 	.word	0x000024cb
    14bc:	000024d3 	.word	0x000024d3

000014c0 <usart_async_read>:
{
    14c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    14c4:	b082      	sub	sp, #8
    14c6:	460f      	mov	r7, r1
    14c8:	4690      	mov	r8, r2
	ASSERT(descr && buf && length);
    14ca:	4606      	mov	r6, r0
    14cc:	b1a0      	cbz	r0, 14f8 <usart_async_read+0x38>
    14ce:	b199      	cbz	r1, 14f8 <usart_async_read+0x38>
    14d0:	2a00      	cmp	r2, #0
    14d2:	d12d      	bne.n	1530 <usart_async_read+0x70>
    14d4:	f44f 72ac 	mov.w	r2, #344	; 0x158
    14d8:	4929      	ldr	r1, [pc, #164]	; (1580 <usart_async_read+0xc0>)
    14da:	2000      	movs	r0, #0
    14dc:	4b29      	ldr	r3, [pc, #164]	; (1584 <usart_async_read+0xc4>)
    14de:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
    14e0:	a801      	add	r0, sp, #4
    14e2:	4b29      	ldr	r3, [pc, #164]	; (1588 <usart_async_read+0xc8>)
    14e4:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
    14e6:	f106 0034 	add.w	r0, r6, #52	; 0x34
    14ea:	4b28      	ldr	r3, [pc, #160]	; (158c <usart_async_read+0xcc>)
    14ec:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
    14ee:	a801      	add	r0, sp, #4
    14f0:	4b27      	ldr	r3, [pc, #156]	; (1590 <usart_async_read+0xd0>)
    14f2:	4798      	blx	r3
	uint16_t                       was_read = 0;
    14f4:	2500      	movs	r5, #0
	return (int32_t)was_read;
    14f6:	e03e      	b.n	1576 <usart_async_read+0xb6>
	ASSERT(descr && buf && length);
    14f8:	f44f 72ac 	mov.w	r2, #344	; 0x158
    14fc:	4920      	ldr	r1, [pc, #128]	; (1580 <usart_async_read+0xc0>)
    14fe:	2000      	movs	r0, #0
    1500:	4b20      	ldr	r3, [pc, #128]	; (1584 <usart_async_read+0xc4>)
    1502:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
    1504:	a801      	add	r0, sp, #4
    1506:	4b20      	ldr	r3, [pc, #128]	; (1588 <usart_async_read+0xc8>)
    1508:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
    150a:	f106 0a34 	add.w	sl, r6, #52	; 0x34
    150e:	4650      	mov	r0, sl
    1510:	4b1e      	ldr	r3, [pc, #120]	; (158c <usart_async_read+0xcc>)
    1512:	4798      	blx	r3
    1514:	4681      	mov	r9, r0
	CRITICAL_SECTION_LEAVE()
    1516:	a801      	add	r0, sp, #4
    1518:	4b1d      	ldr	r3, [pc, #116]	; (1590 <usart_async_read+0xd0>)
    151a:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
    151c:	f1b9 0f00 	cmp.w	r9, #0
    1520:	d004      	beq.n	152c <usart_async_read+0x6c>
    1522:	f1b8 0f00 	cmp.w	r8, #0
    1526:	d119      	bne.n	155c <usart_async_read+0x9c>
	uint16_t                       was_read = 0;
    1528:	2500      	movs	r5, #0
    152a:	e024      	b.n	1576 <usart_async_read+0xb6>
    152c:	2500      	movs	r5, #0
    152e:	e022      	b.n	1576 <usart_async_read+0xb6>
	ASSERT(descr && buf && length);
    1530:	f44f 72ac 	mov.w	r2, #344	; 0x158
    1534:	4912      	ldr	r1, [pc, #72]	; (1580 <usart_async_read+0xc0>)
    1536:	2001      	movs	r0, #1
    1538:	4b12      	ldr	r3, [pc, #72]	; (1584 <usart_async_read+0xc4>)
    153a:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
    153c:	a801      	add	r0, sp, #4
    153e:	4b12      	ldr	r3, [pc, #72]	; (1588 <usart_async_read+0xc8>)
    1540:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
    1542:	f106 0a34 	add.w	sl, r6, #52	; 0x34
    1546:	4650      	mov	r0, sl
    1548:	4b10      	ldr	r3, [pc, #64]	; (158c <usart_async_read+0xcc>)
    154a:	4798      	blx	r3
    154c:	4681      	mov	r9, r0
	CRITICAL_SECTION_LEAVE()
    154e:	a801      	add	r0, sp, #4
    1550:	4b0f      	ldr	r3, [pc, #60]	; (1590 <usart_async_read+0xd0>)
    1552:	4798      	blx	r3
	uint16_t                       was_read = 0;
    1554:	2500      	movs	r5, #0
	while ((was_read < num) && (was_read < length)) {
    1556:	f1b9 0f00 	cmp.w	r9, #0
    155a:	d00c      	beq.n	1576 <usart_async_read+0xb6>
{
    155c:	2400      	movs	r4, #0
		ringbuffer_get(&descr->rx, &buf[was_read++]);
    155e:	4e0d      	ldr	r6, [pc, #52]	; (1594 <usart_async_read+0xd4>)
    1560:	1c60      	adds	r0, r4, #1
    1562:	b285      	uxth	r5, r0
    1564:	1939      	adds	r1, r7, r4
    1566:	4650      	mov	r0, sl
    1568:	47b0      	blx	r6
    156a:	3401      	adds	r4, #1
	while ((was_read < num) && (was_read < length)) {
    156c:	454c      	cmp	r4, r9
    156e:	d202      	bcs.n	1576 <usart_async_read+0xb6>
    1570:	b2a3      	uxth	r3, r4
    1572:	4598      	cmp	r8, r3
    1574:	d8f4      	bhi.n	1560 <usart_async_read+0xa0>
}
    1576:	4628      	mov	r0, r5
    1578:	b002      	add	sp, #8
    157a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    157e:	bf00      	nop
    1580:	0000b13c 	.word	0x0000b13c
    1584:	00001861 	.word	0x00001861
    1588:	00000eb5 	.word	0x00000eb5
    158c:	0000199d 	.word	0x0000199d
    1590:	00000ec3 	.word	0x00000ec3
    1594:	00001919 	.word	0x00001919

00001598 <usart_async_init>:
{
    1598:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    159a:	460d      	mov	r5, r1
    159c:	4616      	mov	r6, r2
    159e:	461f      	mov	r7, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
    15a0:	4604      	mov	r4, r0
    15a2:	b320      	cbz	r0, 15ee <usart_async_init+0x56>
    15a4:	b329      	cbz	r1, 15f2 <usart_async_init+0x5a>
    15a6:	b332      	cbz	r2, 15f6 <usart_async_init+0x5e>
    15a8:	1c18      	adds	r0, r3, #0
    15aa:	bf18      	it	ne
    15ac:	2001      	movne	r0, #1
    15ae:	223a      	movs	r2, #58	; 0x3a
    15b0:	4913      	ldr	r1, [pc, #76]	; (1600 <usart_async_init+0x68>)
    15b2:	4b14      	ldr	r3, [pc, #80]	; (1604 <usart_async_init+0x6c>)
    15b4:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
    15b6:	463a      	mov	r2, r7
    15b8:	4631      	mov	r1, r6
    15ba:	f104 0034 	add.w	r0, r4, #52	; 0x34
    15be:	4b12      	ldr	r3, [pc, #72]	; (1608 <usart_async_init+0x70>)
    15c0:	4798      	blx	r3
    15c2:	b9d0      	cbnz	r0, 15fa <usart_async_init+0x62>
	init_status = _usart_async_init(&descr->device, hw);
    15c4:	4629      	mov	r1, r5
    15c6:	f104 0008 	add.w	r0, r4, #8
    15ca:	4b10      	ldr	r3, [pc, #64]	; (160c <usart_async_init+0x74>)
    15cc:	4798      	blx	r3
	if (init_status) {
    15ce:	4603      	mov	r3, r0
    15d0:	b958      	cbnz	r0, 15ea <usart_async_init+0x52>
	descr->io.read  = usart_async_read;
    15d2:	4a0f      	ldr	r2, [pc, #60]	; (1610 <usart_async_init+0x78>)
    15d4:	6062      	str	r2, [r4, #4]
	descr->io.write = usart_async_write;
    15d6:	4a0f      	ldr	r2, [pc, #60]	; (1614 <usart_async_init+0x7c>)
    15d8:	6022      	str	r2, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_process_byte_sent;
    15da:	4a0f      	ldr	r2, [pc, #60]	; (1618 <usart_async_init+0x80>)
    15dc:	60a2      	str	r2, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_fill_rx_buffer;
    15de:	4a0f      	ldr	r2, [pc, #60]	; (161c <usart_async_init+0x84>)
    15e0:	60e2      	str	r2, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_transmission_complete;
    15e2:	4a0f      	ldr	r2, [pc, #60]	; (1620 <usart_async_init+0x88>)
    15e4:	6122      	str	r2, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_error;
    15e6:	4a0f      	ldr	r2, [pc, #60]	; (1624 <usart_async_init+0x8c>)
    15e8:	6162      	str	r2, [r4, #20]
}
    15ea:	4618      	mov	r0, r3
    15ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
    15ee:	2000      	movs	r0, #0
    15f0:	e7dd      	b.n	15ae <usart_async_init+0x16>
    15f2:	2000      	movs	r0, #0
    15f4:	e7db      	b.n	15ae <usart_async_init+0x16>
    15f6:	2000      	movs	r0, #0
    15f8:	e7d9      	b.n	15ae <usart_async_init+0x16>
		return ERR_INVALID_ARG;
    15fa:	f06f 030c 	mvn.w	r3, #12
    15fe:	e7f4      	b.n	15ea <usart_async_init+0x52>
    1600:	0000b13c 	.word	0x0000b13c
    1604:	00001861 	.word	0x00001861
    1608:	000018c9 	.word	0x000018c9
    160c:	000023ed 	.word	0x000023ed
    1610:	000014c1 	.word	0x000014c1
    1614:	0000142d 	.word	0x0000142d
    1618:	0000148d 	.word	0x0000148d
    161c:	00001411 	.word	0x00001411
    1620:	000013e9 	.word	0x000013e9
    1624:	000013fd 	.word	0x000013fd

00001628 <usart_async_enable>:
{
    1628:	b510      	push	{r4, lr}
	ASSERT(descr);
    162a:	4604      	mov	r4, r0
    162c:	2261      	movs	r2, #97	; 0x61
    162e:	4906      	ldr	r1, [pc, #24]	; (1648 <usart_async_enable+0x20>)
    1630:	3000      	adds	r0, #0
    1632:	bf18      	it	ne
    1634:	2001      	movne	r0, #1
    1636:	4b05      	ldr	r3, [pc, #20]	; (164c <usart_async_enable+0x24>)
    1638:	4798      	blx	r3
	_usart_async_enable(&descr->device);
    163a:	f104 0008 	add.w	r0, r4, #8
    163e:	4b04      	ldr	r3, [pc, #16]	; (1650 <usart_async_enable+0x28>)
    1640:	4798      	blx	r3
}
    1642:	2000      	movs	r0, #0
    1644:	bd10      	pop	{r4, pc}
    1646:	bf00      	nop
    1648:	0000b13c 	.word	0x0000b13c
    164c:	00001861 	.word	0x00001861
    1650:	00002485 	.word	0x00002485

00001654 <usart_async_get_io_descriptor>:
{
    1654:	b538      	push	{r3, r4, r5, lr}
    1656:	460c      	mov	r4, r1
	ASSERT(descr && io);
    1658:	4605      	mov	r5, r0
    165a:	b148      	cbz	r0, 1670 <usart_async_get_io_descriptor+0x1c>
    165c:	1c08      	adds	r0, r1, #0
    165e:	bf18      	it	ne
    1660:	2001      	movne	r0, #1
    1662:	2277      	movs	r2, #119	; 0x77
    1664:	4903      	ldr	r1, [pc, #12]	; (1674 <usart_async_get_io_descriptor+0x20>)
    1666:	4b04      	ldr	r3, [pc, #16]	; (1678 <usart_async_get_io_descriptor+0x24>)
    1668:	4798      	blx	r3
	*io = &descr->io;
    166a:	6025      	str	r5, [r4, #0]
}
    166c:	2000      	movs	r0, #0
    166e:	bd38      	pop	{r3, r4, r5, pc}
    1670:	2000      	movs	r0, #0
    1672:	e7f6      	b.n	1662 <usart_async_get_io_descriptor+0xe>
    1674:	0000b13c 	.word	0x0000b13c
    1678:	00001861 	.word	0x00001861

0000167c <usart_async_register_callback>:
{
    167c:	b570      	push	{r4, r5, r6, lr}
    167e:	460c      	mov	r4, r1
    1680:	4616      	mov	r6, r2
	ASSERT(descr);
    1682:	4605      	mov	r5, r0
    1684:	2283      	movs	r2, #131	; 0x83
    1686:	4917      	ldr	r1, [pc, #92]	; (16e4 <usart_async_register_callback+0x68>)
    1688:	3000      	adds	r0, #0
    168a:	bf18      	it	ne
    168c:	2001      	movne	r0, #1
    168e:	4b16      	ldr	r3, [pc, #88]	; (16e8 <usart_async_register_callback+0x6c>)
    1690:	4798      	blx	r3
	switch (type) {
    1692:	2c01      	cmp	r4, #1
    1694:	d010      	beq.n	16b8 <usart_async_register_callback+0x3c>
    1696:	b124      	cbz	r4, 16a2 <usart_async_register_callback+0x26>
    1698:	2c02      	cmp	r4, #2
    169a:	d018      	beq.n	16ce <usart_async_register_callback+0x52>
		return ERR_INVALID_ARG;
    169c:	f06f 000c 	mvn.w	r0, #12
}
    16a0:	bd70      	pop	{r4, r5, r6, pc}
		descr->usart_cb.rx_done = cb;
    16a2:	62ae      	str	r6, [r5, #40]	; 0x28
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
    16a4:	1c32      	adds	r2, r6, #0
    16a6:	bf18      	it	ne
    16a8:	2201      	movne	r2, #1
    16aa:	2101      	movs	r1, #1
    16ac:	f105 0008 	add.w	r0, r5, #8
    16b0:	4b0e      	ldr	r3, [pc, #56]	; (16ec <usart_async_register_callback+0x70>)
    16b2:	4798      	blx	r3
	return ERR_NONE;
    16b4:	2000      	movs	r0, #0
		break;
    16b6:	bd70      	pop	{r4, r5, r6, pc}
		descr->usart_cb.tx_done = cb;
    16b8:	626e      	str	r6, [r5, #36]	; 0x24
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
    16ba:	1c32      	adds	r2, r6, #0
    16bc:	bf18      	it	ne
    16be:	2201      	movne	r2, #1
    16c0:	2102      	movs	r1, #2
    16c2:	f105 0008 	add.w	r0, r5, #8
    16c6:	4b09      	ldr	r3, [pc, #36]	; (16ec <usart_async_register_callback+0x70>)
    16c8:	4798      	blx	r3
	return ERR_NONE;
    16ca:	2000      	movs	r0, #0
		break;
    16cc:	bd70      	pop	{r4, r5, r6, pc}
		descr->usart_cb.error = cb;
    16ce:	62ee      	str	r6, [r5, #44]	; 0x2c
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
    16d0:	1c32      	adds	r2, r6, #0
    16d2:	bf18      	it	ne
    16d4:	2201      	movne	r2, #1
    16d6:	2103      	movs	r1, #3
    16d8:	f105 0008 	add.w	r0, r5, #8
    16dc:	4b03      	ldr	r3, [pc, #12]	; (16ec <usart_async_register_callback+0x70>)
    16de:	4798      	blx	r3
	return ERR_NONE;
    16e0:	2000      	movs	r0, #0
		break;
    16e2:	bd70      	pop	{r4, r5, r6, pc}
    16e4:	0000b13c 	.word	0x0000b13c
    16e8:	00001861 	.word	0x00001861
    16ec:	000024dd 	.word	0x000024dd

000016f0 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    16f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    16f4:	460f      	mov	r7, r1
    16f6:	4690      	mov	r8, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    16f8:	4604      	mov	r4, r0
    16fa:	b328      	cbz	r0, 1748 <usart_sync_write+0x58>
    16fc:	b331      	cbz	r1, 174c <usart_sync_write+0x5c>
    16fe:	1c10      	adds	r0, r2, #0
    1700:	bf18      	it	ne
    1702:	2001      	movne	r0, #1
    1704:	22f1      	movs	r2, #241	; 0xf1
    1706:	4912      	ldr	r1, [pc, #72]	; (1750 <usart_sync_write+0x60>)
    1708:	4b12      	ldr	r3, [pc, #72]	; (1754 <usart_sync_write+0x64>)
    170a:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    170c:	3408      	adds	r4, #8
    170e:	4d12      	ldr	r5, [pc, #72]	; (1758 <usart_sync_write+0x68>)
    1710:	4620      	mov	r0, r4
    1712:	47a8      	blx	r5
    1714:	2800      	cmp	r0, #0
    1716:	d0fb      	beq.n	1710 <usart_sync_write+0x20>
    1718:	3f01      	subs	r7, #1
    171a:	2600      	movs	r6, #0
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    171c:	f8df 9040 	ldr.w	r9, [pc, #64]	; 1760 <usart_sync_write+0x70>
		while (!_usart_sync_is_ready_to_send(&descr->device))
    1720:	4d0d      	ldr	r5, [pc, #52]	; (1758 <usart_sync_write+0x68>)
		_usart_sync_write_byte(&descr->device, buf[offset]);
    1722:	f817 1f01 	ldrb.w	r1, [r7, #1]!
    1726:	4620      	mov	r0, r4
    1728:	47c8      	blx	r9
		while (!_usart_sync_is_ready_to_send(&descr->device))
    172a:	4620      	mov	r0, r4
    172c:	47a8      	blx	r5
    172e:	2800      	cmp	r0, #0
    1730:	d0fb      	beq.n	172a <usart_sync_write+0x3a>
			;
	} while (++offset < length);
    1732:	3601      	adds	r6, #1
    1734:	4546      	cmp	r6, r8
    1736:	d3f4      	bcc.n	1722 <usart_sync_write+0x32>
	while (!_usart_sync_is_transmit_done(&descr->device))
    1738:	4d08      	ldr	r5, [pc, #32]	; (175c <usart_sync_write+0x6c>)
    173a:	4620      	mov	r0, r4
    173c:	47a8      	blx	r5
    173e:	2800      	cmp	r0, #0
    1740:	d0fb      	beq.n	173a <usart_sync_write+0x4a>
		;
	return (int32_t)offset;
}
    1742:	4630      	mov	r0, r6
    1744:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    1748:	2000      	movs	r0, #0
    174a:	e7db      	b.n	1704 <usart_sync_write+0x14>
    174c:	2000      	movs	r0, #0
    174e:	e7d9      	b.n	1704 <usart_sync_write+0x14>
    1750:	0000b15c 	.word	0x0000b15c
    1754:	00001861 	.word	0x00001861
    1758:	000024ad 	.word	0x000024ad
    175c:	000024b7 	.word	0x000024b7
    1760:	00002499 	.word	0x00002499

00001764 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    1764:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1768:	460f      	mov	r7, r1
    176a:	4690      	mov	r8, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    176c:	4604      	mov	r4, r0
    176e:	b1e0      	cbz	r0, 17aa <usart_sync_read+0x46>
    1770:	b1e9      	cbz	r1, 17ae <usart_sync_read+0x4a>
    1772:	1c10      	adds	r0, r2, #0
    1774:	bf18      	it	ne
    1776:	2001      	movne	r0, #1
    1778:	f44f 7286 	mov.w	r2, #268	; 0x10c
    177c:	490d      	ldr	r1, [pc, #52]	; (17b4 <usart_sync_read+0x50>)
    177e:	4b0e      	ldr	r3, [pc, #56]	; (17b8 <usart_sync_read+0x54>)
    1780:	4798      	blx	r3
    1782:	3f01      	subs	r7, #1
	uint32_t                      offset = 0;
    1784:	2600      	movs	r6, #0
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    1786:	3408      	adds	r4, #8
    1788:	4d0c      	ldr	r5, [pc, #48]	; (17bc <usart_sync_read+0x58>)
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    178a:	f8df 9034 	ldr.w	r9, [pc, #52]	; 17c0 <usart_sync_read+0x5c>
		while (!_usart_sync_is_byte_received(&descr->device))
    178e:	4620      	mov	r0, r4
    1790:	47a8      	blx	r5
    1792:	2800      	cmp	r0, #0
    1794:	d0fb      	beq.n	178e <usart_sync_read+0x2a>
		buf[offset] = _usart_sync_read_byte(&descr->device);
    1796:	4620      	mov	r0, r4
    1798:	47c8      	blx	r9
    179a:	f807 0f01 	strb.w	r0, [r7, #1]!
	} while (++offset < length);
    179e:	3601      	adds	r6, #1
    17a0:	4546      	cmp	r6, r8
    17a2:	d3f4      	bcc.n	178e <usart_sync_read+0x2a>

	return (int32_t)offset;
}
    17a4:	4630      	mov	r0, r6
    17a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    17aa:	2000      	movs	r0, #0
    17ac:	e7e4      	b.n	1778 <usart_sync_read+0x14>
    17ae:	2000      	movs	r0, #0
    17b0:	e7e2      	b.n	1778 <usart_sync_read+0x14>
    17b2:	bf00      	nop
    17b4:	0000b15c 	.word	0x0000b15c
    17b8:	00001861 	.word	0x00001861
    17bc:	000024c1 	.word	0x000024c1
    17c0:	000024a5 	.word	0x000024a5

000017c4 <usart_sync_init>:
{
    17c4:	b538      	push	{r3, r4, r5, lr}
    17c6:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    17c8:	4604      	mov	r4, r0
    17ca:	b198      	cbz	r0, 17f4 <usart_sync_init+0x30>
    17cc:	1c08      	adds	r0, r1, #0
    17ce:	bf18      	it	ne
    17d0:	2001      	movne	r0, #1
    17d2:	2234      	movs	r2, #52	; 0x34
    17d4:	4908      	ldr	r1, [pc, #32]	; (17f8 <usart_sync_init+0x34>)
    17d6:	4b09      	ldr	r3, [pc, #36]	; (17fc <usart_sync_init+0x38>)
    17d8:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    17da:	4629      	mov	r1, r5
    17dc:	f104 0008 	add.w	r0, r4, #8
    17e0:	4b07      	ldr	r3, [pc, #28]	; (1800 <usart_sync_init+0x3c>)
    17e2:	4798      	blx	r3
	if (init_status) {
    17e4:	4603      	mov	r3, r0
    17e6:	b918      	cbnz	r0, 17f0 <usart_sync_init+0x2c>
	descr->io.read  = usart_sync_read;
    17e8:	4a06      	ldr	r2, [pc, #24]	; (1804 <usart_sync_init+0x40>)
    17ea:	6062      	str	r2, [r4, #4]
	descr->io.write = usart_sync_write;
    17ec:	4a06      	ldr	r2, [pc, #24]	; (1808 <usart_sync_init+0x44>)
    17ee:	6022      	str	r2, [r4, #0]
}
    17f0:	4618      	mov	r0, r3
    17f2:	bd38      	pop	{r3, r4, r5, pc}
    17f4:	2000      	movs	r0, #0
    17f6:	e7ec      	b.n	17d2 <usart_sync_init+0xe>
    17f8:	0000b15c 	.word	0x0000b15c
    17fc:	00001861 	.word	0x00001861
    1800:	000023c1 	.word	0x000023c1
    1804:	00001765 	.word	0x00001765
    1808:	000016f1 	.word	0x000016f1

0000180c <usart_sync_enable>:
{
    180c:	b510      	push	{r4, lr}
	ASSERT(descr);
    180e:	4604      	mov	r4, r0
    1810:	2253      	movs	r2, #83	; 0x53
    1812:	4906      	ldr	r1, [pc, #24]	; (182c <usart_sync_enable+0x20>)
    1814:	3000      	adds	r0, #0
    1816:	bf18      	it	ne
    1818:	2001      	movne	r0, #1
    181a:	4b05      	ldr	r3, [pc, #20]	; (1830 <usart_sync_enable+0x24>)
    181c:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
    181e:	f104 0008 	add.w	r0, r4, #8
    1822:	4b04      	ldr	r3, [pc, #16]	; (1834 <usart_sync_enable+0x28>)
    1824:	4798      	blx	r3
}
    1826:	2000      	movs	r0, #0
    1828:	bd10      	pop	{r4, pc}
    182a:	bf00      	nop
    182c:	0000b15c 	.word	0x0000b15c
    1830:	00001861 	.word	0x00001861
    1834:	00002471 	.word	0x00002471

00001838 <usart_sync_get_io_descriptor>:
{
    1838:	b538      	push	{r3, r4, r5, lr}
    183a:	460c      	mov	r4, r1
	ASSERT(descr && io);
    183c:	4605      	mov	r5, r0
    183e:	b148      	cbz	r0, 1854 <usart_sync_get_io_descriptor+0x1c>
    1840:	1c08      	adds	r0, r1, #0
    1842:	bf18      	it	ne
    1844:	2001      	movne	r0, #1
    1846:	2269      	movs	r2, #105	; 0x69
    1848:	4903      	ldr	r1, [pc, #12]	; (1858 <usart_sync_get_io_descriptor+0x20>)
    184a:	4b04      	ldr	r3, [pc, #16]	; (185c <usart_sync_get_io_descriptor+0x24>)
    184c:	4798      	blx	r3
	*io = &descr->io;
    184e:	6025      	str	r5, [r4, #0]
}
    1850:	2000      	movs	r0, #0
    1852:	bd38      	pop	{r3, r4, r5, pc}
    1854:	2000      	movs	r0, #0
    1856:	e7f6      	b.n	1846 <usart_sync_get_io_descriptor+0xe>
    1858:	0000b15c 	.word	0x0000b15c
    185c:	00001861 	.word	0x00001861

00001860 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    1860:	b900      	cbnz	r0, 1864 <assert+0x4>
		__asm("BKPT #0");
    1862:	be00      	bkpt	0x0000
    1864:	4770      	bx	lr

00001866 <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
    1866:	6803      	ldr	r3, [r0, #0]
    1868:	b14b      	cbz	r3, 187e <is_list_element+0x18>
		if (it == element) {
    186a:	428b      	cmp	r3, r1
    186c:	d009      	beq.n	1882 <is_list_element+0x1c>
	for (it = list->head; it; it = it->next) {
    186e:	681b      	ldr	r3, [r3, #0]
    1870:	b11b      	cbz	r3, 187a <is_list_element+0x14>
		if (it == element) {
    1872:	4299      	cmp	r1, r3
    1874:	d1fb      	bne.n	186e <is_list_element+0x8>
			return true;
    1876:	2001      	movs	r0, #1
		}
	}

	return false;
}
    1878:	4770      	bx	lr
	return false;
    187a:	2000      	movs	r0, #0
    187c:	4770      	bx	lr
    187e:	2000      	movs	r0, #0
    1880:	4770      	bx	lr
			return true;
    1882:	2001      	movs	r0, #1
    1884:	4770      	bx	lr
	...

00001888 <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
    1888:	b538      	push	{r3, r4, r5, lr}
    188a:	4604      	mov	r4, r0
    188c:	460d      	mov	r5, r1
	ASSERT(!is_list_element(list, element));
    188e:	4b06      	ldr	r3, [pc, #24]	; (18a8 <list_insert_as_head+0x20>)
    1890:	4798      	blx	r3
    1892:	f080 0001 	eor.w	r0, r0, #1
    1896:	2239      	movs	r2, #57	; 0x39
    1898:	4904      	ldr	r1, [pc, #16]	; (18ac <list_insert_as_head+0x24>)
    189a:	b2c0      	uxtb	r0, r0
    189c:	4b04      	ldr	r3, [pc, #16]	; (18b0 <list_insert_as_head+0x28>)
    189e:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
    18a0:	6823      	ldr	r3, [r4, #0]
    18a2:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
    18a4:	6025      	str	r5, [r4, #0]
    18a6:	bd38      	pop	{r3, r4, r5, pc}
    18a8:	00001867 	.word	0x00001867
    18ac:	0000b178 	.word	0x0000b178
    18b0:	00001861 	.word	0x00001861

000018b4 <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
    18b4:	6803      	ldr	r3, [r0, #0]
    18b6:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
    18b8:	6001      	str	r1, [r0, #0]
    18ba:	4770      	bx	lr

000018bc <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
    18bc:	6803      	ldr	r3, [r0, #0]
    18be:	b10b      	cbz	r3, 18c4 <list_remove_head+0x8>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
    18c0:	681a      	ldr	r2, [r3, #0]
    18c2:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
	}

	return NULL;
}
    18c4:	4618      	mov	r0, r3
    18c6:	4770      	bx	lr

000018c8 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
    18c8:	b570      	push	{r4, r5, r6, lr}
    18ca:	460e      	mov	r6, r1
    18cc:	4615      	mov	r5, r2
	ASSERT(rb && buf && size);
    18ce:	4604      	mov	r4, r0
    18d0:	b178      	cbz	r0, 18f2 <ringbuffer_init+0x2a>
    18d2:	b181      	cbz	r1, 18f6 <ringbuffer_init+0x2e>
    18d4:	b1a2      	cbz	r2, 1900 <ringbuffer_init+0x38>
    18d6:	2001      	movs	r0, #1
    18d8:	2228      	movs	r2, #40	; 0x28
    18da:	490d      	ldr	r1, [pc, #52]	; (1910 <ringbuffer_init+0x48>)
    18dc:	4b0d      	ldr	r3, [pc, #52]	; (1914 <ringbuffer_init+0x4c>)
    18de:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
    18e0:	1e6b      	subs	r3, r5, #1
    18e2:	421d      	tst	r5, r3
    18e4:	d109      	bne.n	18fa <ringbuffer_init+0x32>
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
    18e6:	6063      	str	r3, [r4, #4]
	rb->read_index  = 0;
    18e8:	2000      	movs	r0, #0
    18ea:	60a0      	str	r0, [r4, #8]
	rb->write_index = rb->read_index;
    18ec:	60e0      	str	r0, [r4, #12]
	rb->buf         = (uint8_t *)buf;
    18ee:	6026      	str	r6, [r4, #0]

	return ERR_NONE;
    18f0:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
    18f2:	2000      	movs	r0, #0
    18f4:	e7f0      	b.n	18d8 <ringbuffer_init+0x10>
    18f6:	2000      	movs	r0, #0
    18f8:	e7ee      	b.n	18d8 <ringbuffer_init+0x10>
		return ERR_INVALID_ARG;
    18fa:	f06f 000c 	mvn.w	r0, #12
    18fe:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
    1900:	2228      	movs	r2, #40	; 0x28
    1902:	4903      	ldr	r1, [pc, #12]	; (1910 <ringbuffer_init+0x48>)
    1904:	2000      	movs	r0, #0
    1906:	4b03      	ldr	r3, [pc, #12]	; (1914 <ringbuffer_init+0x4c>)
    1908:	4798      	blx	r3
	if ((size & (size - 1)) != 0) {
    190a:	1e6b      	subs	r3, r5, #1
    190c:	e7eb      	b.n	18e6 <ringbuffer_init+0x1e>
    190e:	bf00      	nop
    1910:	0000b198 	.word	0x0000b198
    1914:	00001861 	.word	0x00001861

00001918 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
    1918:	b538      	push	{r3, r4, r5, lr}
    191a:	460d      	mov	r5, r1
	ASSERT(rb && data);
    191c:	4604      	mov	r4, r0
    191e:	b1a0      	cbz	r0, 194a <ringbuffer_get+0x32>
    1920:	1c08      	adds	r0, r1, #0
    1922:	bf18      	it	ne
    1924:	2001      	movne	r0, #1
    1926:	2240      	movs	r2, #64	; 0x40
    1928:	490a      	ldr	r1, [pc, #40]	; (1954 <ringbuffer_get+0x3c>)
    192a:	4b0b      	ldr	r3, [pc, #44]	; (1958 <ringbuffer_get+0x40>)
    192c:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
    192e:	68a3      	ldr	r3, [r4, #8]
    1930:	68e2      	ldr	r2, [r4, #12]
    1932:	429a      	cmp	r2, r3
    1934:	d00b      	beq.n	194e <ringbuffer_get+0x36>
		*data = rb->buf[rb->read_index & rb->size];
    1936:	6862      	ldr	r2, [r4, #4]
    1938:	4013      	ands	r3, r2
    193a:	6822      	ldr	r2, [r4, #0]
    193c:	5cd3      	ldrb	r3, [r2, r3]
    193e:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
    1940:	68a3      	ldr	r3, [r4, #8]
    1942:	3301      	adds	r3, #1
    1944:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
    1946:	2000      	movs	r0, #0
    1948:	bd38      	pop	{r3, r4, r5, pc}
    194a:	2000      	movs	r0, #0
    194c:	e7eb      	b.n	1926 <ringbuffer_get+0xe>
	}

	return ERR_NOT_FOUND;
    194e:	f06f 0009 	mvn.w	r0, #9
}
    1952:	bd38      	pop	{r3, r4, r5, pc}
    1954:	0000b198 	.word	0x0000b198
    1958:	00001861 	.word	0x00001861

0000195c <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
    195c:	b538      	push	{r3, r4, r5, lr}
    195e:	460d      	mov	r5, r1
	ASSERT(rb);
    1960:	4604      	mov	r4, r0
    1962:	2251      	movs	r2, #81	; 0x51
    1964:	490b      	ldr	r1, [pc, #44]	; (1994 <ringbuffer_put+0x38>)
    1966:	3000      	adds	r0, #0
    1968:	bf18      	it	ne
    196a:	2001      	movne	r0, #1
    196c:	4b0a      	ldr	r3, [pc, #40]	; (1998 <ringbuffer_put+0x3c>)
    196e:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
    1970:	68e3      	ldr	r3, [r4, #12]
    1972:	6862      	ldr	r2, [r4, #4]
    1974:	4013      	ands	r3, r2
    1976:	6822      	ldr	r2, [r4, #0]
    1978:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
    197a:	68e3      	ldr	r3, [r4, #12]
    197c:	6861      	ldr	r1, [r4, #4]
    197e:	68a2      	ldr	r2, [r4, #8]
    1980:	1a9a      	subs	r2, r3, r2
    1982:	428a      	cmp	r2, r1
		rb->read_index = rb->write_index - rb->size;
    1984:	bf84      	itt	hi
    1986:	1a59      	subhi	r1, r3, r1
    1988:	60a1      	strhi	r1, [r4, #8]
	}

	rb->write_index++;
    198a:	3301      	adds	r3, #1
    198c:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
    198e:	2000      	movs	r0, #0
    1990:	bd38      	pop	{r3, r4, r5, pc}
    1992:	bf00      	nop
    1994:	0000b198 	.word	0x0000b198
    1998:	00001861 	.word	0x00001861

0000199c <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
    199c:	b510      	push	{r4, lr}
	ASSERT(rb);
    199e:	4604      	mov	r4, r0
    19a0:	2267      	movs	r2, #103	; 0x67
    19a2:	4905      	ldr	r1, [pc, #20]	; (19b8 <ringbuffer_num+0x1c>)
    19a4:	3000      	adds	r0, #0
    19a6:	bf18      	it	ne
    19a8:	2001      	movne	r0, #1
    19aa:	4b04      	ldr	r3, [pc, #16]	; (19bc <ringbuffer_num+0x20>)
    19ac:	4798      	blx	r3

	return rb->write_index - rb->read_index;
    19ae:	68e0      	ldr	r0, [r4, #12]
    19b0:	68a3      	ldr	r3, [r4, #8]
}
    19b2:	1ac0      	subs	r0, r0, r3
    19b4:	bd10      	pop	{r4, pc}
    19b6:	bf00      	nop
    19b8:	0000b198 	.word	0x0000b198
    19bc:	00001861 	.word	0x00001861

000019c0 <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
    19c0:	4603      	mov	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    19c2:	4a06      	ldr	r2, [pc, #24]	; (19dc <_sbrk+0x1c>)
    19c4:	6812      	ldr	r2, [r2, #0]
    19c6:	b122      	cbz	r2, 19d2 <_sbrk+0x12>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
    19c8:	4a04      	ldr	r2, [pc, #16]	; (19dc <_sbrk+0x1c>)
    19ca:	6810      	ldr	r0, [r2, #0]

	heap += incr;
    19cc:	4403      	add	r3, r0
    19ce:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
    19d0:	4770      	bx	lr
		heap = (unsigned char *)&_end;
    19d2:	4903      	ldr	r1, [pc, #12]	; (19e0 <_sbrk+0x20>)
    19d4:	4a01      	ldr	r2, [pc, #4]	; (19dc <_sbrk+0x1c>)
    19d6:	6011      	str	r1, [r2, #0]
    19d8:	e7f6      	b.n	19c8 <_sbrk+0x8>
    19da:	bf00      	nop
    19dc:	200001a0 	.word	0x200001a0
    19e0:	200195f8 	.word	0x200195f8

000019e4 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
    19e4:	f04f 30ff 	mov.w	r0, #4294967295
    19e8:	4770      	bx	lr

000019ea <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
    19ea:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    19ee:	604b      	str	r3, [r1, #4]

	return 0;
}
    19f0:	2000      	movs	r0, #0
    19f2:	4770      	bx	lr

000019f4 <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
    19f4:	2001      	movs	r0, #1
    19f6:	4770      	bx	lr

000019f8 <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
    19f8:	2000      	movs	r0, #0
    19fa:	4770      	bx	lr

000019fc <_irq_set>:
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    19fc:	0943      	lsrs	r3, r0, #5
    19fe:	f000 001f 	and.w	r0, r0, #31
    1a02:	2201      	movs	r2, #1
    1a04:	fa02 f000 	lsl.w	r0, r2, r0
    1a08:	3340      	adds	r3, #64	; 0x40
    1a0a:	4a02      	ldr	r2, [pc, #8]	; (1a14 <_irq_set+0x18>)
    1a0c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    1a10:	4770      	bx	lr
    1a12:	bf00      	nop
    1a14:	e000e100 	.word	0xe000e100

00001a18 <_get_cycles_for_ms>:
 */
static inline uint32_t _get_cycles_for_ms_internal(const uint16_t ms, const uint32_t freq, const uint8_t power)
{
	switch (power) {
	case 9:
		return (ms * (freq / 1000000) + 2) / 3 * 1000;
    1a18:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
    1a1c:	00c3      	lsls	r3, r0, #3
    1a1e:	3302      	adds	r3, #2
    1a20:	4804      	ldr	r0, [pc, #16]	; (1a34 <_get_cycles_for_ms+0x1c>)
    1a22:	fba0 2303 	umull	r2, r3, r0, r3
    1a26:	085b      	lsrs	r3, r3, #1
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
    1a28:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    1a2c:	fb00 f003 	mul.w	r0, r0, r3
    1a30:	4770      	bx	lr
    1a32:	bf00      	nop
    1a34:	aaaaaaab 	.word	0xaaaaaaab

00001a38 <_delay_cycles>:
	__asm(".align 3 \n"
	      "__delay:\n"
	      "subs r1, r1, #1\n"
	      "bhi __delay\n");
#elif defined __GNUC__
	__asm(".syntax unified\n"
    1a38:	3901      	subs	r1, #1
    1a3a:	d8fd      	bhi.n	1a38 <_delay_cycles>
    1a3c:	4770      	bx	lr
    1a3e:	bf00      	nop

00001a40 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    1a40:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    1a42:	4a09      	ldr	r2, [pc, #36]	; (1a68 <_init_chip+0x28>)
    1a44:	8813      	ldrh	r3, [r2, #0]
    1a46:	b29b      	uxth	r3, r3
    1a48:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    1a4a:	4b08      	ldr	r3, [pc, #32]	; (1a6c <_init_chip+0x2c>)
    1a4c:	4798      	blx	r3
	_oscctrl_init_sources();
    1a4e:	4b08      	ldr	r3, [pc, #32]	; (1a70 <_init_chip+0x30>)
    1a50:	4798      	blx	r3
	_mclk_init();
    1a52:	4b08      	ldr	r3, [pc, #32]	; (1a74 <_init_chip+0x34>)
    1a54:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    1a56:	2002      	movs	r0, #2
    1a58:	4c07      	ldr	r4, [pc, #28]	; (1a78 <_init_chip+0x38>)
    1a5a:	47a0      	blx	r4
#endif
	_oscctrl_init_referenced_generators();
    1a5c:	4b07      	ldr	r3, [pc, #28]	; (1a7c <_init_chip+0x3c>)
    1a5e:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    1a60:	f640 70fd 	movw	r0, #4093	; 0xffd
    1a64:	47a0      	blx	r4
    1a66:	bd10      	pop	{r4, pc}
    1a68:	41004000 	.word	0x41004000
    1a6c:	00002009 	.word	0x00002009
    1a70:	0000201d 	.word	0x0000201d
    1a74:	00001ffd 	.word	0x00001ffd
    1a78:	00001a81 	.word	0x00001a81
    1a7c:	0000204d 	.word	0x0000204d

00001a80 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    1a80:	f010 0f01 	tst.w	r0, #1
    1a84:	d008      	beq.n	1a98 <_gclk_init_generators_by_fref+0x18>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1a86:	4a17      	ldr	r2, [pc, #92]	; (1ae4 <_gclk_init_generators_by_fref+0x64>)
    1a88:	4b17      	ldr	r3, [pc, #92]	; (1ae8 <_gclk_init_generators_by_fref+0x68>)
    1a8a:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1a8c:	4619      	mov	r1, r3
    1a8e:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    1a92:	684b      	ldr	r3, [r1, #4]
    1a94:	4213      	tst	r3, r2
    1a96:	d1fc      	bne.n	1a92 <_gclk_init_generators_by_fref+0x12>
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
    1a98:	f010 0f02 	tst.w	r0, #2
    1a9c:	d008      	beq.n	1ab0 <_gclk_init_generators_by_fref+0x30>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1a9e:	4a13      	ldr	r2, [pc, #76]	; (1aec <_gclk_init_generators_by_fref+0x6c>)
    1aa0:	4b11      	ldr	r3, [pc, #68]	; (1ae8 <_gclk_init_generators_by_fref+0x68>)
    1aa2:	625a      	str	r2, [r3, #36]	; 0x24
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1aa4:	4619      	mov	r1, r3
    1aa6:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    1aaa:	684b      	ldr	r3, [r1, #4]
    1aac:	4213      	tst	r3, r2
    1aae:	d1fc      	bne.n	1aaa <_gclk_init_generators_by_fref+0x2a>
		        | (CONF_GCLK_GENERATOR_1_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_1_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_2_CONFIG == 1
	if (bm & (1ul << 2)) {
    1ab0:	f010 0f04 	tst.w	r0, #4
    1ab4:	d008      	beq.n	1ac8 <_gclk_init_generators_by_fref+0x48>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1ab6:	4a0e      	ldr	r2, [pc, #56]	; (1af0 <_gclk_init_generators_by_fref+0x70>)
    1ab8:	4b0b      	ldr	r3, [pc, #44]	; (1ae8 <_gclk_init_generators_by_fref+0x68>)
    1aba:	629a      	str	r2, [r3, #40]	; 0x28
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1abc:	4619      	mov	r1, r3
    1abe:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    1ac2:	684b      	ldr	r3, [r1, #4]
    1ac4:	4213      	tst	r3, r2
    1ac6:	d1fc      	bne.n	1ac2 <_gclk_init_generators_by_fref+0x42>
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    1ac8:	f010 0f08 	tst.w	r0, #8
    1acc:	d008      	beq.n	1ae0 <_gclk_init_generators_by_fref+0x60>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1ace:	4a09      	ldr	r2, [pc, #36]	; (1af4 <_gclk_init_generators_by_fref+0x74>)
    1ad0:	4b05      	ldr	r3, [pc, #20]	; (1ae8 <_gclk_init_generators_by_fref+0x68>)
    1ad2:	62da      	str	r2, [r3, #44]	; 0x2c
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1ad4:	4619      	mov	r1, r3
    1ad6:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    1ada:	684b      	ldr	r3, [r1, #4]
    1adc:	4213      	tst	r3, r2
    1ade:	d1fc      	bne.n	1ada <_gclk_init_generators_by_fref+0x5a>
    1ae0:	4770      	bx	lr
    1ae2:	bf00      	nop
    1ae4:	00010907 	.word	0x00010907
    1ae8:	40001c00 	.word	0x40001c00
    1aec:	00060900 	.word	0x00060900
    1af0:	00060901 	.word	0x00060901
    1af4:	00010904 	.word	0x00010904

00001af8 <GMAC_Handler>:

/*
 * \internal GMAC interrupt handler
 */
void GMAC_Handler(void)
{
    1af8:	b500      	push	{lr}
    1afa:	b083      	sub	sp, #12
	volatile uint32_t tsr;
	volatile uint32_t rsr;

	tsr = hri_gmac_read_TSR_reg(_gmac_dev->hw);
    1afc:	4b14      	ldr	r3, [pc, #80]	; (1b50 <GMAC_Handler+0x58>)
    1afe:	6818      	ldr	r0, [r3, #0]
    1b00:	6803      	ldr	r3, [r0, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_tsr_reg_t hri_gmac_read_TSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->TSR.reg;
    1b02:	695a      	ldr	r2, [r3, #20]
    1b04:	9201      	str	r2, [sp, #4]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_rsr_reg_t hri_gmac_read_RSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->RSR.reg;
    1b06:	6a1a      	ldr	r2, [r3, #32]
	rsr = hri_gmac_read_RSR_reg(_gmac_dev->hw);
    1b08:	9200      	str	r2, [sp, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_isr_reg_t hri_gmac_read_ISR_reg(const void *const hw)
{
	return ((Gmac *)hw)->ISR.reg;
    1b0a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	/* Must be Clear ISR (Clear on read) */
	hri_gmac_read_ISR_reg(_gmac_dev->hw);

	/* Frame transmited */
	if (tsr & GMAC_TSR_TXCOMP) {
    1b0c:	9a01      	ldr	r2, [sp, #4]
    1b0e:	f012 0f20 	tst.w	r2, #32
    1b12:	d00b      	beq.n	1b2c <GMAC_Handler+0x34>
		hri_gmac_write_TSR_reg(_gmac_dev->hw, tsr);
    1b14:	9a01      	ldr	r2, [sp, #4]
	((Gmac *)hw)->TSR.reg = data;
    1b16:	615a      	str	r2, [r3, #20]
		if ((_txbuf_descrs[_txbuf_index].status.bm.used) && (_gmac_dev->cb.transmited != NULL)) {
    1b18:	4b0d      	ldr	r3, [pc, #52]	; (1b50 <GMAC_Handler+0x58>)
    1b1a:	685a      	ldr	r2, [r3, #4]
    1b1c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1b20:	7bdb      	ldrb	r3, [r3, #15]
    1b22:	09db      	lsrs	r3, r3, #7
    1b24:	d002      	beq.n	1b2c <GMAC_Handler+0x34>
    1b26:	6843      	ldr	r3, [r0, #4]
    1b28:	b103      	cbz	r3, 1b2c <GMAC_Handler+0x34>
			_gmac_dev->cb.transmited(_gmac_dev);
    1b2a:	4798      	blx	r3
		}
	}

	/* Frame received */
	if (rsr & GMAC_RSR_REC) {
    1b2c:	9b00      	ldr	r3, [sp, #0]
    1b2e:	f013 0f02 	tst.w	r3, #2
    1b32:	d004      	beq.n	1b3e <GMAC_Handler+0x46>
		if (_gmac_dev->cb.received != NULL) {
    1b34:	4b06      	ldr	r3, [pc, #24]	; (1b50 <GMAC_Handler+0x58>)
    1b36:	6818      	ldr	r0, [r3, #0]
    1b38:	6883      	ldr	r3, [r0, #8]
    1b3a:	b103      	cbz	r3, 1b3e <GMAC_Handler+0x46>
			_gmac_dev->cb.received(_gmac_dev);
    1b3c:	4798      	blx	r3
		}
	}
	hri_gmac_write_RSR_reg(_gmac_dev->hw, rsr);
    1b3e:	4b04      	ldr	r3, [pc, #16]	; (1b50 <GMAC_Handler+0x58>)
    1b40:	681b      	ldr	r3, [r3, #0]
    1b42:	681b      	ldr	r3, [r3, #0]
    1b44:	9a00      	ldr	r2, [sp, #0]
	((Gmac *)hw)->RSR.reg = data;
    1b46:	621a      	str	r2, [r3, #32]
}
    1b48:	b003      	add	sp, #12
    1b4a:	f85d fb04 	ldr.w	pc, [sp], #4
    1b4e:	bf00      	nop
    1b50:	200001c0 	.word	0x200001c0

00001b54 <_mac_async_init>:

int32_t _mac_async_init(struct _mac_async_device *const dev, void *const hw)
{
    1b54:	b430      	push	{r4, r5}
	dev->hw = hw;
    1b56:	6001      	str	r1, [r0, #0]
	((Gmac *)hw)->NCR.reg = data;
    1b58:	4b29      	ldr	r3, [pc, #164]	; (1c00 <_mac_async_init+0xac>)
    1b5a:	600b      	str	r3, [r1, #0]
	                       (CONF_GMAC_NCR_LBL ? GMAC_NCR_LBL : 0) | (CONF_GMAC_NCR_MPE ? GMAC_NCR_MPE : 0)
	                           | (CONF_GMAC_NCR_WESTAT ? GMAC_NCR_WESTAT : 0) | (CONF_GMAC_NCR_BP ? GMAC_NCR_BP : 0)
	                           | (CONF_GMAC_NCR_ENPBPR ? GMAC_NCR_ENPBPR : 0)
	                           | (CONF_GMAC_NCR_TXPBPF ? GMAC_NCR_TXPBPF : 0));
	hri_gmac_write_NCFGR_reg(
	    dev->hw,
    1b5c:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->NCFGR.reg = data;
    1b5e:	4a29      	ldr	r2, [pc, #164]	; (1c04 <_mac_async_init+0xb0>)
    1b60:	605a      	str	r2, [r3, #4]
	        | (CONF_GMAC_NCFGR_LFERD ? GMAC_NCFGR_LFERD : 0) | (CONF_GMAC_NCFGR_RFCS ? GMAC_NCFGR_RFCS : 0)
	        | GMAC_NCFGR_CLK(CONF_GMAC_NCFGR_CLK) | (CONF_GMAC_NCFGR_DCPF ? GMAC_NCFGR_DCPF : 0)
	        | (CONF_GMAC_NCFGR_RXCOEN ? GMAC_NCFGR_RXCOEN : 0) | (CONF_GMAC_NCFGR_EFRHD ? GMAC_NCFGR_EFRHD : 0)
	        | (CONF_GMAC_NCFGR_IRXFCS ? GMAC_NCFGR_IRXFCS : 0) | (CONF_GMAC_NCFGR_IPGSEN ? GMAC_NCFGR_IPGSEN : 0)
	        | (CONF_GMAC_NCFGR_RXBP ? GMAC_NCFGR_RXBP : 0) | (CONF_GMAC_NCFGR_IRXER ? GMAC_NCFGR_IRXER : 0));
	hri_gmac_write_UR_reg(dev->hw, (CONF_GMAC_UR_MII ? GMAC_UR_MII : 0));
    1b62:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->UR.reg = data;
    1b64:	2300      	movs	r3, #0
    1b66:	60d3      	str	r3, [r2, #12]
	hri_gmac_write_DCFGR_reg(
	    dev->hw,
    1b68:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->DCFGR.reg = data;
    1b6a:	4927      	ldr	r1, [pc, #156]	; (1c08 <_mac_async_init+0xb4>)
    1b6c:	6111      	str	r1, [r2, #16]
	    GMAC_DCFGR_FBLDO(CONF_GMAC_DCFGR_FBLDO) | (CONF_GMAC_DCFGR_ESMA ? GMAC_DCFGR_ESMA : 0)
	        | (CONF_GMAC_DCFGR_ESPA ? GMAC_DCFGR_ESPA : 0) | GMAC_DCFGR_RXBMS(CONF_GMAC_DCFGR_RXBMS)
	        | (CONF_GMAC_DCFGR_TXPBMS ? GMAC_DCFGR_TXPBMS : 0) | (CONF_GMAC_DCFGR_TXCOEN ? GMAC_DCFGR_TXCOEN : 0)
	        | GMAC_DCFGR_DRBS(CONF_GMAC_DCFGR_DRBS) | (CONF_GMAC_DCFGR_DDRP ? GMAC_DCFGR_DDRP : 0));
	hri_gmac_write_WOL_reg(dev->hw, 0);
    1b6e:	6802      	ldr	r2, [r0, #0]
}

static inline void hri_gmac_write_WOL_reg(const void *const hw, hri_gmac_wol_reg_t data)
{
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->WOL.reg = data;
    1b70:	f8c2 30b8 	str.w	r3, [r2, #184]	; 0xb8
	hri_gmac_write_IPGS_reg(dev->hw, GMAC_IPGS_FL((CONF_GMAC_IPGS_FL_MUL << 8) | CONF_GMAC_IPGS_FL_DIV));
    1b74:	6802      	ldr	r2, [r0, #0]
}

static inline void hri_gmac_write_IPGS_reg(const void *const hw, hri_gmac_ipgs_reg_t data)
{
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->IPGS.reg = data;
    1b76:	f240 1101 	movw	r1, #257	; 0x101
    1b7a:	f8c2 10bc 	str.w	r1, [r2, #188]	; 0xbc
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    1b7e:	4923      	ldr	r1, [pc, #140]	; (1c0c <_mac_async_init+0xb8>)
    1b80:	f101 0220 	add.w	r2, r1, #32
    1b84:	608a      	str	r2, [r1, #8]
		_txbuf_descrs[i].status.val     = 0;
    1b86:	60cb      	str	r3, [r1, #12]
		_txbuf_descrs[i].status.bm.used = 1;
    1b88:	2280      	movs	r2, #128	; 0x80
    1b8a:	73ca      	strb	r2, [r1, #15]
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    1b8c:	f201 52fc 	addw	r2, r1, #1532	; 0x5fc
    1b90:	610a      	str	r2, [r1, #16]
		_txbuf_descrs[i].status.val     = 0;
    1b92:	614b      	str	r3, [r1, #20]
	_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    1b94:	22c0      	movs	r2, #192	; 0xc0
    1b96:	75ca      	strb	r2, [r1, #23]
	_txbuf_index                                            = 0;
    1b98:	604b      	str	r3, [r1, #4]
	_last_txbuf_index                                       = 0;
    1b9a:	f8c1 3bd8 	str.w	r3, [r1, #3032]	; 0xbd8
    1b9e:	f501 633e 	add.w	r3, r1, #3040	; 0xbe0
    1ba2:	4a1b      	ldr	r2, [pc, #108]	; (1c10 <_mac_async_init+0xbc>)
    1ba4:	f501 519f 	add.w	r1, r1, #5088	; 0x13e0
		_rxbuf_descrs[i].status.val  = 0;
    1ba8:	2400      	movs	r4, #0
		_rxbuf_descrs[i].address.val = (uint32_t)_rxbuf[i];
    1baa:	f842 3c04 	str.w	r3, [r2, #-4]
		_rxbuf_descrs[i].status.val  = 0;
    1bae:	f842 4b08 	str.w	r4, [r2], #8
    1bb2:	3380      	adds	r3, #128	; 0x80
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1bb4:	428b      	cmp	r3, r1
    1bb6:	d1f8      	bne.n	1baa <_mac_async_init+0x56>
	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    1bb8:	4b16      	ldr	r3, [pc, #88]	; (1c14 <_mac_async_init+0xc0>)
    1bba:	f893 2360 	ldrb.w	r2, [r3, #864]	; 0x360
    1bbe:	f042 0202 	orr.w	r2, r2, #2
    1bc2:	f883 2360 	strb.w	r2, [r3, #864]	; 0x360
	_rxbuf_index                                             = 0;
    1bc6:	2100      	movs	r1, #0
    1bc8:	f8c3 1368 	str.w	r1, [r3, #872]	; 0x368
	hri_gmac_write_TBQB_reg(dev->hw, (uint32_t)_txbuf_descrs);
    1bcc:	6804      	ldr	r4, [r0, #0]
    1bce:	4a0f      	ldr	r2, [pc, #60]	; (1c0c <_mac_async_init+0xb8>)
    1bd0:	f102 0508 	add.w	r5, r2, #8
	((Gmac *)hw)->TBQB.reg = data;
    1bd4:	61e5      	str	r5, [r4, #28]
	hri_gmac_write_RBQB_reg(dev->hw, (uint32_t)_rxbuf_descrs);
    1bd6:	6804      	ldr	r4, [r0, #0]
    1bd8:	f503 733a 	add.w	r3, r3, #744	; 0x2e8
	((Gmac *)hw)->RBQB.reg = data;
    1bdc:	61a3      	str	r3, [r4, #24]
	_mac_init_bufdescr(dev);

	_gmac_dev = dev;
    1bde:	6010      	str	r0, [r2, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1be0:	4b0d      	ldr	r3, [pc, #52]	; (1c18 <_mac_async_init+0xc4>)
    1be2:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    1be6:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
    1bea:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1bee:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1bf2:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1bf6:	609a      	str	r2, [r3, #8]
	NVIC_DisableIRQ(GMAC_IRQn);
	NVIC_ClearPendingIRQ(GMAC_IRQn);
	NVIC_EnableIRQ(GMAC_IRQn);

	return ERR_NONE;
}
    1bf8:	4608      	mov	r0, r1
    1bfa:	bc30      	pop	{r4, r5}
    1bfc:	4770      	bx	lr
    1bfe:	bf00      	nop
    1c00:	00030010 	.word	0x00030010
    1c04:	00100103 	.word	0x00100103
    1c08:	00020704 	.word	0x00020704
    1c0c:	200001c0 	.word	0x200001c0
    1c10:	200015a4 	.word	0x200015a4
    1c14:	200012b8 	.word	0x200012b8
    1c18:	e000e100 	.word	0xe000e100

00001c1c <_mac_async_enable>:
	return ERR_NONE;
}

int32_t _mac_async_enable(struct _mac_async_device *const dev)
{
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
    1c1c:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->NCR.reg |= mask;
    1c1e:	6813      	ldr	r3, [r2, #0]
    1c20:	f043 030c 	orr.w	r3, r3, #12
    1c24:	6013      	str	r3, [r2, #0]
	return ERR_NONE;
}
    1c26:	2000      	movs	r0, #0
    1c28:	4770      	bx	lr
	...

00001c2c <_mac_async_write>:
	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
	return ERR_NONE;
}

int32_t _mac_async_write(struct _mac_async_device *const dev, uint8_t *buf, uint32_t len)
{
    1c2c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1c30:	4682      	mov	sl, r0
    1c32:	4614      	mov	r4, r2
	uint32_t pos;
	uint32_t blen;
	uint32_t i;

	if (_txbuf_descrs[_last_txbuf_index].status.bm.used && !_txbuf_descrs[_last_txbuf_index].status.bm.last_buf) {
    1c34:	4b49      	ldr	r3, [pc, #292]	; (1d5c <_mac_async_write+0x130>)
    1c36:	f8d3 2bd8 	ldr.w	r2, [r3, #3032]	; 0xbd8
    1c3a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1c3e:	7bdb      	ldrb	r3, [r3, #15]
    1c40:	09db      	lsrs	r3, r3, #7
    1c42:	d016      	beq.n	1c72 <_mac_async_write+0x46>
    1c44:	4b45      	ldr	r3, [pc, #276]	; (1d5c <_mac_async_write+0x130>)
    1c46:	f8d3 2bd8 	ldr.w	r2, [r3, #3032]	; 0xbd8
    1c4a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1c4e:	7b5b      	ldrb	r3, [r3, #13]
    1c50:	09db      	lsrs	r3, r3, #7
    1c52:	d10e      	bne.n	1c72 <_mac_async_write+0x46>
		/* Set used flag from first descriptor to last descriptor,
		 * as DMA olny set the first used flag */
		for (i = 1; i < CONF_GMAC_TXDESCR_NUM; i++) {
			pos = _last_txbuf_index + i;
    1c54:	4b41      	ldr	r3, [pc, #260]	; (1d5c <_mac_async_write+0x130>)
    1c56:	f8d3 3bd8 	ldr.w	r3, [r3, #3032]	; 0xbd8
    1c5a:	1c5a      	adds	r2, r3, #1
			if (pos >= CONF_GMAC_TXDESCR_NUM) {
    1c5c:	2a01      	cmp	r2, #1
				pos -= CONF_GMAC_TXDESCR_NUM;
    1c5e:	bf88      	it	hi
    1c60:	f103 32ff 	addhi.w	r2, r3, #4294967295
			}
			_txbuf_descrs[pos].status.bm.used = 1;
    1c64:	4b3d      	ldr	r3, [pc, #244]	; (1d5c <_mac_async_write+0x130>)
    1c66:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1c6a:	7bda      	ldrb	r2, [r3, #15]
    1c6c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    1c70:	73da      	strb	r2, [r3, #15]
				break;
			}
		}
	}

	if (!_txbuf_descrs[_txbuf_index].status.bm.used) {
    1c72:	4b3a      	ldr	r3, [pc, #232]	; (1d5c <_mac_async_write+0x130>)
    1c74:	685a      	ldr	r2, [r3, #4]
    1c76:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1c7a:	7bdb      	ldrb	r3, [r3, #15]
    1c7c:	09db      	lsrs	r3, r3, #7
    1c7e:	d064      	beq.n	1d4a <_mac_async_write+0x11e>
		return ERR_NO_RESOURCE;
	}

	/* Check if have enough buffers, the first buffer already checked */
	if (len > CONF_GMAC_TXBUF_SIZE) {
    1c80:	f240 53dc 	movw	r3, #1500	; 0x5dc
    1c84:	429c      	cmp	r4, r3
    1c86:	d90c      	bls.n	1ca2 <_mac_async_write+0x76>
		for (i = 1; i < CONF_GMAC_TXDESCR_NUM; i++) {
			pos = _txbuf_index + i;
    1c88:	4b34      	ldr	r3, [pc, #208]	; (1d5c <_mac_async_write+0x130>)
    1c8a:	685b      	ldr	r3, [r3, #4]
    1c8c:	1c5a      	adds	r2, r3, #1
			if (pos >= CONF_GMAC_TXDESCR_NUM) {
    1c8e:	2a01      	cmp	r2, #1
				pos -= CONF_GMAC_TXDESCR_NUM;
    1c90:	bf88      	it	hi
    1c92:	f103 32ff 	addhi.w	r2, r3, #4294967295
			}

			if (!_txbuf_descrs[pos].status.bm.used) {
    1c96:	4b31      	ldr	r3, [pc, #196]	; (1d5c <_mac_async_write+0x130>)
    1c98:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1c9c:	7bdb      	ldrb	r3, [r3, #15]
    1c9e:	09db      	lsrs	r3, r3, #7
    1ca0:	d057      	beq.n	1d52 <_mac_async_write+0x126>
			if ((len - (CONF_GMAC_TXBUF_SIZE * i)) < CONF_GMAC_TXBUF_SIZE) {
				break;
			}
		}
	}
	_last_txbuf_index = _txbuf_index;
    1ca2:	4b2e      	ldr	r3, [pc, #184]	; (1d5c <_mac_async_write+0x130>)
    1ca4:	685a      	ldr	r2, [r3, #4]
    1ca6:	f8c3 2bd8 	str.w	r2, [r3, #3032]	; 0xbd8
    1caa:	460f      	mov	r7, r1
    1cac:	f601 38b8 	addw	r8, r1, #3000	; 0xbb8

	/* Write data to transmit buffer */
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    1cb0:	461e      	mov	r6, r3
    1cb2:	f103 0b20 	add.w	fp, r3, #32
    1cb6:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 1d60 <_mac_async_write+0x134>
    1cba:	e027      	b.n	1d0c <_mac_async_write+0xe0>

		if (len > 0) {
			/* Here the Used flag be set to zero */
			_txbuf_descrs[_txbuf_index].status.val = blen;
		} else {
			_txbuf_descrs[_txbuf_index].status.val         = blen;
    1cbc:	4b27      	ldr	r3, [pc, #156]	; (1d5c <_mac_async_write+0x130>)
    1cbe:	685a      	ldr	r2, [r3, #4]
    1cc0:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    1cc4:	60d5      	str	r5, [r2, #12]
			_txbuf_descrs[_txbuf_index].status.bm.last_buf = 1;
    1cc6:	685a      	ldr	r2, [r3, #4]
    1cc8:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    1ccc:	7b51      	ldrb	r1, [r2, #13]
    1cce:	f041 0180 	orr.w	r1, r1, #128	; 0x80
    1cd2:	7351      	strb	r1, [r2, #13]
		}
		_txbuf_index++;
    1cd4:	685a      	ldr	r2, [r3, #4]
    1cd6:	3201      	adds	r2, #1
    1cd8:	605a      	str	r2, [r3, #4]
		if (_txbuf_index == CONF_GMAC_TXDESCR_NUM) {
    1cda:	685b      	ldr	r3, [r3, #4]
    1cdc:	2b02      	cmp	r3, #2
    1cde:	d106      	bne.n	1cee <_mac_async_write+0xc2>
			_txbuf_index                                            = 0;
    1ce0:	4b1e      	ldr	r3, [pc, #120]	; (1d5c <_mac_async_write+0x130>)
    1ce2:	2200      	movs	r2, #0
    1ce4:	605a      	str	r2, [r3, #4]
			_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    1ce6:	7dda      	ldrb	r2, [r3, #23]
    1ce8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    1cec:	75da      	strb	r2, [r3, #23]
  __ASM volatile ("dsb 0xF":::"memory");
    1cee:	f3bf 8f4f 	dsb	sy

	/* Data synchronization barrier */
	__DSB();

	/* Active Transmit */
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_TSTART);
    1cf2:	f8da 2000 	ldr.w	r2, [sl]
    1cf6:	6813      	ldr	r3, [r2, #0]
    1cf8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    1cfc:	6013      	str	r3, [r2, #0]

	return ERR_NONE;
    1cfe:	2000      	movs	r0, #0
    1d00:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1d04:	f207 57dc 	addw	r7, r7, #1500	; 0x5dc
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
    1d08:	4547      	cmp	r7, r8
    1d0a:	d0f0      	beq.n	1cee <_mac_async_write+0xc2>
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
    1d0c:	f240 53dc 	movw	r3, #1500	; 0x5dc
    1d10:	4625      	mov	r5, r4
    1d12:	429c      	cmp	r4, r3
    1d14:	bf28      	it	cs
    1d16:	461d      	movcs	r5, r3
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    1d18:	6870      	ldr	r0, [r6, #4]
    1d1a:	462a      	mov	r2, r5
    1d1c:	4639      	mov	r1, r7
    1d1e:	fb03 b000 	mla	r0, r3, r0, fp
    1d22:	47c8      	blx	r9
		if (len > 0) {
    1d24:	1b64      	subs	r4, r4, r5
    1d26:	d0c9      	beq.n	1cbc <_mac_async_write+0x90>
			_txbuf_descrs[_txbuf_index].status.val = blen;
    1d28:	6873      	ldr	r3, [r6, #4]
    1d2a:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
    1d2e:	60dd      	str	r5, [r3, #12]
		_txbuf_index++;
    1d30:	6873      	ldr	r3, [r6, #4]
    1d32:	3301      	adds	r3, #1
    1d34:	6073      	str	r3, [r6, #4]
		if (_txbuf_index == CONF_GMAC_TXDESCR_NUM) {
    1d36:	6873      	ldr	r3, [r6, #4]
    1d38:	2b02      	cmp	r3, #2
    1d3a:	d1e3      	bne.n	1d04 <_mac_async_write+0xd8>
			_txbuf_index                                            = 0;
    1d3c:	2300      	movs	r3, #0
    1d3e:	6073      	str	r3, [r6, #4]
			_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    1d40:	7df3      	ldrb	r3, [r6, #23]
    1d42:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    1d46:	75f3      	strb	r3, [r6, #23]
    1d48:	e7dc      	b.n	1d04 <_mac_async_write+0xd8>
		return ERR_NO_RESOURCE;
    1d4a:	f06f 001b 	mvn.w	r0, #27
    1d4e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				return ERR_NO_RESOURCE;
    1d52:	f06f 001b 	mvn.w	r0, #27
    1d56:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1d5a:	bf00      	nop
    1d5c:	200001c0 	.word	0x200001c0
    1d60:	00009faf 	.word	0x00009faf

00001d64 <_mac_async_read>:
}

uint32_t _mac_async_read(struct _mac_async_device *const dev, uint8_t *buf, uint32_t len)
{
    1d64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1d68:	b083      	sub	sp, #12
    1d6a:	9101      	str	r1, [sp, #4]
    1d6c:	4691      	mov	r9, r2
	uint32_t i;
	uint32_t j;
	uint32_t pos;
	uint32_t n;
	uint32_t sof       = 0xFFFFFFFF; /* Start of Frame index */
    1d6e:	f04f 37ff 	mov.w	r7, #4294967295
	uint32_t eof       = 0xFFFFFFFF; /* End of Frame index */
	uint32_t total_len = 0;          /* Total length of received package */

	(void)dev;
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1d72:	2400      	movs	r4, #0
		pos = _rxbuf_index + i;
    1d74:	4a45      	ldr	r2, [pc, #276]	; (1e8c <_mac_async_read+0x128>)
    1d76:	e002      	b.n	1d7e <_mac_async_read+0x1a>
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1d78:	3401      	adds	r4, #1
    1d7a:	2c10      	cmp	r4, #16
    1d7c:	d074      	beq.n	1e68 <_mac_async_read+0x104>
		pos = _rxbuf_index + i;
    1d7e:	f8d2 3368 	ldr.w	r3, [r2, #872]	; 0x368
    1d82:	4423      	add	r3, r4

		if (pos >= CONF_GMAC_RXDESCR_NUM) {
    1d84:	2b0f      	cmp	r3, #15
			pos -= CONF_GMAC_RXDESCR_NUM;
    1d86:	bf88      	it	hi
    1d88:	3b10      	subhi	r3, #16
		}

		/* No more data for Ethernet package */
		if (!_rxbuf_descrs[pos].address.bm.ownership) {
    1d8a:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
    1d8e:	f891 12e8 	ldrb.w	r1, [r1, #744]	; 0x2e8
    1d92:	f011 0f01 	tst.w	r1, #1
    1d96:	d061      	beq.n	1e5c <_mac_async_read+0xf8>
			break;
		}

		if (_rxbuf_descrs[pos].status.bm.sof) {
    1d98:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
    1d9c:	f891 12ed 	ldrb.w	r1, [r1, #749]	; 0x2ed
    1da0:	f3c1 1180 	ubfx	r1, r1, #6, #1
    1da4:	2900      	cmp	r1, #0
    1da6:	bf18      	it	ne
    1da8:	4627      	movne	r7, r4
			sof = i;
		}

		if ((_rxbuf_descrs[pos].status.bm.eof) && (sof != 0xFFFFFFFF)) {
    1daa:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
    1dae:	f891 12ed 	ldrb.w	r1, [r1, #749]	; 0x2ed
    1db2:	09c9      	lsrs	r1, r1, #7
    1db4:	d0e0      	beq.n	1d78 <_mac_async_read+0x14>
    1db6:	f1b7 3fff 	cmp.w	r7, #4294967295
    1dba:	d0dd      	beq.n	1d78 <_mac_async_read+0x14>
			/* eof now indicate the number of bufs the frame used */
			eof = i;
			n   = _rxbuf_descrs[pos].status.bm.len;
    1dbc:	4a33      	ldr	r2, [pc, #204]	; (1e8c <_mac_async_read+0x128>)
    1dbe:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    1dc2:	f8b3 32ec 	ldrh.w	r3, [r3, #748]	; 0x2ec
    1dc6:	f3c3 030c 	ubfx	r3, r3, #0, #13
			len = min(n, len);
    1dca:	4599      	cmp	r9, r3
    1dcc:	bf28      	it	cs
    1dce:	4699      	movcs	r9, r3
			/* Break process since the last data has been found */
			break;
		}
	}

	if (eof != 0xFFFFFFFF) {
    1dd0:	f1b4 3fff 	cmp.w	r4, #4294967295
		j = eof + 1;
    1dd4:	bf18      	it	ne
    1dd6:	f104 0801 	addne.w	r8, r4, #1
	if (eof != 0xFFFFFFFF) {
    1dda:	d14b      	bne.n	1e74 <_mac_async_read+0x110>
    1ddc:	46b8      	mov	r8, r7
    1dde:	e049      	b.n	1e74 <_mac_async_read+0x110>
			buf += n;
			total_len += n;
			len -= n;
		}

		_rxbuf_descrs[_rxbuf_index].address.bm.ownership = 0;
    1de0:	f8d5 3368 	ldr.w	r3, [r5, #872]	; 0x368
    1de4:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
    1de8:	f893 22e8 	ldrb.w	r2, [r3, #744]	; 0x2e8
    1dec:	f36f 0200 	bfc	r2, #0, #1
    1df0:	f883 22e8 	strb.w	r2, [r3, #744]	; 0x2e8
		_rxbuf_index++;
    1df4:	f8d5 3368 	ldr.w	r3, [r5, #872]	; 0x368
    1df8:	3301      	adds	r3, #1
    1dfa:	f8c5 3368 	str.w	r3, [r5, #872]	; 0x368

		if (_rxbuf_index == CONF_GMAC_RXDESCR_NUM) {
    1dfe:	f8d5 3368 	ldr.w	r3, [r5, #872]	; 0x368
    1e02:	2b10      	cmp	r3, #16
			_rxbuf_index = 0;
    1e04:	bf04      	itt	eq
    1e06:	2300      	moveq	r3, #0
    1e08:	f8c5 3368 	streq.w	r3, [r5, #872]	; 0x368
	for (i = 0; i < j; i++) {
    1e0c:	3601      	adds	r6, #1
    1e0e:	4546      	cmp	r6, r8
    1e10:	d020      	beq.n	1e54 <_mac_async_read+0xf0>
		if (eof != 0xFFFFFFFF && i >= sof && i <= eof && len > 0) {
    1e12:	f1b4 3fff 	cmp.w	r4, #4294967295
    1e16:	d0e3      	beq.n	1de0 <_mac_async_read+0x7c>
    1e18:	42be      	cmp	r6, r7
    1e1a:	d3e1      	bcc.n	1de0 <_mac_async_read+0x7c>
    1e1c:	42a6      	cmp	r6, r4
    1e1e:	d8df      	bhi.n	1de0 <_mac_async_read+0x7c>
    1e20:	f1b9 0f00 	cmp.w	r9, #0
    1e24:	d0dc      	beq.n	1de0 <_mac_async_read+0x7c>
			n = min(len, CONF_GMAC_RXBUF_SIZE);
    1e26:	46cb      	mov	fp, r9
    1e28:	f1b9 0f80 	cmp.w	r9, #128	; 0x80
    1e2c:	bf28      	it	cs
    1e2e:	f04f 0b80 	movcs.w	fp, #128	; 0x80
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    1e32:	f8d5 1368 	ldr.w	r1, [r5, #872]	; 0x368
    1e36:	465a      	mov	r2, fp
    1e38:	4b15      	ldr	r3, [pc, #84]	; (1e90 <_mac_async_read+0x12c>)
    1e3a:	eb03 11c1 	add.w	r1, r3, r1, lsl #7
    1e3e:	9801      	ldr	r0, [sp, #4]
    1e40:	4b14      	ldr	r3, [pc, #80]	; (1e94 <_mac_async_read+0x130>)
    1e42:	4798      	blx	r3
			buf += n;
    1e44:	9b01      	ldr	r3, [sp, #4]
    1e46:	445b      	add	r3, fp
    1e48:	9301      	str	r3, [sp, #4]
			total_len += n;
    1e4a:	44da      	add	sl, fp
			len -= n;
    1e4c:	eba9 090b 	sub.w	r9, r9, fp
    1e50:	e7c6      	b.n	1de0 <_mac_async_read+0x7c>
	uint32_t total_len = 0;          /* Total length of received package */
    1e52:	46c2      	mov	sl, r8
		}
	}

	return total_len;
}
    1e54:	4650      	mov	r0, sl
    1e56:	b003      	add	sp, #12
    1e58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (sof != 0xFFFFFFFF) {
    1e5c:	f1b7 3fff 	cmp.w	r7, #4294967295
    1e60:	d105      	bne.n	1e6e <_mac_async_read+0x10a>
    1e62:	46a0      	mov	r8, r4
    1e64:	463c      	mov	r4, r7
    1e66:	e005      	b.n	1e74 <_mac_async_read+0x110>
    1e68:	f1b7 3fff 	cmp.w	r7, #4294967295
    1e6c:	d00a      	beq.n	1e84 <_mac_async_read+0x120>
		if (_rxbuf_descrs[pos].status.bm.sof) {
    1e6e:	46b8      	mov	r8, r7
    1e70:	f04f 34ff 	mov.w	r4, #4294967295
	for (i = 0; i < j; i++) {
    1e74:	f1b8 0f00 	cmp.w	r8, #0
    1e78:	d0eb      	beq.n	1e52 <_mac_async_read+0xee>
	} else if (sof != 0xFFFFFFFF) {
    1e7a:	f04f 0a00 	mov.w	sl, #0
    1e7e:	4656      	mov	r6, sl
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    1e80:	4d02      	ldr	r5, [pc, #8]	; (1e8c <_mac_async_read+0x128>)
    1e82:	e7c6      	b.n	1e12 <_mac_async_read+0xae>
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1e84:	46a0      	mov	r8, r4
	} else if (sof != 0xFFFFFFFF) {
    1e86:	463c      	mov	r4, r7
    1e88:	e7f7      	b.n	1e7a <_mac_async_read+0x116>
    1e8a:	bf00      	nop
    1e8c:	200012b8 	.word	0x200012b8
    1e90:	20000da0 	.word	0x20000da0
    1e94:	00009faf 	.word	0x00009faf

00001e98 <_mac_async_read_len>:

uint32_t _mac_async_read_len(struct _mac_async_device *const dev)
{
    1e98:	b470      	push	{r4, r5, r6}
	uint32_t i;
	uint32_t pos;
	bool     sof       = false; /* Start of Frame */
	uint32_t total_len = 0;     /* Total length of received package */
    1e9a:	2000      	movs	r0, #0
	bool     sof       = false; /* Start of Frame */
    1e9c:	4606      	mov	r6, r0

	(void)dev;

	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1e9e:	4601      	mov	r1, r0
		pos = _rxbuf_index + i;
    1ea0:	4a16      	ldr	r2, [pc, #88]	; (1efc <_mac_async_read_len+0x64>)

		if (_rxbuf_descrs[pos].status.bm.sof) {
			sof = true;
		}
		if (sof == true) {
			total_len += _rxbuf_descrs[pos].status.bm.len;
    1ea2:	2501      	movs	r5, #1
    1ea4:	e010      	b.n	1ec8 <_mac_async_read_len+0x30>
    1ea6:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
    1eaa:	f8b4 42ec 	ldrh.w	r4, [r4, #748]	; 0x2ec
    1eae:	f3c4 040c 	ubfx	r4, r4, #0, #13
    1eb2:	4420      	add	r0, r4
    1eb4:	462e      	mov	r6, r5
		}

		if (_rxbuf_descrs[pos].status.bm.eof) {
    1eb6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    1eba:	f893 32ed 	ldrb.w	r3, [r3, #749]	; 0x2ed
    1ebe:	09db      	lsrs	r3, r3, #7
    1ec0:	d119      	bne.n	1ef6 <_mac_async_read_len+0x5e>
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1ec2:	3101      	adds	r1, #1
    1ec4:	2910      	cmp	r1, #16
    1ec6:	d016      	beq.n	1ef6 <_mac_async_read_len+0x5e>
		pos = _rxbuf_index + i;
    1ec8:	f8d2 3368 	ldr.w	r3, [r2, #872]	; 0x368
    1ecc:	440b      	add	r3, r1
		if (pos >= CONF_GMAC_RXDESCR_NUM) {
    1ece:	2b0f      	cmp	r3, #15
			pos -= CONF_GMAC_RXDESCR_NUM;
    1ed0:	bf88      	it	hi
    1ed2:	3b10      	subhi	r3, #16
		if (!(_rxbuf_descrs[pos].address.bm.ownership)) {
    1ed4:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
    1ed8:	f894 42e8 	ldrb.w	r4, [r4, #744]	; 0x2e8
    1edc:	f014 0f01 	tst.w	r4, #1
    1ee0:	d009      	beq.n	1ef6 <_mac_async_read_len+0x5e>
		if (_rxbuf_descrs[pos].status.bm.sof) {
    1ee2:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
    1ee6:	f894 42ed 	ldrb.w	r4, [r4, #749]	; 0x2ed
    1eea:	f014 0f40 	tst.w	r4, #64	; 0x40
    1eee:	d1da      	bne.n	1ea6 <_mac_async_read_len+0xe>
		if (sof == true) {
    1ef0:	2e00      	cmp	r6, #0
    1ef2:	d0e0      	beq.n	1eb6 <_mac_async_read_len+0x1e>
    1ef4:	e7d7      	b.n	1ea6 <_mac_async_read_len+0xe>
			break;
		}
	}

	return total_len;
}
    1ef6:	bc70      	pop	{r4, r5, r6}
    1ef8:	4770      	bx	lr
    1efa:	bf00      	nop
    1efc:	200012b8 	.word	0x200012b8

00001f00 <_mac_async_register_callback>:
}

int32_t _mac_async_register_callback(struct _mac_async_device *const dev, const enum mac_async_cb_type type,
                                     const FUNC_PTR func)
{
	switch (type) {
    1f00:	b169      	cbz	r1, 1f1e <_mac_async_register_callback+0x1e>
    1f02:	2901      	cmp	r1, #1
    1f04:	d111      	bne.n	1f2a <_mac_async_register_callback+0x2a>
	case MAC_ASYNC_TRANSMIT_CB:
		dev->cb.transmited = (_mac_async_cb_t)func;
    1f06:	6042      	str	r2, [r0, #4]
		if (func) {
    1f08:	b122      	cbz	r2, 1f14 <_mac_async_register_callback+0x14>
			hri_gmac_set_IMR_TCOMP_bit(dev->hw);
    1f0a:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->IER.reg = GMAC_IMR_TCOMP;
    1f0c:	2280      	movs	r2, #128	; 0x80
    1f0e:	629a      	str	r2, [r3, #40]	; 0x28
		}
		break;
	default:
		return ERR_INVALID_ARG;
	}
	return ERR_NONE;
    1f10:	2000      	movs	r0, #0
    1f12:	4770      	bx	lr
			hri_gmac_clear_IMR_TCOMP_bit(dev->hw);
    1f14:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->IDR.reg = GMAC_IMR_TCOMP;
    1f16:	2280      	movs	r2, #128	; 0x80
    1f18:	62da      	str	r2, [r3, #44]	; 0x2c
	return ERR_NONE;
    1f1a:	2000      	movs	r0, #0
    1f1c:	4770      	bx	lr
		dev->cb.received = (_mac_async_cb_t)func;
    1f1e:	6082      	str	r2, [r0, #8]
			hri_gmac_set_IMR_RCOMP_bit(dev->hw);
    1f20:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->IER.reg = GMAC_IMR_RCOMP;
    1f22:	2202      	movs	r2, #2
    1f24:	629a      	str	r2, [r3, #40]	; 0x28
	return ERR_NONE;
    1f26:	2000      	movs	r0, #0
    1f28:	4770      	bx	lr
		return ERR_INVALID_ARG;
    1f2a:	f06f 000c 	mvn.w	r0, #12
}
    1f2e:	4770      	bx	lr

00001f30 <_mac_async_set_filter>:

int32_t _mac_async_set_filter(struct _mac_async_device *const dev, uint8_t index, struct mac_async_filter *filter)
{
    1f30:	b570      	push	{r4, r5, r6, lr}
    1f32:	4606      	mov	r6, r0
    1f34:	460c      	mov	r4, r1
    1f36:	4615      	mov	r5, r2
	ASSERT(index < 4);
    1f38:	f240 12cf 	movw	r2, #463	; 0x1cf
    1f3c:	490c      	ldr	r1, [pc, #48]	; (1f70 <_mac_async_set_filter+0x40>)
    1f3e:	2c03      	cmp	r4, #3
    1f40:	bf8c      	ite	hi
    1f42:	2000      	movhi	r0, #0
    1f44:	2001      	movls	r0, #1
    1f46:	4b0b      	ldr	r3, [pc, #44]	; (1f74 <_mac_async_set_filter+0x44>)
    1f48:	4798      	blx	r3

	hri_gmac_write_SAB_reg(dev->hw, index, *((uint32_t *)(filter->mac)));
    1f4a:	6833      	ldr	r3, [r6, #0]
    1f4c:	6829      	ldr	r1, [r5, #0]
	((Gmac *)hw)->Sa[submodule_index].SAB.reg = data;
    1f4e:	f104 0211 	add.w	r2, r4, #17
    1f52:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
	hri_gmac_write_SAT_reg(dev->hw, index, *((uint16_t *)(filter->mac + 4)));
    1f56:	6833      	ldr	r3, [r6, #0]
    1f58:	88a9      	ldrh	r1, [r5, #4]
	((Gmac *)hw)->Sa[submodule_index].SAT.reg = data;
    1f5a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1f5e:	6059      	str	r1, [r3, #4]

	hri_gmac_write_TIDM_reg(dev->hw, index, GMAC_TIDM_TID(*((uint16_t *)(filter->tid)) | filter->tid_enable << 31));
    1f60:	6833      	ldr	r3, [r6, #0]
    1f62:	88ea      	ldrh	r2, [r5, #6]
	((Gmac *)hw)->TIDM[index].reg = data;
    1f64:	342a      	adds	r4, #42	; 0x2a
    1f66:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
	return ERR_NONE;
}
    1f6a:	2000      	movs	r0, #0
    1f6c:	bd70      	pop	{r4, r5, r6, pc}
    1f6e:	bf00      	nop
    1f70:	0000b1bc 	.word	0x0000b1bc
    1f74:	00001861 	.word	0x00001861

00001f78 <_mac_async_write_phy_reg>:

	return ERR_NONE;
}

int32_t _mac_async_write_phy_reg(struct _mac_async_device *const dev, uint16_t addr, uint16_t reg, uint16_t data)
{
    1f78:	b430      	push	{r4, r5}
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_MPE);
    1f7a:	6805      	ldr	r5, [r0, #0]
	((Gmac *)hw)->NCR.reg |= mask;
    1f7c:	682c      	ldr	r4, [r5, #0]
    1f7e:	f044 0410 	orr.w	r4, r4, #16
    1f82:	602c      	str	r4, [r5, #0]
	hri_gmac_write_MAN_reg(dev->hw,
    1f84:	6804      	ldr	r4, [r0, #0]
	                       GMAC_MAN_OP(1) |            /* 0x01 write operation */
	                           CONF_GMAC_CLTTO << 30 | /* Clause 22/45 operation */
	                           GMAC_MAN_WTN(2) |       /* Must be written to 0x2 */
	                           GMAC_MAN_PHYA(addr) | GMAC_MAN_REGA(reg) | GMAC_MAN_DATA(data));
    1f86:	0492      	lsls	r2, r2, #18
    1f88:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
    1f8c:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    1f90:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    1f94:	431a      	orrs	r2, r3
    1f96:	05c9      	lsls	r1, r1, #23
    1f98:	f001 6178 	and.w	r1, r1, #260046848	; 0xf800000
    1f9c:	430a      	orrs	r2, r1
	((Gmac *)hw)->MAN.reg = data;
    1f9e:	6362      	str	r2, [r4, #52]	; 0x34
	/* Wait for the write operation complete */
	while (!hri_gmac_get_NSR_IDLE_bit(dev->hw)) {
    1fa0:	6802      	ldr	r2, [r0, #0]
	return (((Gmac *)hw)->NSR.reg & GMAC_NSR_IDLE) >> GMAC_NSR_IDLE_Pos;
    1fa2:	6893      	ldr	r3, [r2, #8]
    1fa4:	f013 0f04 	tst.w	r3, #4
    1fa8:	d0fb      	beq.n	1fa2 <_mac_async_write_phy_reg+0x2a>
	((Gmac *)hw)->NCR.reg &= ~mask;
    1faa:	6813      	ldr	r3, [r2, #0]
    1fac:	f023 0310 	bic.w	r3, r3, #16
    1fb0:	6013      	str	r3, [r2, #0]
	}

	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_MPE);
	return ERR_NONE;
}
    1fb2:	2000      	movs	r0, #0
    1fb4:	bc30      	pop	{r4, r5}
    1fb6:	4770      	bx	lr

00001fb8 <_mac_async_read_phy_reg>:

int32_t _mac_async_read_phy_reg(struct _mac_async_device *const dev, uint16_t addr, uint16_t reg, uint16_t *data)
{
    1fb8:	b430      	push	{r4, r5}
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_MPE);
    1fba:	6805      	ldr	r5, [r0, #0]
	((Gmac *)hw)->NCR.reg |= mask;
    1fbc:	682c      	ldr	r4, [r5, #0]
    1fbe:	f044 0410 	orr.w	r4, r4, #16
    1fc2:	602c      	str	r4, [r5, #0]
	hri_gmac_write_MAN_reg(dev->hw,
    1fc4:	6804      	ldr	r4, [r0, #0]
	                       GMAC_MAN_OP(2) |            /* 0x02 read operation */
	                           CONF_GMAC_CLTTO << 30 | /* Clause 22/45 operation */
	                           GMAC_MAN_WTN(0x2) |     /* Must be written to 0x2 */
	                           GMAC_MAN_PHYA(addr) | GMAC_MAN_REGA(reg));
    1fc6:	0492      	lsls	r2, r2, #18
    1fc8:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
    1fcc:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
    1fd0:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
    1fd4:	05c9      	lsls	r1, r1, #23
    1fd6:	f001 6178 	and.w	r1, r1, #260046848	; 0xf800000
    1fda:	430a      	orrs	r2, r1
	((Gmac *)hw)->MAN.reg = data;
    1fdc:	6362      	str	r2, [r4, #52]	; 0x34

	/* Wait for the read operation complete */
	while (!hri_gmac_get_NSR_IDLE_bit(dev->hw)) {
    1fde:	6801      	ldr	r1, [r0, #0]
	return (((Gmac *)hw)->NSR.reg & GMAC_NSR_IDLE) >> GMAC_NSR_IDLE_Pos;
    1fe0:	688a      	ldr	r2, [r1, #8]
    1fe2:	f012 0f04 	tst.w	r2, #4
    1fe6:	d0fb      	beq.n	1fe0 <_mac_async_read_phy_reg+0x28>
	return ((Gmac *)hw)->MAN.reg;
    1fe8:	6b4a      	ldr	r2, [r1, #52]	; 0x34
	}

	*data = GMAC_MAN_DATA(hri_gmac_read_MAN_reg(dev->hw));
    1fea:	801a      	strh	r2, [r3, #0]
	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_MPE);
    1fec:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->NCR.reg &= ~mask;
    1fee:	6813      	ldr	r3, [r2, #0]
    1ff0:	f023 0310 	bic.w	r3, r3, #16
    1ff4:	6013      	str	r3, [r2, #0]

	return ERR_NONE;
}
    1ff6:	2000      	movs	r0, #0
    1ff8:	bc30      	pop	{r4, r5}
    1ffa:	4770      	bx	lr

00001ffc <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    1ffc:	2201      	movs	r2, #1
    1ffe:	4b01      	ldr	r3, [pc, #4]	; (2004 <_mclk_init+0x8>)
    2000:	715a      	strb	r2, [r3, #5]
    2002:	4770      	bx	lr
    2004:	40000800 	.word	0x40000800

00002008 <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    2008:	4b03      	ldr	r3, [pc, #12]	; (2018 <_osc32kctrl_init_sources+0x10>)
    200a:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    200c:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    2010:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    2012:	2201      	movs	r2, #1
    2014:	741a      	strb	r2, [r3, #16]
    2016:	4770      	bx	lr
    2018:	40001400 	.word	0x40001400

0000201c <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_XOSCCTRL_reg(const void *const hw, uint8_t index, hri_oscctrl_xoscctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
    201c:	4a08      	ldr	r2, [pc, #32]	; (2040 <_oscctrl_init_sources+0x24>)
    201e:	4b09      	ldr	r3, [pc, #36]	; (2044 <_oscctrl_init_sources+0x28>)
    2020:	615a      	str	r2, [r3, #20]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY0) >> OSCCTRL_STATUS_XOSCRDY0_Pos;
    2022:	461a      	mov	r2, r3
    2024:	6913      	ldr	r3, [r2, #16]
	        | (CONF_XOSC0_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC0_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC0_CONFIG == 1
#if CONF_XOSC0_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY0_bit(hw))
    2026:	f013 0f01 	tst.w	r3, #1
    202a:	d0fb      	beq.n	2024 <_oscctrl_init_sources+0x8>
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
    202c:	4a06      	ldr	r2, [pc, #24]	; (2048 <_oscctrl_init_sources+0x2c>)
    202e:	4b05      	ldr	r3, [pc, #20]	; (2044 <_oscctrl_init_sources+0x28>)
    2030:	619a      	str	r2, [r3, #24]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1) >> OSCCTRL_STATUS_XOSCRDY1_Pos;
    2032:	461a      	mov	r2, r3
    2034:	6913      	ldr	r3, [r2, #16]
	        | (CONF_XOSC1_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC1_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC1_CONFIG == 1
#if CONF_XOSC1_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY1_bit(hw))
    2036:	f013 0f02 	tst.w	r3, #2
    203a:	d0fb      	beq.n	2034 <_oscctrl_init_sources+0x18>
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    203c:	4770      	bx	lr
    203e:	bf00      	nop
    2040:	03002602 	.word	0x03002602
    2044:	40001000 	.word	0x40001000
    2048:	03002606 	.word	0x03002606

0000204c <_oscctrl_init_referenced_generators>:
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLRATIO.reg = data;
    204c:	223b      	movs	r2, #59	; 0x3b
    204e:	4b0e      	ldr	r3, [pc, #56]	; (2088 <_oscctrl_init_referenced_generators+0x3c>)
    2050:	635a      	str	r2, [r3, #52]	; 0x34
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    2052:	461a      	mov	r2, r3
    2054:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
    2056:	f013 0f06 	tst.w	r3, #6
    205a:	d1fb      	bne.n	2054 <_oscctrl_init_referenced_generators+0x8>
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLB.reg = data;
    205c:	4b0a      	ldr	r3, [pc, #40]	; (2088 <_oscctrl_init_referenced_generators+0x3c>)
    205e:	4a0b      	ldr	r2, [pc, #44]	; (208c <_oscctrl_init_referenced_generators+0x40>)
    2060:	639a      	str	r2, [r3, #56]	; 0x38
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLA.reg = data;
    2062:	2202      	movs	r2, #2
    2064:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    2068:	461a      	mov	r2, r3
    206a:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
    206c:	f013 0f02 	tst.w	r3, #2
    2070:	d1fb      	bne.n	206a <_oscctrl_init_referenced_generators+0x1e>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_LOCK)
    2072:	4b05      	ldr	r3, [pc, #20]	; (2088 <_oscctrl_init_referenced_generators+0x3c>)
    2074:	6c1a      	ldr	r2, [r3, #64]	; 0x40
#endif
#endif

#if CONF_FDPLL0_CONFIG == 1
#if CONF_FDPLL0_ENABLE == 1
	while (!(hri_oscctrl_get_DPLLSTATUS_LOCK_bit(hw, 0) || hri_oscctrl_get_DPLLSTATUS_CLKRDY_bit(hw, 0)))
    2076:	f012 0f01 	tst.w	r2, #1
    207a:	d103      	bne.n	2084 <_oscctrl_init_referenced_generators+0x38>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_CLKRDY)
    207c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    207e:	f012 0f02 	tst.w	r2, #2
    2082:	d0f7      	beq.n	2074 <_oscctrl_init_referenced_generators+0x28>
    2084:	4770      	bx	lr
    2086:	bf00      	nop
    2088:	40001000 	.word	0x40001000
    208c:	00020040 	.word	0x00020040

00002090 <RAMECC_Handler>:

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    2090:	b500      	push	{lr}
    2092:	b083      	sub	sp, #12
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    2094:	4b0d      	ldr	r3, [pc, #52]	; (20cc <RAMECC_Handler+0x3c>)
    2096:	789b      	ldrb	r3, [r3, #2]
    2098:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    209a:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    209c:	9b01      	ldr	r3, [sp, #4]
    209e:	f013 0f02 	tst.w	r3, #2
    20a2:	d006      	beq.n	20b2 <RAMECC_Handler+0x22>
    20a4:	4b0a      	ldr	r3, [pc, #40]	; (20d0 <RAMECC_Handler+0x40>)
    20a6:	681b      	ldr	r3, [r3, #0]
    20a8:	b11b      	cbz	r3, 20b2 <RAMECC_Handler+0x22>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    20aa:	4a08      	ldr	r2, [pc, #32]	; (20cc <RAMECC_Handler+0x3c>)
    20ac:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.dual_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    20ae:	4798      	blx	r3
    20b0:	e009      	b.n	20c6 <RAMECC_Handler+0x36>
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    20b2:	9b01      	ldr	r3, [sp, #4]
    20b4:	f013 0f01 	tst.w	r3, #1
    20b8:	d005      	beq.n	20c6 <RAMECC_Handler+0x36>
    20ba:	4b05      	ldr	r3, [pc, #20]	; (20d0 <RAMECC_Handler+0x40>)
    20bc:	685b      	ldr	r3, [r3, #4]
    20be:	b113      	cbz	r3, 20c6 <RAMECC_Handler+0x36>
    20c0:	4a02      	ldr	r2, [pc, #8]	; (20cc <RAMECC_Handler+0x3c>)
    20c2:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    20c4:	4798      	blx	r3
	} else {
		return;
	}
}
    20c6:	b003      	add	sp, #12
    20c8:	f85d fb04 	ldr.w	pc, [sp], #4
    20cc:	41020000 	.word	0x41020000
    20d0:	200082e8 	.word	0x200082e8

000020d4 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    20d4:	b470      	push	{r4, r5, r6}
    20d6:	b089      	sub	sp, #36	; 0x24
    20d8:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    20da:	466c      	mov	r4, sp
    20dc:	4d0d      	ldr	r5, [pc, #52]	; (2114 <_sercom_get_hardware_index+0x40>)
    20de:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    20e0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    20e2:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    20e6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    20ea:	9b00      	ldr	r3, [sp, #0]
    20ec:	42b3      	cmp	r3, r6
    20ee:	d00d      	beq.n	210c <_sercom_get_hardware_index+0x38>
    20f0:	4631      	mov	r1, r6
    20f2:	ab01      	add	r3, sp, #4
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    20f4:	2001      	movs	r0, #1
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    20f6:	f853 2b04 	ldr.w	r2, [r3], #4
    20fa:	428a      	cmp	r2, r1
    20fc:	d007      	beq.n	210e <_sercom_get_hardware_index+0x3a>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    20fe:	3001      	adds	r0, #1
    2100:	2808      	cmp	r0, #8
    2102:	d1f8      	bne.n	20f6 <_sercom_get_hardware_index+0x22>
			return i;
		}
	}
	return 0;
    2104:	2000      	movs	r0, #0
}
    2106:	b009      	add	sp, #36	; 0x24
    2108:	bc70      	pop	{r4, r5, r6}
    210a:	4770      	bx	lr
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    210c:	2000      	movs	r0, #0
			return i;
    210e:	b2c0      	uxtb	r0, r0
    2110:	e7f9      	b.n	2106 <_sercom_get_hardware_index+0x32>
    2112:	bf00      	nop
    2114:	0000b1d4 	.word	0x0000b1d4

00002118 <_sercom_usart_interrupt_handler>:
 * \internal Sercom interrupt handler
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _sercom_usart_interrupt_handler(struct _usart_async_device *device)
{
    2118:	b510      	push	{r4, lr}
	void *hw = device->hw;
    211a:	6984      	ldr	r4, [r0, #24]
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
}

static inline bool hri_sercomusart_get_interrupt_DRE_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    211c:	7e23      	ldrb	r3, [r4, #24]

	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
    211e:	f013 0f01 	tst.w	r3, #1
    2122:	d003      	beq.n	212c <_sercom_usart_interrupt_handler+0x14>
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
}

static inline bool hri_sercomusart_get_INTEN_DRE_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
    2124:	7da3      	ldrb	r3, [r4, #22]
    2126:	f013 0f01 	tst.w	r3, #1
    212a:	d112      	bne.n	2152 <_sercom_usart_interrupt_handler+0x3a>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    212c:	7e23      	ldrb	r3, [r4, #24]
		hri_sercomusart_clear_INTEN_DRE_bit(hw);
		device->usart_cb.tx_byte_sent(device);
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
    212e:	f013 0f02 	tst.w	r3, #2
    2132:	d003      	beq.n	213c <_sercom_usart_interrupt_handler+0x24>
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
}

static inline bool hri_sercomusart_get_INTEN_TXC_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
    2134:	7da3      	ldrb	r3, [r4, #22]
    2136:	f013 0f02 	tst.w	r3, #2
    213a:	d10f      	bne.n	215c <_sercom_usart_interrupt_handler+0x44>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    213c:	7e23      	ldrb	r3, [r4, #24]
		hri_sercomusart_clear_INTEN_TXC_bit(hw);
		device->usart_cb.tx_done_cb(device);
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
    213e:	f013 0f04 	tst.w	r3, #4
    2142:	d015      	beq.n	2170 <_sercom_usart_interrupt_handler+0x58>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
    2144:	8b63      	ldrh	r3, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
    2146:	f003 0337 	and.w	r3, r3, #55	; 0x37
    214a:	b163      	cbz	r3, 2166 <_sercom_usart_interrupt_handler+0x4e>
	((Sercom *)hw)->USART.STATUS.reg = mask;
    214c:	23ff      	movs	r3, #255	; 0xff
    214e:	8363      	strh	r3, [r4, #26]
    2150:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
    2152:	2301      	movs	r3, #1
    2154:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_byte_sent(device);
    2156:	6803      	ldr	r3, [r0, #0]
    2158:	4798      	blx	r3
    215a:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
    215c:	2302      	movs	r3, #2
    215e:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_done_cb(device);
    2160:	6883      	ldr	r3, [r0, #8]
    2162:	4798      	blx	r3
    2164:	bd10      	pop	{r4, pc}
	return ((Sercom *)hw)->USART.DATA.reg;
    2166:	6aa1      	ldr	r1, [r4, #40]	; 0x28
		       | SERCOM_USART_STATUS_ISF | SERCOM_USART_STATUS_COLL)) {
			hri_sercomusart_clear_STATUS_reg(hw, SERCOM_USART_STATUS_MASK);
			return;
		}

		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
    2168:	6843      	ldr	r3, [r0, #4]
    216a:	b2c9      	uxtb	r1, r1
    216c:	4798      	blx	r3
    216e:	bd10      	pop	{r4, pc}
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
    2170:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
    2172:	09db      	lsrs	r3, r3, #7
    2174:	d100      	bne.n	2178 <_sercom_usart_interrupt_handler+0x60>
    2176:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
    2178:	2380      	movs	r3, #128	; 0x80
    217a:	7623      	strb	r3, [r4, #24]
		uint32_t status;

		hri_sercomusart_clear_interrupt_ERROR_bit(hw);
		device->usart_cb.error_cb(device);
    217c:	68c3      	ldr	r3, [r0, #12]
    217e:	4798      	blx	r3
	return ((Sercom *)hw)->USART.STATUS.reg;
    2180:	8b63      	ldrh	r3, [r4, #26]
    2182:	b29b      	uxth	r3, r3
	((Sercom *)hw)->USART.STATUS.reg = mask;
    2184:	8363      	strh	r3, [r4, #26]
    2186:	e7f6      	b.n	2176 <_sercom_usart_interrupt_handler+0x5e>

00002188 <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
    2188:	b508      	push	{r3, lr}
	return SERCOM0_0_IRQn + (_sercom_get_hardware_index(hw) << 2);
    218a:	4b03      	ldr	r3, [pc, #12]	; (2198 <_sercom_get_irq_num+0x10>)
    218c:	4798      	blx	r3
    218e:	0080      	lsls	r0, r0, #2
    2190:	302e      	adds	r0, #46	; 0x2e
}
    2192:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
    2196:	bd08      	pop	{r3, pc}
    2198:	000020d5 	.word	0x000020d5

0000219c <_usart_init>:
{
    219c:	b510      	push	{r4, lr}
    219e:	4604      	mov	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    21a0:	4b41      	ldr	r3, [pc, #260]	; (22a8 <_usart_init+0x10c>)
    21a2:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
    21a4:	2800      	cmp	r0, #0
    21a6:	d05c      	beq.n	2262 <_usart_init+0xc6>
    21a8:	2801      	cmp	r0, #1
    21aa:	d05c      	beq.n	2266 <_usart_init+0xca>
	ASSERT(false);
    21ac:	f240 226b 	movw	r2, #619	; 0x26b
    21b0:	493e      	ldr	r1, [pc, #248]	; (22ac <_usart_init+0x110>)
    21b2:	2000      	movs	r0, #0
    21b4:	4b3e      	ldr	r3, [pc, #248]	; (22b0 <_usart_init+0x114>)
    21b6:	4798      	blx	r3
	return 0;
    21b8:	2100      	movs	r1, #0
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    21ba:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    21bc:	f013 0f01 	tst.w	r3, #1
    21c0:	d122      	bne.n	2208 <_usart_init+0x6c>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
    21c2:	004b      	lsls	r3, r1, #1
    21c4:	185a      	adds	r2, r3, r1
    21c6:	4b3b      	ldr	r3, [pc, #236]	; (22b4 <_usart_init+0x118>)
    21c8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    21cc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    21ce:	f002 021c 	and.w	r2, r2, #28
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    21d2:	69e3      	ldr	r3, [r4, #28]
    21d4:	f013 0f03 	tst.w	r3, #3
    21d8:	d1fb      	bne.n	21d2 <_usart_init+0x36>
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    21da:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    21dc:	f013 0f02 	tst.w	r3, #2
    21e0:	d00b      	beq.n	21fa <_usart_init+0x5e>
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    21e2:	6823      	ldr	r3, [r4, #0]
    21e4:	f023 0302 	bic.w	r3, r3, #2
    21e8:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    21ea:	69e3      	ldr	r3, [r4, #28]
    21ec:	f013 0f03 	tst.w	r3, #3
    21f0:	d1fb      	bne.n	21ea <_usart_init+0x4e>
    21f2:	69e3      	ldr	r3, [r4, #28]
    21f4:	f013 0f02 	tst.w	r3, #2
    21f8:	d1fb      	bne.n	21f2 <_usart_init+0x56>
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
    21fa:	f042 0201 	orr.w	r2, r2, #1
	((Sercom *)hw)->USART.CTRLA.reg = data;
    21fe:	6022      	str	r2, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    2200:	69e3      	ldr	r3, [r4, #28]
    2202:	f013 0f03 	tst.w	r3, #3
    2206:	d1fb      	bne.n	2200 <_usart_init+0x64>
    2208:	69e3      	ldr	r3, [r4, #28]
    220a:	f013 0f01 	tst.w	r3, #1
    220e:	d1fb      	bne.n	2208 <_usart_init+0x6c>
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    2210:	460a      	mov	r2, r1
    2212:	004b      	lsls	r3, r1, #1
    2214:	440b      	add	r3, r1
    2216:	4927      	ldr	r1, [pc, #156]	; (22b4 <_usart_init+0x118>)
    2218:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
    221c:	6a48      	ldr	r0, [r1, #36]	; 0x24
	((Sercom *)hw)->USART.CTRLA.reg = data;
    221e:	6020      	str	r0, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    2220:	69e3      	ldr	r3, [r4, #28]
    2222:	f013 0f03 	tst.w	r3, #3
    2226:	d1fb      	bne.n	2220 <_usart_init+0x84>
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
    2228:	0053      	lsls	r3, r2, #1
    222a:	1899      	adds	r1, r3, r2
    222c:	4b21      	ldr	r3, [pc, #132]	; (22b4 <_usart_init+0x118>)
    222e:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    2232:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	((Sercom *)hw)->USART.CTRLB.reg = data;
    2234:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    2236:	69e3      	ldr	r3, [r4, #28]
    2238:	f013 0f1f 	tst.w	r3, #31
    223c:	d1fb      	bne.n	2236 <_usart_init+0x9a>
	hri_sercomusart_write_CTRLC_reg(hw, _usarts[i].ctrl_c);
    223e:	0053      	lsls	r3, r2, #1
    2240:	1899      	adds	r1, r3, r2
    2242:	4b1c      	ldr	r3, [pc, #112]	; (22b4 <_usart_init+0x118>)
    2244:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    2248:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	((Sercom *)hw)->USART.CTRLC.reg = data;
    224a:	60a3      	str	r3, [r4, #8]
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
    224c:	f410 4fc0 	tst.w	r0, #24576	; 0x6000
    2250:	d10b      	bne.n	226a <_usart_init+0xce>
		hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
    2252:	0053      	lsls	r3, r2, #1
    2254:	1899      	adds	r1, r3, r2
    2256:	4b17      	ldr	r3, [pc, #92]	; (22b4 <_usart_init+0x118>)
    2258:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    225c:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
	((Sercom *)hw)->USART.BAUD.reg = data;
    225e:	81a3      	strh	r3, [r4, #12]
    2260:	e011      	b.n	2286 <_usart_init+0xea>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    2262:	2100      	movs	r1, #0
    2264:	e7a9      	b.n	21ba <_usart_init+0x1e>
		if (_usarts[i].number == sercom_offset) {
    2266:	2101      	movs	r1, #1
    2268:	e7a7      	b.n	21ba <_usart_init+0x1e>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
    226a:	4b12      	ldr	r3, [pc, #72]	; (22b4 <_usart_init+0x118>)
    226c:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    2270:	8e18      	ldrh	r0, [r3, #48]	; 0x30
    2272:	89a1      	ldrh	r1, [r4, #12]
    2274:	f360 010c 	bfi	r1, r0, #0, #13
    2278:	81a1      	strh	r1, [r4, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
    227a:	f893 1032 	ldrb.w	r1, [r3, #50]	; 0x32
    227e:	89a3      	ldrh	r3, [r4, #12]
    2280:	f361 334f 	bfi	r3, r1, #13, #3
    2284:	81a3      	strh	r3, [r4, #12]
	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
    2286:	4b0b      	ldr	r3, [pc, #44]	; (22b4 <_usart_init+0x118>)
    2288:	0051      	lsls	r1, r2, #1
    228a:	1888      	adds	r0, r1, r2
    228c:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    2290:	f890 0033 	ldrb.w	r0, [r0, #51]	; 0x33
	((Sercom *)hw)->USART.RXPL.reg = data;
    2294:	73a0      	strb	r0, [r4, #14]
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
    2296:	440a      	add	r2, r1
    2298:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    229c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    22a0:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
}
    22a4:	2000      	movs	r0, #0
    22a6:	bd10      	pop	{r4, pc}
    22a8:	000020d5 	.word	0x000020d5
    22ac:	0000b23c 	.word	0x0000b23c
    22b0:	00001861 	.word	0x00001861
    22b4:	0000b1d4 	.word	0x0000b1d4

000022b8 <_get_i2cm_index>:
{
    22b8:	b508      	push	{r3, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    22ba:	4b07      	ldr	r3, [pc, #28]	; (22d8 <_get_i2cm_index+0x20>)
    22bc:	4798      	blx	r3
		if (_i2cms[i].number == sercom_offset) {
    22be:	2803      	cmp	r0, #3
    22c0:	d008      	beq.n	22d4 <_get_i2cm_index+0x1c>
	ASSERT(false);
    22c2:	f240 32ce 	movw	r2, #974	; 0x3ce
    22c6:	4905      	ldr	r1, [pc, #20]	; (22dc <_get_i2cm_index+0x24>)
    22c8:	2000      	movs	r0, #0
    22ca:	4b05      	ldr	r3, [pc, #20]	; (22e0 <_get_i2cm_index+0x28>)
    22cc:	4798      	blx	r3
	return -1;
    22ce:	f04f 30ff 	mov.w	r0, #4294967295
}
    22d2:	bd08      	pop	{r3, pc}
			return i;
    22d4:	2000      	movs	r0, #0
    22d6:	bd08      	pop	{r3, pc}
    22d8:	000020d5 	.word	0x000020d5
    22dc:	0000b23c 	.word	0x0000b23c
    22e0:	00001861 	.word	0x00001861

000022e4 <_i2c_m_sync_init_impl>:
	}
	return ERR_NONE;
}

static int32_t _i2c_m_sync_init_impl(struct _i2c_m_service *const service, void *const hw)
{
    22e4:	b538      	push	{r3, r4, r5, lr}
    22e6:	4605      	mov	r5, r0
    22e8:	460c      	mov	r4, r1
	uint8_t i = _get_i2cm_index(hw);
    22ea:	4608      	mov	r0, r1
    22ec:	4b32      	ldr	r3, [pc, #200]	; (23b8 <_i2c_m_sync_init_impl+0xd4>)
    22ee:	4798      	blx	r3
    22f0:	b2c0      	uxtb	r0, r0
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
    22f2:	69e3      	ldr	r3, [r4, #28]

	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
    22f4:	f013 0f01 	tst.w	r3, #1
    22f8:	d122      	bne.n	2340 <_i2c_m_sync_init_impl+0x5c>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
    22fa:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    22fe:	4a2f      	ldr	r2, [pc, #188]	; (23bc <_i2c_m_sync_init_impl+0xd8>)
    2300:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    2304:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    2306:	f002 021c 	and.w	r2, r2, #28
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    230a:	69e3      	ldr	r3, [r4, #28]
    230c:	f013 0f03 	tst.w	r3, #3
    2310:	d1fb      	bne.n	230a <_i2c_m_sync_init_impl+0x26>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    2312:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
    2314:	f013 0f02 	tst.w	r3, #2
    2318:	d00b      	beq.n	2332 <_i2c_m_sync_init_impl+0x4e>
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
    231a:	6823      	ldr	r3, [r4, #0]
    231c:	f023 0302 	bic.w	r3, r3, #2
    2320:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2322:	69e3      	ldr	r3, [r4, #28]
    2324:	f013 0f03 	tst.w	r3, #3
    2328:	d1fb      	bne.n	2322 <_i2c_m_sync_init_impl+0x3e>
    232a:	69e3      	ldr	r3, [r4, #28]
    232c:	f013 0f02 	tst.w	r3, #2
    2330:	d1fb      	bne.n	232a <_i2c_m_sync_init_impl+0x46>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
		}
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
    2332:	f042 0201 	orr.w	r2, r2, #1
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    2336:	6022      	str	r2, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2338:	69e3      	ldr	r3, [r4, #28]
    233a:	f013 0f03 	tst.w	r3, #3
    233e:	d1fb      	bne.n	2338 <_i2c_m_sync_init_impl+0x54>
    2340:	69e3      	ldr	r3, [r4, #28]
    2342:	f013 0f01 	tst.w	r3, #1
    2346:	d1fb      	bne.n	2340 <_i2c_m_sync_init_impl+0x5c>
	}
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);

	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
    2348:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    234c:	4a1b      	ldr	r2, [pc, #108]	; (23bc <_i2c_m_sync_init_impl+0xd8>)
    234e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    2352:	6d5a      	ldr	r2, [r3, #84]	; 0x54
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    2354:	6022      	str	r2, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2356:	69e3      	ldr	r3, [r4, #28]
    2358:	f013 0f03 	tst.w	r3, #3
    235c:	d1fb      	bne.n	2356 <_i2c_m_sync_init_impl+0x72>
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
    235e:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    2362:	4916      	ldr	r1, [pc, #88]	; (23bc <_i2c_m_sync_init_impl+0xd8>)
    2364:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
    2368:	6d9b      	ldr	r3, [r3, #88]	; 0x58
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
    236a:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    236c:	69e3      	ldr	r3, [r4, #28]
    236e:	f013 0f04 	tst.w	r3, #4
    2372:	d1fb      	bne.n	236c <_i2c_m_sync_init_impl+0x88>
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
    2374:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    2378:	4910      	ldr	r1, [pc, #64]	; (23bc <_i2c_m_sync_init_impl+0xd8>)
    237a:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
    237e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
	((Sercom *)hw)->I2CM.BAUD.reg = data;
    2380:	60e3      	str	r3, [r4, #12]

	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
    2382:	f3c2 6301 	ubfx	r3, r2, #24, #2
    2386:	81ab      	strh	r3, [r5, #12]
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
    2388:	6a62      	ldr	r2, [r4, #36]	; 0x24
	tmp &= ~SERCOM_I2CM_ADDR_HS;
    238a:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
    238e:	2b01      	cmp	r3, #1
    2390:	bf94      	ite	ls
    2392:	2300      	movls	r3, #0
    2394:	2301      	movhi	r3, #1
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
    2396:	ea42 3383 	orr.w	r3, r2, r3, lsl #14
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
    239a:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    239c:	69e3      	ldr	r3, [r4, #28]
    239e:	f013 0f04 	tst.w	r3, #4
    23a2:	d1fb      	bne.n	239c <_i2c_m_sync_init_impl+0xb8>

	service->trise = _i2cms[i].trise;
    23a4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    23a8:	4b04      	ldr	r3, [pc, #16]	; (23bc <_i2c_m_sync_init_impl+0xd8>)
    23aa:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    23ae:	f8b0 3062 	ldrh.w	r3, [r0, #98]	; 0x62
    23b2:	81eb      	strh	r3, [r5, #14]

	return ERR_NONE;
}
    23b4:	2000      	movs	r0, #0
    23b6:	bd38      	pop	{r3, r4, r5, pc}
    23b8:	000022b9 	.word	0x000022b9
    23bc:	0000b1d4 	.word	0x0000b1d4

000023c0 <_usart_sync_init>:
{
    23c0:	b538      	push	{r3, r4, r5, lr}
    23c2:	460c      	mov	r4, r1
	ASSERT(device);
    23c4:	4605      	mov	r5, r0
    23c6:	22bd      	movs	r2, #189	; 0xbd
    23c8:	4905      	ldr	r1, [pc, #20]	; (23e0 <_usart_sync_init+0x20>)
    23ca:	3000      	adds	r0, #0
    23cc:	bf18      	it	ne
    23ce:	2001      	movne	r0, #1
    23d0:	4b04      	ldr	r3, [pc, #16]	; (23e4 <_usart_sync_init+0x24>)
    23d2:	4798      	blx	r3
	device->hw = hw;
    23d4:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
    23d6:	4620      	mov	r0, r4
    23d8:	4b03      	ldr	r3, [pc, #12]	; (23e8 <_usart_sync_init+0x28>)
    23da:	4798      	blx	r3
}
    23dc:	bd38      	pop	{r3, r4, r5, pc}
    23de:	bf00      	nop
    23e0:	0000b23c 	.word	0x0000b23c
    23e4:	00001861 	.word	0x00001861
    23e8:	0000219d 	.word	0x0000219d

000023ec <_usart_async_init>:
{
    23ec:	b570      	push	{r4, r5, r6, lr}
    23ee:	460d      	mov	r5, r1
	ASSERT(device);
    23f0:	4606      	mov	r6, r0
    23f2:	22cb      	movs	r2, #203	; 0xcb
    23f4:	4918      	ldr	r1, [pc, #96]	; (2458 <_usart_async_init+0x6c>)
    23f6:	3000      	adds	r0, #0
    23f8:	bf18      	it	ne
    23fa:	2001      	movne	r0, #1
    23fc:	4b17      	ldr	r3, [pc, #92]	; (245c <_usart_async_init+0x70>)
    23fe:	4798      	blx	r3
	init_status = _usart_init(hw);
    2400:	4628      	mov	r0, r5
    2402:	4b17      	ldr	r3, [pc, #92]	; (2460 <_usart_async_init+0x74>)
    2404:	4798      	blx	r3
	if (init_status) {
    2406:	4604      	mov	r4, r0
    2408:	b108      	cbz	r0, 240e <_usart_async_init+0x22>
}
    240a:	4620      	mov	r0, r4
    240c:	bd70      	pop	{r4, r5, r6, pc}
	device->hw = hw;
    240e:	61b5      	str	r5, [r6, #24]
	if (hw == SERCOM0) {
    2410:	4b14      	ldr	r3, [pc, #80]	; (2464 <_usart_async_init+0x78>)
    2412:	429d      	cmp	r5, r3
		_sercom0_dev = (struct _usart_async_device *)dev;
    2414:	bf04      	itt	eq
    2416:	4b14      	ldreq	r3, [pc, #80]	; (2468 <_usart_async_init+0x7c>)
    2418:	601e      	streq	r6, [r3, #0]
	uint8_t irq = _sercom_get_irq_num(hw);
    241a:	4628      	mov	r0, r5
    241c:	4b13      	ldr	r3, [pc, #76]	; (246c <_usart_async_init+0x80>)
    241e:	4798      	blx	r3
    2420:	1d01      	adds	r1, r0, #4
    2422:	b2c9      	uxtb	r1, r1
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2424:	2501      	movs	r5, #1
    2426:	f000 021f 	and.w	r2, r0, #31
    242a:	fa05 f202 	lsl.w	r2, r5, r2
    242e:	0943      	lsrs	r3, r0, #5
    2430:	009b      	lsls	r3, r3, #2
    2432:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    2436:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    243a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    243e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2442:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2446:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    244a:	601a      	str	r2, [r3, #0]
		irq++;
    244c:	3001      	adds	r0, #1
    244e:	b2c0      	uxtb	r0, r0
	for (uint32_t i = 0; i < 4; i++) {
    2450:	4281      	cmp	r1, r0
    2452:	d1e8      	bne.n	2426 <_usart_async_init+0x3a>
    2454:	e7d9      	b.n	240a <_usart_async_init+0x1e>
    2456:	bf00      	nop
    2458:	0000b23c 	.word	0x0000b23c
    245c:	00001861 	.word	0x00001861
    2460:	0000219d 	.word	0x0000219d
    2464:	40003000 	.word	0x40003000
    2468:	20001624 	.word	0x20001624
    246c:	00002189 	.word	0x00002189

00002470 <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    2470:	6802      	ldr	r2, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    2472:	6813      	ldr	r3, [r2, #0]
    2474:	f043 0302 	orr.w	r3, r3, #2
    2478:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    247a:	69d3      	ldr	r3, [r2, #28]
    247c:	f013 0f03 	tst.w	r3, #3
    2480:	d1fb      	bne.n	247a <_usart_sync_enable+0xa>
}
    2482:	4770      	bx	lr

00002484 <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    2484:	6982      	ldr	r2, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    2486:	6813      	ldr	r3, [r2, #0]
    2488:	f043 0302 	orr.w	r3, r3, #2
    248c:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    248e:	69d3      	ldr	r3, [r2, #28]
    2490:	f013 0f03 	tst.w	r3, #3
    2494:	d1fb      	bne.n	248e <_usart_async_enable+0xa>
}
    2496:	4770      	bx	lr

00002498 <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    2498:	6803      	ldr	r3, [r0, #0]
	((Sercom *)hw)->USART.DATA.reg = data;
    249a:	6299      	str	r1, [r3, #40]	; 0x28
    249c:	4770      	bx	lr

0000249e <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    249e:	6983      	ldr	r3, [r0, #24]
    24a0:	6299      	str	r1, [r3, #40]	; 0x28
    24a2:	4770      	bx	lr

000024a4 <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
    24a4:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
    24a6:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
    24a8:	b2c0      	uxtb	r0, r0
    24aa:	4770      	bx	lr

000024ac <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    24ac:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    24ae:	7e18      	ldrb	r0, [r3, #24]
}
    24b0:	f000 0001 	and.w	r0, r0, #1
    24b4:	4770      	bx	lr

000024b6 <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    24b6:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    24b8:	7e18      	ldrb	r0, [r3, #24]
}
    24ba:	f3c0 0040 	ubfx	r0, r0, #1, #1
    24be:	4770      	bx	lr

000024c0 <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    24c0:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    24c2:	7e18      	ldrb	r0, [r3, #24]
}
    24c4:	f3c0 0080 	ubfx	r0, r0, #2, #1
    24c8:	4770      	bx	lr

000024ca <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
    24ca:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
    24cc:	2201      	movs	r2, #1
    24ce:	759a      	strb	r2, [r3, #22]
    24d0:	4770      	bx	lr

000024d2 <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
    24d2:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
    24d4:	2202      	movs	r2, #2
    24d6:	759a      	strb	r2, [r3, #22]
    24d8:	4770      	bx	lr
	...

000024dc <_usart_async_set_irq_state>:
{
    24dc:	b570      	push	{r4, r5, r6, lr}
    24de:	460c      	mov	r4, r1
    24e0:	4616      	mov	r6, r2
	ASSERT(device);
    24e2:	4605      	mov	r5, r0
    24e4:	f240 222b 	movw	r2, #555	; 0x22b
    24e8:	4915      	ldr	r1, [pc, #84]	; (2540 <_usart_async_set_irq_state+0x64>)
    24ea:	3000      	adds	r0, #0
    24ec:	bf18      	it	ne
    24ee:	2001      	movne	r0, #1
    24f0:	4b14      	ldr	r3, [pc, #80]	; (2544 <_usart_async_set_irq_state+0x68>)
    24f2:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
    24f4:	f014 0ffd 	tst.w	r4, #253	; 0xfd
    24f8:	d10d      	bne.n	2516 <_usart_async_set_irq_state+0x3a>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
    24fa:	69ab      	ldr	r3, [r5, #24]
	if (value == 0x0) {
    24fc:	b92e      	cbnz	r6, 250a <_usart_async_set_irq_state+0x2e>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
    24fe:	2201      	movs	r2, #1
    2500:	751a      	strb	r2, [r3, #20]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
    2502:	69ab      	ldr	r3, [r5, #24]
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
    2504:	2202      	movs	r2, #2
    2506:	751a      	strb	r2, [r3, #20]
    2508:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
    250a:	2201      	movs	r2, #1
    250c:	759a      	strb	r2, [r3, #22]
    250e:	69ab      	ldr	r3, [r5, #24]
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
    2510:	2202      	movs	r2, #2
    2512:	759a      	strb	r2, [r3, #22]
    2514:	bd70      	pop	{r4, r5, r6, pc}
	} else if (USART_ASYNC_RX_DONE == type) {
    2516:	2c01      	cmp	r4, #1
    2518:	d002      	beq.n	2520 <_usart_async_set_irq_state+0x44>
	} else if (USART_ASYNC_ERROR == type) {
    251a:	2c03      	cmp	r4, #3
    251c:	d008      	beq.n	2530 <_usart_async_set_irq_state+0x54>
    251e:	bd70      	pop	{r4, r5, r6, pc}
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
    2520:	69ab      	ldr	r3, [r5, #24]
	if (value == 0x0) {
    2522:	b916      	cbnz	r6, 252a <_usart_async_set_irq_state+0x4e>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_RXC;
    2524:	2204      	movs	r2, #4
    2526:	751a      	strb	r2, [r3, #20]
    2528:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_RXC;
    252a:	2204      	movs	r2, #4
    252c:	759a      	strb	r2, [r3, #22]
    252e:	bd70      	pop	{r4, r5, r6, pc}
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
    2530:	69ab      	ldr	r3, [r5, #24]
	if (value == 0x0) {
    2532:	b116      	cbz	r6, 253a <_usart_async_set_irq_state+0x5e>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
    2534:	2280      	movs	r2, #128	; 0x80
    2536:	759a      	strb	r2, [r3, #22]
}
    2538:	e7f1      	b.n	251e <_usart_async_set_irq_state+0x42>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
    253a:	2280      	movs	r2, #128	; 0x80
    253c:	751a      	strb	r2, [r3, #20]
    253e:	bd70      	pop	{r4, r5, r6, pc}
    2540:	0000b23c 	.word	0x0000b23c
    2544:	00001861 	.word	0x00001861

00002548 <_i2c_m_sync_init>:
{
    2548:	b538      	push	{r3, r4, r5, lr}
    254a:	460d      	mov	r5, r1
	ASSERT(i2c_dev);
    254c:	4604      	mov	r4, r0
    254e:	f44f 62a8 	mov.w	r2, #1344	; 0x540
    2552:	4906      	ldr	r1, [pc, #24]	; (256c <_i2c_m_sync_init+0x24>)
    2554:	3000      	adds	r0, #0
    2556:	bf18      	it	ne
    2558:	2001      	movne	r0, #1
    255a:	4b05      	ldr	r3, [pc, #20]	; (2570 <_i2c_m_sync_init+0x28>)
    255c:	4798      	blx	r3
	i2c_dev->hw = hw;
    255e:	6125      	str	r5, [r4, #16]
	return _i2c_m_sync_init_impl(&i2c_dev->service, hw);
    2560:	4629      	mov	r1, r5
    2562:	4620      	mov	r0, r4
    2564:	4b03      	ldr	r3, [pc, #12]	; (2574 <_i2c_m_sync_init+0x2c>)
    2566:	4798      	blx	r3
}
    2568:	bd38      	pop	{r3, r4, r5, pc}
    256a:	bf00      	nop
    256c:	0000b23c 	.word	0x0000b23c
    2570:	00001861 	.word	0x00001861
    2574:	000022e5 	.word	0x000022e5

00002578 <_i2c_m_sync_transfer>:
{
    2578:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    257c:	4605      	mov	r5, r0
    257e:	460e      	mov	r6, r1
	void *   hw = i2c_dev->hw;
    2580:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
    2582:	f110 0800 	adds.w	r8, r0, #0
    2586:	bf18      	it	ne
    2588:	f04f 0801 	movne.w	r8, #1
    258c:	f8df 92c4 	ldr.w	r9, [pc, #708]	; 2854 <_i2c_m_sync_transfer+0x2dc>
    2590:	f44f 62bf 	mov.w	r2, #1528	; 0x5f8
    2594:	4649      	mov	r1, r9
    2596:	4640      	mov	r0, r8
    2598:	4fad      	ldr	r7, [pc, #692]	; (2850 <_i2c_m_sync_transfer+0x2d8>)
    259a:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
    259c:	6928      	ldr	r0, [r5, #16]
    259e:	f240 52f9 	movw	r2, #1529	; 0x5f9
    25a2:	4649      	mov	r1, r9
    25a4:	3000      	adds	r0, #0
    25a6:	bf18      	it	ne
    25a8:	2001      	movne	r0, #1
    25aa:	47b8      	blx	r7
	ASSERT(msg);
    25ac:	f240 52fa 	movw	r2, #1530	; 0x5fa
    25b0:	4649      	mov	r1, r9
    25b2:	1c30      	adds	r0, r6, #0
    25b4:	bf18      	it	ne
    25b6:	2001      	movne	r0, #1
    25b8:	47b8      	blx	r7
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    25ba:	886b      	ldrh	r3, [r5, #2]
    25bc:	f413 7f80 	tst.w	r3, #256	; 0x100
    25c0:	f040 8218 	bne.w	29f4 <_i2c_m_sync_transfer+0x47c>
	msg->flags |= I2C_M_BUSY;
    25c4:	8873      	ldrh	r3, [r6, #2]
    25c6:	b29b      	uxth	r3, r3
    25c8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    25cc:	8073      	strh	r3, [r6, #2]
	i2c_dev->service.msg = *msg;
    25ce:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
    25d2:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
    25d6:	6863      	ldr	r3, [r4, #4]
    25d8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    25dc:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    25de:	69e3      	ldr	r3, [r4, #28]
    25e0:	f013 0f04 	tst.w	r3, #4
    25e4:	d1fb      	bne.n	25de <_i2c_m_sync_transfer+0x66>
	void *             hw    = i2c_dev->hw;
    25e6:	692f      	ldr	r7, [r5, #16]
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    25e8:	f8d7 9000 	ldr.w	r9, [r7]
	ASSERT(i2c_dev);
    25ec:	f240 52cd 	movw	r2, #1485	; 0x5cd
    25f0:	4998      	ldr	r1, [pc, #608]	; (2854 <_i2c_m_sync_transfer+0x2dc>)
    25f2:	4640      	mov	r0, r8
    25f4:	4b96      	ldr	r3, [pc, #600]	; (2850 <_i2c_m_sync_transfer+0x2d8>)
    25f6:	4798      	blx	r3
	if (msg->len == 1 && sclsm) {
    25f8:	686b      	ldr	r3, [r5, #4]
    25fa:	2b01      	cmp	r3, #1
    25fc:	d05e      	beq.n	26bc <_i2c_m_sync_transfer+0x144>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    25fe:	687b      	ldr	r3, [r7, #4]
    2600:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
    2604:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2606:	69fb      	ldr	r3, [r7, #28]
    2608:	f013 0f04 	tst.w	r3, #4
    260c:	d1fb      	bne.n	2606 <_i2c_m_sync_transfer+0x8e>
	if (msg->addr & I2C_M_TEN) {
    260e:	882b      	ldrh	r3, [r5, #0]
    2610:	f413 6f80 	tst.w	r3, #1024	; 0x400
    2614:	d05e      	beq.n	26d4 <_i2c_m_sync_transfer+0x15c>
		if (msg->flags & I2C_M_RD) {
    2616:	886a      	ldrh	r2, [r5, #2]
    2618:	f012 0f01 	tst.w	r2, #1
    261c:	d004      	beq.n	2628 <_i2c_m_sync_transfer+0xb0>
			msg->flags |= I2C_M_TEN;
    261e:	886a      	ldrh	r2, [r5, #2]
    2620:	b292      	uxth	r2, r2
    2622:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    2626:	806a      	strh	r2, [r5, #2]
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    2628:	f240 72fe 	movw	r2, #2046	; 0x7fe
    262c:	ea02 0243 	and.w	r2, r2, r3, lsl #1
    2630:	69fb      	ldr	r3, [r7, #28]
    2632:	f013 0f04 	tst.w	r3, #4
    2636:	d1fb      	bne.n	2630 <_i2c_m_sync_transfer+0xb8>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    2638:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    263a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
		hri_sercomi2cm_write_ADDR_reg(hw,
    263e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    2642:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    2644:	627b      	str	r3, [r7, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2646:	69fb      	ldr	r3, [r7, #28]
    2648:	f013 0f04 	tst.w	r3, #4
    264c:	d1fb      	bne.n	2646 <_i2c_m_sync_transfer+0xce>
	void *   hw      = i2c_dev->hw;
    264e:	6929      	ldr	r1, [r5, #16]
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    2650:	7e0b      	ldrb	r3, [r1, #24]
    2652:	b2db      	uxtb	r3, r3
    2654:	f64f 72ff 	movw	r2, #65535	; 0xffff
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    2658:	f013 0f03 	tst.w	r3, #3
    265c:	d103      	bne.n	2666 <_i2c_m_sync_transfer+0xee>
    265e:	7e0b      	ldrb	r3, [r1, #24]
    2660:	b2db      	uxtb	r3, r3
		if (timeout-- == 0) {
    2662:	3a01      	subs	r2, #1
    2664:	d1f8      	bne.n	2658 <_i2c_m_sync_transfer+0xe0>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    2666:	6839      	ldr	r1, [r7, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2668:	69fa      	ldr	r2, [r7, #28]
    266a:	f012 0f04 	tst.w	r2, #4
    266e:	d1fb      	bne.n	2668 <_i2c_m_sync_transfer+0xf0>
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    2670:	8b7a      	ldrh	r2, [r7, #26]
    2672:	b292      	uxth	r2, r2
	if (flags & MB_FLAG) {
    2674:	f013 0f01 	tst.w	r3, #1
    2678:	f000 80a3 	beq.w	27c2 <_i2c_m_sync_transfer+0x24a>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    267c:	f012 0f02 	tst.w	r2, #2
    2680:	d03c      	beq.n	26fc <_i2c_m_sync_transfer+0x184>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    2682:	2301      	movs	r3, #1
    2684:	763b      	strb	r3, [r7, #24]
			msg->flags |= I2C_M_FAIL;
    2686:	886b      	ldrh	r3, [r5, #2]
    2688:	b29b      	uxth	r3, r3
    268a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    268e:	806b      	strh	r3, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
    2690:	886b      	ldrh	r3, [r5, #2]
    2692:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    2696:	041b      	lsls	r3, r3, #16
    2698:	0c1b      	lsrs	r3, r3, #16
    269a:	806b      	strh	r3, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    269c:	f002 0201 	and.w	r2, r2, #1
			return I2C_ERR_BAD_ADDRESS;
    26a0:	2a00      	cmp	r2, #0
    26a2:	bf14      	ite	ne
    26a4:	f06f 0004 	mvnne.w	r0, #4
    26a8:	f06f 0003 	mvneq.w	r0, #3
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    26ac:	886b      	ldrh	r3, [r5, #2]
    26ae:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    26b2:	041b      	lsls	r3, r3, #16
    26b4:	0c1b      	lsrs	r3, r3, #16
    26b6:	806b      	strh	r3, [r5, #2]
		return ret;
    26b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (msg->len == 1 && sclsm) {
    26bc:	f019 6f00 	tst.w	r9, #134217728	; 0x8000000
    26c0:	d09d      	beq.n	25fe <_i2c_m_sync_transfer+0x86>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    26c2:	687b      	ldr	r3, [r7, #4]
    26c4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    26c8:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    26ca:	69fb      	ldr	r3, [r7, #28]
    26cc:	f013 0f04 	tst.w	r3, #4
    26d0:	d1fb      	bne.n	26ca <_i2c_m_sync_transfer+0x152>
    26d2:	e79c      	b.n	260e <_i2c_m_sync_transfer+0x96>
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
    26d4:	8869      	ldrh	r1, [r5, #2]
    26d6:	005a      	lsls	r2, r3, #1
    26d8:	b2d2      	uxtb	r2, r2
    26da:	f001 0301 	and.w	r3, r1, #1
    26de:	431a      	orrs	r2, r3
    26e0:	69fb      	ldr	r3, [r7, #28]
    26e2:	f013 0f04 	tst.w	r3, #4
    26e6:	d1fb      	bne.n	26e0 <_i2c_m_sync_transfer+0x168>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    26e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    26ea:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
		hri_sercomi2cm_write_ADDR_reg(hw,
    26ee:	431a      	orrs	r2, r3
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    26f0:	627a      	str	r2, [r7, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    26f2:	69fb      	ldr	r3, [r7, #28]
    26f4:	f013 0f04 	tst.w	r3, #4
    26f8:	d1fb      	bne.n	26f2 <_i2c_m_sync_transfer+0x17a>
    26fa:	e7a8      	b.n	264e <_i2c_m_sync_transfer+0xd6>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    26fc:	f012 0f04 	tst.w	r2, #4
    2700:	d11d      	bne.n	273e <_i2c_m_sync_transfer+0x1c6>
			if (msg->flags & I2C_M_TEN) {
    2702:	886b      	ldrh	r3, [r5, #2]
    2704:	f413 6f80 	tst.w	r3, #1024	; 0x400
    2708:	d037      	beq.n	277a <_i2c_m_sync_transfer+0x202>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
    270a:	882b      	ldrh	r3, [r5, #0]
    270c:	09db      	lsrs	r3, r3, #7
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    270e:	f003 0206 	and.w	r2, r3, #6
    2712:	69fb      	ldr	r3, [r7, #28]
    2714:	f013 0f04 	tst.w	r3, #4
    2718:	d1fb      	bne.n	2712 <_i2c_m_sync_transfer+0x19a>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    271a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    271c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
				hri_sercomi2cm_write_ADDR_reg(hw,
    2720:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
    2724:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    2726:	627b      	str	r3, [r7, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2728:	69fb      	ldr	r3, [r7, #28]
    272a:	f013 0f04 	tst.w	r3, #4
    272e:	d1fb      	bne.n	2728 <_i2c_m_sync_transfer+0x1b0>
				msg->flags &= ~I2C_M_TEN;
    2730:	886b      	ldrh	r3, [r5, #2]
    2732:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    2736:	041b      	lsls	r3, r3, #16
    2738:	0c1b      	lsrs	r3, r3, #16
    273a:	806b      	strh	r3, [r5, #2]
    273c:	e069      	b.n	2812 <_i2c_m_sync_transfer+0x29a>
				if (msg->len > 0) {
    273e:	686b      	ldr	r3, [r5, #4]
    2740:	2b00      	cmp	r3, #0
    2742:	dd04      	ble.n	274e <_i2c_m_sync_transfer+0x1d6>
					msg->flags |= I2C_M_FAIL;
    2744:	886b      	ldrh	r3, [r5, #2]
    2746:	b29b      	uxth	r3, r3
    2748:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    274c:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
    274e:	886b      	ldrh	r3, [r5, #2]
    2750:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    2754:	d108      	bne.n	2768 <_i2c_m_sync_transfer+0x1f0>
				msg->flags &= ~I2C_M_BUSY;
    2756:	886b      	ldrh	r3, [r5, #2]
    2758:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    275c:	041b      	lsls	r3, r3, #16
    275e:	0c1b      	lsrs	r3, r3, #16
    2760:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
    2762:	f06f 0001 	mvn.w	r0, #1
    2766:	e7a1      	b.n	26ac <_i2c_m_sync_transfer+0x134>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    2768:	687b      	ldr	r3, [r7, #4]
    276a:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    276e:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2770:	69fb      	ldr	r3, [r7, #28]
    2772:	f013 0f04 	tst.w	r3, #4
    2776:	d1fb      	bne.n	2770 <_i2c_m_sync_transfer+0x1f8>
    2778:	e7ed      	b.n	2756 <_i2c_m_sync_transfer+0x1de>
			if (msg->len == 0) {
    277a:	686b      	ldr	r3, [r5, #4]
    277c:	b99b      	cbnz	r3, 27a6 <_i2c_m_sync_transfer+0x22e>
				if (msg->flags & I2C_M_STOP) {
    277e:	886b      	ldrh	r3, [r5, #2]
    2780:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    2784:	d106      	bne.n	2794 <_i2c_m_sync_transfer+0x21c>
				msg->flags &= ~I2C_M_BUSY;
    2786:	886b      	ldrh	r3, [r5, #2]
    2788:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    278c:	041b      	lsls	r3, r3, #16
    278e:	0c1b      	lsrs	r3, r3, #16
    2790:	806b      	strh	r3, [r5, #2]
    2792:	e03e      	b.n	2812 <_i2c_m_sync_transfer+0x29a>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    2794:	687b      	ldr	r3, [r7, #4]
    2796:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    279a:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    279c:	69fb      	ldr	r3, [r7, #28]
    279e:	f013 0f04 	tst.w	r3, #4
    27a2:	d1fb      	bne.n	279c <_i2c_m_sync_transfer+0x224>
    27a4:	e7ef      	b.n	2786 <_i2c_m_sync_transfer+0x20e>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    27a6:	68ab      	ldr	r3, [r5, #8]
    27a8:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
    27aa:	62bb      	str	r3, [r7, #40]	; 0x28
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    27ac:	69fb      	ldr	r3, [r7, #28]
    27ae:	f013 0f04 	tst.w	r3, #4
    27b2:	d1fb      	bne.n	27ac <_i2c_m_sync_transfer+0x234>
				msg->buffer++;
    27b4:	68ab      	ldr	r3, [r5, #8]
    27b6:	3301      	adds	r3, #1
    27b8:	60ab      	str	r3, [r5, #8]
				msg->len--;
    27ba:	686b      	ldr	r3, [r5, #4]
    27bc:	3b01      	subs	r3, #1
    27be:	606b      	str	r3, [r5, #4]
    27c0:	e027      	b.n	2812 <_i2c_m_sync_transfer+0x29a>
	} else if (flags & SB_FLAG) {
    27c2:	f013 0f02 	tst.w	r3, #2
    27c6:	d024      	beq.n	2812 <_i2c_m_sync_transfer+0x29a>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    27c8:	686b      	ldr	r3, [r5, #4]
    27ca:	2b00      	cmp	r3, #0
    27cc:	d03a      	beq.n	2844 <_i2c_m_sync_transfer+0x2cc>
    27ce:	f012 0f04 	tst.w	r2, #4
    27d2:	d137      	bne.n	2844 <_i2c_m_sync_transfer+0x2cc>
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
    27d4:	f3c1 61c0 	ubfx	r1, r1, #27, #1
			msg->len--;
    27d8:	3b01      	subs	r3, #1
    27da:	606b      	str	r3, [r5, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    27dc:	2b00      	cmp	r3, #0
    27de:	f040 810d 	bne.w	29fc <_i2c_m_sync_transfer+0x484>
    27e2:	2900      	cmp	r1, #0
    27e4:	f000 8110 	beq.w	2a08 <_i2c_m_sync_transfer+0x490>
				if (msg->flags & I2C_M_STOP) {
    27e8:	886b      	ldrh	r3, [r5, #2]
    27ea:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    27ee:	d118      	bne.n	2822 <_i2c_m_sync_transfer+0x2aa>
				msg->flags &= ~I2C_M_BUSY;
    27f0:	886b      	ldrh	r3, [r5, #2]
    27f2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    27f6:	041b      	lsls	r3, r3, #16
    27f8:	0c1b      	lsrs	r3, r3, #16
    27fa:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    27fc:	68aa      	ldr	r2, [r5, #8]
    27fe:	1c53      	adds	r3, r2, #1
    2800:	60ab      	str	r3, [r5, #8]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2802:	69fb      	ldr	r3, [r7, #28]
    2804:	f013 0f04 	tst.w	r3, #4
    2808:	d1fb      	bne.n	2802 <_i2c_m_sync_transfer+0x28a>
	return ((Sercom *)hw)->I2CM.DATA.reg;
    280a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    280c:	7013      	strb	r3, [r2, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    280e:	2302      	movs	r3, #2
    2810:	763b      	strb	r3, [r7, #24]
			return I2C_NACK;
    2812:	2200      	movs	r2, #0
	return I2C_OK;
    2814:	4610      	mov	r0, r2
    2816:	2702      	movs	r7, #2
			return I2C_NACK;
    2818:	f06f 0c01 	mvn.w	ip, #1
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    281c:	f04f 0e01 	mov.w	lr, #1
    2820:	e0b0      	b.n	2984 <_i2c_m_sync_transfer+0x40c>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    2822:	687b      	ldr	r3, [r7, #4]
    2824:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    2828:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    282a:	69fb      	ldr	r3, [r7, #28]
    282c:	f013 0f04 	tst.w	r3, #4
    2830:	d1fb      	bne.n	282a <_i2c_m_sync_transfer+0x2b2>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    2832:	687b      	ldr	r3, [r7, #4]
    2834:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    2838:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    283a:	69fb      	ldr	r3, [r7, #28]
    283c:	f013 0f04 	tst.w	r3, #4
    2840:	d1fb      	bne.n	283a <_i2c_m_sync_transfer+0x2c2>
    2842:	e7d5      	b.n	27f0 <_i2c_m_sync_transfer+0x278>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    2844:	2302      	movs	r3, #2
    2846:	763b      	strb	r3, [r7, #24]
    2848:	f06f 0001 	mvn.w	r0, #1
    284c:	e72e      	b.n	26ac <_i2c_m_sync_transfer+0x134>
    284e:	bf00      	nop
    2850:	00001861 	.word	0x00001861
    2854:	0000b23c 	.word	0x0000b23c
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    2858:	6863      	ldr	r3, [r4, #4]
    285a:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    285e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2860:	69e3      	ldr	r3, [r4, #28]
    2862:	f013 0f04 	tst.w	r3, #4
    2866:	d1fb      	bne.n	2860 <_i2c_m_sync_transfer+0x2e8>
    2868:	e0a1      	b.n	29ae <_i2c_m_sync_transfer+0x436>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    286a:	f012 0f04 	tst.w	r2, #4
    286e:	d11e      	bne.n	28ae <_i2c_m_sync_transfer+0x336>
			if (msg->flags & I2C_M_TEN) {
    2870:	886b      	ldrh	r3, [r5, #2]
    2872:	f413 6f80 	tst.w	r3, #1024	; 0x400
    2876:	d037      	beq.n	28e8 <_i2c_m_sync_transfer+0x370>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
    2878:	882b      	ldrh	r3, [r5, #0]
    287a:	09db      	lsrs	r3, r3, #7
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    287c:	f003 0206 	and.w	r2, r3, #6
    2880:	69e3      	ldr	r3, [r4, #28]
    2882:	f013 0f04 	tst.w	r3, #4
    2886:	d1fb      	bne.n	2880 <_i2c_m_sync_transfer+0x308>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    2888:	6a63      	ldr	r3, [r4, #36]	; 0x24
    288a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
				hri_sercomi2cm_write_ADDR_reg(hw,
    288e:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
    2892:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    2894:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2896:	69e3      	ldr	r3, [r4, #28]
    2898:	f013 0f04 	tst.w	r3, #4
    289c:	d1fb      	bne.n	2896 <_i2c_m_sync_transfer+0x31e>
				msg->flags &= ~I2C_M_TEN;
    289e:	886b      	ldrh	r3, [r5, #2]
    28a0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    28a4:	041b      	lsls	r3, r3, #16
    28a6:	0c1b      	lsrs	r3, r3, #16
    28a8:	806b      	strh	r3, [r5, #2]
				return I2C_OK;
    28aa:	4602      	mov	r2, r0
    28ac:	e06a      	b.n	2984 <_i2c_m_sync_transfer+0x40c>
				if (msg->len > 0) {
    28ae:	686b      	ldr	r3, [r5, #4]
    28b0:	2b00      	cmp	r3, #0
    28b2:	dd04      	ble.n	28be <_i2c_m_sync_transfer+0x346>
					msg->flags |= I2C_M_FAIL;
    28b4:	886b      	ldrh	r3, [r5, #2]
    28b6:	b29b      	uxth	r3, r3
    28b8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    28bc:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
    28be:	886b      	ldrh	r3, [r5, #2]
    28c0:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    28c4:	d107      	bne.n	28d6 <_i2c_m_sync_transfer+0x35e>
				msg->flags &= ~I2C_M_BUSY;
    28c6:	886b      	ldrh	r3, [r5, #2]
    28c8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    28cc:	041b      	lsls	r3, r3, #16
    28ce:	0c1b      	lsrs	r3, r3, #16
    28d0:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
    28d2:	4662      	mov	r2, ip
    28d4:	e056      	b.n	2984 <_i2c_m_sync_transfer+0x40c>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    28d6:	6863      	ldr	r3, [r4, #4]
    28d8:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    28dc:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    28de:	69e3      	ldr	r3, [r4, #28]
    28e0:	f013 0f04 	tst.w	r3, #4
    28e4:	d1fb      	bne.n	28de <_i2c_m_sync_transfer+0x366>
    28e6:	e7ee      	b.n	28c6 <_i2c_m_sync_transfer+0x34e>
			if (msg->len == 0) {
    28e8:	686b      	ldr	r3, [r5, #4]
    28ea:	b9a3      	cbnz	r3, 2916 <_i2c_m_sync_transfer+0x39e>
				if (msg->flags & I2C_M_STOP) {
    28ec:	886b      	ldrh	r3, [r5, #2]
    28ee:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    28f2:	d107      	bne.n	2904 <_i2c_m_sync_transfer+0x38c>
				msg->flags &= ~I2C_M_BUSY;
    28f4:	886b      	ldrh	r3, [r5, #2]
    28f6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    28fa:	041b      	lsls	r3, r3, #16
    28fc:	0c1b      	lsrs	r3, r3, #16
    28fe:	806b      	strh	r3, [r5, #2]
			return I2C_OK;
    2900:	4602      	mov	r2, r0
    2902:	e03f      	b.n	2984 <_i2c_m_sync_transfer+0x40c>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    2904:	6863      	ldr	r3, [r4, #4]
    2906:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    290a:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    290c:	69e3      	ldr	r3, [r4, #28]
    290e:	f013 0f04 	tst.w	r3, #4
    2912:	d1fb      	bne.n	290c <_i2c_m_sync_transfer+0x394>
    2914:	e7ee      	b.n	28f4 <_i2c_m_sync_transfer+0x37c>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    2916:	68ab      	ldr	r3, [r5, #8]
    2918:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
    291a:	62a3      	str	r3, [r4, #40]	; 0x28
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    291c:	69e3      	ldr	r3, [r4, #28]
    291e:	f013 0f04 	tst.w	r3, #4
    2922:	d1fb      	bne.n	291c <_i2c_m_sync_transfer+0x3a4>
				msg->buffer++;
    2924:	68ab      	ldr	r3, [r5, #8]
    2926:	3301      	adds	r3, #1
    2928:	60ab      	str	r3, [r5, #8]
				msg->len--;
    292a:	686b      	ldr	r3, [r5, #4]
    292c:	3b01      	subs	r3, #1
    292e:	606b      	str	r3, [r5, #4]
			return I2C_OK;
    2930:	4602      	mov	r2, r0
    2932:	e027      	b.n	2984 <_i2c_m_sync_transfer+0x40c>
	} else if (flags & SB_FLAG) {
    2934:	f013 0f02 	tst.w	r3, #2
    2938:	d057      	beq.n	29ea <_i2c_m_sync_transfer+0x472>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    293a:	686b      	ldr	r3, [r5, #4]
    293c:	2b00      	cmp	r3, #0
    293e:	d051      	beq.n	29e4 <_i2c_m_sync_transfer+0x46c>
    2940:	f012 0f04 	tst.w	r2, #4
    2944:	d14e      	bne.n	29e4 <_i2c_m_sync_transfer+0x46c>
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
    2946:	f3c1 61c0 	ubfx	r1, r1, #27, #1
			msg->len--;
    294a:	3b01      	subs	r3, #1
    294c:	606b      	str	r3, [r5, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    294e:	2b00      	cmp	r3, #0
    2950:	f040 808c 	bne.w	2a6c <_i2c_m_sync_transfer+0x4f4>
    2954:	2900      	cmp	r1, #0
    2956:	f000 808f 	beq.w	2a78 <_i2c_m_sync_transfer+0x500>
				if (msg->flags & I2C_M_STOP) {
    295a:	886b      	ldrh	r3, [r5, #2]
    295c:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    2960:	d12f      	bne.n	29c2 <_i2c_m_sync_transfer+0x44a>
				msg->flags &= ~I2C_M_BUSY;
    2962:	886b      	ldrh	r3, [r5, #2]
    2964:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    2968:	041b      	lsls	r3, r3, #16
    296a:	0c1b      	lsrs	r3, r3, #16
    296c:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    296e:	68aa      	ldr	r2, [r5, #8]
    2970:	1c53      	adds	r3, r2, #1
    2972:	60ab      	str	r3, [r5, #8]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2974:	69e3      	ldr	r3, [r4, #28]
    2976:	f013 0f04 	tst.w	r3, #4
    297a:	d1fb      	bne.n	2974 <_i2c_m_sync_transfer+0x3fc>
	return ((Sercom *)hw)->I2CM.DATA.reg;
    297c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    297e:	7013      	strb	r3, [r2, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    2980:	7627      	strb	r7, [r4, #24]
	return I2C_OK;
    2982:	4602      	mov	r2, r0
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    2984:	886b      	ldrh	r3, [r5, #2]
    2986:	f413 7f80 	tst.w	r3, #256	; 0x100
    298a:	d030      	beq.n	29ee <_i2c_m_sync_transfer+0x476>
	void *   hw      = i2c_dev->hw;
    298c:	6929      	ldr	r1, [r5, #16]
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    298e:	7e0b      	ldrb	r3, [r1, #24]
    2990:	b2db      	uxtb	r3, r3
    2992:	f64f 72ff 	movw	r2, #65535	; 0xffff
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    2996:	f013 0f03 	tst.w	r3, #3
    299a:	d142      	bne.n	2a22 <_i2c_m_sync_transfer+0x4aa>
    299c:	7e0b      	ldrb	r3, [r1, #24]
    299e:	b2db      	uxtb	r3, r3
		if (timeout-- == 0) {
    29a0:	3a01      	subs	r2, #1
    29a2:	d1f8      	bne.n	2996 <_i2c_m_sync_transfer+0x41e>
			if (msg->flags & I2C_M_STOP) {
    29a4:	8873      	ldrh	r3, [r6, #2]
    29a6:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    29aa:	f47f af55 	bne.w	2858 <_i2c_m_sync_transfer+0x2e0>
			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    29ae:	886b      	ldrh	r3, [r5, #2]
    29b0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    29b4:	041b      	lsls	r3, r3, #16
    29b6:	0c1b      	lsrs	r3, r3, #16
    29b8:	806b      	strh	r3, [r5, #2]
			return I2C_ERR_BUS;
    29ba:	f06f 0004 	mvn.w	r0, #4
			return ret;
    29be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    29c2:	6863      	ldr	r3, [r4, #4]
    29c4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    29c8:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    29ca:	69e3      	ldr	r3, [r4, #28]
    29cc:	f013 0f04 	tst.w	r3, #4
    29d0:	d1fb      	bne.n	29ca <_i2c_m_sync_transfer+0x452>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    29d2:	6863      	ldr	r3, [r4, #4]
    29d4:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    29d8:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    29da:	69e3      	ldr	r3, [r4, #28]
    29dc:	f013 0f04 	tst.w	r3, #4
    29e0:	d1fb      	bne.n	29da <_i2c_m_sync_transfer+0x462>
    29e2:	e7be      	b.n	2962 <_i2c_m_sync_transfer+0x3ea>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    29e4:	7627      	strb	r7, [r4, #24]
			return I2C_NACK;
    29e6:	4662      	mov	r2, ip
    29e8:	e7cc      	b.n	2984 <_i2c_m_sync_transfer+0x40c>
	return I2C_OK;
    29ea:	4602      	mov	r2, r0
    29ec:	e7ca      	b.n	2984 <_i2c_m_sync_transfer+0x40c>
    29ee:	4610      	mov	r0, r2
    29f0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return I2C_ERR_BUSY;
    29f4:	f06f 0005 	mvn.w	r0, #5
    29f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    29fc:	2b01      	cmp	r3, #1
    29fe:	f47f aefd 	bne.w	27fc <_i2c_m_sync_transfer+0x284>
    2a02:	2900      	cmp	r1, #0
    2a04:	f43f aefa 	beq.w	27fc <_i2c_m_sync_transfer+0x284>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    2a08:	687b      	ldr	r3, [r7, #4]
    2a0a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    2a0e:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2a10:	69fb      	ldr	r3, [r7, #28]
    2a12:	f013 0f04 	tst.w	r3, #4
    2a16:	d1fb      	bne.n	2a10 <_i2c_m_sync_transfer+0x498>
			if (msg->len == 0) {
    2a18:	686b      	ldr	r3, [r5, #4]
    2a1a:	2b00      	cmp	r3, #0
    2a1c:	f43f aee4 	beq.w	27e8 <_i2c_m_sync_transfer+0x270>
    2a20:	e6ec      	b.n	27fc <_i2c_m_sync_transfer+0x284>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    2a22:	6821      	ldr	r1, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2a24:	69e2      	ldr	r2, [r4, #28]
    2a26:	f012 0f04 	tst.w	r2, #4
    2a2a:	d1fb      	bne.n	2a24 <_i2c_m_sync_transfer+0x4ac>
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    2a2c:	8b62      	ldrh	r2, [r4, #26]
    2a2e:	b292      	uxth	r2, r2
	if (flags & MB_FLAG) {
    2a30:	f013 0f01 	tst.w	r3, #1
    2a34:	f43f af7e 	beq.w	2934 <_i2c_m_sync_transfer+0x3bc>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    2a38:	f012 0f02 	tst.w	r2, #2
    2a3c:	f43f af15 	beq.w	286a <_i2c_m_sync_transfer+0x2f2>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    2a40:	f884 e018 	strb.w	lr, [r4, #24]
			msg->flags |= I2C_M_FAIL;
    2a44:	886b      	ldrh	r3, [r5, #2]
    2a46:	b29b      	uxth	r3, r3
    2a48:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    2a4c:	806b      	strh	r3, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
    2a4e:	886b      	ldrh	r3, [r5, #2]
    2a50:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    2a54:	041b      	lsls	r3, r3, #16
    2a56:	0c1b      	lsrs	r3, r3, #16
    2a58:	806b      	strh	r3, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    2a5a:	f002 0201 	and.w	r2, r2, #1
			return I2C_ERR_BAD_ADDRESS;
    2a5e:	2a00      	cmp	r2, #0
    2a60:	bf14      	ite	ne
    2a62:	f06f 0204 	mvnne.w	r2, #4
    2a66:	f06f 0203 	mvneq.w	r2, #3
    2a6a:	e78b      	b.n	2984 <_i2c_m_sync_transfer+0x40c>
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    2a6c:	2b01      	cmp	r3, #1
    2a6e:	f47f af7e 	bne.w	296e <_i2c_m_sync_transfer+0x3f6>
    2a72:	2900      	cmp	r1, #0
    2a74:	f43f af7b 	beq.w	296e <_i2c_m_sync_transfer+0x3f6>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    2a78:	6863      	ldr	r3, [r4, #4]
    2a7a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    2a7e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2a80:	69e3      	ldr	r3, [r4, #28]
    2a82:	f013 0f04 	tst.w	r3, #4
    2a86:	d1fb      	bne.n	2a80 <_i2c_m_sync_transfer+0x508>
			if (msg->len == 0) {
    2a88:	686b      	ldr	r3, [r5, #4]
    2a8a:	2b00      	cmp	r3, #0
    2a8c:	f43f af65 	beq.w	295a <_i2c_m_sync_transfer+0x3e2>
    2a90:	e76d      	b.n	296e <_i2c_m_sync_transfer+0x3f6>
    2a92:	bf00      	nop

00002a94 <SERCOM0_0_Handler>:

/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_0_Handler(void)
{
    2a94:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom0_dev);
    2a96:	4b02      	ldr	r3, [pc, #8]	; (2aa0 <SERCOM0_0_Handler+0xc>)
    2a98:	6818      	ldr	r0, [r3, #0]
    2a9a:	4b02      	ldr	r3, [pc, #8]	; (2aa4 <SERCOM0_0_Handler+0x10>)
    2a9c:	4798      	blx	r3
    2a9e:	bd08      	pop	{r3, pc}
    2aa0:	20001624 	.word	0x20001624
    2aa4:	00002119 	.word	0x00002119

00002aa8 <SERCOM0_1_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_1_Handler(void)
{
    2aa8:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom0_dev);
    2aaa:	4b02      	ldr	r3, [pc, #8]	; (2ab4 <SERCOM0_1_Handler+0xc>)
    2aac:	6818      	ldr	r0, [r3, #0]
    2aae:	4b02      	ldr	r3, [pc, #8]	; (2ab8 <SERCOM0_1_Handler+0x10>)
    2ab0:	4798      	blx	r3
    2ab2:	bd08      	pop	{r3, pc}
    2ab4:	20001624 	.word	0x20001624
    2ab8:	00002119 	.word	0x00002119

00002abc <SERCOM0_2_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_2_Handler(void)
{
    2abc:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom0_dev);
    2abe:	4b02      	ldr	r3, [pc, #8]	; (2ac8 <SERCOM0_2_Handler+0xc>)
    2ac0:	6818      	ldr	r0, [r3, #0]
    2ac2:	4b02      	ldr	r3, [pc, #8]	; (2acc <SERCOM0_2_Handler+0x10>)
    2ac4:	4798      	blx	r3
    2ac6:	bd08      	pop	{r3, pc}
    2ac8:	20001624 	.word	0x20001624
    2acc:	00002119 	.word	0x00002119

00002ad0 <SERCOM0_3_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_3_Handler(void)
{
    2ad0:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom0_dev);
    2ad2:	4b02      	ldr	r3, [pc, #8]	; (2adc <SERCOM0_3_Handler+0xc>)
    2ad4:	6818      	ldr	r0, [r3, #0]
    2ad6:	4b02      	ldr	r3, [pc, #8]	; (2ae0 <SERCOM0_3_Handler+0x10>)
    2ad8:	4798      	blx	r3
    2ada:	bd08      	pop	{r3, pc}
    2adc:	20001624 	.word	0x20001624
    2ae0:	00002119 	.word	0x00002119

00002ae4 <get_tc_index>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The index of TC configuration
 */
static int8_t get_tc_index(const void *const hw)
{
    2ae4:	b570      	push	{r4, r5, r6, lr}
    2ae6:	b088      	sub	sp, #32
    2ae8:	4606      	mov	r6, r0
 * \param[in] hw The pointer to hardware instance
 */
static inline uint8_t _get_hardware_offset(const void *const hw)
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
    2aea:	466c      	mov	r4, sp
    2aec:	4d12      	ldr	r5, [pc, #72]	; (2b38 <get_tc_index+0x54>)
    2aee:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2af0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    2af2:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    2af6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
    2afa:	9b00      	ldr	r3, [sp, #0]
    2afc:	42b3      	cmp	r3, r6
    2afe:	d00b      	beq.n	2b18 <get_tc_index+0x34>
    2b00:	4630      	mov	r0, r6
    2b02:	aa01      	add	r2, sp, #4
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    2b04:	2301      	movs	r3, #1
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
    2b06:	f852 1b04 	ldr.w	r1, [r2], #4
    2b0a:	4281      	cmp	r1, r0
    2b0c:	d005      	beq.n	2b1a <get_tc_index+0x36>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    2b0e:	3301      	adds	r3, #1
    2b10:	2b08      	cmp	r3, #8
    2b12:	d1f8      	bne.n	2b06 <get_tc_index+0x22>
			return i;
    2b14:	2000      	movs	r0, #0
    2b16:	e00b      	b.n	2b30 <get_tc_index+0x4c>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    2b18:	2300      	movs	r3, #0
		if (_tcs[i].number == index) {
    2b1a:	f013 0fff 	tst.w	r3, #255	; 0xff
    2b1e:	d009      	beq.n	2b34 <get_tc_index+0x50>
	ASSERT(false);
    2b20:	f44f 729e 	mov.w	r2, #316	; 0x13c
    2b24:	4905      	ldr	r1, [pc, #20]	; (2b3c <get_tc_index+0x58>)
    2b26:	2000      	movs	r0, #0
    2b28:	4b05      	ldr	r3, [pc, #20]	; (2b40 <get_tc_index+0x5c>)
    2b2a:	4798      	blx	r3
	return -1;
    2b2c:	f04f 30ff 	mov.w	r0, #4294967295
}
    2b30:	b008      	add	sp, #32
    2b32:	bd70      	pop	{r4, r5, r6, pc}
			return i;
    2b34:	2000      	movs	r0, #0
    2b36:	e7fb      	b.n	2b30 <get_tc_index+0x4c>
    2b38:	0000b258 	.word	0x0000b258
    2b3c:	0000b28c 	.word	0x0000b28c
    2b40:	00001861 	.word	0x00001861

00002b44 <_timer_init>:
{
    2b44:	b570      	push	{r4, r5, r6, lr}
    2b46:	4606      	mov	r6, r0
    2b48:	460c      	mov	r4, r1
	int8_t i = get_tc_index(hw);
    2b4a:	4608      	mov	r0, r1
    2b4c:	4b60      	ldr	r3, [pc, #384]	; (2cd0 <_timer_init+0x18c>)
    2b4e:	4798      	blx	r3
    2b50:	4605      	mov	r5, r0
	device->hw = hw;
    2b52:	60f4      	str	r4, [r6, #12]
	ASSERT(ARRAY_SIZE(_tcs));
    2b54:	228d      	movs	r2, #141	; 0x8d
    2b56:	495f      	ldr	r1, [pc, #380]	; (2cd4 <_timer_init+0x190>)
    2b58:	2001      	movs	r0, #1
    2b5a:	4b5f      	ldr	r3, [pc, #380]	; (2cd8 <_timer_init+0x194>)
    2b5c:	4798      	blx	r3
	};
}

static inline bool hri_tc_is_syncing(const void *const hw, hri_tc_syncbusy_reg_t reg)
{
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
    2b5e:	6923      	ldr	r3, [r4, #16]
	if (!hri_tc_is_syncing(hw, TC_SYNCBUSY_SWRST)) {
    2b60:	f013 0f01 	tst.w	r3, #1
    2b64:	d119      	bne.n	2b9a <_timer_init+0x56>
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2b66:	6923      	ldr	r3, [r4, #16]
    2b68:	f013 0f03 	tst.w	r3, #3
    2b6c:	d1fb      	bne.n	2b66 <_timer_init+0x22>

static inline hri_tc_ctrla_reg_t hri_tc_get_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    2b6e:	6823      	ldr	r3, [r4, #0]
		if (hri_tc_get_CTRLA_reg(hw, TC_CTRLA_ENABLE)) {
    2b70:	f013 0f02 	tst.w	r3, #2
    2b74:	d00b      	beq.n	2b8e <_timer_init+0x4a>
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
    2b76:	6823      	ldr	r3, [r4, #0]
    2b78:	f023 0302 	bic.w	r3, r3, #2
    2b7c:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2b7e:	6923      	ldr	r3, [r4, #16]
    2b80:	f013 0f03 	tst.w	r3, #3
    2b84:	d1fb      	bne.n	2b7e <_timer_init+0x3a>
    2b86:	6923      	ldr	r3, [r4, #16]
    2b88:	f013 0f02 	tst.w	r3, #2
    2b8c:	d1fb      	bne.n	2b86 <_timer_init+0x42>
}

static inline void hri_tc_write_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    2b8e:	2301      	movs	r3, #1
    2b90:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2b92:	6923      	ldr	r3, [r4, #16]
    2b94:	f013 0f03 	tst.w	r3, #3
    2b98:	d1fb      	bne.n	2b92 <_timer_init+0x4e>
    2b9a:	6923      	ldr	r3, [r4, #16]
    2b9c:	f013 0f01 	tst.w	r3, #1
    2ba0:	d1fb      	bne.n	2b9a <_timer_init+0x56>
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
    2ba2:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2ba6:	4a4d      	ldr	r2, [pc, #308]	; (2cdc <_timer_init+0x198>)
    2ba8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2bac:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    2bae:	6022      	str	r2, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2bb0:	6923      	ldr	r3, [r4, #16]
    2bb2:	f013 0f03 	tst.w	r3, #3
    2bb6:	d1fb      	bne.n	2bb0 <_timer_init+0x6c>
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
    2bb8:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2bbc:	4947      	ldr	r1, [pc, #284]	; (2cdc <_timer_init+0x198>)
    2bbe:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    2bc2:	f893 102a 	ldrb.w	r1, [r3, #42]	; 0x2a
}

static inline void hri_tc_write_DBGCTRL_reg(const void *const hw, hri_tc_dbgctrl_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.DBGCTRL.reg = data;
    2bc6:	73e1      	strb	r1, [r4, #15]
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
    2bc8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
    2bca:	80e3      	strh	r3, [r4, #6]
	((Tc *)hw)->COUNT16.WAVE.reg = data;
    2bcc:	2301      	movs	r3, #1
    2bce:	7323      	strb	r3, [r4, #12]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
    2bd0:	f002 020c 	and.w	r2, r2, #12
    2bd4:	2a08      	cmp	r2, #8
    2bd6:	d048      	beq.n	2c6a <_timer_init+0x126>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
    2bd8:	2a00      	cmp	r2, #0
    2bda:	d158      	bne.n	2c8e <_timer_init+0x14a>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)_tcs[i].cc0);
    2bdc:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2be0:	4a3e      	ldr	r2, [pc, #248]	; (2cdc <_timer_init+0x198>)
    2be2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2be6:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
}

static inline void hri_tccount16_write_CC_reg(const void *const hw, uint8_t index, hri_tccount16_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    2be8:	83a3      	strh	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2bea:	6923      	ldr	r3, [r4, #16]
    2bec:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2bf0:	d1fb      	bne.n	2bea <_timer_init+0xa6>
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    2bf2:	2300      	movs	r3, #0
    2bf4:	83e3      	strh	r3, [r4, #30]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2bf6:	6923      	ldr	r3, [r4, #16]
    2bf8:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2bfc:	d1fb      	bne.n	2bf6 <_timer_init+0xb2>
	((Tc *)hw)->COUNT16.INTENSET.reg = TC_INTENSET_OVF;
    2bfe:	2301      	movs	r3, #1
    2c00:	7263      	strb	r3, [r4, #9]
	if (hw == TC0) {
    2c02:	4b37      	ldr	r3, [pc, #220]	; (2ce0 <_timer_init+0x19c>)
    2c04:	429c      	cmp	r4, r3
		_tc0_dev = (struct _timer_device *)dev;
    2c06:	bf04      	itt	eq
    2c08:	4b36      	ldreq	r3, [pc, #216]	; (2ce4 <_timer_init+0x1a0>)
    2c0a:	601e      	streq	r6, [r3, #0]
	NVIC_DisableIRQ(_tcs[i].irq);
    2c0c:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2c10:	4a32      	ldr	r2, [pc, #200]	; (2cdc <_timer_init+0x198>)
    2c12:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2c16:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
    2c1a:	2b00      	cmp	r3, #0
    2c1c:	db23      	blt.n	2c66 <_timer_init+0x122>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2c1e:	095a      	lsrs	r2, r3, #5
    2c20:	f003 031f 	and.w	r3, r3, #31
    2c24:	2101      	movs	r1, #1
    2c26:	fa01 f303 	lsl.w	r3, r1, r3
    2c2a:	3220      	adds	r2, #32
    2c2c:	492e      	ldr	r1, [pc, #184]	; (2ce8 <_timer_init+0x1a4>)
    2c2e:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    2c32:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2c36:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(_tcs[i].irq);
    2c3a:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    2c3e:	4b27      	ldr	r3, [pc, #156]	; (2cdc <_timer_init+0x198>)
    2c40:	eb03 0585 	add.w	r5, r3, r5, lsl #2
    2c44:	f9b5 3022 	ldrsh.w	r3, [r5, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
    2c48:	2b00      	cmp	r3, #0
    2c4a:	db0c      	blt.n	2c66 <_timer_init+0x122>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2c4c:	0959      	lsrs	r1, r3, #5
    2c4e:	f003 031f 	and.w	r3, r3, #31
    2c52:	2201      	movs	r2, #1
    2c54:	fa02 f303 	lsl.w	r3, r2, r3
    2c58:	4a23      	ldr	r2, [pc, #140]	; (2ce8 <_timer_init+0x1a4>)
    2c5a:	f101 0060 	add.w	r0, r1, #96	; 0x60
    2c5e:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2c62:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
    2c66:	2000      	movs	r0, #0
    2c68:	bd70      	pop	{r4, r5, r6, pc}
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
    2c6a:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2c6e:	4a1b      	ldr	r2, [pc, #108]	; (2cdc <_timer_init+0x198>)
    2c70:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2c74:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}

static inline void hri_tccount32_write_CC_reg(const void *const hw, uint8_t index, hri_tccount32_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    2c76:	61e3      	str	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2c78:	6923      	ldr	r3, [r4, #16]
    2c7a:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2c7e:	d1fb      	bne.n	2c78 <_timer_init+0x134>
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    2c80:	2300      	movs	r3, #0
    2c82:	6223      	str	r3, [r4, #32]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2c84:	6923      	ldr	r3, [r4, #16]
    2c86:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2c8a:	d1fb      	bne.n	2c84 <_timer_init+0x140>
    2c8c:	e7b7      	b.n	2bfe <_timer_init+0xba>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT8) {
    2c8e:	2a04      	cmp	r2, #4
    2c90:	d1b5      	bne.n	2bfe <_timer_init+0xba>
		hri_tccount8_write_CC_reg(hw, 0, (uint8_t)_tcs[i].cc0);
    2c92:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2c96:	4a11      	ldr	r2, [pc, #68]	; (2cdc <_timer_init+0x198>)
    2c98:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2c9c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
	((Tc *)hw)->COUNT8.CC[index].reg = data;
    2ca0:	7723      	strb	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2ca2:	6923      	ldr	r3, [r4, #16]
    2ca4:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2ca8:	d1fb      	bne.n	2ca2 <_timer_init+0x15e>
	((Tc *)hw)->COUNT8.CC[index].reg = data;
    2caa:	2300      	movs	r3, #0
    2cac:	7763      	strb	r3, [r4, #29]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2cae:	6923      	ldr	r3, [r4, #16]
    2cb0:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2cb4:	d1fb      	bne.n	2cae <_timer_init+0x16a>
		hri_tccount8_write_PER_reg(hw, _tcs[i].per);
    2cb6:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2cba:	4a08      	ldr	r2, [pc, #32]	; (2cdc <_timer_init+0x198>)
    2cbc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2cc0:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
	((Tc *)hw)->COUNT8.PER.reg = data;
    2cc4:	76e3      	strb	r3, [r4, #27]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2cc6:	6923      	ldr	r3, [r4, #16]
    2cc8:	f013 0f20 	tst.w	r3, #32
    2ccc:	d1fb      	bne.n	2cc6 <_timer_init+0x182>
    2cce:	e796      	b.n	2bfe <_timer_init+0xba>
    2cd0:	00002ae5 	.word	0x00002ae5
    2cd4:	0000b28c 	.word	0x0000b28c
    2cd8:	00001861 	.word	0x00001861
    2cdc:	0000b258 	.word	0x0000b258
    2ce0:	40003800 	.word	0x40003800
    2ce4:	20001628 	.word	0x20001628
    2ce8:	e000e100 	.word	0xe000e100

00002cec <_timer_start>:
	hri_tc_set_CTRLA_ENABLE_bit(device->hw);
    2cec:	68c2      	ldr	r2, [r0, #12]
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
    2cee:	6813      	ldr	r3, [r2, #0]
    2cf0:	f043 0302 	orr.w	r3, r3, #2
    2cf4:	6013      	str	r3, [r2, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2cf6:	6913      	ldr	r3, [r2, #16]
    2cf8:	f013 0f03 	tst.w	r3, #3
    2cfc:	d1fb      	bne.n	2cf6 <_timer_start+0xa>
}
    2cfe:	4770      	bx	lr

00002d00 <_timer_is_started>:
	return hri_tc_get_CTRLA_ENABLE_bit(device->hw);
    2d00:	68c2      	ldr	r2, [r0, #12]
    2d02:	6913      	ldr	r3, [r2, #16]
    2d04:	f013 0f03 	tst.w	r3, #3
    2d08:	d1fb      	bne.n	2d02 <_timer_is_started+0x2>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    2d0a:	6810      	ldr	r0, [r2, #0]
}
    2d0c:	f3c0 0040 	ubfx	r0, r0, #1, #1
    2d10:	4770      	bx	lr

00002d12 <_tc_get_timer>:
}
    2d12:	2000      	movs	r0, #0
    2d14:	4770      	bx	lr
	...

00002d18 <_timer_set_irq>:
{
    2d18:	b510      	push	{r4, lr}
	int8_t      i  = get_tc_index(hw);
    2d1a:	68c0      	ldr	r0, [r0, #12]
    2d1c:	4b09      	ldr	r3, [pc, #36]	; (2d44 <_timer_set_irq+0x2c>)
    2d1e:	4798      	blx	r3
    2d20:	4604      	mov	r4, r0
	ASSERT(ARRAY_SIZE(_tcs));
    2d22:	f240 120f 	movw	r2, #271	; 0x10f
    2d26:	4908      	ldr	r1, [pc, #32]	; (2d48 <_timer_set_irq+0x30>)
    2d28:	2001      	movs	r0, #1
    2d2a:	4b08      	ldr	r3, [pc, #32]	; (2d4c <_timer_set_irq+0x34>)
    2d2c:	4798      	blx	r3
	_irq_set(_tcs[i].irq);
    2d2e:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    2d32:	4b07      	ldr	r3, [pc, #28]	; (2d50 <_timer_set_irq+0x38>)
    2d34:	eb03 0484 	add.w	r4, r3, r4, lsl #2
    2d38:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
    2d3c:	4b05      	ldr	r3, [pc, #20]	; (2d54 <_timer_set_irq+0x3c>)
    2d3e:	4798      	blx	r3
    2d40:	bd10      	pop	{r4, pc}
    2d42:	bf00      	nop
    2d44:	00002ae5 	.word	0x00002ae5
    2d48:	0000b28c 	.word	0x0000b28c
    2d4c:	00001861 	.word	0x00001861
    2d50:	0000b258 	.word	0x0000b258
    2d54:	000019fd 	.word	0x000019fd

00002d58 <TC0_Handler>:
{
    2d58:	b508      	push	{r3, lr}
	tc_interrupt_handler(_tc0_dev);
    2d5a:	4b06      	ldr	r3, [pc, #24]	; (2d74 <TC0_Handler+0x1c>)
    2d5c:	6818      	ldr	r0, [r3, #0]
	void *const hw = device->hw;
    2d5e:	68c3      	ldr	r3, [r0, #12]
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
    2d60:	7a9a      	ldrb	r2, [r3, #10]
	if (hri_tc_get_interrupt_OVF_bit(hw)) {
    2d62:	f012 0f01 	tst.w	r2, #1
    2d66:	d100      	bne.n	2d6a <TC0_Handler+0x12>
    2d68:	bd08      	pop	{r3, pc}
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
    2d6a:	2201      	movs	r2, #1
    2d6c:	729a      	strb	r2, [r3, #10]
		device->timer_cb.period_expired(device);
    2d6e:	6803      	ldr	r3, [r0, #0]
    2d70:	4798      	blx	r3
}
    2d72:	e7f9      	b.n	2d68 <TC0_Handler+0x10>
    2d74:	20001628 	.word	0x20001628

00002d78 <mac_low_level_init>:

/**
 * \brief Initialize the MAC hardware
 */
void mac_low_level_init(struct netif *netif)
{
    2d78:	b510      	push	{r4, lr}
    2d7a:	b084      	sub	sp, #16
	struct mac_async_descriptor *mac;
	struct mac_async_filter      filter;

	mac = (struct mac_async_descriptor *)(netif->state);
    2d7c:	6a44      	ldr	r4, [r0, #36]	; 0x24

	/* set MAC hardware address */
	memcpy(filter.mac, netif->hwaddr, NETIF_MAX_HWADDR_LEN);
    2d7e:	4603      	mov	r3, r0
    2d80:	f853 0f2f 	ldr.w	r0, [r3, #47]!
    2d84:	9001      	str	r0, [sp, #4]
    2d86:	889b      	ldrh	r3, [r3, #4]
    2d88:	f8ad 3008 	strh.w	r3, [sp, #8]
	filter.tid_enable = false; //true; //tph false;
    2d8c:	2100      	movs	r1, #0
    2d8e:	f88d 100c 	strb.w	r1, [sp, #12]
	mac_async_set_filter(mac, 0, &filter);
    2d92:	aa01      	add	r2, sp, #4
    2d94:	4620      	mov	r0, r4
    2d96:	4b02      	ldr	r3, [pc, #8]	; (2da0 <mac_low_level_init+0x28>)
    2d98:	4798      	blx	r3
}
    2d9a:	b004      	add	sp, #16
    2d9c:	bd10      	pop	{r4, pc}
    2d9e:	bf00      	nop
    2da0:	00001151 	.word	0x00001151

00002da4 <mac_low_level_output>:

/**
 * \berif Transmission packet though the MAC hardware.
 */
err_t mac_low_level_output(struct netif *netif, struct pbuf *p)
{
    2da4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2da8:	460f      	mov	r7, r1
	struct mac_async_descriptor *mac;
	struct pbuf *                q;
	void *                       tbuf;
	uint8_t *                    pos;

	mac = (struct mac_async_descriptor *)(netif->state);
    2daa:	f8d0 8024 	ldr.w	r8, [r0, #36]	; 0x24

#if ETH_PAD_SIZE
	pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
#endif

	if (p->tot_len == p->len) {
    2dae:	890a      	ldrh	r2, [r1, #8]
    2db0:	894b      	ldrh	r3, [r1, #10]
    2db2:	4293      	cmp	r3, r2
    2db4:	d01f      	beq.n	2df6 <mac_low_level_output+0x52>
		mac_async_write(mac, p->payload, p->tot_len);
	} else {
		tbuf = mem_malloc(LWIP_MEM_ALIGN_SIZE(p->tot_len));
    2db6:	3203      	adds	r2, #3
    2db8:	f64f 70fc 	movw	r0, #65532	; 0xfffc
    2dbc:	4010      	ands	r0, r2
    2dbe:	4b13      	ldr	r3, [pc, #76]	; (2e0c <mac_low_level_output+0x68>)
    2dc0:	4798      	blx	r3
		pos  = tbuf;
		if (tbuf == NULL) {
    2dc2:	4681      	mov	r9, r0
    2dc4:	b1f0      	cbz	r0, 2e04 <mac_low_level_output+0x60>
			return ERR_MEM;
		}
		for (q = p; q != NULL; q = q->next) {
    2dc6:	b15f      	cbz	r7, 2de0 <mac_low_level_output+0x3c>
    2dc8:	4605      	mov	r5, r0
    2dca:	463c      	mov	r4, r7
			memcpy(pos, q->payload, q->len);
    2dcc:	4e10      	ldr	r6, [pc, #64]	; (2e10 <mac_low_level_output+0x6c>)
    2dce:	8962      	ldrh	r2, [r4, #10]
    2dd0:	6861      	ldr	r1, [r4, #4]
    2dd2:	4628      	mov	r0, r5
    2dd4:	47b0      	blx	r6
			pos += q->len;
    2dd6:	8963      	ldrh	r3, [r4, #10]
    2dd8:	441d      	add	r5, r3
		for (q = p; q != NULL; q = q->next) {
    2dda:	6824      	ldr	r4, [r4, #0]
    2ddc:	2c00      	cmp	r4, #0
    2dde:	d1f6      	bne.n	2dce <mac_low_level_output+0x2a>
		}
		mac_async_write(mac, tbuf, p->tot_len);
    2de0:	893a      	ldrh	r2, [r7, #8]
    2de2:	4649      	mov	r1, r9
    2de4:	4640      	mov	r0, r8
    2de6:	4b0b      	ldr	r3, [pc, #44]	; (2e14 <mac_low_level_output+0x70>)
    2de8:	4798      	blx	r3
		mem_free(tbuf);
    2dea:	4648      	mov	r0, r9
    2dec:	4b0a      	ldr	r3, [pc, #40]	; (2e18 <mac_low_level_output+0x74>)
    2dee:	4798      	blx	r3
	pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
#endif

	LINK_STATS_INC(link.xmit);

	return ERR_OK;
    2df0:	2000      	movs	r0, #0
    2df2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		mac_async_write(mac, p->payload, p->tot_len);
    2df6:	6849      	ldr	r1, [r1, #4]
    2df8:	4640      	mov	r0, r8
    2dfa:	4b06      	ldr	r3, [pc, #24]	; (2e14 <mac_low_level_output+0x70>)
    2dfc:	4798      	blx	r3
	return ERR_OK;
    2dfe:	2000      	movs	r0, #0
    2e00:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			return ERR_MEM;
    2e04:	f04f 30ff 	mov.w	r0, #4294967295
}
    2e08:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2e0c:	0000582d 	.word	0x0000582d
    2e10:	00009faf 	.word	0x00009faf
    2e14:	0000105d 	.word	0x0000105d
    2e18:	000056d9 	.word	0x000056d9

00002e1c <ethernetif_mac_input>:

/**
 * \brief Process incoming ethernet packet.
 */
void ethernetif_mac_input(struct netif *netif)
{
    2e1c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2e20:	4606      	mov	r6, r0
	len = mac_async_read_len(mac); /* Obtain the size of the packet */
    2e22:	4f1b      	ldr	r7, [pc, #108]	; (2e90 <ethernetif_mac_input+0x74>)
	p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
    2e24:	f8df 9078 	ldr.w	r9, [pc, #120]	; 2ea0 <ethernetif_mac_input+0x84>
		mac_async_read(mac, p->payload, p->len);
    2e28:	f8df 8068 	ldr.w	r8, [pc, #104]	; 2e94 <ethernetif_mac_input+0x78>
    2e2c:	e00b      	b.n	2e46 <ethernetif_mac_input+0x2a>
		mac_async_read(mac, NULL, 0);
    2e2e:	2200      	movs	r2, #0
    2e30:	4611      	mov	r1, r2
    2e32:	4628      	mov	r0, r5
    2e34:	4b17      	ldr	r3, [pc, #92]	; (2e94 <ethernetif_mac_input+0x78>)
    2e36:	4798      	blx	r3
    2e38:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			/* PPPoE packet? */
		case ETHTYPE_PPPOEDISC:
		case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */
			/* full packet send to tcpip_thread to process */
			if (netif->input(p, netif) != ERR_OK) {
    2e3c:	6933      	ldr	r3, [r6, #16]
    2e3e:	4631      	mov	r1, r6
    2e40:	4620      	mov	r0, r4
    2e42:	4798      	blx	r3
    2e44:	b9e8      	cbnz	r0, 2e82 <ethernetif_mac_input+0x66>
	mac = (struct mac_async_descriptor *)(netif->state);
    2e46:	6a75      	ldr	r5, [r6, #36]	; 0x24
	len = mac_async_read_len(mac); /* Obtain the size of the packet */
    2e48:	4628      	mov	r0, r5
    2e4a:	47b8      	blx	r7
    2e4c:	b281      	uxth	r1, r0
	if (len == 0) {
    2e4e:	b1e1      	cbz	r1, 2e8a <ethernetif_mac_input+0x6e>
	p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
    2e50:	2200      	movs	r2, #0
    2e52:	2003      	movs	r0, #3
    2e54:	47c8      	blx	r9
	if (p != NULL) {
    2e56:	4604      	mov	r4, r0
    2e58:	2800      	cmp	r0, #0
    2e5a:	d0e8      	beq.n	2e2e <ethernetif_mac_input+0x12>
		mac_async_read(mac, p->payload, p->len);
    2e5c:	8942      	ldrh	r2, [r0, #10]
    2e5e:	6841      	ldr	r1, [r0, #4]
    2e60:	4628      	mov	r0, r5
    2e62:	47c0      	blx	r8
		switch (htons(ethhdr->type)) {
    2e64:	6863      	ldr	r3, [r4, #4]
    2e66:	8998      	ldrh	r0, [r3, #12]
    2e68:	4b0b      	ldr	r3, [pc, #44]	; (2e98 <ethernetif_mac_input+0x7c>)
    2e6a:	4798      	blx	r3
    2e6c:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
    2e70:	d0e4      	beq.n	2e3c <ethernetif_mac_input+0x20>
    2e72:	f640 0306 	movw	r3, #2054	; 0x806
    2e76:	4298      	cmp	r0, r3
    2e78:	d0e0      	beq.n	2e3c <ethernetif_mac_input+0x20>
				p = NULL;
			}
			break;

		default:
			pbuf_free(p);
    2e7a:	4620      	mov	r0, r4
    2e7c:	4b07      	ldr	r3, [pc, #28]	; (2e9c <ethernetif_mac_input+0x80>)
    2e7e:	4798      	blx	r3
			p = NULL;
			break;
    2e80:	e7e1      	b.n	2e46 <ethernetif_mac_input+0x2a>
				pbuf_free(p);
    2e82:	4620      	mov	r0, r4
    2e84:	4b05      	ldr	r3, [pc, #20]	; (2e9c <ethernetif_mac_input+0x80>)
    2e86:	4798      	blx	r3
    2e88:	e7dd      	b.n	2e46 <ethernetif_mac_input+0x2a>
    2e8a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2e8e:	bf00      	nop
    2e90:	000010c9 	.word	0x000010c9
    2e94:	00001099 	.word	0x00001099
    2e98:	00002ea5 	.word	0x00002ea5
    2e9c:	00005c89 	.word	0x00005c89
    2ea0:	00005cf1 	.word	0x00005cf1

00002ea4 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t lwip_htons(u16_t n)
{
	return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
    2ea4:	0a03      	lsrs	r3, r0, #8
    2ea6:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
}
    2eaa:	b280      	uxth	r0, r0
    2eac:	4770      	bx	lr

00002eae <lwip_ntohs>:
	return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
    2eae:	0a03      	lsrs	r3, r0, #8
    2eb0:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 * @return n in host byte order
 */
u16_t lwip_ntohs(u16_t n)
{
	return lwip_htons(n);
}
    2eb4:	b280      	uxth	r0, r0
    2eb6:	4770      	bx	lr

00002eb8 <lwip_htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t lwip_htonl(u32_t n)
{
	return ((n & 0xff) << 24) | ((n & 0xff00) << 8) | ((n & 0xff0000UL) >> 8) | ((n & 0xff000000UL) >> 24);
    2eb8:	0e03      	lsrs	r3, r0, #24
    2eba:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
    2ebe:	0202      	lsls	r2, r0, #8
    2ec0:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    2ec4:	4313      	orrs	r3, r2
    2ec6:	0a00      	lsrs	r0, r0, #8
    2ec8:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
}
    2ecc:	4318      	orrs	r0, r3
    2ece:	4770      	bx	lr

00002ed0 <lwip_ntohl>:
 *
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t lwip_ntohl(u32_t n)
{
    2ed0:	b508      	push	{r3, lr}
	return lwip_htonl(n);
    2ed2:	4b01      	ldr	r3, [pc, #4]	; (2ed8 <lwip_ntohl+0x8>)
    2ed4:	4798      	blx	r3
}
    2ed6:	bd08      	pop	{r3, pc}
    2ed8:	00002eb9 	.word	0x00002eb9

00002edc <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
	if (new_state != dhcp->state) {
    2edc:	7b03      	ldrb	r3, [r0, #12]
    2ede:	428b      	cmp	r3, r1
    2ee0:	d003      	beq.n	2eea <dhcp_set_state+0xe>
		dhcp->state           = new_state;
    2ee2:	7301      	strb	r1, [r0, #12]
		dhcp->tries           = 0;
    2ee4:	2300      	movs	r3, #0
    2ee6:	7343      	strb	r3, [r0, #13]
		dhcp->request_timeout = 0;
    2ee8:	8343      	strh	r3, [r0, #26]
    2eea:	4770      	bx	lr

00002eec <dhcp_option>:
 * Concatenate an option type and length field to the outgoing
 * DHCP message.
 *
 */
static void dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
    2eec:	b430      	push	{r4, r5}
	LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    2eee:	6943      	ldr	r3, [r0, #20]
    2ef0:	8b04      	ldrh	r4, [r0, #24]
    2ef2:	1c65      	adds	r5, r4, #1
    2ef4:	8305      	strh	r5, [r0, #24]
    2ef6:	4423      	add	r3, r4
    2ef8:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
    2efc:	6943      	ldr	r3, [r0, #20]
    2efe:	8b01      	ldrh	r1, [r0, #24]
    2f00:	1c4c      	adds	r4, r1, #1
    2f02:	8304      	strh	r4, [r0, #24]
    2f04:	440b      	add	r3, r1
    2f06:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
}
    2f0a:	bc30      	pop	{r4, r5}
    2f0c:	4770      	bx	lr

00002f0e <dhcp_option_byte>:
/*
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
    2f0e:	b410      	push	{r4}
	LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = value;
    2f10:	6943      	ldr	r3, [r0, #20]
    2f12:	8b02      	ldrh	r2, [r0, #24]
    2f14:	1c54      	adds	r4, r2, #1
    2f16:	8304      	strh	r4, [r0, #24]
    2f18:	4413      	add	r3, r2
    2f1a:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    2f1e:	f85d 4b04 	ldr.w	r4, [sp], #4
    2f22:	4770      	bx	lr

00002f24 <dhcp_option_short>:

static void dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
    2f24:	b410      	push	{r4}
	LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    2f26:	6943      	ldr	r3, [r0, #20]
    2f28:	8b02      	ldrh	r2, [r0, #24]
    2f2a:	1c54      	adds	r4, r2, #1
    2f2c:	8304      	strh	r4, [r0, #24]
    2f2e:	4413      	add	r3, r2
    2f30:	0a0a      	lsrs	r2, r1, #8
    2f32:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)(value & 0x00ffU);
    2f36:	6943      	ldr	r3, [r0, #20]
    2f38:	8b02      	ldrh	r2, [r0, #24]
    2f3a:	1c54      	adds	r4, r2, #1
    2f3c:	8304      	strh	r4, [r0, #24]
    2f3e:	4413      	add	r3, r2
    2f40:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    2f44:	f85d 4b04 	ldr.w	r4, [sp], #4
    2f48:	4770      	bx	lr

00002f4a <dhcp_option_long>:

static void dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
    2f4a:	b410      	push	{r4}
	LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
    2f4c:	6943      	ldr	r3, [r0, #20]
    2f4e:	8b02      	ldrh	r2, [r0, #24]
    2f50:	1c54      	adds	r4, r2, #1
    2f52:	8304      	strh	r4, [r0, #24]
    2f54:	4413      	add	r3, r2
    2f56:	0e0a      	lsrs	r2, r1, #24
    2f58:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
    2f5c:	6943      	ldr	r3, [r0, #20]
    2f5e:	8b02      	ldrh	r2, [r0, #24]
    2f60:	1c54      	adds	r4, r2, #1
    2f62:	8304      	strh	r4, [r0, #24]
    2f64:	4413      	add	r3, r2
    2f66:	0c0a      	lsrs	r2, r1, #16
    2f68:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    2f6c:	6943      	ldr	r3, [r0, #20]
    2f6e:	8b02      	ldrh	r2, [r0, #24]
    2f70:	1c54      	adds	r4, r2, #1
    2f72:	8304      	strh	r4, [r0, #24]
    2f74:	4413      	add	r3, r2
    2f76:	0a0a      	lsrs	r2, r1, #8
    2f78:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
    2f7c:	6943      	ldr	r3, [r0, #20]
    2f7e:	8b02      	ldrh	r2, [r0, #24]
    2f80:	1c54      	adds	r4, r2, #1
    2f82:	8304      	strh	r4, [r0, #24]
    2f84:	4413      	add	r3, r2
    2f86:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    2f8a:	f85d 4b04 	ldr.w	r4, [sp], #4
    2f8e:	4770      	bx	lr

00002f90 <dhcp_option_trailer>:
 * necessary, up to three padding bytes.
 *
 * @param dhcp DHCP state structure
 */
static void dhcp_option_trailer(struct dhcp *dhcp)
{
    2f90:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    2f92:	b150      	cbz	r0, 2faa <dhcp_option_trailer+0x1a>
    2f94:	4601      	mov	r1, r0
	LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
	LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n",
	            dhcp->options_out_len < DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
    2f96:	6943      	ldr	r3, [r0, #20]
    2f98:	8b02      	ldrh	r2, [r0, #24]
    2f9a:	1c50      	adds	r0, r2, #1
    2f9c:	8308      	strh	r0, [r1, #24]
    2f9e:	4413      	add	r3, r2
    2fa0:	22ff      	movs	r2, #255	; 0xff
    2fa2:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	/* packet is too small, or not 4 byte aligned? */
	while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3))
	       && (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
		/* add a fill/padding byte */
		dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    2fa6:	2400      	movs	r4, #0
	while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3))
    2fa8:	e00d      	b.n	2fc6 <dhcp_option_trailer+0x36>
	LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    2faa:	4b09      	ldr	r3, [pc, #36]	; (2fd0 <dhcp_option_trailer+0x40>)
    2fac:	f240 62e7 	movw	r2, #1767	; 0x6e7
    2fb0:	4908      	ldr	r1, [pc, #32]	; (2fd4 <dhcp_option_trailer+0x44>)
    2fb2:	4809      	ldr	r0, [pc, #36]	; (2fd8 <dhcp_option_trailer+0x48>)
    2fb4:	4c09      	ldr	r4, [pc, #36]	; (2fdc <dhcp_option_trailer+0x4c>)
    2fb6:	47a0      	blx	r4
    2fb8:	e7fe      	b.n	2fb8 <dhcp_option_trailer+0x28>
		dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    2fba:	694a      	ldr	r2, [r1, #20]
    2fbc:	1c58      	adds	r0, r3, #1
    2fbe:	8308      	strh	r0, [r1, #24]
    2fc0:	4413      	add	r3, r2
    2fc2:	f883 40f0 	strb.w	r4, [r3, #240]	; 0xf0
	while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3))
    2fc6:	8b0b      	ldrh	r3, [r1, #24]
    2fc8:	2b43      	cmp	r3, #67	; 0x43
    2fca:	d9f6      	bls.n	2fba <dhcp_option_trailer+0x2a>
	}
}
    2fcc:	bd10      	pop	{r4, pc}
    2fce:	bf00      	nop
    2fd0:	0000b2a0 	.word	0x0000b2a0
    2fd4:	0000b2c4 	.word	0x0000b2c4
    2fd8:	0000b2e8 	.word	0x0000b2e8
    2fdc:	00009fd5 	.word	0x00009fd5

00002fe0 <dhcp_create_msg>:
{
    2fe0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
    2fe4:	2800      	cmp	r0, #0
    2fe6:	f000 809f 	beq.w	3128 <dhcp_create_msg+0x148>
    2fea:	460c      	mov	r4, r1
    2fec:	4615      	mov	r5, r2
    2fee:	4606      	mov	r6, r0
	LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    2ff0:	2900      	cmp	r1, #0
    2ff2:	f000 80a1 	beq.w	3138 <dhcp_create_msg+0x158>
	dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
    2ff6:	2200      	movs	r2, #0
    2ff8:	f44f 719a 	mov.w	r1, #308	; 0x134
    2ffc:	4610      	mov	r0, r2
    2ffe:	4b56      	ldr	r3, [pc, #344]	; (3158 <dhcp_create_msg+0x178>)
    3000:	4798      	blx	r3
    3002:	6120      	str	r0, [r4, #16]
	if (dhcp->p_out == NULL) {
    3004:	2800      	cmp	r0, #0
    3006:	f000 809f 	beq.w	3148 <dhcp_create_msg+0x168>
	if (dhcp->tries == 0) {
    300a:	7b63      	ldrb	r3, [r4, #13]
    300c:	b91b      	cbnz	r3, 3016 <dhcp_create_msg+0x36>
		xid++;
    300e:	4a53      	ldr	r2, [pc, #332]	; (315c <dhcp_create_msg+0x17c>)
    3010:	6813      	ldr	r3, [r2, #0]
    3012:	3301      	adds	r3, #1
    3014:	6013      	str	r3, [r2, #0]
	dhcp->xid = xid;
    3016:	4b51      	ldr	r3, [pc, #324]	; (315c <dhcp_create_msg+0x17c>)
    3018:	6819      	ldr	r1, [r3, #0]
    301a:	6021      	str	r1, [r4, #0]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("transaction id xid(%" X32_F ")\n", xid));
    301c:	4850      	ldr	r0, [pc, #320]	; (3160 <dhcp_create_msg+0x180>)
    301e:	4b51      	ldr	r3, [pc, #324]	; (3164 <dhcp_create_msg+0x184>)
    3020:	4798      	blx	r3
	dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
    3022:	6923      	ldr	r3, [r4, #16]
    3024:	685a      	ldr	r2, [r3, #4]
    3026:	6162      	str	r2, [r4, #20]
	dhcp->msg_out->op = DHCP_BOOTREQUEST;
    3028:	2301      	movs	r3, #1
    302a:	7013      	strb	r3, [r2, #0]
	dhcp->msg_out->htype = DHCP_HTYPE_ETH;
    302c:	6962      	ldr	r2, [r4, #20]
    302e:	7053      	strb	r3, [r2, #1]
	dhcp->msg_out->hlen  = netif->hwaddr_len;
    3030:	6963      	ldr	r3, [r4, #20]
    3032:	f896 202e 	ldrb.w	r2, [r6, #46]	; 0x2e
    3036:	709a      	strb	r2, [r3, #2]
	dhcp->msg_out->hops  = 0;
    3038:	6963      	ldr	r3, [r4, #20]
    303a:	2700      	movs	r7, #0
    303c:	70df      	strb	r7, [r3, #3]
	dhcp->msg_out->xid   = htonl(dhcp->xid);
    303e:	f8d4 8014 	ldr.w	r8, [r4, #20]
    3042:	6820      	ldr	r0, [r4, #0]
    3044:	4b48      	ldr	r3, [pc, #288]	; (3168 <dhcp_create_msg+0x188>)
    3046:	4798      	blx	r3
    3048:	f8c8 0004 	str.w	r0, [r8, #4]
	dhcp->msg_out->secs  = 0;
    304c:	6963      	ldr	r3, [r4, #20]
    304e:	721f      	strb	r7, [r3, #8]
    3050:	725f      	strb	r7, [r3, #9]
	dhcp->msg_out->flags = 0;
    3052:	6963      	ldr	r3, [r4, #20]
    3054:	729f      	strb	r7, [r3, #10]
    3056:	72df      	strb	r7, [r3, #11]
	ip_addr_set_zero(&dhcp->msg_out->ciaddr);
    3058:	6963      	ldr	r3, [r4, #20]
    305a:	731f      	strb	r7, [r3, #12]
    305c:	735f      	strb	r7, [r3, #13]
    305e:	739f      	strb	r7, [r3, #14]
    3060:	73df      	strb	r7, [r3, #15]
	if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE)
    3062:	2d08      	cmp	r5, #8
    3064:	d008      	beq.n	3078 <dhcp_create_msg+0x98>
    3066:	2d04      	cmp	r5, #4
    3068:	d006      	beq.n	3078 <dhcp_create_msg+0x98>
	    || ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    306a:	2d03      	cmp	r5, #3
    306c:	d107      	bne.n	307e <dhcp_create_msg+0x9e>
	        ((dhcp->state == DHCP_RENEWING) || dhcp->state == DHCP_REBINDING))) {
    306e:	7b23      	ldrb	r3, [r4, #12]
    3070:	3b04      	subs	r3, #4
	    || ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    3072:	b2db      	uxtb	r3, r3
    3074:	2b01      	cmp	r3, #1
    3076:	d802      	bhi.n	307e <dhcp_create_msg+0x9e>
		ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
    3078:	6963      	ldr	r3, [r4, #20]
    307a:	6872      	ldr	r2, [r6, #4]
    307c:	60da      	str	r2, [r3, #12]
	ip_addr_set_zero(&dhcp->msg_out->yiaddr);
    307e:	6962      	ldr	r2, [r4, #20]
    3080:	2300      	movs	r3, #0
    3082:	7413      	strb	r3, [r2, #16]
    3084:	7453      	strb	r3, [r2, #17]
    3086:	7493      	strb	r3, [r2, #18]
    3088:	74d3      	strb	r3, [r2, #19]
	ip_addr_set_zero(&dhcp->msg_out->siaddr);
    308a:	6962      	ldr	r2, [r4, #20]
    308c:	7513      	strb	r3, [r2, #20]
    308e:	7553      	strb	r3, [r2, #21]
    3090:	7593      	strb	r3, [r2, #22]
    3092:	75d3      	strb	r3, [r2, #23]
	ip_addr_set_zero(&dhcp->msg_out->giaddr);
    3094:	6962      	ldr	r2, [r4, #20]
    3096:	7613      	strb	r3, [r2, #24]
    3098:	7653      	strb	r3, [r2, #25]
    309a:	7693      	strb	r3, [r2, #26]
    309c:	76d3      	strb	r3, [r2, #27]
    309e:	f106 012f 	add.w	r1, r6, #47	; 0x2f
		dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0 /* pad byte*/;
    30a2:	469c      	mov	ip, r3
    30a4:	6962      	ldr	r2, [r4, #20]
    30a6:	f896 e02e 	ldrb.w	lr, [r6, #46]	; 0x2e
    30aa:	b29f      	uxth	r7, r3
    30ac:	45be      	cmp	lr, r7
    30ae:	bf8c      	ite	hi
    30b0:	780f      	ldrbhi	r7, [r1, #0]
    30b2:	4667      	movls	r7, ip
    30b4:	441a      	add	r2, r3
    30b6:	7717      	strb	r7, [r2, #28]
    30b8:	3301      	adds	r3, #1
    30ba:	3101      	adds	r1, #1
	for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    30bc:	2b10      	cmp	r3, #16
    30be:	d1f1      	bne.n	30a4 <dhcp_create_msg+0xc4>
    30c0:	2300      	movs	r3, #0
		dhcp->msg_out->sname[i] = 0;
    30c2:	4619      	mov	r1, r3
    30c4:	6962      	ldr	r2, [r4, #20]
    30c6:	441a      	add	r2, r3
    30c8:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
    30cc:	3301      	adds	r3, #1
	for (i = 0; i < DHCP_SNAME_LEN; i++) {
    30ce:	2b40      	cmp	r3, #64	; 0x40
    30d0:	d1f8      	bne.n	30c4 <dhcp_create_msg+0xe4>
    30d2:	2300      	movs	r3, #0
		dhcp->msg_out->file[i] = 0;
    30d4:	4619      	mov	r1, r3
    30d6:	6962      	ldr	r2, [r4, #20]
    30d8:	441a      	add	r2, r3
    30da:	f882 106c 	strb.w	r1, [r2, #108]	; 0x6c
    30de:	3301      	adds	r3, #1
	for (i = 0; i < DHCP_FILE_LEN; i++) {
    30e0:	2b80      	cmp	r3, #128	; 0x80
    30e2:	d1f8      	bne.n	30d6 <dhcp_create_msg+0xf6>
	dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
    30e4:	6962      	ldr	r2, [r4, #20]
    30e6:	2300      	movs	r3, #0
    30e8:	2163      	movs	r1, #99	; 0x63
    30ea:	f882 10ec 	strb.w	r1, [r2, #236]	; 0xec
    30ee:	f06f 007d 	mvn.w	r0, #125	; 0x7d
    30f2:	f882 00ed 	strb.w	r0, [r2, #237]	; 0xed
    30f6:	2053      	movs	r0, #83	; 0x53
    30f8:	f882 00ee 	strb.w	r0, [r2, #238]	; 0xee
    30fc:	f882 10ef 	strb.w	r1, [r2, #239]	; 0xef
	dhcp->options_out_len = 0;
    3100:	8323      	strh	r3, [r4, #24]
		dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
    3102:	6962      	ldr	r2, [r4, #20]
    3104:	441a      	add	r2, r3
    3106:	f882 30f0 	strb.w	r3, [r2, #240]	; 0xf0
    310a:	3301      	adds	r3, #1
	for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    310c:	2b44      	cmp	r3, #68	; 0x44
    310e:	d1f8      	bne.n	3102 <dhcp_create_msg+0x122>
	dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    3110:	2201      	movs	r2, #1
    3112:	2135      	movs	r1, #53	; 0x35
    3114:	4620      	mov	r0, r4
    3116:	4b15      	ldr	r3, [pc, #84]	; (316c <dhcp_create_msg+0x18c>)
    3118:	4798      	blx	r3
	dhcp_option_byte(dhcp, message_type);
    311a:	4629      	mov	r1, r5
    311c:	4620      	mov	r0, r4
    311e:	4b14      	ldr	r3, [pc, #80]	; (3170 <dhcp_create_msg+0x190>)
    3120:	4798      	blx	r3
	return ERR_OK;
    3122:	2000      	movs	r0, #0
}
    3124:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
    3128:	4b12      	ldr	r3, [pc, #72]	; (3174 <dhcp_create_msg+0x194>)
    312a:	f44f 62d1 	mov.w	r2, #1672	; 0x688
    312e:	4912      	ldr	r1, [pc, #72]	; (3178 <dhcp_create_msg+0x198>)
    3130:	4812      	ldr	r0, [pc, #72]	; (317c <dhcp_create_msg+0x19c>)
    3132:	4c0c      	ldr	r4, [pc, #48]	; (3164 <dhcp_create_msg+0x184>)
    3134:	47a0      	blx	r4
    3136:	e7fe      	b.n	3136 <dhcp_create_msg+0x156>
	LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    3138:	4b0e      	ldr	r3, [pc, #56]	; (3174 <dhcp_create_msg+0x194>)
    313a:	f240 6289 	movw	r2, #1673	; 0x689
    313e:	4910      	ldr	r1, [pc, #64]	; (3180 <dhcp_create_msg+0x1a0>)
    3140:	480e      	ldr	r0, [pc, #56]	; (317c <dhcp_create_msg+0x19c>)
    3142:	4c08      	ldr	r4, [pc, #32]	; (3164 <dhcp_create_msg+0x184>)
    3144:	47a0      	blx	r4
    3146:	e7fe      	b.n	3146 <dhcp_create_msg+0x166>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    3148:	480e      	ldr	r0, [pc, #56]	; (3184 <dhcp_create_msg+0x1a4>)
    314a:	4b0f      	ldr	r3, [pc, #60]	; (3188 <dhcp_create_msg+0x1a8>)
    314c:	4798      	blx	r3
		return ERR_MEM;
    314e:	f04f 30ff 	mov.w	r0, #4294967295
    3152:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3156:	bf00      	nop
    3158:	00005cf1 	.word	0x00005cf1
    315c:	20000000 	.word	0x20000000
    3160:	0000b37c 	.word	0x0000b37c
    3164:	00009fd5 	.word	0x00009fd5
    3168:	00002eb9 	.word	0x00002eb9
    316c:	00002eed 	.word	0x00002eed
    3170:	00002f0f 	.word	0x00002f0f
    3174:	0000b2a0 	.word	0x0000b2a0
    3178:	0000b310 	.word	0x0000b310
    317c:	0000b2e8 	.word	0x0000b2e8
    3180:	0000b330 	.word	0x0000b330
    3184:	0000b350 	.word	0x0000b350
    3188:	0000a0bd 	.word	0x0000a0bd

0000318c <dhcp_delete_msg>:
{
    318c:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
    318e:	b140      	cbz	r0, 31a2 <dhcp_delete_msg+0x16>
    3190:	4604      	mov	r4, r0
	if (dhcp->p_out != NULL) {
    3192:	6900      	ldr	r0, [r0, #16]
    3194:	b108      	cbz	r0, 319a <dhcp_delete_msg+0xe>
		pbuf_free(dhcp->p_out);
    3196:	4b07      	ldr	r3, [pc, #28]	; (31b4 <dhcp_delete_msg+0x28>)
    3198:	4798      	blx	r3
	dhcp->p_out   = NULL;
    319a:	2300      	movs	r3, #0
    319c:	6123      	str	r3, [r4, #16]
	dhcp->msg_out = NULL;
    319e:	6163      	str	r3, [r4, #20]
    31a0:	bd10      	pop	{r4, pc}
	LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
    31a2:	4b05      	ldr	r3, [pc, #20]	; (31b8 <dhcp_delete_msg+0x2c>)
    31a4:	f240 62d3 	movw	r2, #1747	; 0x6d3
    31a8:	4904      	ldr	r1, [pc, #16]	; (31bc <dhcp_delete_msg+0x30>)
    31aa:	4805      	ldr	r0, [pc, #20]	; (31c0 <dhcp_delete_msg+0x34>)
    31ac:	4c05      	ldr	r4, [pc, #20]	; (31c4 <dhcp_delete_msg+0x38>)
    31ae:	47a0      	blx	r4
    31b0:	e7fe      	b.n	31b0 <dhcp_delete_msg+0x24>
    31b2:	bf00      	nop
    31b4:	00005c89 	.word	0x00005c89
    31b8:	0000b2a0 	.word	0x0000b2a0
    31bc:	0000b394 	.word	0x0000b394
    31c0:	0000b2e8 	.word	0x0000b2e8
    31c4:	00009fd5 	.word	0x00009fd5

000031c8 <dhcp_rebind>:
{
    31c8:	b570      	push	{r4, r5, r6, lr}
    31ca:	b082      	sub	sp, #8
    31cc:	4606      	mov	r6, r0
	struct dhcp *dhcp = netif->dhcp;
    31ce:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
    31d0:	4827      	ldr	r0, [pc, #156]	; (3270 <dhcp_rebind+0xa8>)
    31d2:	4b28      	ldr	r3, [pc, #160]	; (3274 <dhcp_rebind+0xac>)
    31d4:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_REBINDING);
    31d6:	2104      	movs	r1, #4
    31d8:	4620      	mov	r0, r4
    31da:	4b27      	ldr	r3, [pc, #156]	; (3278 <dhcp_rebind+0xb0>)
    31dc:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    31de:	2203      	movs	r2, #3
    31e0:	4621      	mov	r1, r4
    31e2:	4630      	mov	r0, r6
    31e4:	4b25      	ldr	r3, [pc, #148]	; (327c <dhcp_rebind+0xb4>)
    31e6:	4798      	blx	r3
	if (result == ERR_OK) {
    31e8:	4605      	mov	r5, r0
    31ea:	2800      	cmp	r0, #0
    31ec:	d139      	bne.n	3262 <dhcp_rebind+0x9a>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    31ee:	2202      	movs	r2, #2
    31f0:	2139      	movs	r1, #57	; 0x39
    31f2:	4620      	mov	r0, r4
    31f4:	4b22      	ldr	r3, [pc, #136]	; (3280 <dhcp_rebind+0xb8>)
    31f6:	4798      	blx	r3
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    31f8:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
    31fa:	4620      	mov	r0, r4
    31fc:	4b21      	ldr	r3, [pc, #132]	; (3284 <dhcp_rebind+0xbc>)
    31fe:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    3200:	4620      	mov	r0, r4
    3202:	4b21      	ldr	r3, [pc, #132]	; (3288 <dhcp_rebind+0xc0>)
    3204:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3206:	8b21      	ldrh	r1, [r4, #24]
    3208:	31f0      	adds	r1, #240	; 0xf0
    320a:	b289      	uxth	r1, r1
    320c:	6920      	ldr	r0, [r4, #16]
    320e:	4b1f      	ldr	r3, [pc, #124]	; (328c <dhcp_rebind+0xc4>)
    3210:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    3212:	6921      	ldr	r1, [r4, #16]
    3214:	6860      	ldr	r0, [r4, #4]
    3216:	9600      	str	r6, [sp, #0]
    3218:	2343      	movs	r3, #67	; 0x43
    321a:	4a1d      	ldr	r2, [pc, #116]	; (3290 <dhcp_rebind+0xc8>)
    321c:	4e1d      	ldr	r6, [pc, #116]	; (3294 <dhcp_rebind+0xcc>)
    321e:	47b0      	blx	r6
		dhcp_delete_msg(dhcp);
    3220:	4620      	mov	r0, r4
    3222:	4b1d      	ldr	r3, [pc, #116]	; (3298 <dhcp_rebind+0xd0>)
    3224:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
    3226:	481d      	ldr	r0, [pc, #116]	; (329c <dhcp_rebind+0xd4>)
    3228:	4b12      	ldr	r3, [pc, #72]	; (3274 <dhcp_rebind+0xac>)
    322a:	4798      	blx	r3
	dhcp->tries++;
    322c:	7b61      	ldrb	r1, [r4, #13]
    322e:	3101      	adds	r1, #1
    3230:	b2c9      	uxtb	r1, r1
    3232:	7361      	strb	r1, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    3234:	2909      	cmp	r1, #9
    3236:	d818      	bhi.n	326a <dhcp_rebind+0xa2>
    3238:	ebc1 1341 	rsb	r3, r1, r1, lsl #5
    323c:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    3240:	00c9      	lsls	r1, r1, #3
    3242:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3244:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    3248:	4a15      	ldr	r2, [pc, #84]	; (32a0 <dhcp_rebind+0xd8>)
    324a:	fb82 0203 	smull	r0, r2, r2, r3
    324e:	17db      	asrs	r3, r3, #31
    3250:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    3254:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    3256:	4813      	ldr	r0, [pc, #76]	; (32a4 <dhcp_rebind+0xdc>)
    3258:	4b13      	ldr	r3, [pc, #76]	; (32a8 <dhcp_rebind+0xe0>)
    325a:	4798      	blx	r3
}
    325c:	4628      	mov	r0, r5
    325e:	b002      	add	sp, #8
    3260:	bd70      	pop	{r4, r5, r6, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    3262:	4812      	ldr	r0, [pc, #72]	; (32ac <dhcp_rebind+0xe4>)
    3264:	4b03      	ldr	r3, [pc, #12]	; (3274 <dhcp_rebind+0xac>)
    3266:	4798      	blx	r3
    3268:	e7e0      	b.n	322c <dhcp_rebind+0x64>
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    326a:	f242 7110 	movw	r1, #10000	; 0x2710
    326e:	e7e9      	b.n	3244 <dhcp_rebind+0x7c>
    3270:	0000b3b4 	.word	0x0000b3b4
    3274:	0000a0bd 	.word	0x0000a0bd
    3278:	00002edd 	.word	0x00002edd
    327c:	00002fe1 	.word	0x00002fe1
    3280:	00002eed 	.word	0x00002eed
    3284:	00002f25 	.word	0x00002f25
    3288:	00002f91 	.word	0x00002f91
    328c:	00005e2d 	.word	0x00005e2d
    3290:	0000c298 	.word	0x0000c298
    3294:	00008cb1 	.word	0x00008cb1
    3298:	0000318d 	.word	0x0000318d
    329c:	0000b3c4 	.word	0x0000b3c4
    32a0:	10624dd3 	.word	0x10624dd3
    32a4:	0000b40c 	.word	0x0000b40c
    32a8:	00009fd5 	.word	0x00009fd5
    32ac:	0000b3dc 	.word	0x0000b3dc

000032b0 <dhcp_discover>:
{
    32b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    32b4:	b082      	sub	sp, #8
    32b6:	4606      	mov	r6, r0
	struct dhcp *dhcp   = netif->dhcp;
    32b8:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
    32ba:	4836      	ldr	r0, [pc, #216]	; (3394 <dhcp_discover+0xe4>)
    32bc:	4b36      	ldr	r3, [pc, #216]	; (3398 <dhcp_discover+0xe8>)
    32be:	4798      	blx	r3
	ip_addr_set_any(&dhcp->offered_ip_addr);
    32c0:	2300      	movs	r3, #0
    32c2:	6263      	str	r3, [r4, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_SELECTING);
    32c4:	2106      	movs	r1, #6
    32c6:	4620      	mov	r0, r4
    32c8:	4b34      	ldr	r3, [pc, #208]	; (339c <dhcp_discover+0xec>)
    32ca:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
    32cc:	2201      	movs	r2, #1
    32ce:	4621      	mov	r1, r4
    32d0:	4630      	mov	r0, r6
    32d2:	4b33      	ldr	r3, [pc, #204]	; (33a0 <dhcp_discover+0xf0>)
    32d4:	4798      	blx	r3
	if (result == ERR_OK) {
    32d6:	4605      	mov	r5, r0
    32d8:	2800      	cmp	r0, #0
    32da:	d156      	bne.n	338a <dhcp_discover+0xda>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    32dc:	4831      	ldr	r0, [pc, #196]	; (33a4 <dhcp_discover+0xf4>)
    32de:	4f2e      	ldr	r7, [pc, #184]	; (3398 <dhcp_discover+0xe8>)
    32e0:	47b8      	blx	r7
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    32e2:	2202      	movs	r2, #2
    32e4:	2139      	movs	r1, #57	; 0x39
    32e6:	4620      	mov	r0, r4
    32e8:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 33e0 <dhcp_discover+0x130>
    32ec:	47c0      	blx	r8
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    32ee:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
    32f0:	4620      	mov	r0, r4
    32f2:	4b2d      	ldr	r3, [pc, #180]	; (33a8 <dhcp_discover+0xf8>)
    32f4:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4 /*num options*/);
    32f6:	2204      	movs	r2, #4
    32f8:	2137      	movs	r1, #55	; 0x37
    32fa:	4620      	mov	r0, r4
    32fc:	47c0      	blx	r8
		dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    32fe:	2101      	movs	r1, #1
    3300:	4620      	mov	r0, r4
    3302:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 33e4 <dhcp_discover+0x134>
    3306:	47c0      	blx	r8
		dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    3308:	2103      	movs	r1, #3
    330a:	4620      	mov	r0, r4
    330c:	47c0      	blx	r8
		dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    330e:	211c      	movs	r1, #28
    3310:	4620      	mov	r0, r4
    3312:	47c0      	blx	r8
		dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    3314:	2106      	movs	r1, #6
    3316:	4620      	mov	r0, r4
    3318:	47c0      	blx	r8
		dhcp_option_trailer(dhcp);
    331a:	4620      	mov	r0, r4
    331c:	4b23      	ldr	r3, [pc, #140]	; (33ac <dhcp_discover+0xfc>)
    331e:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    3320:	4823      	ldr	r0, [pc, #140]	; (33b0 <dhcp_discover+0x100>)
    3322:	47b8      	blx	r7
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3324:	8b21      	ldrh	r1, [r4, #24]
    3326:	31f0      	adds	r1, #240	; 0xf0
    3328:	b289      	uxth	r1, r1
    332a:	6920      	ldr	r0, [r4, #16]
    332c:	4b21      	ldr	r3, [pc, #132]	; (33b4 <dhcp_discover+0x104>)
    332e:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    3330:	4821      	ldr	r0, [pc, #132]	; (33b8 <dhcp_discover+0x108>)
    3332:	47b8      	blx	r7
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    3334:	6921      	ldr	r1, [r4, #16]
    3336:	6860      	ldr	r0, [r4, #4]
    3338:	9600      	str	r6, [sp, #0]
    333a:	2343      	movs	r3, #67	; 0x43
    333c:	4a1f      	ldr	r2, [pc, #124]	; (33bc <dhcp_discover+0x10c>)
    333e:	4e20      	ldr	r6, [pc, #128]	; (33c0 <dhcp_discover+0x110>)
    3340:	47b0      	blx	r6
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    3342:	4820      	ldr	r0, [pc, #128]	; (33c4 <dhcp_discover+0x114>)
    3344:	47b8      	blx	r7
		dhcp_delete_msg(dhcp);
    3346:	4620      	mov	r0, r4
    3348:	4b1f      	ldr	r3, [pc, #124]	; (33c8 <dhcp_discover+0x118>)
    334a:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    334c:	481f      	ldr	r0, [pc, #124]	; (33cc <dhcp_discover+0x11c>)
    334e:	47b8      	blx	r7
	dhcp->tries++;
    3350:	7b61      	ldrb	r1, [r4, #13]
    3352:	3101      	adds	r1, #1
    3354:	b2c9      	uxtb	r1, r1
    3356:	7361      	strb	r1, [r4, #13]
	msecs                 = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    3358:	2905      	cmp	r1, #5
    335a:	bf9a      	itte	ls
    335c:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
    3360:	fa03 f101 	lslls.w	r1, r3, r1
    3364:	f64e 2160 	movwhi	r1, #60000	; 0xea60
    3368:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    336a:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    336e:	4a18      	ldr	r2, [pc, #96]	; (33d0 <dhcp_discover+0x120>)
    3370:	fb82 0203 	smull	r0, r2, r2, r3
    3374:	17db      	asrs	r3, r3, #31
    3376:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    337a:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    337c:	4815      	ldr	r0, [pc, #84]	; (33d4 <dhcp_discover+0x124>)
    337e:	4b16      	ldr	r3, [pc, #88]	; (33d8 <dhcp_discover+0x128>)
    3380:	4798      	blx	r3
}
    3382:	4628      	mov	r0, r5
    3384:	b002      	add	sp, #8
    3386:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    338a:	4814      	ldr	r0, [pc, #80]	; (33dc <dhcp_discover+0x12c>)
    338c:	4b02      	ldr	r3, [pc, #8]	; (3398 <dhcp_discover+0xe8>)
    338e:	4798      	blx	r3
    3390:	e7de      	b.n	3350 <dhcp_discover+0xa0>
    3392:	bf00      	nop
    3394:	0000b43c 	.word	0x0000b43c
    3398:	0000a0bd 	.word	0x0000a0bd
    339c:	00002edd 	.word	0x00002edd
    33a0:	00002fe1 	.word	0x00002fe1
    33a4:	0000b44c 	.word	0x0000b44c
    33a8:	00002f25 	.word	0x00002f25
    33ac:	00002f91 	.word	0x00002f91
    33b0:	0000b46c 	.word	0x0000b46c
    33b4:	00005e2d 	.word	0x00005e2d
    33b8:	0000b488 	.word	0x0000b488
    33bc:	0000c298 	.word	0x0000c298
    33c0:	00008cb1 	.word	0x00008cb1
    33c4:	0000b4d0 	.word	0x0000b4d0
    33c8:	0000318d 	.word	0x0000318d
    33cc:	0000b4f0 	.word	0x0000b4f0
    33d0:	10624dd3 	.word	0x10624dd3
    33d4:	0000b53c 	.word	0x0000b53c
    33d8:	00009fd5 	.word	0x00009fd5
    33dc:	0000b50c 	.word	0x0000b50c
    33e0:	00002eed 	.word	0x00002eed
    33e4:	00002f0f 	.word	0x00002f0f

000033e8 <dhcp_select>:
{
    33e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    33ec:	b083      	sub	sp, #12
    33ee:	4605      	mov	r5, r0
	struct dhcp *dhcp = netif->dhcp;
    33f0:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(
    33f2:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
    33f6:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
    33fa:	f890 1038 	ldrb.w	r1, [r0, #56]	; 0x38
    33fe:	9100      	str	r1, [sp, #0]
    3400:	4601      	mov	r1, r0
    3402:	483a      	ldr	r0, [pc, #232]	; (34ec <dhcp_select+0x104>)
    3404:	4e3a      	ldr	r6, [pc, #232]	; (34f0 <dhcp_select+0x108>)
    3406:	47b0      	blx	r6
	dhcp_set_state(dhcp, DHCP_REQUESTING);
    3408:	2101      	movs	r1, #1
    340a:	4620      	mov	r0, r4
    340c:	4b39      	ldr	r3, [pc, #228]	; (34f4 <dhcp_select+0x10c>)
    340e:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    3410:	2203      	movs	r2, #3
    3412:	4621      	mov	r1, r4
    3414:	4628      	mov	r0, r5
    3416:	4b38      	ldr	r3, [pc, #224]	; (34f8 <dhcp_select+0x110>)
    3418:	4798      	blx	r3
	if (result == ERR_OK) {
    341a:	4681      	mov	r9, r0
    341c:	2800      	cmp	r0, #0
    341e:	d161      	bne.n	34e4 <dhcp_select+0xfc>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    3420:	2202      	movs	r2, #2
    3422:	2139      	movs	r1, #57	; 0x39
    3424:	4620      	mov	r0, r4
    3426:	4f35      	ldr	r7, [pc, #212]	; (34fc <dhcp_select+0x114>)
    3428:	47b8      	blx	r7
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    342a:	8da9      	ldrh	r1, [r5, #44]	; 0x2c
    342c:	4620      	mov	r0, r4
    342e:	4b34      	ldr	r3, [pc, #208]	; (3500 <dhcp_select+0x118>)
    3430:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    3432:	2204      	movs	r2, #4
    3434:	2132      	movs	r1, #50	; 0x32
    3436:	4620      	mov	r0, r4
    3438:	47b8      	blx	r7
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    343a:	6a60      	ldr	r0, [r4, #36]	; 0x24
    343c:	4e31      	ldr	r6, [pc, #196]	; (3504 <dhcp_select+0x11c>)
    343e:	47b0      	blx	r6
    3440:	4601      	mov	r1, r0
    3442:	4620      	mov	r0, r4
    3444:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 3534 <dhcp_select+0x14c>
    3448:	47c0      	blx	r8
		dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    344a:	2204      	movs	r2, #4
    344c:	2136      	movs	r1, #54	; 0x36
    344e:	4620      	mov	r0, r4
    3450:	47b8      	blx	r7
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->server_ip_addr)));
    3452:	6a20      	ldr	r0, [r4, #32]
    3454:	47b0      	blx	r6
    3456:	4601      	mov	r1, r0
    3458:	4620      	mov	r0, r4
    345a:	47c0      	blx	r8
		dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4 /*num options*/);
    345c:	2204      	movs	r2, #4
    345e:	2137      	movs	r1, #55	; 0x37
    3460:	4620      	mov	r0, r4
    3462:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    3464:	2101      	movs	r1, #1
    3466:	4620      	mov	r0, r4
    3468:	4f27      	ldr	r7, [pc, #156]	; (3508 <dhcp_select+0x120>)
    346a:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    346c:	2103      	movs	r1, #3
    346e:	4620      	mov	r0, r4
    3470:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    3472:	211c      	movs	r1, #28
    3474:	4620      	mov	r0, r4
    3476:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    3478:	2106      	movs	r1, #6
    347a:	4620      	mov	r0, r4
    347c:	47b8      	blx	r7
		dhcp_option_trailer(dhcp);
    347e:	4620      	mov	r0, r4
    3480:	4b22      	ldr	r3, [pc, #136]	; (350c <dhcp_select+0x124>)
    3482:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3484:	8b21      	ldrh	r1, [r4, #24]
    3486:	31f0      	adds	r1, #240	; 0xf0
    3488:	b289      	uxth	r1, r1
    348a:	6920      	ldr	r0, [r4, #16]
    348c:	4b20      	ldr	r3, [pc, #128]	; (3510 <dhcp_select+0x128>)
    348e:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    3490:	6921      	ldr	r1, [r4, #16]
    3492:	6860      	ldr	r0, [r4, #4]
    3494:	9500      	str	r5, [sp, #0]
    3496:	2343      	movs	r3, #67	; 0x43
    3498:	4a1e      	ldr	r2, [pc, #120]	; (3514 <dhcp_select+0x12c>)
    349a:	4d1f      	ldr	r5, [pc, #124]	; (3518 <dhcp_select+0x130>)
    349c:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    349e:	4620      	mov	r0, r4
    34a0:	4b1e      	ldr	r3, [pc, #120]	; (351c <dhcp_select+0x134>)
    34a2:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    34a4:	481e      	ldr	r0, [pc, #120]	; (3520 <dhcp_select+0x138>)
    34a6:	4b1f      	ldr	r3, [pc, #124]	; (3524 <dhcp_select+0x13c>)
    34a8:	4798      	blx	r3
	dhcp->tries++;
    34aa:	7b61      	ldrb	r1, [r4, #13]
    34ac:	3101      	adds	r1, #1
    34ae:	b2c9      	uxtb	r1, r1
    34b0:	7361      	strb	r1, [r4, #13]
	msecs                 = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    34b2:	2905      	cmp	r1, #5
    34b4:	bf9a      	itte	ls
    34b6:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
    34ba:	fa03 f101 	lslls.w	r1, r3, r1
    34be:	f64e 2160 	movwhi	r1, #60000	; 0xea60
    34c2:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    34c4:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    34c8:	4a17      	ldr	r2, [pc, #92]	; (3528 <dhcp_select+0x140>)
    34ca:	fb82 0203 	smull	r0, r2, r2, r3
    34ce:	17db      	asrs	r3, r3, #31
    34d0:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    34d4:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %" U16_F " msecs\n", msecs));
    34d6:	4815      	ldr	r0, [pc, #84]	; (352c <dhcp_select+0x144>)
    34d8:	4b05      	ldr	r3, [pc, #20]	; (34f0 <dhcp_select+0x108>)
    34da:	4798      	blx	r3
}
    34dc:	4648      	mov	r0, r9
    34de:	b003      	add	sp, #12
    34e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    34e4:	4812      	ldr	r0, [pc, #72]	; (3530 <dhcp_select+0x148>)
    34e6:	4b0f      	ldr	r3, [pc, #60]	; (3524 <dhcp_select+0x13c>)
    34e8:	4798      	blx	r3
    34ea:	e7de      	b.n	34aa <dhcp_select+0xc2>
    34ec:	0000b56c 	.word	0x0000b56c
    34f0:	00009fd5 	.word	0x00009fd5
    34f4:	00002edd 	.word	0x00002edd
    34f8:	00002fe1 	.word	0x00002fe1
    34fc:	00002eed 	.word	0x00002eed
    3500:	00002f25 	.word	0x00002f25
    3504:	00002ed1 	.word	0x00002ed1
    3508:	00002f0f 	.word	0x00002f0f
    350c:	00002f91 	.word	0x00002f91
    3510:	00005e2d 	.word	0x00005e2d
    3514:	0000c298 	.word	0x0000c298
    3518:	00008cb1 	.word	0x00008cb1
    351c:	0000318d 	.word	0x0000318d
    3520:	0000b58c 	.word	0x0000b58c
    3524:	0000a0bd 	.word	0x0000a0bd
    3528:	10624dd3 	.word	0x10624dd3
    352c:	0000b5d4 	.word	0x0000b5d4
    3530:	0000b5a4 	.word	0x0000b5a4
    3534:	00002f4b 	.word	0x00002f4b

00003538 <dhcp_reboot>:
{
    3538:	b5f0      	push	{r4, r5, r6, r7, lr}
    353a:	b083      	sub	sp, #12
    353c:	4606      	mov	r6, r0
	struct dhcp *dhcp = netif->dhcp;
    353e:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
    3540:	482d      	ldr	r0, [pc, #180]	; (35f8 <dhcp_reboot+0xc0>)
    3542:	4b2e      	ldr	r3, [pc, #184]	; (35fc <dhcp_reboot+0xc4>)
    3544:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_REBOOTING);
    3546:	2103      	movs	r1, #3
    3548:	4620      	mov	r0, r4
    354a:	4b2d      	ldr	r3, [pc, #180]	; (3600 <dhcp_reboot+0xc8>)
    354c:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    354e:	2203      	movs	r2, #3
    3550:	4621      	mov	r1, r4
    3552:	4630      	mov	r0, r6
    3554:	4b2b      	ldr	r3, [pc, #172]	; (3604 <dhcp_reboot+0xcc>)
    3556:	4798      	blx	r3
	if (result == ERR_OK) {
    3558:	4605      	mov	r5, r0
    355a:	2800      	cmp	r0, #0
    355c:	d145      	bne.n	35ea <dhcp_reboot+0xb2>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    355e:	2202      	movs	r2, #2
    3560:	2139      	movs	r1, #57	; 0x39
    3562:	4620      	mov	r0, r4
    3564:	4f28      	ldr	r7, [pc, #160]	; (3608 <dhcp_reboot+0xd0>)
    3566:	47b8      	blx	r7
		dhcp_option_short(dhcp, 576);
    3568:	f44f 7110 	mov.w	r1, #576	; 0x240
    356c:	4620      	mov	r0, r4
    356e:	4b27      	ldr	r3, [pc, #156]	; (360c <dhcp_reboot+0xd4>)
    3570:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    3572:	2204      	movs	r2, #4
    3574:	2132      	movs	r1, #50	; 0x32
    3576:	4620      	mov	r0, r4
    3578:	47b8      	blx	r7
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    357a:	6a60      	ldr	r0, [r4, #36]	; 0x24
    357c:	4b24      	ldr	r3, [pc, #144]	; (3610 <dhcp_reboot+0xd8>)
    357e:	4798      	blx	r3
    3580:	4601      	mov	r1, r0
    3582:	4620      	mov	r0, r4
    3584:	4b23      	ldr	r3, [pc, #140]	; (3614 <dhcp_reboot+0xdc>)
    3586:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    3588:	4620      	mov	r0, r4
    358a:	4b23      	ldr	r3, [pc, #140]	; (3618 <dhcp_reboot+0xe0>)
    358c:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    358e:	8b21      	ldrh	r1, [r4, #24]
    3590:	31f0      	adds	r1, #240	; 0xf0
    3592:	b289      	uxth	r1, r1
    3594:	6920      	ldr	r0, [r4, #16]
    3596:	4b21      	ldr	r3, [pc, #132]	; (361c <dhcp_reboot+0xe4>)
    3598:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    359a:	6921      	ldr	r1, [r4, #16]
    359c:	6860      	ldr	r0, [r4, #4]
    359e:	9600      	str	r6, [sp, #0]
    35a0:	2343      	movs	r3, #67	; 0x43
    35a2:	4a1f      	ldr	r2, [pc, #124]	; (3620 <dhcp_reboot+0xe8>)
    35a4:	4e1f      	ldr	r6, [pc, #124]	; (3624 <dhcp_reboot+0xec>)
    35a6:	47b0      	blx	r6
		dhcp_delete_msg(dhcp);
    35a8:	4620      	mov	r0, r4
    35aa:	4b1f      	ldr	r3, [pc, #124]	; (3628 <dhcp_reboot+0xf0>)
    35ac:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
    35ae:	481f      	ldr	r0, [pc, #124]	; (362c <dhcp_reboot+0xf4>)
    35b0:	4b12      	ldr	r3, [pc, #72]	; (35fc <dhcp_reboot+0xc4>)
    35b2:	4798      	blx	r3
	dhcp->tries++;
    35b4:	7b61      	ldrb	r1, [r4, #13]
    35b6:	3101      	adds	r1, #1
    35b8:	b2c9      	uxtb	r1, r1
    35ba:	7361      	strb	r1, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    35bc:	2909      	cmp	r1, #9
    35be:	d818      	bhi.n	35f2 <dhcp_reboot+0xba>
    35c0:	ebc1 1341 	rsb	r3, r1, r1, lsl #5
    35c4:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    35c8:	00c9      	lsls	r1, r1, #3
    35ca:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    35cc:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    35d0:	4a17      	ldr	r2, [pc, #92]	; (3630 <dhcp_reboot+0xf8>)
    35d2:	fb82 0203 	smull	r0, r2, r2, r3
    35d6:	17db      	asrs	r3, r3, #31
    35d8:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    35dc:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    35de:	4815      	ldr	r0, [pc, #84]	; (3634 <dhcp_reboot+0xfc>)
    35e0:	4b15      	ldr	r3, [pc, #84]	; (3638 <dhcp_reboot+0x100>)
    35e2:	4798      	blx	r3
}
    35e4:	4628      	mov	r0, r5
    35e6:	b003      	add	sp, #12
    35e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    35ea:	4814      	ldr	r0, [pc, #80]	; (363c <dhcp_reboot+0x104>)
    35ec:	4b03      	ldr	r3, [pc, #12]	; (35fc <dhcp_reboot+0xc4>)
    35ee:	4798      	blx	r3
    35f0:	e7e0      	b.n	35b4 <dhcp_reboot+0x7c>
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    35f2:	f242 7110 	movw	r1, #10000	; 0x2710
    35f6:	e7e9      	b.n	35cc <dhcp_reboot+0x94>
    35f8:	0000b604 	.word	0x0000b604
    35fc:	0000a0bd 	.word	0x0000a0bd
    3600:	00002edd 	.word	0x00002edd
    3604:	00002fe1 	.word	0x00002fe1
    3608:	00002eed 	.word	0x00002eed
    360c:	00002f25 	.word	0x00002f25
    3610:	00002ed1 	.word	0x00002ed1
    3614:	00002f4b 	.word	0x00002f4b
    3618:	00002f91 	.word	0x00002f91
    361c:	00005e2d 	.word	0x00005e2d
    3620:	0000c298 	.word	0x0000c298
    3624:	00008cb1 	.word	0x00008cb1
    3628:	0000318d 	.word	0x0000318d
    362c:	0000b614 	.word	0x0000b614
    3630:	10624dd3 	.word	0x10624dd3
    3634:	0000b65c 	.word	0x0000b65c
    3638:	00009fd5 	.word	0x00009fd5
    363c:	0000b62c 	.word	0x0000b62c

00003640 <dhcp_check>:
{
    3640:	b570      	push	{r4, r5, r6, lr}
    3642:	4605      	mov	r5, r0
	struct dhcp *dhcp = netif->dhcp;
    3644:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    3646:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
    364a:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
    364e:	4601      	mov	r1, r0
    3650:	480e      	ldr	r0, [pc, #56]	; (368c <dhcp_check+0x4c>)
    3652:	4e0f      	ldr	r6, [pc, #60]	; (3690 <dhcp_check+0x50>)
    3654:	47b0      	blx	r6
	dhcp_set_state(dhcp, DHCP_CHECKING);
    3656:	2108      	movs	r1, #8
    3658:	4620      	mov	r0, r4
    365a:	4b0e      	ldr	r3, [pc, #56]	; (3694 <dhcp_check+0x54>)
    365c:	4798      	blx	r3
	result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
    365e:	2200      	movs	r2, #0
    3660:	f104 0124 	add.w	r1, r4, #36	; 0x24
    3664:	4628      	mov	r0, r5
    3666:	4b0c      	ldr	r3, [pc, #48]	; (3698 <dhcp_check+0x58>)
    3668:	4798      	blx	r3
	if (result != ERR_OK) {
    366a:	b950      	cbnz	r0, 3682 <dhcp_check+0x42>
	dhcp->tries++;
    366c:	7b63      	ldrb	r3, [r4, #13]
    366e:	3301      	adds	r3, #1
    3670:	7363      	strb	r3, [r4, #13]
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3672:	2301      	movs	r3, #1
    3674:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    3676:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    367a:	4808      	ldr	r0, [pc, #32]	; (369c <dhcp_check+0x5c>)
    367c:	4b04      	ldr	r3, [pc, #16]	; (3690 <dhcp_check+0x50>)
    367e:	4798      	blx	r3
    3680:	bd70      	pop	{r4, r5, r6, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    3682:	4807      	ldr	r0, [pc, #28]	; (36a0 <dhcp_check+0x60>)
    3684:	4b07      	ldr	r3, [pc, #28]	; (36a4 <dhcp_check+0x64>)
    3686:	4798      	blx	r3
    3688:	e7f0      	b.n	366c <dhcp_check+0x2c>
    368a:	bf00      	nop
    368c:	0000b68c 	.word	0x0000b68c
    3690:	00009fd5 	.word	0x00009fd5
    3694:	00002edd 	.word	0x00002edd
    3698:	000091ad 	.word	0x000091ad
    369c:	0000b6d0 	.word	0x0000b6d0
    36a0:	0000b6a8 	.word	0x0000b6a8
    36a4:	0000a0bd 	.word	0x0000a0bd

000036a8 <dhcp_bind>:
{
    36a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    36aa:	b085      	sub	sp, #20
	LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
    36ac:	2800      	cmp	r0, #0
    36ae:	f000 8085 	beq.w	37bc <dhcp_bind+0x114>
    36b2:	4605      	mov	r5, r0
	dhcp = netif->dhcp;
    36b4:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
    36b6:	2c00      	cmp	r4, #0
    36b8:	f000 8088 	beq.w	37cc <dhcp_bind+0x124>
	LWIP_DEBUGF(
    36bc:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
    36c0:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
    36c4:	f890 1038 	ldrb.w	r1, [r0, #56]	; 0x38
    36c8:	9100      	str	r1, [sp, #0]
    36ca:	4601      	mov	r1, r0
    36cc:	484e      	ldr	r0, [pc, #312]	; (3808 <dhcp_bind+0x160>)
    36ce:	4e4f      	ldr	r6, [pc, #316]	; (380c <dhcp_bind+0x164>)
    36d0:	47b0      	blx	r6
	if (dhcp->offered_t1_renew != 0xffffffffUL) {
    36d2:	6b61      	ldr	r1, [r4, #52]	; 0x34
    36d4:	f1b1 3fff 	cmp.w	r1, #4294967295
    36d8:	d018      	beq.n	370c <dhcp_bind+0x64>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    36da:	484d      	ldr	r0, [pc, #308]	; (3810 <dhcp_bind+0x168>)
    36dc:	47b0      	blx	r6
		timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    36de:	6b62      	ldr	r2, [r4, #52]	; 0x34
    36e0:	f102 031e 	add.w	r3, r2, #30
    36e4:	494b      	ldr	r1, [pc, #300]	; (3814 <dhcp_bind+0x16c>)
    36e6:	fba1 1303 	umull	r1, r3, r1, r3
    36ea:	095b      	lsrs	r3, r3, #5
		dhcp->t1_timeout = (u16_t)timeout;
    36ec:	f64f 71ff 	movw	r1, #65535	; 0xffff
    36f0:	428b      	cmp	r3, r1
    36f2:	bf28      	it	cs
    36f4:	460b      	movcs	r3, r1
    36f6:	b29b      	uxth	r3, r3
		if (dhcp->t1_timeout == 0) {
    36f8:	2b00      	cmp	r3, #0
    36fa:	d06f      	beq.n	37dc <dhcp_bind+0x134>
		dhcp->t1_timeout = (u16_t)timeout;
    36fc:	83a3      	strh	r3, [r4, #28]
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    36fe:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    3702:	fb01 f102 	mul.w	r1, r1, r2
    3706:	4844      	ldr	r0, [pc, #272]	; (3818 <dhcp_bind+0x170>)
    3708:	4b40      	ldr	r3, [pc, #256]	; (380c <dhcp_bind+0x164>)
    370a:	4798      	blx	r3
	if (dhcp->offered_t2_rebind != 0xffffffffUL) {
    370c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    370e:	f1b1 3fff 	cmp.w	r1, #4294967295
    3712:	d019      	beq.n	3748 <dhcp_bind+0xa0>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    3714:	4841      	ldr	r0, [pc, #260]	; (381c <dhcp_bind+0x174>)
    3716:	4b3d      	ldr	r3, [pc, #244]	; (380c <dhcp_bind+0x164>)
    3718:	4798      	blx	r3
		timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    371a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    371c:	f102 031e 	add.w	r3, r2, #30
    3720:	493c      	ldr	r1, [pc, #240]	; (3814 <dhcp_bind+0x16c>)
    3722:	fba1 1303 	umull	r1, r3, r1, r3
    3726:	095b      	lsrs	r3, r3, #5
		dhcp->t2_timeout = (u16_t)timeout;
    3728:	f64f 71ff 	movw	r1, #65535	; 0xffff
    372c:	428b      	cmp	r3, r1
    372e:	bf28      	it	cs
    3730:	460b      	movcs	r3, r1
    3732:	b29b      	uxth	r3, r3
		if (dhcp->t2_timeout == 0) {
    3734:	2b00      	cmp	r3, #0
    3736:	d054      	beq.n	37e2 <dhcp_bind+0x13a>
		dhcp->t2_timeout = (u16_t)timeout;
    3738:	83e3      	strh	r3, [r4, #30]
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    373a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    373e:	fb01 f102 	mul.w	r1, r1, r2
    3742:	4835      	ldr	r0, [pc, #212]	; (3818 <dhcp_bind+0x170>)
    3744:	4b31      	ldr	r3, [pc, #196]	; (380c <dhcp_bind+0x164>)
    3746:	4798      	blx	r3
	if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
    3748:	8be3      	ldrh	r3, [r4, #30]
    374a:	8ba2      	ldrh	r2, [r4, #28]
    374c:	429a      	cmp	r2, r3
    374e:	d302      	bcc.n	3756 <dhcp_bind+0xae>
    3750:	b10b      	cbz	r3, 3756 <dhcp_bind+0xae>
		dhcp->t1_timeout = 0;
    3752:	2300      	movs	r3, #0
    3754:	83a3      	strh	r3, [r4, #28]
	if (dhcp->subnet_mask_given) {
    3756:	7ba3      	ldrb	r3, [r4, #14]
    3758:	2b00      	cmp	r3, #0
    375a:	d045      	beq.n	37e8 <dhcp_bind+0x140>
		ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
    375c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    375e:	9303      	str	r3, [sp, #12]
	ip_addr_copy(gw_addr, dhcp->offered_gw_addr);
    3760:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    3762:	9302      	str	r3, [sp, #8]
	if (ip_addr_isany(&gw_addr)) {
    3764:	b92b      	cbnz	r3, 3772 <dhcp_bind+0xca>
		ip_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
    3766:	6a63      	ldr	r3, [r4, #36]	; 0x24
    3768:	9a03      	ldr	r2, [sp, #12]
    376a:	4013      	ands	r3, r2
		ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
    376c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    3770:	9302      	str	r3, [sp, #8]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE,
    3772:	4626      	mov	r6, r4
    3774:	f856 1f24 	ldr.w	r1, [r6, #36]!
    3778:	4829      	ldr	r0, [pc, #164]	; (3820 <dhcp_bind+0x178>)
    377a:	4f24      	ldr	r7, [pc, #144]	; (380c <dhcp_bind+0x164>)
    377c:	47b8      	blx	r7
	netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
    377e:	4631      	mov	r1, r6
    3780:	4628      	mov	r0, r5
    3782:	4b28      	ldr	r3, [pc, #160]	; (3824 <dhcp_bind+0x17c>)
    3784:	4798      	blx	r3
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08" X32_F "\n", ip4_addr_get_u32(&sn_mask)));
    3786:	ae04      	add	r6, sp, #16
    3788:	f856 1d04 	ldr.w	r1, [r6, #-4]!
    378c:	4826      	ldr	r0, [pc, #152]	; (3828 <dhcp_bind+0x180>)
    378e:	47b8      	blx	r7
	netif_set_netmask(netif, &sn_mask);
    3790:	4631      	mov	r1, r6
    3792:	4628      	mov	r0, r5
    3794:	4b25      	ldr	r3, [pc, #148]	; (382c <dhcp_bind+0x184>)
    3796:	4798      	blx	r3
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08" X32_F "\n", ip4_addr_get_u32(&gw_addr)));
    3798:	ae04      	add	r6, sp, #16
    379a:	f856 1d08 	ldr.w	r1, [r6, #-8]!
    379e:	4824      	ldr	r0, [pc, #144]	; (3830 <dhcp_bind+0x188>)
    37a0:	47b8      	blx	r7
	netif_set_gw(netif, &gw_addr);
    37a2:	4631      	mov	r1, r6
    37a4:	4628      	mov	r0, r5
    37a6:	4b23      	ldr	r3, [pc, #140]	; (3834 <dhcp_bind+0x18c>)
    37a8:	4798      	blx	r3
	netif_set_up(netif);
    37aa:	4628      	mov	r0, r5
    37ac:	4b22      	ldr	r3, [pc, #136]	; (3838 <dhcp_bind+0x190>)
    37ae:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_BOUND);
    37b0:	210a      	movs	r1, #10
    37b2:	4620      	mov	r0, r4
    37b4:	4b21      	ldr	r3, [pc, #132]	; (383c <dhcp_bind+0x194>)
    37b6:	4798      	blx	r3
}
    37b8:	b005      	add	sp, #20
    37ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
	LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
    37bc:	4b20      	ldr	r3, [pc, #128]	; (3840 <dhcp_bind+0x198>)
    37be:	f240 32a3 	movw	r2, #931	; 0x3a3
    37c2:	4920      	ldr	r1, [pc, #128]	; (3844 <dhcp_bind+0x19c>)
    37c4:	4820      	ldr	r0, [pc, #128]	; (3848 <dhcp_bind+0x1a0>)
    37c6:	4c11      	ldr	r4, [pc, #68]	; (380c <dhcp_bind+0x164>)
    37c8:	47a0      	blx	r4
    37ca:	e7fe      	b.n	37ca <dhcp_bind+0x122>
	LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
    37cc:	4b1c      	ldr	r3, [pc, #112]	; (3840 <dhcp_bind+0x198>)
    37ce:	f240 32a5 	movw	r2, #933	; 0x3a5
    37d2:	491e      	ldr	r1, [pc, #120]	; (384c <dhcp_bind+0x1a4>)
    37d4:	481c      	ldr	r0, [pc, #112]	; (3848 <dhcp_bind+0x1a0>)
    37d6:	4c0d      	ldr	r4, [pc, #52]	; (380c <dhcp_bind+0x164>)
    37d8:	47a0      	blx	r4
    37da:	e7fe      	b.n	37da <dhcp_bind+0x132>
			dhcp->t1_timeout = 1;
    37dc:	2301      	movs	r3, #1
    37de:	83a3      	strh	r3, [r4, #28]
    37e0:	e78d      	b.n	36fe <dhcp_bind+0x56>
			dhcp->t2_timeout = 1;
    37e2:	2301      	movs	r3, #1
    37e4:	83e3      	strh	r3, [r4, #30]
    37e6:	e7a8      	b.n	373a <dhcp_bind+0x92>
		u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
    37e8:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
		if (first_octet <= 127) {
    37ec:	f013 0f80 	tst.w	r3, #128	; 0x80
    37f0:	d102      	bne.n	37f8 <dhcp_bind+0x150>
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
    37f2:	23ff      	movs	r3, #255	; 0xff
    37f4:	9303      	str	r3, [sp, #12]
    37f6:	e7b3      	b.n	3760 <dhcp_bind+0xb8>
		} else if (first_octet >= 192) {
    37f8:	2bbf      	cmp	r3, #191	; 0xbf
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
    37fa:	bf8c      	ite	hi
    37fc:	f06f 437f 	mvnhi.w	r3, #4278190080	; 0xff000000
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
    3800:	f64f 73ff 	movwls	r3, #65535	; 0xffff
    3804:	9303      	str	r3, [sp, #12]
    3806:	e7ab      	b.n	3760 <dhcp_bind+0xb8>
    3808:	0000b734 	.word	0x0000b734
    380c:	00009fd5 	.word	0x00009fd5
    3810:	0000b754 	.word	0x0000b754
    3814:	88888889 	.word	0x88888889
    3818:	0000b77c 	.word	0x0000b77c
    381c:	0000b7a8 	.word	0x0000b7a8
    3820:	0000b7d0 	.word	0x0000b7d0
    3824:	000059dd 	.word	0x000059dd
    3828:	0000b7ec 	.word	0x0000b7ec
    382c:	00005acd 	.word	0x00005acd
    3830:	0000b808 	.word	0x0000b808
    3834:	00005ac1 	.word	0x00005ac1
    3838:	00005ae5 	.word	0x00005ae5
    383c:	00002edd 	.word	0x00002edd
    3840:	0000b2a0 	.word	0x0000b2a0
    3844:	0000b700 	.word	0x0000b700
    3848:	0000b2e8 	.word	0x0000b2e8
    384c:	0000b71c 	.word	0x0000b71c

00003850 <dhcp_recv>:
{
    3850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3854:	b08d      	sub	sp, #52	; 0x34
    3856:	4681      	mov	r9, r0
    3858:	4693      	mov	fp, r2
	struct dhcp *    dhcp      = netif->dhcp;
    385a:	6a82      	ldr	r2, [r0, #40]	; 0x28
    385c:	9204      	str	r2, [sp, #16]
	struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
    385e:	f8db 5004 	ldr.w	r5, [fp, #4]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    3862:	7859      	ldrb	r1, [r3, #1]
    3864:	781a      	ldrb	r2, [r3, #0]
    3866:	f8bd 0058 	ldrh.w	r0, [sp, #88]	; 0x58
    386a:	9002      	str	r0, [sp, #8]
    386c:	78d8      	ldrb	r0, [r3, #3]
    386e:	9001      	str	r0, [sp, #4]
    3870:	789b      	ldrb	r3, [r3, #2]
    3872:	9300      	str	r3, [sp, #0]
    3874:	460b      	mov	r3, r1
    3876:	4659      	mov	r1, fp
    3878:	4859      	ldr	r0, [pc, #356]	; (39e0 <dhcp_recv+0x190>)
    387a:	4c5a      	ldr	r4, [pc, #360]	; (39e4 <dhcp_recv+0x194>)
    387c:	47a0      	blx	r4
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->len = %" U16_F "\n", p->len));
    387e:	f8bb 100a 	ldrh.w	r1, [fp, #10]
    3882:	4859      	ldr	r0, [pc, #356]	; (39e8 <dhcp_recv+0x198>)
    3884:	47a0      	blx	r4
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %" U16_F "\n", p->tot_len));
    3886:	f8bb 1008 	ldrh.w	r1, [fp, #8]
    388a:	4858      	ldr	r0, [pc, #352]	; (39ec <dhcp_recv+0x19c>)
    388c:	47a0      	blx	r4
	if (p->len < DHCP_MIN_REPLY_LEN) {
    388e:	f8bb 300a 	ldrh.w	r3, [fp, #10]
    3892:	2b2b      	cmp	r3, #43	; 0x2b
    3894:	d920      	bls.n	38d8 <dhcp_recv+0x88>
	if (reply_msg->op != DHCP_BOOTREPLY) {
    3896:	7829      	ldrb	r1, [r5, #0]
    3898:	2902      	cmp	r1, #2
    389a:	d121      	bne.n	38e0 <dhcp_recv+0x90>
	for (i = 0; i < netif->hwaddr_len; i++) {
    389c:	f899 702e 	ldrb.w	r7, [r9, #46]	; 0x2e
    38a0:	b367      	cbz	r7, 38fc <dhcp_recv+0xac>
		if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    38a2:	f899 202f 	ldrb.w	r2, [r9, #47]	; 0x2f
    38a6:	7f28      	ldrb	r0, [r5, #28]
    38a8:	4282      	cmp	r2, r0
    38aa:	d125      	bne.n	38f8 <dhcp_recv+0xa8>
    38ac:	f109 0630 	add.w	r6, r9, #48	; 0x30
    38b0:	f105 041d 	add.w	r4, r5, #29
    38b4:	2301      	movs	r3, #1
	for (i = 0; i < netif->hwaddr_len; i++) {
    38b6:	b2da      	uxtb	r2, r3
    38b8:	42ba      	cmp	r2, r7
    38ba:	d21f      	bcs.n	38fc <dhcp_recv+0xac>
		if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    38bc:	4619      	mov	r1, r3
    38be:	f816 2b01 	ldrb.w	r2, [r6], #1
    38c2:	f814 0b01 	ldrb.w	r0, [r4], #1
    38c6:	3301      	adds	r3, #1
    38c8:	4282      	cmp	r2, r0
    38ca:	d0f4      	beq.n	38b6 <dhcp_recv+0x66>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    38cc:	9000      	str	r0, [sp, #0]
    38ce:	460b      	mov	r3, r1
    38d0:	4847      	ldr	r0, [pc, #284]	; (39f0 <dhcp_recv+0x1a0>)
    38d2:	4c44      	ldr	r4, [pc, #272]	; (39e4 <dhcp_recv+0x194>)
    38d4:	47a0      	blx	r4
			goto free_pbuf_and_return;
    38d6:	e006      	b.n	38e6 <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    38d8:	4846      	ldr	r0, [pc, #280]	; (39f4 <dhcp_recv+0x1a4>)
    38da:	4b47      	ldr	r3, [pc, #284]	; (39f8 <dhcp_recv+0x1a8>)
    38dc:	4798      	blx	r3
		goto free_pbuf_and_return;
    38de:	e002      	b.n	38e6 <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    38e0:	4846      	ldr	r0, [pc, #280]	; (39fc <dhcp_recv+0x1ac>)
    38e2:	4b40      	ldr	r3, [pc, #256]	; (39e4 <dhcp_recv+0x194>)
    38e4:	4798      	blx	r3
	dhcp->msg_in = NULL;
    38e6:	2300      	movs	r3, #0
    38e8:	9a04      	ldr	r2, [sp, #16]
    38ea:	6093      	str	r3, [r2, #8]
	pbuf_free(p);
    38ec:	4658      	mov	r0, fp
    38ee:	4b44      	ldr	r3, [pc, #272]	; (3a00 <dhcp_recv+0x1b0>)
    38f0:	4798      	blx	r3
}
    38f2:	b00d      	add	sp, #52	; 0x34
    38f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    38f8:	2100      	movs	r1, #0
    38fa:	e7e7      	b.n	38cc <dhcp_recv+0x7c>
	if (ntohl(reply_msg->xid) != dhcp->xid) {
    38fc:	6868      	ldr	r0, [r5, #4]
    38fe:	4b41      	ldr	r3, [pc, #260]	; (3a04 <dhcp_recv+0x1b4>)
    3900:	4798      	blx	r3
    3902:	9c04      	ldr	r4, [sp, #16]
    3904:	6823      	ldr	r3, [r4, #0]
    3906:	4298      	cmp	r0, r3
    3908:	d008      	beq.n	391c <dhcp_recv+0xcc>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    390a:	6868      	ldr	r0, [r5, #4]
    390c:	4b3d      	ldr	r3, [pc, #244]	; (3a04 <dhcp_recv+0x1b4>)
    390e:	4798      	blx	r3
    3910:	6822      	ldr	r2, [r4, #0]
    3912:	4601      	mov	r1, r0
    3914:	483c      	ldr	r0, [pc, #240]	; (3a08 <dhcp_recv+0x1b8>)
    3916:	4b33      	ldr	r3, [pc, #204]	; (39e4 <dhcp_recv+0x194>)
    3918:	4798      	blx	r3
		goto free_pbuf_and_return;
    391a:	e7e4      	b.n	38e6 <dhcp_recv+0x96>
	dhcp_clear_all_options(dhcp);
    391c:	4b3b      	ldr	r3, [pc, #236]	; (3a0c <dhcp_recv+0x1bc>)
    391e:	2200      	movs	r2, #0
    3920:	601a      	str	r2, [r3, #0]
    3922:	605a      	str	r2, [r3, #4]
    3924:	811a      	strh	r2, [r3, #8]
	if (p->len < DHCP_SNAME_OFS) {
    3926:	f8bb 300a 	ldrh.w	r3, [fp, #10]
    392a:	2b2b      	cmp	r3, #43	; 0x2b
    392c:	f240 8259 	bls.w	3de2 <dhcp_recv+0x592>
	dhcp->msg_in = (struct dhcp_msg *)p->payload;
    3930:	f8db 3004 	ldr.w	r3, [fp, #4]
    3934:	9a04      	ldr	r2, [sp, #16]
    3936:	6093      	str	r3, [r2, #8]
	options_idx_max = p->tot_len;
    3938:	f8bb a008 	ldrh.w	sl, [fp, #8]
	int          parse_sname_as_options = 0;
    393c:	2300      	movs	r3, #0
    393e:	9306      	str	r3, [sp, #24]
	options_idx = DHCP_OPTIONS_OFS;
    3940:	24f0      	movs	r4, #240	; 0xf0
    3942:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
    3946:	f8cd b014 	str.w	fp, [sp, #20]
	while ((q != NULL) && (options_idx >= q->len)) {
    394a:	9a05      	ldr	r2, [sp, #20]
    394c:	2a00      	cmp	r2, #0
    394e:	f000 8243 	beq.w	3dd8 <dhcp_recv+0x588>
    3952:	8953      	ldrh	r3, [r2, #10]
    3954:	429c      	cmp	r4, r3
    3956:	f0c0 82fd 	bcc.w	3f54 <dhcp_recv+0x704>
		options_idx -= q->len;
    395a:	1ae4      	subs	r4, r4, r3
    395c:	b2a4      	uxth	r4, r4
		options_idx_max -= q->len;
    395e:	ebaa 0a03 	sub.w	sl, sl, r3
    3962:	fa1f fa8a 	uxth.w	sl, sl
		q = q->next;
    3966:	6812      	ldr	r2, [r2, #0]
	while ((q != NULL) && (options_idx >= q->len)) {
    3968:	2a00      	cmp	r2, #0
    396a:	f000 8238 	beq.w	3dde <dhcp_recv+0x58e>
    396e:	8953      	ldrh	r3, [r2, #10]
    3970:	42a3      	cmp	r3, r4
    3972:	d9f2      	bls.n	395a <dhcp_recv+0x10a>
    3974:	4693      	mov	fp, r2
	options    = (u8_t *)q->payload;
    3976:	f8db 3004 	ldr.w	r3, [fp, #4]
    397a:	9307      	str	r3, [sp, #28]
	while ((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    397c:	4622      	mov	r2, r4
    397e:	5d1b      	ldrb	r3, [r3, r4]
    3980:	2bff      	cmp	r3, #255	; 0xff
    3982:	d002      	beq.n	398a <dhcp_recv+0x13a>
    3984:	45a2      	cmp	sl, r4
    3986:	f200 80a3 	bhi.w	3ad0 <dhcp_recv+0x280>
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
    398a:	4b20      	ldr	r3, [pc, #128]	; (3a0c <dhcp_recv+0x1bc>)
    398c:	781b      	ldrb	r3, [r3, #0]
    398e:	2b00      	cmp	r3, #0
    3990:	f000 8210 	beq.w	3db4 <dhcp_recv+0x564>
		u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    3994:	4b1e      	ldr	r3, [pc, #120]	; (3a10 <dhcp_recv+0x1c0>)
    3996:	6819      	ldr	r1, [r3, #0]
		dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    3998:	2200      	movs	r2, #0
    399a:	4b1c      	ldr	r3, [pc, #112]	; (3a0c <dhcp_recv+0x1bc>)
    399c:	701a      	strb	r2, [r3, #0]
		if (overload == DHCP_OVERLOAD_FILE) {
    399e:	2901      	cmp	r1, #1
    39a0:	f040 81f2 	bne.w	3d88 <dhcp_recv+0x538>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    39a4:	481b      	ldr	r0, [pc, #108]	; (3a14 <dhcp_recv+0x1c4>)
    39a6:	4b14      	ldr	r3, [pc, #80]	; (39f8 <dhcp_recv+0x1a8>)
    39a8:	4798      	blx	r3
		options_idx_max       = DHCP_FILE_OFS + DHCP_FILE_LEN;
    39aa:	f04f 0aec 	mov.w	sl, #236	; 0xec
		options_idx           = DHCP_FILE_OFS;
    39ae:	246c      	movs	r4, #108	; 0x6c
    39b0:	e7cb      	b.n	394a <dhcp_recv+0xfa>
		parse_sname_as_options = 0;
    39b2:	2300      	movs	r3, #0
    39b4:	9306      	str	r3, [sp, #24]
		options_idx_max        = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
    39b6:	f04f 0a6c 	mov.w	sl, #108	; 0x6c
		options_idx            = DHCP_SNAME_OFS;
    39ba:	242c      	movs	r4, #44	; 0x2c
    39bc:	e7c5      	b.n	394a <dhcp_recv+0xfa>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    39be:	f8db 2000 	ldr.w	r2, [fp]
    39c2:	2a00      	cmp	r2, #0
    39c4:	f000 830c 	beq.w	3fe0 <dhcp_recv+0x790>
    39c8:	6852      	ldr	r2, [r2, #4]
    39ca:	7817      	ldrb	r7, [r2, #0]
    39cc:	e089      	b.n	3ae2 <dhcp_recv+0x292>
			offset--;
    39ce:	3c01      	subs	r4, #1
    39d0:	b2a4      	uxth	r4, r4
			decode_len = len = 0;
    39d2:	2700      	movs	r7, #0
    39d4:	3402      	adds	r4, #2
		offset += len + 2;
    39d6:	fa17 f484 	uxtah	r4, r7, r4
    39da:	b2a4      	uxth	r4, r4
    39dc:	e055      	b.n	3a8a <dhcp_recv+0x23a>
    39de:	bf00      	nop
    39e0:	0000b824 	.word	0x0000b824
    39e4:	00009fd5 	.word	0x00009fd5
    39e8:	0000b864 	.word	0x0000b864
    39ec:	0000b878 	.word	0x0000b878
    39f0:	0000b8e0 	.word	0x0000b8e0
    39f4:	0000b890 	.word	0x0000b890
    39f8:	0000a0bd 	.word	0x0000a0bd
    39fc:	0000b8b8 	.word	0x0000b8b8
    3a00:	00005c89 	.word	0x00005c89
    3a04:	00002ed1 	.word	0x00002ed1
    3a08:	0000b91c 	.word	0x0000b91c
    3a0c:	200082f8 	.word	0x200082f8
    3a10:	20008304 	.word	0x20008304
    3a14:	0000b9dc 	.word	0x0000b9dc
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3a18:	2f04      	cmp	r7, #4
    3a1a:	f040 80e1 	bne.w	3be0 <dhcp_recv+0x390>
		decode_len = len;
    3a1e:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
    3a20:	2606      	movs	r6, #6
    3a22:	1ca3      	adds	r3, r4, #2
		offset += len + 2;
    3a24:	fa17 f783 	uxtah	r7, r7, r3
    3a28:	b2bb      	uxth	r3, r7
    3a2a:	9308      	str	r3, [sp, #32]
			u32_t value = 0;
    3a2c:	2300      	movs	r3, #0
    3a2e:	930b      	str	r3, [sp, #44]	; 0x2c
			if (!dhcp_option_given(dhcp, decode_idx)) {
    3a30:	4bb9      	ldr	r3, [pc, #740]	; (3d18 <dhcp_recv+0x4c8>)
    3a32:	5d9b      	ldrb	r3, [r3, r6]
    3a34:	bb43      	cbnz	r3, 3a88 <dhcp_recv+0x238>
		u16_t val_offset = offset + 2;
    3a36:	3402      	adds	r4, #2
    3a38:	b2a4      	uxth	r4, r4
    3a3a:	4fb7      	ldr	r7, [pc, #732]	; (3d18 <dhcp_recv+0x4c8>)
    3a3c:	4437      	add	r7, r6
    3a3e:	4bb7      	ldr	r3, [pc, #732]	; (3d1c <dhcp_recv+0x4cc>)
    3a40:	eb03 0886 	add.w	r8, r3, r6, lsl #2
				pbuf_copy_partial(q, &value, copy_len, val_offset);
    3a44:	f8df 9300 	ldr.w	r9, [pc, #768]	; 3d48 <dhcp_recv+0x4f8>
				copy_len = LWIP_MIN(decode_len, 4);
    3a48:	2d03      	cmp	r5, #3
    3a4a:	bf94      	ite	ls
    3a4c:	462a      	movls	r2, r5
    3a4e:	2204      	movhi	r2, #4
				pbuf_copy_partial(q, &value, copy_len, val_offset);
    3a50:	4623      	mov	r3, r4
    3a52:	b292      	uxth	r2, r2
    3a54:	a90b      	add	r1, sp, #44	; 0x2c
    3a56:	4658      	mov	r0, fp
    3a58:	47c8      	blx	r9
				if (decode_len > 4) {
    3a5a:	2d04      	cmp	r5, #4
    3a5c:	f240 8176 	bls.w	3d4c <dhcp_recv+0x4fc>
					LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
    3a60:	f015 0f03 	tst.w	r5, #3
    3a64:	f040 8150 	bne.w	3d08 <dhcp_recv+0x4b8>
					dhcp_got_option(dhcp, decode_idx);
    3a68:	2301      	movs	r3, #1
    3a6a:	703b      	strb	r3, [r7, #0]
					dhcp_set_option_value(dhcp, decode_idx, htonl(value));
    3a6c:	980b      	ldr	r0, [sp, #44]	; 0x2c
    3a6e:	4bac      	ldr	r3, [pc, #688]	; (3d20 <dhcp_recv+0x4d0>)
    3a70:	4798      	blx	r3
    3a72:	f848 0f04 	str.w	r0, [r8, #4]!
					decode_len -= 4;
    3a76:	3d04      	subs	r5, #4
    3a78:	b2ed      	uxtb	r5, r5
					val_offset += 4;
    3a7a:	3404      	adds	r4, #4
    3a7c:	b2a4      	uxth	r4, r4
					decode_idx++;
    3a7e:	3601      	adds	r6, #1
			if (!dhcp_option_given(dhcp, decode_idx)) {
    3a80:	f817 3f01 	ldrb.w	r3, [r7, #1]!
    3a84:	2b00      	cmp	r3, #0
    3a86:	d0df      	beq.n	3a48 <dhcp_recv+0x1f8>
    3a88:	9c08      	ldr	r4, [sp, #32]
		if (offset >= q->len) {
    3a8a:	f8bb 300a 	ldrh.w	r3, [fp, #10]
    3a8e:	42a3      	cmp	r3, r4
    3a90:	d811      	bhi.n	3ab6 <dhcp_recv+0x266>
			offset -= q->len;
    3a92:	1ae4      	subs	r4, r4, r3
    3a94:	b2a4      	uxth	r4, r4
			offset_max -= q->len;
    3a96:	ebaa 0a03 	sub.w	sl, sl, r3
    3a9a:	fa1f fa8a 	uxth.w	sl, sl
			if ((offset < offset_max) && offset_max) {
    3a9e:	4554      	cmp	r4, sl
    3aa0:	f4bf af73 	bcs.w	398a <dhcp_recv+0x13a>
    3aa4:	f1ba 0f00 	cmp.w	sl, #0
    3aa8:	f43f af6f 	beq.w	398a <dhcp_recv+0x13a>
				q = q->next;
    3aac:	f8db b000 	ldr.w	fp, [fp]
				options = (u8_t *)q->payload;
    3ab0:	f8db 3004 	ldr.w	r3, [fp, #4]
    3ab4:	9307      	str	r3, [sp, #28]
	while ((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    3ab6:	f1bb 0f00 	cmp.w	fp, #0
    3aba:	f43f af66 	beq.w	398a <dhcp_recv+0x13a>
    3abe:	4622      	mov	r2, r4
    3ac0:	9b07      	ldr	r3, [sp, #28]
    3ac2:	5d1b      	ldrb	r3, [r3, r4]
    3ac4:	2bff      	cmp	r3, #255	; 0xff
    3ac6:	f43f af60 	beq.w	398a <dhcp_recv+0x13a>
    3aca:	45a2      	cmp	sl, r4
    3acc:	f67f af5d 	bls.w	398a <dhcp_recv+0x13a>
		if (offset + 1 < q->len) {
    3ad0:	1c61      	adds	r1, r4, #1
    3ad2:	f8bb 000a 	ldrh.w	r0, [fp, #10]
    3ad6:	4281      	cmp	r1, r0
    3ad8:	f6bf af71 	bge.w	39be <dhcp_recv+0x16e>
			len = options[offset + 1];
    3adc:	9907      	ldr	r1, [sp, #28]
    3ade:	440a      	add	r2, r1
    3ae0:	7857      	ldrb	r7, [r2, #1]
		switch (op) {
    3ae2:	2b3b      	cmp	r3, #59	; 0x3b
    3ae4:	f200 810b 	bhi.w	3cfe <dhcp_recv+0x4ae>
    3ae8:	a201      	add	r2, pc, #4	; (adr r2, 3af0 <dhcp_recv+0x2a0>)
    3aea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    3aee:	bf00      	nop
    3af0:	000039cf 	.word	0x000039cf
    3af4:	00003a19 	.word	0x00003a19
    3af8:	00003cff 	.word	0x00003cff
    3afc:	00003bf3 	.word	0x00003bf3
    3b00:	00003cff 	.word	0x00003cff
    3b04:	00003cff 	.word	0x00003cff
    3b08:	00003c0f 	.word	0x00003c0f
    3b0c:	00003cff 	.word	0x00003cff
    3b10:	00003cff 	.word	0x00003cff
    3b14:	00003cff 	.word	0x00003cff
    3b18:	00003cff 	.word	0x00003cff
    3b1c:	00003cff 	.word	0x00003cff
    3b20:	00003cff 	.word	0x00003cff
    3b24:	00003cff 	.word	0x00003cff
    3b28:	00003cff 	.word	0x00003cff
    3b2c:	00003cff 	.word	0x00003cff
    3b30:	00003cff 	.word	0x00003cff
    3b34:	00003cff 	.word	0x00003cff
    3b38:	00003cff 	.word	0x00003cff
    3b3c:	00003cff 	.word	0x00003cff
    3b40:	00003cff 	.word	0x00003cff
    3b44:	00003cff 	.word	0x00003cff
    3b48:	00003cff 	.word	0x00003cff
    3b4c:	00003cff 	.word	0x00003cff
    3b50:	00003cff 	.word	0x00003cff
    3b54:	00003cff 	.word	0x00003cff
    3b58:	00003cff 	.word	0x00003cff
    3b5c:	00003cff 	.word	0x00003cff
    3b60:	00003cff 	.word	0x00003cff
    3b64:	00003cff 	.word	0x00003cff
    3b68:	00003cff 	.word	0x00003cff
    3b6c:	00003cff 	.word	0x00003cff
    3b70:	00003cff 	.word	0x00003cff
    3b74:	00003cff 	.word	0x00003cff
    3b78:	00003cff 	.word	0x00003cff
    3b7c:	00003cff 	.word	0x00003cff
    3b80:	00003cff 	.word	0x00003cff
    3b84:	00003cff 	.word	0x00003cff
    3b88:	00003cff 	.word	0x00003cff
    3b8c:	00003cff 	.word	0x00003cff
    3b90:	00003cff 	.word	0x00003cff
    3b94:	00003cff 	.word	0x00003cff
    3b98:	00003cff 	.word	0x00003cff
    3b9c:	00003cff 	.word	0x00003cff
    3ba0:	00003cff 	.word	0x00003cff
    3ba4:	00003cff 	.word	0x00003cff
    3ba8:	00003cff 	.word	0x00003cff
    3bac:	00003cff 	.word	0x00003cff
    3bb0:	00003cff 	.word	0x00003cff
    3bb4:	00003cff 	.word	0x00003cff
    3bb8:	00003cff 	.word	0x00003cff
    3bbc:	00003c57 	.word	0x00003c57
    3bc0:	00003c73 	.word	0x00003c73
    3bc4:	00003c8f 	.word	0x00003c8f
    3bc8:	00003cab 	.word	0x00003cab
    3bcc:	00003cff 	.word	0x00003cff
    3bd0:	00003cff 	.word	0x00003cff
    3bd4:	00003cff 	.word	0x00003cff
    3bd8:	00003cc7 	.word	0x00003cc7
    3bdc:	00003ce3 	.word	0x00003ce3
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3be0:	4b50      	ldr	r3, [pc, #320]	; (3d24 <dhcp_recv+0x4d4>)
    3be2:	f240 527c 	movw	r2, #1404	; 0x57c
    3be6:	4950      	ldr	r1, [pc, #320]	; (3d28 <dhcp_recv+0x4d8>)
    3be8:	4850      	ldr	r0, [pc, #320]	; (3d2c <dhcp_recv+0x4dc>)
    3bea:	4c51      	ldr	r4, [pc, #324]	; (3d30 <dhcp_recv+0x4e0>)
    3bec:	47a0      	blx	r4
    3bee:	e7fe      	b.n	3bee <dhcp_recv+0x39e>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3bf0:	2700      	movs	r7, #0
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    3bf2:	2f03      	cmp	r7, #3
    3bf4:	d902      	bls.n	3bfc <dhcp_recv+0x3ac>
			decode_idx = DHCP_OPTION_IDX_ROUTER;
    3bf6:	2607      	movs	r6, #7
			decode_len = 4; /* only copy the first given router */
    3bf8:	2504      	movs	r5, #4
    3bfa:	e712      	b.n	3a22 <dhcp_recv+0x1d2>
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    3bfc:	4b49      	ldr	r3, [pc, #292]	; (3d24 <dhcp_recv+0x4d4>)
    3bfe:	f240 5281 	movw	r2, #1409	; 0x581
    3c02:	494c      	ldr	r1, [pc, #304]	; (3d34 <dhcp_recv+0x4e4>)
    3c04:	4849      	ldr	r0, [pc, #292]	; (3d2c <dhcp_recv+0x4dc>)
    3c06:	4c4a      	ldr	r4, [pc, #296]	; (3d30 <dhcp_recv+0x4e0>)
    3c08:	47a0      	blx	r4
    3c0a:	e7fe      	b.n	3c0a <dhcp_recv+0x3ba>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3c0c:	2700      	movs	r7, #0
			LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
    3c0e:	f017 0f03 	tst.w	r7, #3
    3c12:	d10f      	bne.n	3c34 <dhcp_recv+0x3e4>
			decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
    3c14:	463d      	mov	r5, r7
    3c16:	2f08      	cmp	r7, #8
    3c18:	bf28      	it	cs
    3c1a:	2508      	movcs	r5, #8
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    3c1c:	42bd      	cmp	r5, r7
    3c1e:	d811      	bhi.n	3c44 <dhcp_recv+0x3f4>
    3c20:	1ca3      	adds	r3, r4, #2
		offset += len + 2;
    3c22:	fa17 f783 	uxtah	r7, r7, r3
    3c26:	b2bb      	uxth	r3, r7
    3c28:	9308      	str	r3, [sp, #32]
		if (decode_len > 0) {
    3c2a:	2d00      	cmp	r5, #0
    3c2c:	f000 80aa 	beq.w	3d84 <dhcp_recv+0x534>
			decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
    3c30:	2608      	movs	r6, #8
    3c32:	e6fb      	b.n	3a2c <dhcp_recv+0x1dc>
			LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
    3c34:	4b3b      	ldr	r3, [pc, #236]	; (3d24 <dhcp_recv+0x4d4>)
    3c36:	f240 5286 	movw	r2, #1414	; 0x586
    3c3a:	493f      	ldr	r1, [pc, #252]	; (3d38 <dhcp_recv+0x4e8>)
    3c3c:	483b      	ldr	r0, [pc, #236]	; (3d2c <dhcp_recv+0x4dc>)
    3c3e:	4c3c      	ldr	r4, [pc, #240]	; (3d30 <dhcp_recv+0x4e0>)
    3c40:	47a0      	blx	r4
    3c42:	e7fe      	b.n	3c42 <dhcp_recv+0x3f2>
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    3c44:	4b37      	ldr	r3, [pc, #220]	; (3d24 <dhcp_recv+0x4d4>)
    3c46:	f240 5289 	movw	r2, #1417	; 0x589
    3c4a:	493a      	ldr	r1, [pc, #232]	; (3d34 <dhcp_recv+0x4e4>)
    3c4c:	4837      	ldr	r0, [pc, #220]	; (3d2c <dhcp_recv+0x4dc>)
    3c4e:	4c38      	ldr	r4, [pc, #224]	; (3d30 <dhcp_recv+0x4e0>)
    3c50:	47a0      	blx	r4
    3c52:	e7fe      	b.n	3c52 <dhcp_recv+0x402>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3c54:	2700      	movs	r7, #0
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3c56:	2f04      	cmp	r7, #4
    3c58:	d102      	bne.n	3c60 <dhcp_recv+0x410>
		decode_len = len;
    3c5a:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
    3c5c:	2603      	movs	r6, #3
    3c5e:	e6e0      	b.n	3a22 <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3c60:	4b30      	ldr	r3, [pc, #192]	; (3d24 <dhcp_recv+0x4d4>)
    3c62:	f240 528d 	movw	r2, #1421	; 0x58d
    3c66:	4930      	ldr	r1, [pc, #192]	; (3d28 <dhcp_recv+0x4d8>)
    3c68:	4830      	ldr	r0, [pc, #192]	; (3d2c <dhcp_recv+0x4dc>)
    3c6a:	4c31      	ldr	r4, [pc, #196]	; (3d30 <dhcp_recv+0x4e0>)
    3c6c:	47a0      	blx	r4
    3c6e:	e7fe      	b.n	3c6e <dhcp_recv+0x41e>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3c70:	2700      	movs	r7, #0
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    3c72:	2f01      	cmp	r7, #1
    3c74:	d102      	bne.n	3c7c <dhcp_recv+0x42c>
		decode_len = len;
    3c76:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_OVERLOAD;
    3c78:	2600      	movs	r6, #0
    3c7a:	e6d2      	b.n	3a22 <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    3c7c:	4b29      	ldr	r3, [pc, #164]	; (3d24 <dhcp_recv+0x4d4>)
    3c7e:	f240 5291 	movw	r2, #1425	; 0x591
    3c82:	492e      	ldr	r1, [pc, #184]	; (3d3c <dhcp_recv+0x4ec>)
    3c84:	4829      	ldr	r0, [pc, #164]	; (3d2c <dhcp_recv+0x4dc>)
    3c86:	4c2a      	ldr	r4, [pc, #168]	; (3d30 <dhcp_recv+0x4e0>)
    3c88:	47a0      	blx	r4
    3c8a:	e7fe      	b.n	3c8a <dhcp_recv+0x43a>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3c8c:	2700      	movs	r7, #0
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    3c8e:	2f01      	cmp	r7, #1
    3c90:	d102      	bne.n	3c98 <dhcp_recv+0x448>
		decode_len = len;
    3c92:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
    3c94:	2601      	movs	r6, #1
    3c96:	e6c4      	b.n	3a22 <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    3c98:	4b22      	ldr	r3, [pc, #136]	; (3d24 <dhcp_recv+0x4d4>)
    3c9a:	f240 5295 	movw	r2, #1429	; 0x595
    3c9e:	4927      	ldr	r1, [pc, #156]	; (3d3c <dhcp_recv+0x4ec>)
    3ca0:	4822      	ldr	r0, [pc, #136]	; (3d2c <dhcp_recv+0x4dc>)
    3ca2:	4c23      	ldr	r4, [pc, #140]	; (3d30 <dhcp_recv+0x4e0>)
    3ca4:	47a0      	blx	r4
    3ca6:	e7fe      	b.n	3ca6 <dhcp_recv+0x456>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3ca8:	2700      	movs	r7, #0
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3caa:	2f04      	cmp	r7, #4
    3cac:	d102      	bne.n	3cb4 <dhcp_recv+0x464>
		decode_len = len;
    3cae:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_SERVER_ID;
    3cb0:	2602      	movs	r6, #2
    3cb2:	e6b6      	b.n	3a22 <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3cb4:	4b1b      	ldr	r3, [pc, #108]	; (3d24 <dhcp_recv+0x4d4>)
    3cb6:	f240 5299 	movw	r2, #1433	; 0x599
    3cba:	491b      	ldr	r1, [pc, #108]	; (3d28 <dhcp_recv+0x4d8>)
    3cbc:	481b      	ldr	r0, [pc, #108]	; (3d2c <dhcp_recv+0x4dc>)
    3cbe:	4c1c      	ldr	r4, [pc, #112]	; (3d30 <dhcp_recv+0x4e0>)
    3cc0:	47a0      	blx	r4
    3cc2:	e7fe      	b.n	3cc2 <dhcp_recv+0x472>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3cc4:	2700      	movs	r7, #0
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3cc6:	2f04      	cmp	r7, #4
    3cc8:	d102      	bne.n	3cd0 <dhcp_recv+0x480>
		decode_len = len;
    3cca:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_T1;
    3ccc:	2604      	movs	r6, #4
    3cce:	e6a8      	b.n	3a22 <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3cd0:	4b14      	ldr	r3, [pc, #80]	; (3d24 <dhcp_recv+0x4d4>)
    3cd2:	f240 529d 	movw	r2, #1437	; 0x59d
    3cd6:	4914      	ldr	r1, [pc, #80]	; (3d28 <dhcp_recv+0x4d8>)
    3cd8:	4814      	ldr	r0, [pc, #80]	; (3d2c <dhcp_recv+0x4dc>)
    3cda:	4c15      	ldr	r4, [pc, #84]	; (3d30 <dhcp_recv+0x4e0>)
    3cdc:	47a0      	blx	r4
    3cde:	e7fe      	b.n	3cde <dhcp_recv+0x48e>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3ce0:	2700      	movs	r7, #0
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3ce2:	2f04      	cmp	r7, #4
    3ce4:	d102      	bne.n	3cec <dhcp_recv+0x49c>
		decode_len = len;
    3ce6:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_T2;
    3ce8:	2605      	movs	r6, #5
    3cea:	e69a      	b.n	3a22 <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3cec:	4b0d      	ldr	r3, [pc, #52]	; (3d24 <dhcp_recv+0x4d4>)
    3cee:	f240 52a1 	movw	r2, #1441	; 0x5a1
    3cf2:	490d      	ldr	r1, [pc, #52]	; (3d28 <dhcp_recv+0x4d8>)
    3cf4:	480d      	ldr	r0, [pc, #52]	; (3d2c <dhcp_recv+0x4dc>)
    3cf6:	4c0e      	ldr	r4, [pc, #56]	; (3d30 <dhcp_recv+0x4e0>)
    3cf8:	47a0      	blx	r4
    3cfa:	e7fe      	b.n	3cfa <dhcp_recv+0x4aa>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3cfc:	2700      	movs	r7, #0
			LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %" U16_F " in options\n", op));
    3cfe:	4619      	mov	r1, r3
    3d00:	480f      	ldr	r0, [pc, #60]	; (3d40 <dhcp_recv+0x4f0>)
    3d02:	4b0b      	ldr	r3, [pc, #44]	; (3d30 <dhcp_recv+0x4e0>)
    3d04:	4798      	blx	r3
    3d06:	e665      	b.n	39d4 <dhcp_recv+0x184>
					LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
    3d08:	4b06      	ldr	r3, [pc, #24]	; (3d24 <dhcp_recv+0x4d4>)
    3d0a:	f240 52b4 	movw	r2, #1460	; 0x5b4
    3d0e:	490d      	ldr	r1, [pc, #52]	; (3d44 <dhcp_recv+0x4f4>)
    3d10:	4806      	ldr	r0, [pc, #24]	; (3d2c <dhcp_recv+0x4dc>)
    3d12:	4c07      	ldr	r4, [pc, #28]	; (3d30 <dhcp_recv+0x4e0>)
    3d14:	47a0      	blx	r4
    3d16:	e7fe      	b.n	3d16 <dhcp_recv+0x4c6>
    3d18:	200082f8 	.word	0x200082f8
    3d1c:	20008300 	.word	0x20008300
    3d20:	00002eb9 	.word	0x00002eb9
    3d24:	0000b2a0 	.word	0x0000b2a0
    3d28:	0000b958 	.word	0x0000b958
    3d2c:	0000b2e8 	.word	0x0000b2e8
    3d30:	00009fd5 	.word	0x00009fd5
    3d34:	0000b964 	.word	0x0000b964
    3d38:	0000b978 	.word	0x0000b978
    3d3c:	0000b988 	.word	0x0000b988
    3d40:	0000b994 	.word	0x0000b994
    3d44:	0000b9b4 	.word	0x0000b9b4
    3d48:	00006015 	.word	0x00006015
				} else if (decode_len == 4) {
    3d4c:	2d04      	cmp	r5, #4
    3d4e:	d00c      	beq.n	3d6a <dhcp_recv+0x51a>
					LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
    3d50:	2d01      	cmp	r5, #1
    3d52:	d10f      	bne.n	3d74 <dhcp_recv+0x524>
					value = ((u8_t *)&value)[0];
    3d54:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    3d58:	930b      	str	r3, [sp, #44]	; 0x2c
				dhcp_got_option(dhcp, decode_idx);
    3d5a:	2201      	movs	r2, #1
    3d5c:	4b7f      	ldr	r3, [pc, #508]	; (3f5c <dhcp_recv+0x70c>)
    3d5e:	559a      	strb	r2, [r3, r6]
				dhcp_set_option_value(dhcp, decode_idx, value);
    3d60:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    3d62:	4b7f      	ldr	r3, [pc, #508]	; (3f60 <dhcp_recv+0x710>)
    3d64:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
    3d68:	e68e      	b.n	3a88 <dhcp_recv+0x238>
					value = ntohl(value);
    3d6a:	980b      	ldr	r0, [sp, #44]	; 0x2c
    3d6c:	4b7d      	ldr	r3, [pc, #500]	; (3f64 <dhcp_recv+0x714>)
    3d6e:	4798      	blx	r3
    3d70:	900b      	str	r0, [sp, #44]	; 0x2c
    3d72:	e7f2      	b.n	3d5a <dhcp_recv+0x50a>
					LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
    3d74:	4b7c      	ldr	r3, [pc, #496]	; (3f68 <dhcp_recv+0x718>)
    3d76:	f240 52be 	movw	r2, #1470	; 0x5be
    3d7a:	497c      	ldr	r1, [pc, #496]	; (3f6c <dhcp_recv+0x71c>)
    3d7c:	487c      	ldr	r0, [pc, #496]	; (3f70 <dhcp_recv+0x720>)
    3d7e:	4c7d      	ldr	r4, [pc, #500]	; (3f74 <dhcp_recv+0x724>)
    3d80:	47a0      	blx	r4
    3d82:	e7fe      	b.n	3d82 <dhcp_recv+0x532>
		offset += len + 2;
    3d84:	9c08      	ldr	r4, [sp, #32]
    3d86:	e680      	b.n	3a8a <dhcp_recv+0x23a>
		} else if (overload == DHCP_OVERLOAD_SNAME) {
    3d88:	2902      	cmp	r1, #2
    3d8a:	d108      	bne.n	3d9e <dhcp_recv+0x54e>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    3d8c:	487a      	ldr	r0, [pc, #488]	; (3f78 <dhcp_recv+0x728>)
    3d8e:	4b7b      	ldr	r3, [pc, #492]	; (3f7c <dhcp_recv+0x72c>)
    3d90:	4798      	blx	r3
		parse_sname_as_options = 0;
    3d92:	2300      	movs	r3, #0
    3d94:	9306      	str	r3, [sp, #24]
		options_idx_max        = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
    3d96:	f04f 0a6c 	mov.w	sl, #108	; 0x6c
		options_idx            = DHCP_SNAME_OFS;
    3d9a:	242c      	movs	r4, #44	; 0x2c
    3d9c:	e5d5      	b.n	394a <dhcp_recv+0xfa>
		} else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
    3d9e:	2903      	cmp	r1, #3
    3da0:	d105      	bne.n	3dae <dhcp_recv+0x55e>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname and file field\n"));
    3da2:	4877      	ldr	r0, [pc, #476]	; (3f80 <dhcp_recv+0x730>)
    3da4:	4b75      	ldr	r3, [pc, #468]	; (3f7c <dhcp_recv+0x72c>)
    3da6:	4798      	blx	r3
			parse_sname_as_options = 1;
    3da8:	2301      	movs	r3, #1
    3daa:	9306      	str	r3, [sp, #24]
    3dac:	e5fd      	b.n	39aa <dhcp_recv+0x15a>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("invalid overload option: %d\n", (int)overload));
    3dae:	4875      	ldr	r0, [pc, #468]	; (3f84 <dhcp_recv+0x734>)
    3db0:	4b70      	ldr	r3, [pc, #448]	; (3f74 <dhcp_recv+0x724>)
    3db2:	4798      	blx	r3
	} else if (parse_sname_as_options) {
    3db4:	9b06      	ldr	r3, [sp, #24]
    3db6:	2b00      	cmp	r3, #0
    3db8:	f47f adfb 	bne.w	39b2 <dhcp_recv+0x162>
    3dbc:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    3dc0:	f8dd b014 	ldr.w	fp, [sp, #20]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
    3dc4:	4870      	ldr	r0, [pc, #448]	; (3f88 <dhcp_recv+0x738>)
    3dc6:	4b6d      	ldr	r3, [pc, #436]	; (3f7c <dhcp_recv+0x72c>)
    3dc8:	4798      	blx	r3
	if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    3dca:	4b64      	ldr	r3, [pc, #400]	; (3f5c <dhcp_recv+0x70c>)
    3dcc:	785b      	ldrb	r3, [r3, #1]
    3dce:	b963      	cbnz	r3, 3dea <dhcp_recv+0x59a>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    3dd0:	486e      	ldr	r0, [pc, #440]	; (3f8c <dhcp_recv+0x73c>)
    3dd2:	4b6a      	ldr	r3, [pc, #424]	; (3f7c <dhcp_recv+0x72c>)
    3dd4:	4798      	blx	r3
		goto free_pbuf_and_return;
    3dd6:	e586      	b.n	38e6 <dhcp_recv+0x96>
    3dd8:	f8dd b014 	ldr.w	fp, [sp, #20]
    3ddc:	e001      	b.n	3de2 <dhcp_recv+0x592>
    3dde:	f8dd b014 	ldr.w	fp, [sp, #20]
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    3de2:	486b      	ldr	r0, [pc, #428]	; (3f90 <dhcp_recv+0x740>)
    3de4:	4b65      	ldr	r3, [pc, #404]	; (3f7c <dhcp_recv+0x72c>)
    3de6:	4798      	blx	r3
		goto free_pbuf_and_return;
    3de8:	e57d      	b.n	38e6 <dhcp_recv+0x96>
	msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
    3dea:	4b5d      	ldr	r3, [pc, #372]	; (3f60 <dhcp_recv+0x710>)
    3dec:	791b      	ldrb	r3, [r3, #4]
	if (msg_type == DHCP_ACK) {
    3dee:	2b05      	cmp	r3, #5
    3df0:	d149      	bne.n	3e86 <dhcp_recv+0x636>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    3df2:	4868      	ldr	r0, [pc, #416]	; (3f94 <dhcp_recv+0x744>)
    3df4:	4b61      	ldr	r3, [pc, #388]	; (3f7c <dhcp_recv+0x72c>)
    3df6:	4798      	blx	r3
		if (dhcp->state == DHCP_REQUESTING) {
    3df8:	9b04      	ldr	r3, [sp, #16]
    3dfa:	7b1b      	ldrb	r3, [r3, #12]
    3dfc:	2b01      	cmp	r3, #1
    3dfe:	d139      	bne.n	3e74 <dhcp_recv+0x624>
	struct dhcp *dhcp = netif->dhcp;
    3e00:	f8d9 4028 	ldr.w	r4, [r9, #40]	; 0x28
	ip_addr_set_zero(&dhcp->offered_sn_mask);
    3e04:	2300      	movs	r3, #0
    3e06:	62a3      	str	r3, [r4, #40]	; 0x28
	ip_addr_set_zero(&dhcp->offered_gw_addr);
    3e08:	62e3      	str	r3, [r4, #44]	; 0x2c
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
    3e0a:	4b54      	ldr	r3, [pc, #336]	; (3f5c <dhcp_recv+0x70c>)
    3e0c:	78db      	ldrb	r3, [r3, #3]
    3e0e:	b113      	cbz	r3, 3e16 <dhcp_recv+0x5c6>
		dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
    3e10:	4b53      	ldr	r3, [pc, #332]	; (3f60 <dhcp_recv+0x710>)
    3e12:	68db      	ldr	r3, [r3, #12]
    3e14:	6323      	str	r3, [r4, #48]	; 0x30
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
    3e16:	4b51      	ldr	r3, [pc, #324]	; (3f5c <dhcp_recv+0x70c>)
    3e18:	791b      	ldrb	r3, [r3, #4]
    3e1a:	b30b      	cbz	r3, 3e60 <dhcp_recv+0x610>
		dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
    3e1c:	4b50      	ldr	r3, [pc, #320]	; (3f60 <dhcp_recv+0x710>)
    3e1e:	691b      	ldr	r3, [r3, #16]
    3e20:	6363      	str	r3, [r4, #52]	; 0x34
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
    3e22:	4b4e      	ldr	r3, [pc, #312]	; (3f5c <dhcp_recv+0x70c>)
    3e24:	795b      	ldrb	r3, [r3, #5]
    3e26:	b1fb      	cbz	r3, 3e68 <dhcp_recv+0x618>
		dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
    3e28:	4b4d      	ldr	r3, [pc, #308]	; (3f60 <dhcp_recv+0x710>)
    3e2a:	695b      	ldr	r3, [r3, #20]
    3e2c:	63a3      	str	r3, [r4, #56]	; 0x38
	ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    3e2e:	68a3      	ldr	r3, [r4, #8]
    3e30:	691b      	ldr	r3, [r3, #16]
    3e32:	6263      	str	r3, [r4, #36]	; 0x24
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
    3e34:	4b49      	ldr	r3, [pc, #292]	; (3f5c <dhcp_recv+0x70c>)
    3e36:	799b      	ldrb	r3, [r3, #6]
    3e38:	b1cb      	cbz	r3, 3e6e <dhcp_recv+0x61e>
		ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
    3e3a:	4b49      	ldr	r3, [pc, #292]	; (3f60 <dhcp_recv+0x710>)
    3e3c:	6998      	ldr	r0, [r3, #24]
    3e3e:	4b56      	ldr	r3, [pc, #344]	; (3f98 <dhcp_recv+0x748>)
    3e40:	4798      	blx	r3
    3e42:	62a0      	str	r0, [r4, #40]	; 0x28
		dhcp->subnet_mask_given = 1;
    3e44:	2301      	movs	r3, #1
    3e46:	73a3      	strb	r3, [r4, #14]
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
    3e48:	4b44      	ldr	r3, [pc, #272]	; (3f5c <dhcp_recv+0x70c>)
    3e4a:	79db      	ldrb	r3, [r3, #7]
    3e4c:	b123      	cbz	r3, 3e58 <dhcp_recv+0x608>
		ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
    3e4e:	4b44      	ldr	r3, [pc, #272]	; (3f60 <dhcp_recv+0x710>)
    3e50:	69d8      	ldr	r0, [r3, #28]
    3e52:	4b51      	ldr	r3, [pc, #324]	; (3f98 <dhcp_recv+0x748>)
    3e54:	4798      	blx	r3
    3e56:	62e0      	str	r0, [r4, #44]	; 0x2c
			dhcp_check(netif);
    3e58:	4648      	mov	r0, r9
    3e5a:	4b50      	ldr	r3, [pc, #320]	; (3f9c <dhcp_recv+0x74c>)
    3e5c:	4798      	blx	r3
    3e5e:	e542      	b.n	38e6 <dhcp_recv+0x96>
		dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
    3e60:	6b23      	ldr	r3, [r4, #48]	; 0x30
    3e62:	085b      	lsrs	r3, r3, #1
    3e64:	6363      	str	r3, [r4, #52]	; 0x34
    3e66:	e7dc      	b.n	3e22 <dhcp_recv+0x5d2>
		dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
    3e68:	6b23      	ldr	r3, [r4, #48]	; 0x30
    3e6a:	63a3      	str	r3, [r4, #56]	; 0x38
    3e6c:	e7df      	b.n	3e2e <dhcp_recv+0x5de>
		dhcp->subnet_mask_given = 0;
    3e6e:	2300      	movs	r3, #0
    3e70:	73a3      	strb	r3, [r4, #14]
    3e72:	e7e9      	b.n	3e48 <dhcp_recv+0x5f8>
		else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
    3e74:	3b03      	subs	r3, #3
    3e76:	b2db      	uxtb	r3, r3
    3e78:	2b02      	cmp	r3, #2
    3e7a:	f63f ad34 	bhi.w	38e6 <dhcp_recv+0x96>
			dhcp_bind(netif);
    3e7e:	4648      	mov	r0, r9
    3e80:	4b47      	ldr	r3, [pc, #284]	; (3fa0 <dhcp_recv+0x750>)
    3e82:	4798      	blx	r3
    3e84:	e52f      	b.n	38e6 <dhcp_recv+0x96>
	else if ((msg_type == DHCP_NAK)
    3e86:	2b06      	cmp	r3, #6
    3e88:	d130      	bne.n	3eec <dhcp_recv+0x69c>
	         && ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_REBINDING)
    3e8a:	9b04      	ldr	r3, [sp, #16]
    3e8c:	7b1a      	ldrb	r2, [r3, #12]
    3e8e:	1ed3      	subs	r3, r2, #3
    3e90:	b2db      	uxtb	r3, r3
    3e92:	2b02      	cmp	r3, #2
    3e94:	d902      	bls.n	3e9c <dhcp_recv+0x64c>
    3e96:	2a01      	cmp	r2, #1
    3e98:	f47f ad25 	bne.w	38e6 <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    3e9c:	4841      	ldr	r0, [pc, #260]	; (3fa4 <dhcp_recv+0x754>)
    3e9e:	4b37      	ldr	r3, [pc, #220]	; (3f7c <dhcp_recv+0x72c>)
    3ea0:	4798      	blx	r3
	struct dhcp *dhcp = netif->dhcp;
    3ea2:	f8d9 5028 	ldr.w	r5, [r9, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    3ea6:	f899 3037 	ldrb.w	r3, [r9, #55]	; 0x37
    3eaa:	f899 2036 	ldrb.w	r2, [r9, #54]	; 0x36
    3eae:	f899 1038 	ldrb.w	r1, [r9, #56]	; 0x38
    3eb2:	9100      	str	r1, [sp, #0]
    3eb4:	4649      	mov	r1, r9
    3eb6:	483c      	ldr	r0, [pc, #240]	; (3fa8 <dhcp_recv+0x758>)
    3eb8:	4c2e      	ldr	r4, [pc, #184]	; (3f74 <dhcp_recv+0x724>)
    3eba:	47a0      	blx	r4
	netif_set_down(netif);
    3ebc:	4648      	mov	r0, r9
    3ebe:	4b3b      	ldr	r3, [pc, #236]	; (3fac <dhcp_recv+0x75c>)
    3ec0:	4798      	blx	r3
	netif_set_ipaddr(netif, IP_ADDR_ANY);
    3ec2:	4c3b      	ldr	r4, [pc, #236]	; (3fb0 <dhcp_recv+0x760>)
    3ec4:	4621      	mov	r1, r4
    3ec6:	4648      	mov	r0, r9
    3ec8:	4b3a      	ldr	r3, [pc, #232]	; (3fb4 <dhcp_recv+0x764>)
    3eca:	4798      	blx	r3
	netif_set_gw(netif, IP_ADDR_ANY);
    3ecc:	4621      	mov	r1, r4
    3ece:	4648      	mov	r0, r9
    3ed0:	4b39      	ldr	r3, [pc, #228]	; (3fb8 <dhcp_recv+0x768>)
    3ed2:	4798      	blx	r3
	netif_set_netmask(netif, IP_ADDR_ANY);
    3ed4:	4621      	mov	r1, r4
    3ed6:	4648      	mov	r0, r9
    3ed8:	4b38      	ldr	r3, [pc, #224]	; (3fbc <dhcp_recv+0x76c>)
    3eda:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    3edc:	210c      	movs	r1, #12
    3ede:	4628      	mov	r0, r5
    3ee0:	4b37      	ldr	r3, [pc, #220]	; (3fc0 <dhcp_recv+0x770>)
    3ee2:	4798      	blx	r3
	dhcp_discover(netif);
    3ee4:	4648      	mov	r0, r9
    3ee6:	4b37      	ldr	r3, [pc, #220]	; (3fc4 <dhcp_recv+0x774>)
    3ee8:	4798      	blx	r3
    3eea:	e4fc      	b.n	38e6 <dhcp_recv+0x96>
	else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
    3eec:	2b02      	cmp	r3, #2
    3eee:	f47f acfa 	bne.w	38e6 <dhcp_recv+0x96>
    3ef2:	9b04      	ldr	r3, [sp, #16]
    3ef4:	7b1b      	ldrb	r3, [r3, #12]
    3ef6:	2b06      	cmp	r3, #6
    3ef8:	f47f acf5 	bne.w	38e6 <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    3efc:	4832      	ldr	r0, [pc, #200]	; (3fc8 <dhcp_recv+0x778>)
    3efe:	4b1f      	ldr	r3, [pc, #124]	; (3f7c <dhcp_recv+0x72c>)
    3f00:	4798      	blx	r3
		dhcp->request_timeout = 0;
    3f02:	2300      	movs	r3, #0
    3f04:	9a04      	ldr	r2, [sp, #16]
    3f06:	8353      	strh	r3, [r2, #26]
	struct dhcp *dhcp = netif->dhcp;
    3f08:	f8d9 4028 	ldr.w	r4, [r9, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    3f0c:	f899 3037 	ldrb.w	r3, [r9, #55]	; 0x37
    3f10:	f899 2036 	ldrb.w	r2, [r9, #54]	; 0x36
    3f14:	f899 1038 	ldrb.w	r1, [r9, #56]	; 0x38
    3f18:	9100      	str	r1, [sp, #0]
    3f1a:	4649      	mov	r1, r9
    3f1c:	482b      	ldr	r0, [pc, #172]	; (3fcc <dhcp_recv+0x77c>)
    3f1e:	4d15      	ldr	r5, [pc, #84]	; (3f74 <dhcp_recv+0x724>)
    3f20:	47a8      	blx	r5
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
    3f22:	4b0e      	ldr	r3, [pc, #56]	; (3f5c <dhcp_recv+0x70c>)
    3f24:	789b      	ldrb	r3, [r3, #2]
    3f26:	b183      	cbz	r3, 3f4a <dhcp_recv+0x6fa>
		ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
    3f28:	4b0d      	ldr	r3, [pc, #52]	; (3f60 <dhcp_recv+0x710>)
    3f2a:	6898      	ldr	r0, [r3, #8]
    3f2c:	4b1a      	ldr	r3, [pc, #104]	; (3f98 <dhcp_recv+0x748>)
    3f2e:	4798      	blx	r3
    3f30:	4601      	mov	r1, r0
    3f32:	6220      	str	r0, [r4, #32]
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE,
    3f34:	4826      	ldr	r0, [pc, #152]	; (3fd0 <dhcp_recv+0x780>)
    3f36:	47a8      	blx	r5
		ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    3f38:	68a3      	ldr	r3, [r4, #8]
    3f3a:	6919      	ldr	r1, [r3, #16]
    3f3c:	6261      	str	r1, [r4, #36]	; 0x24
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE,
    3f3e:	4825      	ldr	r0, [pc, #148]	; (3fd4 <dhcp_recv+0x784>)
    3f40:	47a8      	blx	r5
		dhcp_select(netif);
    3f42:	4648      	mov	r0, r9
    3f44:	4b24      	ldr	r3, [pc, #144]	; (3fd8 <dhcp_recv+0x788>)
    3f46:	4798      	blx	r3
    3f48:	e4cd      	b.n	38e6 <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    3f4a:	4649      	mov	r1, r9
    3f4c:	4823      	ldr	r0, [pc, #140]	; (3fdc <dhcp_recv+0x78c>)
    3f4e:	4b09      	ldr	r3, [pc, #36]	; (3f74 <dhcp_recv+0x724>)
    3f50:	4798      	blx	r3
    3f52:	e4c8      	b.n	38e6 <dhcp_recv+0x96>
	q = p;
    3f54:	f8dd b014 	ldr.w	fp, [sp, #20]
    3f58:	e50d      	b.n	3976 <dhcp_recv+0x126>
    3f5a:	bf00      	nop
    3f5c:	200082f8 	.word	0x200082f8
    3f60:	20008304 	.word	0x20008304
    3f64:	00002ed1 	.word	0x00002ed1
    3f68:	0000b2a0 	.word	0x0000b2a0
    3f6c:	0000b9c8 	.word	0x0000b9c8
    3f70:	0000b2e8 	.word	0x0000b2e8
    3f74:	00009fd5 	.word	0x00009fd5
    3f78:	0000b9f4 	.word	0x0000b9f4
    3f7c:	0000a0bd 	.word	0x0000a0bd
    3f80:	0000ba0c 	.word	0x0000ba0c
    3f84:	0000ba2c 	.word	0x0000ba2c
    3f88:	0000ba84 	.word	0x0000ba84
    3f8c:	0000baa8 	.word	0x0000baa8
    3f90:	0000ba4c 	.word	0x0000ba4c
    3f94:	0000bad4 	.word	0x0000bad4
    3f98:	00002eb9 	.word	0x00002eb9
    3f9c:	00003641 	.word	0x00003641
    3fa0:	000036a9 	.word	0x000036a9
    3fa4:	0000bae8 	.word	0x0000bae8
    3fa8:	0000bafc 	.word	0x0000bafc
    3fac:	00005b21 	.word	0x00005b21
    3fb0:	0000c29c 	.word	0x0000c29c
    3fb4:	000059dd 	.word	0x000059dd
    3fb8:	00005ac1 	.word	0x00005ac1
    3fbc:	00005acd 	.word	0x00005acd
    3fc0:	00002edd 	.word	0x00002edd
    3fc4:	000032b1 	.word	0x000032b1
    3fc8:	0000bb20 	.word	0x0000bb20
    3fcc:	0000bb4c 	.word	0x0000bb4c
    3fd0:	0000bb74 	.word	0x0000bb74
    3fd4:	0000bb98 	.word	0x0000bb98
    3fd8:	000033e9 	.word	0x000033e9
    3fdc:	0000bbc0 	.word	0x0000bbc0
		switch (op) {
    3fe0:	2b3b      	cmp	r3, #59	; 0x3b
    3fe2:	f63f ae8b 	bhi.w	3cfc <dhcp_recv+0x4ac>
    3fe6:	a201      	add	r2, pc, #4	; (adr r2, 3fec <dhcp_recv+0x79c>)
    3fe8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    3fec:	000039cf 	.word	0x000039cf
    3ff0:	00003be1 	.word	0x00003be1
    3ff4:	00003cfd 	.word	0x00003cfd
    3ff8:	00003bf1 	.word	0x00003bf1
    3ffc:	00003cfd 	.word	0x00003cfd
    4000:	00003cfd 	.word	0x00003cfd
    4004:	00003c0d 	.word	0x00003c0d
    4008:	00003cfd 	.word	0x00003cfd
    400c:	00003cfd 	.word	0x00003cfd
    4010:	00003cfd 	.word	0x00003cfd
    4014:	00003cfd 	.word	0x00003cfd
    4018:	00003cfd 	.word	0x00003cfd
    401c:	00003cfd 	.word	0x00003cfd
    4020:	00003cfd 	.word	0x00003cfd
    4024:	00003cfd 	.word	0x00003cfd
    4028:	00003cfd 	.word	0x00003cfd
    402c:	00003cfd 	.word	0x00003cfd
    4030:	00003cfd 	.word	0x00003cfd
    4034:	00003cfd 	.word	0x00003cfd
    4038:	00003cfd 	.word	0x00003cfd
    403c:	00003cfd 	.word	0x00003cfd
    4040:	00003cfd 	.word	0x00003cfd
    4044:	00003cfd 	.word	0x00003cfd
    4048:	00003cfd 	.word	0x00003cfd
    404c:	00003cfd 	.word	0x00003cfd
    4050:	00003cfd 	.word	0x00003cfd
    4054:	00003cfd 	.word	0x00003cfd
    4058:	00003cfd 	.word	0x00003cfd
    405c:	00003cfd 	.word	0x00003cfd
    4060:	00003cfd 	.word	0x00003cfd
    4064:	00003cfd 	.word	0x00003cfd
    4068:	00003cfd 	.word	0x00003cfd
    406c:	00003cfd 	.word	0x00003cfd
    4070:	00003cfd 	.word	0x00003cfd
    4074:	00003cfd 	.word	0x00003cfd
    4078:	00003cfd 	.word	0x00003cfd
    407c:	00003cfd 	.word	0x00003cfd
    4080:	00003cfd 	.word	0x00003cfd
    4084:	00003cfd 	.word	0x00003cfd
    4088:	00003cfd 	.word	0x00003cfd
    408c:	00003cfd 	.word	0x00003cfd
    4090:	00003cfd 	.word	0x00003cfd
    4094:	00003cfd 	.word	0x00003cfd
    4098:	00003cfd 	.word	0x00003cfd
    409c:	00003cfd 	.word	0x00003cfd
    40a0:	00003cfd 	.word	0x00003cfd
    40a4:	00003cfd 	.word	0x00003cfd
    40a8:	00003cfd 	.word	0x00003cfd
    40ac:	00003cfd 	.word	0x00003cfd
    40b0:	00003cfd 	.word	0x00003cfd
    40b4:	00003cfd 	.word	0x00003cfd
    40b8:	00003c55 	.word	0x00003c55
    40bc:	00003c71 	.word	0x00003c71
    40c0:	00003c8d 	.word	0x00003c8d
    40c4:	00003ca9 	.word	0x00003ca9
    40c8:	00003cfd 	.word	0x00003cfd
    40cc:	00003cfd 	.word	0x00003cfd
    40d0:	00003cfd 	.word	0x00003cfd
    40d4:	00003cc5 	.word	0x00003cc5
    40d8:	00003ce1 	.word	0x00003ce1

000040dc <dhcp_arp_reply>:
{
    40dc:	b570      	push	{r4, r5, r6, lr}
    40de:	b082      	sub	sp, #8
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    40e0:	b158      	cbz	r0, 40fa <dhcp_arp_reply+0x1e>
    40e2:	460c      	mov	r4, r1
    40e4:	4605      	mov	r5, r0
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
    40e6:	482e      	ldr	r0, [pc, #184]	; (41a0 <dhcp_arp_reply+0xc4>)
    40e8:	4b2e      	ldr	r3, [pc, #184]	; (41a4 <dhcp_arp_reply+0xc8>)
    40ea:	4798      	blx	r3
	if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
    40ec:	6aab      	ldr	r3, [r5, #40]	; 0x28
    40ee:	b113      	cbz	r3, 40f6 <dhcp_arp_reply+0x1a>
    40f0:	7b1b      	ldrb	r3, [r3, #12]
    40f2:	2b08      	cmp	r3, #8
    40f4:	d009      	beq.n	410a <dhcp_arp_reply+0x2e>
}
    40f6:	b002      	add	sp, #8
    40f8:	bd70      	pop	{r4, r5, r6, pc}
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    40fa:	4b2b      	ldr	r3, [pc, #172]	; (41a8 <dhcp_arp_reply+0xcc>)
    40fc:	f240 3226 	movw	r2, #806	; 0x326
    4100:	492a      	ldr	r1, [pc, #168]	; (41ac <dhcp_arp_reply+0xd0>)
    4102:	482b      	ldr	r0, [pc, #172]	; (41b0 <dhcp_arp_reply+0xd4>)
    4104:	4c2b      	ldr	r4, [pc, #172]	; (41b4 <dhcp_arp_reply+0xd8>)
    4106:	47a0      	blx	r4
    4108:	e7fe      	b.n	4108 <dhcp_arp_reply+0x2c>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    410a:	6821      	ldr	r1, [r4, #0]
    410c:	482a      	ldr	r0, [pc, #168]	; (41b8 <dhcp_arp_reply+0xdc>)
    410e:	4b29      	ldr	r3, [pc, #164]	; (41b4 <dhcp_arp_reply+0xd8>)
    4110:	4798      	blx	r3
		if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
    4112:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4114:	6822      	ldr	r2, [r4, #0]
    4116:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    4118:	429a      	cmp	r2, r3
    411a:	d1ec      	bne.n	40f6 <dhcp_arp_reply+0x1a>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
    411c:	4827      	ldr	r0, [pc, #156]	; (41bc <dhcp_arp_reply+0xe0>)
    411e:	4e21      	ldr	r6, [pc, #132]	; (41a4 <dhcp_arp_reply+0xc8>)
    4120:	47b0      	blx	r6
	struct dhcp *dhcp   = netif->dhcp;
    4122:	6aac      	ldr	r4, [r5, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
    4124:	4826      	ldr	r0, [pc, #152]	; (41c0 <dhcp_arp_reply+0xe4>)
    4126:	47b0      	blx	r6
	dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    4128:	210c      	movs	r1, #12
    412a:	4620      	mov	r0, r4
    412c:	4b25      	ldr	r3, [pc, #148]	; (41c4 <dhcp_arp_reply+0xe8>)
    412e:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
    4130:	2204      	movs	r2, #4
    4132:	4621      	mov	r1, r4
    4134:	4628      	mov	r0, r5
    4136:	4b24      	ldr	r3, [pc, #144]	; (41c8 <dhcp_arp_reply+0xec>)
    4138:	4798      	blx	r3
	if (result == ERR_OK) {
    413a:	2800      	cmp	r0, #0
    413c:	d12b      	bne.n	4196 <dhcp_arp_reply+0xba>
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    413e:	2204      	movs	r2, #4
    4140:	2132      	movs	r1, #50	; 0x32
    4142:	4620      	mov	r0, r4
    4144:	4b21      	ldr	r3, [pc, #132]	; (41cc <dhcp_arp_reply+0xf0>)
    4146:	4798      	blx	r3
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    4148:	6a60      	ldr	r0, [r4, #36]	; 0x24
    414a:	4b21      	ldr	r3, [pc, #132]	; (41d0 <dhcp_arp_reply+0xf4>)
    414c:	4798      	blx	r3
    414e:	4601      	mov	r1, r0
    4150:	4620      	mov	r0, r4
    4152:	4b20      	ldr	r3, [pc, #128]	; (41d4 <dhcp_arp_reply+0xf8>)
    4154:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    4156:	4620      	mov	r0, r4
    4158:	4b1f      	ldr	r3, [pc, #124]	; (41d8 <dhcp_arp_reply+0xfc>)
    415a:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    415c:	8b21      	ldrh	r1, [r4, #24]
    415e:	31f0      	adds	r1, #240	; 0xf0
    4160:	b289      	uxth	r1, r1
    4162:	6920      	ldr	r0, [r4, #16]
    4164:	4b1d      	ldr	r3, [pc, #116]	; (41dc <dhcp_arp_reply+0x100>)
    4166:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    4168:	6921      	ldr	r1, [r4, #16]
    416a:	6860      	ldr	r0, [r4, #4]
    416c:	9500      	str	r5, [sp, #0]
    416e:	2343      	movs	r3, #67	; 0x43
    4170:	4a1b      	ldr	r2, [pc, #108]	; (41e0 <dhcp_arp_reply+0x104>)
    4172:	4d1c      	ldr	r5, [pc, #112]	; (41e4 <dhcp_arp_reply+0x108>)
    4174:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    4176:	4620      	mov	r0, r4
    4178:	4b1b      	ldr	r3, [pc, #108]	; (41e8 <dhcp_arp_reply+0x10c>)
    417a:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
    417c:	481b      	ldr	r0, [pc, #108]	; (41ec <dhcp_arp_reply+0x110>)
    417e:	47b0      	blx	r6
	dhcp->tries++;
    4180:	7b63      	ldrb	r3, [r4, #13]
    4182:	3301      	adds	r3, #1
    4184:	7363      	strb	r3, [r4, #13]
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    4186:	2314      	movs	r3, #20
    4188:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %" U16_F " msecs\n", msecs));
    418a:	f242 7110 	movw	r1, #10000	; 0x2710
    418e:	4818      	ldr	r0, [pc, #96]	; (41f0 <dhcp_arp_reply+0x114>)
    4190:	4b08      	ldr	r3, [pc, #32]	; (41b4 <dhcp_arp_reply+0xd8>)
    4192:	4798      	blx	r3
}
    4194:	e7af      	b.n	40f6 <dhcp_arp_reply+0x1a>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    4196:	4817      	ldr	r0, [pc, #92]	; (41f4 <dhcp_arp_reply+0x118>)
    4198:	4b02      	ldr	r3, [pc, #8]	; (41a4 <dhcp_arp_reply+0xc8>)
    419a:	4798      	blx	r3
    419c:	e7f0      	b.n	4180 <dhcp_arp_reply+0xa4>
    419e:	bf00      	nop
    41a0:	0000bc94 	.word	0x0000bc94
    41a4:	0000a0bd 	.word	0x0000a0bd
    41a8:	0000b2a0 	.word	0x0000b2a0
    41ac:	0000bbf4 	.word	0x0000bbf4
    41b0:	0000b2e8 	.word	0x0000b2e8
    41b4:	00009fd5 	.word	0x00009fd5
    41b8:	0000bca8 	.word	0x0000bca8
    41bc:	0000bcdc 	.word	0x0000bcdc
    41c0:	0000bd20 	.word	0x0000bd20
    41c4:	00002edd 	.word	0x00002edd
    41c8:	00002fe1 	.word	0x00002fe1
    41cc:	00002eed 	.word	0x00002eed
    41d0:	00002ed1 	.word	0x00002ed1
    41d4:	00002f4b 	.word	0x00002f4b
    41d8:	00002f91 	.word	0x00002f91
    41dc:	00005e2d 	.word	0x00005e2d
    41e0:	0000c298 	.word	0x0000c298
    41e4:	00008cb1 	.word	0x00008cb1
    41e8:	0000318d 	.word	0x0000318d
    41ec:	0000bd30 	.word	0x0000bd30
    41f0:	0000bd7c 	.word	0x0000bd7c
    41f4:	0000bd4c 	.word	0x0000bd4c

000041f8 <dhcp_renew>:
{
    41f8:	b570      	push	{r4, r5, r6, lr}
    41fa:	b082      	sub	sp, #8
    41fc:	4606      	mov	r6, r0
	struct dhcp *dhcp = netif->dhcp;
    41fe:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
    4200:	4828      	ldr	r0, [pc, #160]	; (42a4 <dhcp_renew+0xac>)
    4202:	4b29      	ldr	r3, [pc, #164]	; (42a8 <dhcp_renew+0xb0>)
    4204:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_RENEWING);
    4206:	2105      	movs	r1, #5
    4208:	4620      	mov	r0, r4
    420a:	4b28      	ldr	r3, [pc, #160]	; (42ac <dhcp_renew+0xb4>)
    420c:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    420e:	2203      	movs	r2, #3
    4210:	4621      	mov	r1, r4
    4212:	4630      	mov	r0, r6
    4214:	4b26      	ldr	r3, [pc, #152]	; (42b0 <dhcp_renew+0xb8>)
    4216:	4798      	blx	r3
	if (result == ERR_OK) {
    4218:	4605      	mov	r5, r0
    421a:	2800      	cmp	r0, #0
    421c:	d13a      	bne.n	4294 <dhcp_renew+0x9c>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    421e:	2202      	movs	r2, #2
    4220:	2139      	movs	r1, #57	; 0x39
    4222:	4620      	mov	r0, r4
    4224:	4b23      	ldr	r3, [pc, #140]	; (42b4 <dhcp_renew+0xbc>)
    4226:	4798      	blx	r3
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    4228:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
    422a:	4620      	mov	r0, r4
    422c:	4b22      	ldr	r3, [pc, #136]	; (42b8 <dhcp_renew+0xc0>)
    422e:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    4230:	4620      	mov	r0, r4
    4232:	4b22      	ldr	r3, [pc, #136]	; (42bc <dhcp_renew+0xc4>)
    4234:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    4236:	8b21      	ldrh	r1, [r4, #24]
    4238:	31f0      	adds	r1, #240	; 0xf0
    423a:	b289      	uxth	r1, r1
    423c:	6920      	ldr	r0, [r4, #16]
    423e:	4b20      	ldr	r3, [pc, #128]	; (42c0 <dhcp_renew+0xc8>)
    4240:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    4242:	6921      	ldr	r1, [r4, #16]
    4244:	6860      	ldr	r0, [r4, #4]
    4246:	9600      	str	r6, [sp, #0]
    4248:	2343      	movs	r3, #67	; 0x43
    424a:	f104 0220 	add.w	r2, r4, #32
    424e:	4e1d      	ldr	r6, [pc, #116]	; (42c4 <dhcp_renew+0xcc>)
    4250:	47b0      	blx	r6
		dhcp_delete_msg(dhcp);
    4252:	4620      	mov	r0, r4
    4254:	4b1c      	ldr	r3, [pc, #112]	; (42c8 <dhcp_renew+0xd0>)
    4256:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
    4258:	481c      	ldr	r0, [pc, #112]	; (42cc <dhcp_renew+0xd4>)
    425a:	4b13      	ldr	r3, [pc, #76]	; (42a8 <dhcp_renew+0xb0>)
    425c:	4798      	blx	r3
	dhcp->tries++;
    425e:	7b61      	ldrb	r1, [r4, #13]
    4260:	3101      	adds	r1, #1
    4262:	b2c9      	uxtb	r1, r1
    4264:	7361      	strb	r1, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    4266:	2909      	cmp	r1, #9
    4268:	d818      	bhi.n	429c <dhcp_renew+0xa4>
    426a:	ebc1 1341 	rsb	r3, r1, r1, lsl #5
    426e:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    4272:	0109      	lsls	r1, r1, #4
    4274:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    4276:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    427a:	4a15      	ldr	r2, [pc, #84]	; (42d0 <dhcp_renew+0xd8>)
    427c:	fb82 0203 	smull	r0, r2, r2, r3
    4280:	17db      	asrs	r3, r3, #31
    4282:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    4286:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    4288:	4812      	ldr	r0, [pc, #72]	; (42d4 <dhcp_renew+0xdc>)
    428a:	4b13      	ldr	r3, [pc, #76]	; (42d8 <dhcp_renew+0xe0>)
    428c:	4798      	blx	r3
}
    428e:	4628      	mov	r0, r5
    4290:	b002      	add	sp, #8
    4292:	bd70      	pop	{r4, r5, r6, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    4294:	4811      	ldr	r0, [pc, #68]	; (42dc <dhcp_renew+0xe4>)
    4296:	4b04      	ldr	r3, [pc, #16]	; (42a8 <dhcp_renew+0xb0>)
    4298:	4798      	blx	r3
    429a:	e7e0      	b.n	425e <dhcp_renew+0x66>
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    429c:	f644 6120 	movw	r1, #20000	; 0x4e20
    42a0:	e7e9      	b.n	4276 <dhcp_renew+0x7e>
    42a2:	bf00      	nop
    42a4:	0000bdac 	.word	0x0000bdac
    42a8:	0000a0bd 	.word	0x0000a0bd
    42ac:	00002edd 	.word	0x00002edd
    42b0:	00002fe1 	.word	0x00002fe1
    42b4:	00002eed 	.word	0x00002eed
    42b8:	00002f25 	.word	0x00002f25
    42bc:	00002f91 	.word	0x00002f91
    42c0:	00005e2d 	.word	0x00005e2d
    42c4:	00008cb1 	.word	0x00008cb1
    42c8:	0000318d 	.word	0x0000318d
    42cc:	0000bdbc 	.word	0x0000bdbc
    42d0:	10624dd3 	.word	0x10624dd3
    42d4:	0000be00 	.word	0x0000be00
    42d8:	00009fd5 	.word	0x00009fd5
    42dc:	0000bdd4 	.word	0x0000bdd4

000042e0 <dhcp_coarse_tmr>:
{
    42e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct netif *netif = netif_list;
    42e4:	4b22      	ldr	r3, [pc, #136]	; (4370 <dhcp_coarse_tmr+0x90>)
    42e6:	681c      	ldr	r4, [r3, #0]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
    42e8:	4822      	ldr	r0, [pc, #136]	; (4374 <dhcp_coarse_tmr+0x94>)
    42ea:	4b23      	ldr	r3, [pc, #140]	; (4378 <dhcp_coarse_tmr+0x98>)
    42ec:	4798      	blx	r3
	while (netif != NULL) {
    42ee:	2c00      	cmp	r4, #0
    42f0:	d03b      	beq.n	436a <dhcp_coarse_tmr+0x8a>
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
    42f2:	4f22      	ldr	r7, [pc, #136]	; (437c <dhcp_coarse_tmr+0x9c>)
    42f4:	4d20      	ldr	r5, [pc, #128]	; (4378 <dhcp_coarse_tmr+0x98>)
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
    42f6:	4e22      	ldr	r6, [pc, #136]	; (4380 <dhcp_coarse_tmr+0xa0>)
    42f8:	e00f      	b.n	431a <dhcp_coarse_tmr+0x3a>
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
    42fa:	4822      	ldr	r0, [pc, #136]	; (4384 <dhcp_coarse_tmr+0xa4>)
    42fc:	47a8      	blx	r5
	struct dhcp *dhcp = netif->dhcp;
    42fe:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
    4302:	4821      	ldr	r0, [pc, #132]	; (4388 <dhcp_coarse_tmr+0xa8>)
    4304:	47a8      	blx	r5
	if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    4306:	f898 300c 	ldrb.w	r3, [r8, #12]
    430a:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
    430e:	2a01      	cmp	r2, #1
    4310:	d025      	beq.n	435e <dhcp_coarse_tmr+0x7e>
    4312:	2b0a      	cmp	r3, #10
    4314:	d023      	beq.n	435e <dhcp_coarse_tmr+0x7e>
		netif = netif->next;
    4316:	6824      	ldr	r4, [r4, #0]
	while (netif != NULL) {
    4318:	b33c      	cbz	r4, 436a <dhcp_coarse_tmr+0x8a>
		if (netif->dhcp != NULL) {
    431a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    431c:	2b00      	cmp	r3, #0
    431e:	d0fa      	beq.n	4316 <dhcp_coarse_tmr+0x36>
			if (netif->dhcp->t2_timeout-- == 1) {
    4320:	8bda      	ldrh	r2, [r3, #30]
    4322:	1e51      	subs	r1, r2, #1
    4324:	83d9      	strh	r1, [r3, #30]
    4326:	2a01      	cmp	r2, #1
    4328:	d0e7      	beq.n	42fa <dhcp_coarse_tmr+0x1a>
			} else if (netif->dhcp->t1_timeout-- == 1) {
    432a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    432c:	8b93      	ldrh	r3, [r2, #28]
    432e:	1e59      	subs	r1, r3, #1
    4330:	8391      	strh	r1, [r2, #28]
    4332:	2b01      	cmp	r3, #1
    4334:	d1ef      	bne.n	4316 <dhcp_coarse_tmr+0x36>
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
    4336:	4638      	mov	r0, r7
    4338:	47a8      	blx	r5
	struct dhcp *dhcp = netif->dhcp;
    433a:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
    433e:	4630      	mov	r0, r6
    4340:	47a8      	blx	r5
	if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    4342:	f898 300c 	ldrb.w	r3, [r8, #12]
    4346:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
    434a:	2a01      	cmp	r2, #1
    434c:	d001      	beq.n	4352 <dhcp_coarse_tmr+0x72>
    434e:	2b0a      	cmp	r3, #10
    4350:	d1e1      	bne.n	4316 <dhcp_coarse_tmr+0x36>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    4352:	480e      	ldr	r0, [pc, #56]	; (438c <dhcp_coarse_tmr+0xac>)
    4354:	47a8      	blx	r5
		dhcp_renew(netif);
    4356:	4620      	mov	r0, r4
    4358:	4b0d      	ldr	r3, [pc, #52]	; (4390 <dhcp_coarse_tmr+0xb0>)
    435a:	4798      	blx	r3
    435c:	e7db      	b.n	4316 <dhcp_coarse_tmr+0x36>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    435e:	480d      	ldr	r0, [pc, #52]	; (4394 <dhcp_coarse_tmr+0xb4>)
    4360:	47a8      	blx	r5
		dhcp_rebind(netif);
    4362:	4620      	mov	r0, r4
    4364:	4b0c      	ldr	r3, [pc, #48]	; (4398 <dhcp_coarse_tmr+0xb8>)
    4366:	4798      	blx	r3
    4368:	e7d5      	b.n	4316 <dhcp_coarse_tmr+0x36>
    436a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    436e:	bf00      	nop
    4370:	200092f0 	.word	0x200092f0
    4374:	0000be30 	.word	0x0000be30
    4378:	0000a0bd 	.word	0x0000a0bd
    437c:	0000be98 	.word	0x0000be98
    4380:	0000beb8 	.word	0x0000beb8
    4384:	0000be44 	.word	0x0000be44
    4388:	0000be64 	.word	0x0000be64
    438c:	0000becc 	.word	0x0000becc
    4390:	000041f9 	.word	0x000041f9
    4394:	0000be78 	.word	0x0000be78
    4398:	000031c9 	.word	0x000031c9

0000439c <dhcp_release>:
{
    439c:	b5f0      	push	{r4, r5, r6, r7, lr}
    439e:	b083      	sub	sp, #12
    43a0:	4605      	mov	r5, r0
	struct dhcp *dhcp = netif->dhcp;
    43a2:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));
    43a4:	482f      	ldr	r0, [pc, #188]	; (4464 <dhcp_release+0xc8>)
    43a6:	4b30      	ldr	r3, [pc, #192]	; (4468 <dhcp_release+0xcc>)
    43a8:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_OFF);
    43aa:	2100      	movs	r1, #0
    43ac:	4620      	mov	r0, r4
    43ae:	4b2f      	ldr	r3, [pc, #188]	; (446c <dhcp_release+0xd0>)
    43b0:	4798      	blx	r3
	ip_addr_set_zero(&dhcp->server_ip_addr);
    43b2:	2300      	movs	r3, #0
    43b4:	6223      	str	r3, [r4, #32]
	ip_addr_set_zero(&dhcp->offered_ip_addr);
    43b6:	6263      	str	r3, [r4, #36]	; 0x24
	ip_addr_set_zero(&dhcp->offered_sn_mask);
    43b8:	62a3      	str	r3, [r4, #40]	; 0x28
	ip_addr_set_zero(&dhcp->offered_gw_addr);
    43ba:	62e3      	str	r3, [r4, #44]	; 0x2c
	dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
    43bc:	63a3      	str	r3, [r4, #56]	; 0x38
    43be:	6363      	str	r3, [r4, #52]	; 0x34
    43c0:	6323      	str	r3, [r4, #48]	; 0x30
	result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
    43c2:	2207      	movs	r2, #7
    43c4:	4621      	mov	r1, r4
    43c6:	4628      	mov	r0, r5
    43c8:	4b29      	ldr	r3, [pc, #164]	; (4470 <dhcp_release+0xd4>)
    43ca:	4798      	blx	r3
	if (result == ERR_OK) {
    43cc:	4606      	mov	r6, r0
    43ce:	2800      	cmp	r0, #0
    43d0:	d141      	bne.n	4456 <dhcp_release+0xba>
		dhcp_option_trailer(dhcp);
    43d2:	4620      	mov	r0, r4
    43d4:	4b27      	ldr	r3, [pc, #156]	; (4474 <dhcp_release+0xd8>)
    43d6:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    43d8:	8b21      	ldrh	r1, [r4, #24]
    43da:	31f0      	adds	r1, #240	; 0xf0
    43dc:	b289      	uxth	r1, r1
    43de:	6920      	ldr	r0, [r4, #16]
    43e0:	4b25      	ldr	r3, [pc, #148]	; (4478 <dhcp_release+0xdc>)
    43e2:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    43e4:	6921      	ldr	r1, [r4, #16]
    43e6:	6860      	ldr	r0, [r4, #4]
    43e8:	9500      	str	r5, [sp, #0]
    43ea:	2343      	movs	r3, #67	; 0x43
    43ec:	f104 0220 	add.w	r2, r4, #32
    43f0:	4f22      	ldr	r7, [pc, #136]	; (447c <dhcp_release+0xe0>)
    43f2:	47b8      	blx	r7
		dhcp_delete_msg(dhcp);
    43f4:	4620      	mov	r0, r4
    43f6:	4b22      	ldr	r3, [pc, #136]	; (4480 <dhcp_release+0xe4>)
    43f8:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
    43fa:	4822      	ldr	r0, [pc, #136]	; (4484 <dhcp_release+0xe8>)
    43fc:	4b1a      	ldr	r3, [pc, #104]	; (4468 <dhcp_release+0xcc>)
    43fe:	4798      	blx	r3
	dhcp->tries++;
    4400:	7b61      	ldrb	r1, [r4, #13]
    4402:	3101      	adds	r1, #1
    4404:	b2c9      	uxtb	r1, r1
    4406:	7361      	strb	r1, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    4408:	2909      	cmp	r1, #9
    440a:	d828      	bhi.n	445e <dhcp_release+0xc2>
    440c:	ebc1 1341 	rsb	r3, r1, r1, lsl #5
    4410:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    4414:	00c9      	lsls	r1, r1, #3
    4416:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    4418:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    441c:	4a1a      	ldr	r2, [pc, #104]	; (4488 <dhcp_release+0xec>)
    441e:	fb82 0203 	smull	r0, r2, r2, r3
    4422:	17db      	asrs	r3, r3, #31
    4424:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    4428:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    442a:	4818      	ldr	r0, [pc, #96]	; (448c <dhcp_release+0xf0>)
    442c:	4b18      	ldr	r3, [pc, #96]	; (4490 <dhcp_release+0xf4>)
    442e:	4798      	blx	r3
	netif_set_down(netif);
    4430:	4628      	mov	r0, r5
    4432:	4b18      	ldr	r3, [pc, #96]	; (4494 <dhcp_release+0xf8>)
    4434:	4798      	blx	r3
	netif_set_ipaddr(netif, IP_ADDR_ANY);
    4436:	4c18      	ldr	r4, [pc, #96]	; (4498 <dhcp_release+0xfc>)
    4438:	4621      	mov	r1, r4
    443a:	4628      	mov	r0, r5
    443c:	4b17      	ldr	r3, [pc, #92]	; (449c <dhcp_release+0x100>)
    443e:	4798      	blx	r3
	netif_set_gw(netif, IP_ADDR_ANY);
    4440:	4621      	mov	r1, r4
    4442:	4628      	mov	r0, r5
    4444:	4b16      	ldr	r3, [pc, #88]	; (44a0 <dhcp_release+0x104>)
    4446:	4798      	blx	r3
	netif_set_netmask(netif, IP_ADDR_ANY);
    4448:	4621      	mov	r1, r4
    444a:	4628      	mov	r0, r5
    444c:	4b15      	ldr	r3, [pc, #84]	; (44a4 <dhcp_release+0x108>)
    444e:	4798      	blx	r3
}
    4450:	4630      	mov	r0, r6
    4452:	b003      	add	sp, #12
    4454:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    4456:	4814      	ldr	r0, [pc, #80]	; (44a8 <dhcp_release+0x10c>)
    4458:	4b03      	ldr	r3, [pc, #12]	; (4468 <dhcp_release+0xcc>)
    445a:	4798      	blx	r3
    445c:	e7d0      	b.n	4400 <dhcp_release+0x64>
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    445e:	f242 7110 	movw	r1, #10000	; 0x2710
    4462:	e7d9      	b.n	4418 <dhcp_release+0x7c>
    4464:	0000beec 	.word	0x0000beec
    4468:	0000a0bd 	.word	0x0000a0bd
    446c:	00002edd 	.word	0x00002edd
    4470:	00002fe1 	.word	0x00002fe1
    4474:	00002f91 	.word	0x00002f91
    4478:	00005e2d 	.word	0x00005e2d
    447c:	00008cb1 	.word	0x00008cb1
    4480:	0000318d 	.word	0x0000318d
    4484:	0000befc 	.word	0x0000befc
    4488:	10624dd3 	.word	0x10624dd3
    448c:	0000bf50 	.word	0x0000bf50
    4490:	00009fd5 	.word	0x00009fd5
    4494:	00005b21 	.word	0x00005b21
    4498:	0000c29c 	.word	0x0000c29c
    449c:	000059dd 	.word	0x000059dd
    44a0:	00005ac1 	.word	0x00005ac1
    44a4:	00005acd 	.word	0x00005acd
    44a8:	0000bf20 	.word	0x0000bf20

000044ac <dhcp_fine_tmr>:
{
    44ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct netif *netif = netif_list;
    44b0:	4b3a      	ldr	r3, [pc, #232]	; (459c <dhcp_fine_tmr+0xf0>)
    44b2:	681c      	ldr	r4, [r3, #0]
	while (netif != NULL) {
    44b4:	2c00      	cmp	r4, #0
    44b6:	d06f      	beq.n	4598 <dhcp_fine_tmr+0xec>
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
    44b8:	4f39      	ldr	r7, [pc, #228]	; (45a0 <dhcp_fine_tmr+0xf4>)
    44ba:	4d3a      	ldr	r5, [pc, #232]	; (45a4 <dhcp_fine_tmr+0xf8>)
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
    44bc:	4e3a      	ldr	r6, [pc, #232]	; (45a8 <dhcp_fine_tmr+0xfc>)
    44be:	e004      	b.n	44ca <dhcp_fine_tmr+0x1e>
			} else if (netif->dhcp->request_timeout == 1) {
    44c0:	2b01      	cmp	r3, #1
    44c2:	d00b      	beq.n	44dc <dhcp_fine_tmr+0x30>
		netif = netif->next;
    44c4:	6824      	ldr	r4, [r4, #0]
	while (netif != NULL) {
    44c6:	2c00      	cmp	r4, #0
    44c8:	d066      	beq.n	4598 <dhcp_fine_tmr+0xec>
		if (netif->dhcp != NULL) {
    44ca:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    44cc:	2a00      	cmp	r2, #0
    44ce:	d0f9      	beq.n	44c4 <dhcp_fine_tmr+0x18>
			if (netif->dhcp->request_timeout > 1) {
    44d0:	8b53      	ldrh	r3, [r2, #26]
    44d2:	2b01      	cmp	r3, #1
    44d4:	d9f4      	bls.n	44c0 <dhcp_fine_tmr+0x14>
				netif->dhcp->request_timeout--;
    44d6:	3b01      	subs	r3, #1
    44d8:	8353      	strh	r3, [r2, #26]
    44da:	e7f3      	b.n	44c4 <dhcp_fine_tmr+0x18>
				netif->dhcp->request_timeout--;
    44dc:	2300      	movs	r3, #0
    44de:	8353      	strh	r3, [r2, #26]
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
    44e0:	4638      	mov	r0, r7
    44e2:	47a8      	blx	r5
	struct dhcp *dhcp = netif->dhcp;
    44e4:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
    44e8:	4630      	mov	r0, r6
    44ea:	47a8      	blx	r5
	if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    44ec:	f898 300c 	ldrb.w	r3, [r8, #12]
    44f0:	2b0c      	cmp	r3, #12
    44f2:	d014      	beq.n	451e <dhcp_fine_tmr+0x72>
    44f4:	2b06      	cmp	r3, #6
    44f6:	d012      	beq.n	451e <dhcp_fine_tmr+0x72>
	} else if (dhcp->state == DHCP_REQUESTING) {
    44f8:	2b01      	cmp	r3, #1
    44fa:	d016      	beq.n	452a <dhcp_fine_tmr+0x7e>
	} else if (dhcp->state == DHCP_CHECKING) {
    44fc:	2b08      	cmp	r3, #8
    44fe:	d027      	beq.n	4550 <dhcp_fine_tmr+0xa4>
	else if (dhcp->state == DHCP_RENEWING) {
    4500:	2b05      	cmp	r3, #5
    4502:	d030      	beq.n	4566 <dhcp_fine_tmr+0xba>
	} else if (dhcp->state == DHCP_REBINDING) {
    4504:	2b04      	cmp	r3, #4
    4506:	d034      	beq.n	4572 <dhcp_fine_tmr+0xc6>
	} else if (dhcp->state == DHCP_REBOOTING) {
    4508:	2b03      	cmp	r3, #3
    450a:	d1db      	bne.n	44c4 <dhcp_fine_tmr+0x18>
		if (dhcp->tries < REBOOT_TRIES) {
    450c:	f898 300d 	ldrb.w	r3, [r8, #13]
    4510:	2b01      	cmp	r3, #1
			dhcp_reboot(netif);
    4512:	4620      	mov	r0, r4
    4514:	bf94      	ite	ls
    4516:	4b25      	ldrls	r3, [pc, #148]	; (45ac <dhcp_fine_tmr+0x100>)
			dhcp_discover(netif);
    4518:	4b25      	ldrhi	r3, [pc, #148]	; (45b0 <dhcp_fine_tmr+0x104>)
    451a:	4798      	blx	r3
    451c:	e7d2      	b.n	44c4 <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    451e:	4825      	ldr	r0, [pc, #148]	; (45b4 <dhcp_fine_tmr+0x108>)
    4520:	47a8      	blx	r5
		dhcp_discover(netif);
    4522:	4620      	mov	r0, r4
    4524:	4b22      	ldr	r3, [pc, #136]	; (45b0 <dhcp_fine_tmr+0x104>)
    4526:	4798      	blx	r3
    4528:	e7cc      	b.n	44c4 <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    452a:	4823      	ldr	r0, [pc, #140]	; (45b8 <dhcp_fine_tmr+0x10c>)
    452c:	47a8      	blx	r5
		if (dhcp->tries <= 5) {
    452e:	f898 300d 	ldrb.w	r3, [r8, #13]
    4532:	2b05      	cmp	r3, #5
    4534:	d803      	bhi.n	453e <dhcp_fine_tmr+0x92>
			dhcp_select(netif);
    4536:	4620      	mov	r0, r4
    4538:	4b20      	ldr	r3, [pc, #128]	; (45bc <dhcp_fine_tmr+0x110>)
    453a:	4798      	blx	r3
    453c:	e7c2      	b.n	44c4 <dhcp_fine_tmr+0x18>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    453e:	4820      	ldr	r0, [pc, #128]	; (45c0 <dhcp_fine_tmr+0x114>)
    4540:	47a8      	blx	r5
			dhcp_release(netif);
    4542:	4620      	mov	r0, r4
    4544:	4b1f      	ldr	r3, [pc, #124]	; (45c4 <dhcp_fine_tmr+0x118>)
    4546:	4798      	blx	r3
			dhcp_discover(netif);
    4548:	4620      	mov	r0, r4
    454a:	4b19      	ldr	r3, [pc, #100]	; (45b0 <dhcp_fine_tmr+0x104>)
    454c:	4798      	blx	r3
    454e:	e7b9      	b.n	44c4 <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    4550:	481d      	ldr	r0, [pc, #116]	; (45c8 <dhcp_fine_tmr+0x11c>)
    4552:	47a8      	blx	r5
		if (dhcp->tries <= 1) {
    4554:	f898 300d 	ldrb.w	r3, [r8, #13]
    4558:	2b01      	cmp	r3, #1
			dhcp_check(netif);
    455a:	4620      	mov	r0, r4
    455c:	bf94      	ite	ls
    455e:	4b1b      	ldrls	r3, [pc, #108]	; (45cc <dhcp_fine_tmr+0x120>)
			dhcp_bind(netif);
    4560:	4b1b      	ldrhi	r3, [pc, #108]	; (45d0 <dhcp_fine_tmr+0x124>)
    4562:	4798      	blx	r3
    4564:	e7ae      	b.n	44c4 <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    4566:	481b      	ldr	r0, [pc, #108]	; (45d4 <dhcp_fine_tmr+0x128>)
    4568:	47a8      	blx	r5
		dhcp_renew(netif);
    456a:	4620      	mov	r0, r4
    456c:	4b1a      	ldr	r3, [pc, #104]	; (45d8 <dhcp_fine_tmr+0x12c>)
    456e:	4798      	blx	r3
    4570:	e7a8      	b.n	44c4 <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    4572:	481a      	ldr	r0, [pc, #104]	; (45dc <dhcp_fine_tmr+0x130>)
    4574:	47a8      	blx	r5
		if (dhcp->tries <= 8) {
    4576:	f898 300d 	ldrb.w	r3, [r8, #13]
    457a:	2b08      	cmp	r3, #8
    457c:	d803      	bhi.n	4586 <dhcp_fine_tmr+0xda>
			dhcp_rebind(netif);
    457e:	4620      	mov	r0, r4
    4580:	4b17      	ldr	r3, [pc, #92]	; (45e0 <dhcp_fine_tmr+0x134>)
    4582:	4798      	blx	r3
    4584:	e79e      	b.n	44c4 <dhcp_fine_tmr+0x18>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
    4586:	4817      	ldr	r0, [pc, #92]	; (45e4 <dhcp_fine_tmr+0x138>)
    4588:	47a8      	blx	r5
			dhcp_release(netif);
    458a:	4620      	mov	r0, r4
    458c:	4b0d      	ldr	r3, [pc, #52]	; (45c4 <dhcp_fine_tmr+0x118>)
    458e:	4798      	blx	r3
			dhcp_discover(netif);
    4590:	4620      	mov	r0, r4
    4592:	4b07      	ldr	r3, [pc, #28]	; (45b0 <dhcp_fine_tmr+0x104>)
    4594:	4798      	blx	r3
    4596:	e795      	b.n	44c4 <dhcp_fine_tmr+0x18>
    4598:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    459c:	200092f0 	.word	0x200092f0
    45a0:	0000bf80 	.word	0x0000bf80
    45a4:	0000a0bd 	.word	0x0000a0bd
    45a8:	0000bfa4 	.word	0x0000bfa4
    45ac:	00003539 	.word	0x00003539
    45b0:	000032b1 	.word	0x000032b1
    45b4:	0000bfb4 	.word	0x0000bfb4
    45b8:	0000bfdc 	.word	0x0000bfdc
    45bc:	000033e9 	.word	0x000033e9
    45c0:	0000c010 	.word	0x0000c010
    45c4:	0000439d 	.word	0x0000439d
    45c8:	0000c044 	.word	0x0000c044
    45cc:	00003641 	.word	0x00003641
    45d0:	000036a9 	.word	0x000036a9
    45d4:	0000c074 	.word	0x0000c074
    45d8:	000041f9 	.word	0x000041f9
    45dc:	0000c0a8 	.word	0x0000c0a8
    45e0:	000031c9 	.word	0x000031c9
    45e4:	0000c0dc 	.word	0x0000c0dc

000045e8 <dhcp_stop>:
{
    45e8:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    45ea:	b1a8      	cbz	r0, 4618 <dhcp_stop+0x30>
	dhcp = netif->dhcp;
    45ec:	6a84      	ldr	r4, [r0, #40]	; 0x28
	netif->flags &= ~NETIF_FLAG_DHCP;
    45ee:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
    45f2:	f022 0208 	bic.w	r2, r2, #8
    45f6:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
    45fa:	480b      	ldr	r0, [pc, #44]	; (4628 <dhcp_stop+0x40>)
    45fc:	4b0b      	ldr	r3, [pc, #44]	; (462c <dhcp_stop+0x44>)
    45fe:	4798      	blx	r3
	if (dhcp != NULL) {
    4600:	b14c      	cbz	r4, 4616 <dhcp_stop+0x2e>
		if (dhcp->pcb != NULL) {
    4602:	6860      	ldr	r0, [r4, #4]
    4604:	b118      	cbz	r0, 460e <dhcp_stop+0x26>
			udp_remove(dhcp->pcb);
    4606:	4b0a      	ldr	r3, [pc, #40]	; (4630 <dhcp_stop+0x48>)
    4608:	4798      	blx	r3
			dhcp->pcb = NULL;
    460a:	2300      	movs	r3, #0
    460c:	6063      	str	r3, [r4, #4]
		dhcp_set_state(dhcp, DHCP_OFF);
    460e:	2100      	movs	r1, #0
    4610:	4620      	mov	r0, r4
    4612:	4b08      	ldr	r3, [pc, #32]	; (4634 <dhcp_stop+0x4c>)
    4614:	4798      	blx	r3
    4616:	bd10      	pop	{r4, pc}
	LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    4618:	4b07      	ldr	r3, [pc, #28]	; (4638 <dhcp_stop+0x50>)
    461a:	f240 42cc 	movw	r2, #1228	; 0x4cc
    461e:	4907      	ldr	r1, [pc, #28]	; (463c <dhcp_stop+0x54>)
    4620:	4807      	ldr	r0, [pc, #28]	; (4640 <dhcp_stop+0x58>)
    4622:	4c08      	ldr	r4, [pc, #32]	; (4644 <dhcp_stop+0x5c>)
    4624:	47a0      	blx	r4
    4626:	e7fe      	b.n	4626 <dhcp_stop+0x3e>
    4628:	0000c120 	.word	0x0000c120
    462c:	0000a0bd 	.word	0x0000a0bd
    4630:	00008e5d 	.word	0x00008e5d
    4634:	00002edd 	.word	0x00002edd
    4638:	0000b2a0 	.word	0x0000b2a0
    463c:	0000c104 	.word	0x0000c104
    4640:	0000b2e8 	.word	0x0000b2e8
    4644:	00009fd5 	.word	0x00009fd5

00004648 <dhcp_start>:
{
    4648:	b570      	push	{r4, r5, r6, lr}
    464a:	b082      	sub	sp, #8
	LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
    464c:	2800      	cmp	r0, #0
    464e:	d052      	beq.n	46f6 <dhcp_start+0xae>
    4650:	4604      	mov	r4, r0
	dhcp = netif->dhcp;
    4652:	6a85      	ldr	r5, [r0, #40]	; 0x28
	LWIP_DEBUGF(
    4654:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
    4658:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
    465c:	f890 1038 	ldrb.w	r1, [r0, #56]	; 0x38
    4660:	9100      	str	r1, [sp, #0]
    4662:	4601      	mov	r1, r0
    4664:	483d      	ldr	r0, [pc, #244]	; (475c <dhcp_start+0x114>)
    4666:	4e3e      	ldr	r6, [pc, #248]	; (4760 <dhcp_start+0x118>)
    4668:	47b0      	blx	r6
	netif->flags &= ~NETIF_FLAG_DHCP;
    466a:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    466e:	f023 0208 	bic.w	r2, r3, #8
    4672:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
	if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
    4676:	f013 0f20 	tst.w	r3, #32
    467a:	d044      	beq.n	4706 <dhcp_start+0xbe>
	if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
    467c:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    467e:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
    4682:	d346      	bcc.n	4712 <dhcp_start+0xca>
	if (dhcp == NULL) {
    4684:	2d00      	cmp	r5, #0
    4686:	d04a      	beq.n	471e <dhcp_start+0xd6>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    4688:	4836      	ldr	r0, [pc, #216]	; (4764 <dhcp_start+0x11c>)
    468a:	4b37      	ldr	r3, [pc, #220]	; (4768 <dhcp_start+0x120>)
    468c:	4798      	blx	r3
		if (dhcp->pcb != NULL) {
    468e:	6868      	ldr	r0, [r5, #4]
    4690:	b108      	cbz	r0, 4696 <dhcp_start+0x4e>
			udp_remove(dhcp->pcb);
    4692:	4b36      	ldr	r3, [pc, #216]	; (476c <dhcp_start+0x124>)
    4694:	4798      	blx	r3
	memset(dhcp, 0, sizeof(struct dhcp));
    4696:	223c      	movs	r2, #60	; 0x3c
    4698:	2100      	movs	r1, #0
    469a:	4628      	mov	r0, r5
    469c:	4b34      	ldr	r3, [pc, #208]	; (4770 <dhcp_start+0x128>)
    469e:	4798      	blx	r3
	dhcp->pcb = udp_new();
    46a0:	4b34      	ldr	r3, [pc, #208]	; (4774 <dhcp_start+0x12c>)
    46a2:	4798      	blx	r3
    46a4:	6068      	str	r0, [r5, #4]
	if (dhcp->pcb == NULL) {
    46a6:	2800      	cmp	r0, #0
    46a8:	d04c      	beq.n	4744 <dhcp_start+0xfc>
	ip_set_option(dhcp->pcb, SOF_BROADCAST);
    46aa:	7a03      	ldrb	r3, [r0, #8]
    46ac:	f043 0320 	orr.w	r3, r3, #32
    46b0:	7203      	strb	r3, [r0, #8]
	udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    46b2:	4e31      	ldr	r6, [pc, #196]	; (4778 <dhcp_start+0x130>)
    46b4:	2244      	movs	r2, #68	; 0x44
    46b6:	4631      	mov	r1, r6
    46b8:	6868      	ldr	r0, [r5, #4]
    46ba:	4b30      	ldr	r3, [pc, #192]	; (477c <dhcp_start+0x134>)
    46bc:	4798      	blx	r3
	udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
    46be:	2243      	movs	r2, #67	; 0x43
    46c0:	4631      	mov	r1, r6
    46c2:	6868      	ldr	r0, [r5, #4]
    46c4:	4b2e      	ldr	r3, [pc, #184]	; (4780 <dhcp_start+0x138>)
    46c6:	4798      	blx	r3
	udp_recv(dhcp->pcb, dhcp_recv, netif);
    46c8:	4622      	mov	r2, r4
    46ca:	492e      	ldr	r1, [pc, #184]	; (4784 <dhcp_start+0x13c>)
    46cc:	6868      	ldr	r0, [r5, #4]
    46ce:	4b2e      	ldr	r3, [pc, #184]	; (4788 <dhcp_start+0x140>)
    46d0:	4798      	blx	r3
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
    46d2:	482e      	ldr	r0, [pc, #184]	; (478c <dhcp_start+0x144>)
    46d4:	4b24      	ldr	r3, [pc, #144]	; (4768 <dhcp_start+0x120>)
    46d6:	4798      	blx	r3
	result = dhcp_discover(netif);
    46d8:	4620      	mov	r0, r4
    46da:	4b2d      	ldr	r3, [pc, #180]	; (4790 <dhcp_start+0x148>)
    46dc:	4798      	blx	r3
	if (result != ERR_OK) {
    46de:	4603      	mov	r3, r0
    46e0:	2800      	cmp	r0, #0
    46e2:	d135      	bne.n	4750 <dhcp_start+0x108>
	netif->flags |= NETIF_FLAG_DHCP;
    46e4:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
    46e8:	f042 0208 	orr.w	r2, r2, #8
    46ec:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
}
    46f0:	4618      	mov	r0, r3
    46f2:	b002      	add	sp, #8
    46f4:	bd70      	pop	{r4, r5, r6, pc}
	LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
    46f6:	4b27      	ldr	r3, [pc, #156]	; (4794 <dhcp_start+0x14c>)
    46f8:	f240 227a 	movw	r2, #634	; 0x27a
    46fc:	4926      	ldr	r1, [pc, #152]	; (4798 <dhcp_start+0x150>)
    46fe:	4827      	ldr	r0, [pc, #156]	; (479c <dhcp_start+0x154>)
    4700:	4c17      	ldr	r4, [pc, #92]	; (4760 <dhcp_start+0x118>)
    4702:	47a0      	blx	r4
    4704:	e7fe      	b.n	4704 <dhcp_start+0xbc>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): No ETHARP netif\n"));
    4706:	4826      	ldr	r0, [pc, #152]	; (47a0 <dhcp_start+0x158>)
    4708:	4b17      	ldr	r3, [pc, #92]	; (4768 <dhcp_start+0x120>)
    470a:	4798      	blx	r3
		return ERR_ARG;
    470c:	f06f 030d 	mvn.w	r3, #13
    4710:	e7ee      	b.n	46f0 <dhcp_start+0xa8>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    4712:	4824      	ldr	r0, [pc, #144]	; (47a4 <dhcp_start+0x15c>)
    4714:	4b14      	ldr	r3, [pc, #80]	; (4768 <dhcp_start+0x120>)
    4716:	4798      	blx	r3
		return ERR_MEM;
    4718:	f04f 33ff 	mov.w	r3, #4294967295
    471c:	e7e8      	b.n	46f0 <dhcp_start+0xa8>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    471e:	4822      	ldr	r0, [pc, #136]	; (47a8 <dhcp_start+0x160>)
    4720:	4b11      	ldr	r3, [pc, #68]	; (4768 <dhcp_start+0x120>)
    4722:	4798      	blx	r3
		dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
    4724:	203c      	movs	r0, #60	; 0x3c
    4726:	4b21      	ldr	r3, [pc, #132]	; (47ac <dhcp_start+0x164>)
    4728:	4798      	blx	r3
		if (dhcp == NULL) {
    472a:	4605      	mov	r5, r0
    472c:	b120      	cbz	r0, 4738 <dhcp_start+0xf0>
		netif->dhcp = dhcp;
    472e:	62a0      	str	r0, [r4, #40]	; 0x28
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
    4730:	481f      	ldr	r0, [pc, #124]	; (47b0 <dhcp_start+0x168>)
    4732:	4b0b      	ldr	r3, [pc, #44]	; (4760 <dhcp_start+0x118>)
    4734:	4798      	blx	r3
    4736:	e7ae      	b.n	4696 <dhcp_start+0x4e>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
    4738:	481e      	ldr	r0, [pc, #120]	; (47b4 <dhcp_start+0x16c>)
    473a:	4b0b      	ldr	r3, [pc, #44]	; (4768 <dhcp_start+0x120>)
    473c:	4798      	blx	r3
			return ERR_MEM;
    473e:	f04f 33ff 	mov.w	r3, #4294967295
    4742:	e7d5      	b.n	46f0 <dhcp_start+0xa8>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    4744:	481c      	ldr	r0, [pc, #112]	; (47b8 <dhcp_start+0x170>)
    4746:	4b08      	ldr	r3, [pc, #32]	; (4768 <dhcp_start+0x120>)
    4748:	4798      	blx	r3
		return ERR_MEM;
    474a:	f04f 33ff 	mov.w	r3, #4294967295
    474e:	e7cf      	b.n	46f0 <dhcp_start+0xa8>
		dhcp_stop(netif);
    4750:	4620      	mov	r0, r4
    4752:	4b1a      	ldr	r3, [pc, #104]	; (47bc <dhcp_start+0x174>)
    4754:	4798      	blx	r3
		return ERR_MEM;
    4756:	f04f 33ff 	mov.w	r3, #4294967295
    475a:	e7c9      	b.n	46f0 <dhcp_start+0xa8>
    475c:	0000c12c 	.word	0x0000c12c
    4760:	00009fd5 	.word	0x00009fd5
    4764:	0000c21c 	.word	0x0000c21c
    4768:	0000a0bd 	.word	0x0000a0bd
    476c:	00008e5d 	.word	0x00008e5d
    4770:	00009fc5 	.word	0x00009fc5
    4774:	00008e99 	.word	0x00008e99
    4778:	0000c29c 	.word	0x0000c29c
    477c:	00008bd5 	.word	0x00008bd5
    4780:	00008df5 	.word	0x00008df5
    4784:	00003851 	.word	0x00003851
    4788:	00008e55 	.word	0x00008e55
    478c:	0000c26c 	.word	0x0000c26c
    4790:	000032b1 	.word	0x000032b1
    4794:	0000b2a0 	.word	0x0000b2a0
    4798:	0000bbf4 	.word	0x0000bbf4
    479c:	0000b2e8 	.word	0x0000b2e8
    47a0:	0000c14c 	.word	0x0000c14c
    47a4:	0000c16c 	.word	0x0000c16c
    47a8:	0000c1ac 	.word	0x0000c1ac
    47ac:	0000582d 	.word	0x0000582d
    47b0:	0000c1fc 	.word	0x0000c1fc
    47b4:	0000c1d4 	.word	0x0000c1d4
    47b8:	0000c248 	.word	0x0000c248
    47bc:	000045e9 	.word	0x000045e9

000047c0 <lwip_init>:

/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void lwip_init(void)
{
    47c0:	b508      	push	{r3, lr}
	/* Modules initialization */
	stats_init();
#if !NO_SYS
	sys_init();
#endif /* !NO_SYS */
	mem_init();
    47c2:	4b06      	ldr	r3, [pc, #24]	; (47dc <lwip_init+0x1c>)
    47c4:	4798      	blx	r3
	memp_init();
    47c6:	4b06      	ldr	r3, [pc, #24]	; (47e0 <lwip_init+0x20>)
    47c8:	4798      	blx	r3
	pbuf_init();
	netif_init();
    47ca:	4b06      	ldr	r3, [pc, #24]	; (47e4 <lwip_init+0x24>)
    47cc:	4798      	blx	r3
#endif /* LWIP_ARP */
#if LWIP_RAW
	raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
	udp_init();
    47ce:	4b06      	ldr	r3, [pc, #24]	; (47e8 <lwip_init+0x28>)
    47d0:	4798      	blx	r3
#endif /* LWIP_UDP */
#if LWIP_TCP
	tcp_init();
    47d2:	4b06      	ldr	r3, [pc, #24]	; (47ec <lwip_init+0x2c>)
    47d4:	4798      	blx	r3
#if LWIP_DNS
	dns_init();
#endif /* LWIP_DNS */

#if LWIP_TIMERS
	sys_timeouts_init();
    47d6:	4b06      	ldr	r3, [pc, #24]	; (47f0 <lwip_init+0x30>)
    47d8:	4798      	blx	r3
    47da:	bd08      	pop	{r3, pc}
    47dc:	000056a5 	.word	0x000056a5
    47e0:	00005901 	.word	0x00005901
    47e4:	000059d9 	.word	0x000059d9
    47e8:	000089e1 	.word	0x000089e1
    47ec:	00006129 	.word	0x00006129
    47f0:	000088a1 	.word	0x000088a1

000047f4 <icmp_send_response>:
 *          p->payload pointing to the IP header
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
    47f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    47f8:	b085      	sub	sp, #20
    47fa:	4680      	mov	r8, r0
    47fc:	4689      	mov	r9, r1
    47fe:	4615      	mov	r5, r2
	/* we can use the echo header here */
	struct icmp_echo_hdr *icmphdr;
	ip_addr_t             iphdr_src;

	/* ICMP header + IP header + 8 bytes of data */
	q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE, PBUF_RAM);
    4800:	2200      	movs	r2, #0
    4802:	2124      	movs	r1, #36	; 0x24
    4804:	2001      	movs	r0, #1
    4806:	4b22      	ldr	r3, [pc, #136]	; (4890 <icmp_send_response+0x9c>)
    4808:	4798      	blx	r3
	if (q == NULL) {
    480a:	2800      	cmp	r0, #0
    480c:	d03d      	beq.n	488a <icmp_send_response+0x96>
    480e:	4606      	mov	r6, r0
		return;
	}
	LWIP_ASSERT("check that first pbuf can hold icmp message",
	            (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

	iphdr = (struct ip_hdr *)p->payload;
    4810:	f8d8 7004 	ldr.w	r7, [r8, #4]
	ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
	LWIP_DEBUGF(ICMP_DEBUG, (" to "));
	ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
	LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

	icmphdr        = (struct icmp_echo_hdr *)q->payload;
    4814:	6844      	ldr	r4, [r0, #4]
	icmphdr->type  = type;
    4816:	f884 9000 	strb.w	r9, [r4]
	icmphdr->code  = code;
    481a:	7065      	strb	r5, [r4, #1]
	icmphdr->id    = 0;
    481c:	2500      	movs	r5, #0
    481e:	7125      	strb	r5, [r4, #4]
    4820:	7165      	strb	r5, [r4, #5]
	icmphdr->seqno = 0;
    4822:	71a5      	strb	r5, [r4, #6]
    4824:	71e5      	strb	r5, [r4, #7]

	/* copy fields from original packet */
	SMEMCPY(
    4826:	f8d0 c004 	ldr.w	ip, [r0, #4]
    482a:	f8d8 3004 	ldr.w	r3, [r8, #4]
    482e:	f8d3 e000 	ldr.w	lr, [r3]
    4832:	6858      	ldr	r0, [r3, #4]
    4834:	6899      	ldr	r1, [r3, #8]
    4836:	f8d3 800c 	ldr.w	r8, [r3, #12]
    483a:	f8cc e008 	str.w	lr, [ip, #8]
    483e:	f8cc 000c 	str.w	r0, [ip, #12]
    4842:	f8cc 1010 	str.w	r1, [ip, #16]
    4846:	f8cc 8014 	str.w	r8, [ip, #20]
    484a:	f8d3 e010 	ldr.w	lr, [r3, #16]
    484e:	6958      	ldr	r0, [r3, #20]
    4850:	6999      	ldr	r1, [r3, #24]
    4852:	f8cc e018 	str.w	lr, [ip, #24]
    4856:	f8cc 001c 	str.w	r0, [ip, #28]
    485a:	f8cc 1020 	str.w	r1, [ip, #32]
	    (u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload, IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

	/* calculate checksum */
	icmphdr->chksum = 0;
    485e:	70a5      	strb	r5, [r4, #2]
    4860:	70e5      	strb	r5, [r4, #3]
	icmphdr->chksum = inet_chksum(icmphdr, q->len);
    4862:	8971      	ldrh	r1, [r6, #10]
    4864:	4620      	mov	r0, r4
    4866:	4b0b      	ldr	r3, [pc, #44]	; (4894 <icmp_send_response+0xa0>)
    4868:	4798      	blx	r3
    486a:	8060      	strh	r0, [r4, #2]
	ICMP_STATS_INC(icmp.xmit);
	/* increase number of messages attempted to send */
	snmp_inc_icmpoutmsgs();
	/* increase number of destination unreachable messages attempted to send */
	snmp_inc_icmpouttimeexcds();
	ip_addr_copy(iphdr_src, iphdr->src);
    486c:	68fb      	ldr	r3, [r7, #12]
    486e:	aa04      	add	r2, sp, #16
    4870:	f842 3d04 	str.w	r3, [r2, #-4]!
	ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
    4874:	2301      	movs	r3, #1
    4876:	9301      	str	r3, [sp, #4]
    4878:	9500      	str	r5, [sp, #0]
    487a:	23ff      	movs	r3, #255	; 0xff
    487c:	4629      	mov	r1, r5
    487e:	4630      	mov	r0, r6
    4880:	4c05      	ldr	r4, [pc, #20]	; (4898 <icmp_send_response+0xa4>)
    4882:	47a0      	blx	r4
	pbuf_free(q);
    4884:	4630      	mov	r0, r6
    4886:	4b05      	ldr	r3, [pc, #20]	; (489c <icmp_send_response+0xa8>)
    4888:	4798      	blx	r3
}
    488a:	b005      	add	sp, #20
    488c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4890:	00005cf1 	.word	0x00005cf1
    4894:	00004b29 	.word	0x00004b29
    4898:	00004eb9 	.word	0x00004eb9
    489c:	00005c89 	.word	0x00005c89

000048a0 <icmp_input>:
{
    48a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    48a4:	b085      	sub	sp, #20
    48a6:	4606      	mov	r6, r0
    48a8:	4688      	mov	r8, r1
	iphdr = (struct ip_hdr *)p->payload;
    48aa:	6847      	ldr	r7, [r0, #4]
	hlen  = IPH_HL(iphdr) * 4;
    48ac:	783c      	ldrb	r4, [r7, #0]
    48ae:	f004 040f 	and.w	r4, r4, #15
    48b2:	00a4      	lsls	r4, r4, #2
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
    48b4:	4265      	negs	r5, r4
    48b6:	b22d      	sxth	r5, r5
    48b8:	4629      	mov	r1, r5
    48ba:	4b45      	ldr	r3, [pc, #276]	; (49d0 <icmp_input+0x130>)
    48bc:	4798      	blx	r3
    48be:	b9a0      	cbnz	r0, 48ea <icmp_input+0x4a>
    48c0:	8933      	ldrh	r3, [r6, #8]
    48c2:	2b03      	cmp	r3, #3
    48c4:	d911      	bls.n	48ea <icmp_input+0x4a>
	type = *((u8_t *)p->payload);
    48c6:	6873      	ldr	r3, [r6, #4]
	switch (type) {
    48c8:	781b      	ldrb	r3, [r3, #0]
    48ca:	2b08      	cmp	r3, #8
    48cc:	d16f      	bne.n	49ae <icmp_input+0x10e>
		if (ip_addr_ismulticast(&current_iphdr_dest)) {
    48ce:	4b41      	ldr	r3, [pc, #260]	; (49d4 <icmp_input+0x134>)
    48d0:	6818      	ldr	r0, [r3, #0]
    48d2:	f000 09f0 	and.w	r9, r0, #240	; 0xf0
		if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
    48d6:	4641      	mov	r1, r8
    48d8:	4b3f      	ldr	r3, [pc, #252]	; (49d8 <icmp_input+0x138>)
    48da:	4798      	blx	r3
    48dc:	b958      	cbnz	r0, 48f6 <icmp_input+0x56>
		if (!accepted) {
    48de:	f1b9 0fe0 	cmp.w	r9, #224	; 0xe0
    48e2:	d008      	beq.n	48f6 <icmp_input+0x56>
		if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
    48e4:	8933      	ldrh	r3, [r6, #8]
    48e6:	2b07      	cmp	r3, #7
    48e8:	d809      	bhi.n	48fe <icmp_input+0x5e>
	pbuf_free(p);
    48ea:	4630      	mov	r0, r6
    48ec:	4b3b      	ldr	r3, [pc, #236]	; (49dc <icmp_input+0x13c>)
    48ee:	4798      	blx	r3
}
    48f0:	b005      	add	sp, #20
    48f2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			pbuf_free(p);
    48f6:	4630      	mov	r0, r6
    48f8:	4b38      	ldr	r3, [pc, #224]	; (49dc <icmp_input+0x13c>)
    48fa:	4798      	blx	r3
			return;
    48fc:	e7f8      	b.n	48f0 <icmp_input+0x50>
		if (inet_chksum_pbuf(p) != 0) {
    48fe:	4630      	mov	r0, r6
    4900:	4b37      	ldr	r3, [pc, #220]	; (49e0 <icmp_input+0x140>)
    4902:	4798      	blx	r3
    4904:	b970      	cbnz	r0, 4924 <icmp_input+0x84>
	hlen  = IPH_HL(iphdr) * 4;
    4906:	b224      	sxth	r4, r4
		if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    4908:	2122      	movs	r1, #34	; 0x22
    490a:	4630      	mov	r0, r6
    490c:	4b30      	ldr	r3, [pc, #192]	; (49d0 <icmp_input+0x130>)
    490e:	4798      	blx	r3
    4910:	b330      	cbz	r0, 4960 <icmp_input+0xc0>
			if (pbuf_header(p, hlen)) {
    4912:	4621      	mov	r1, r4
    4914:	4630      	mov	r0, r6
    4916:	4b2e      	ldr	r3, [pc, #184]	; (49d0 <icmp_input+0x130>)
    4918:	4798      	blx	r3
    491a:	b138      	cbz	r0, 492c <icmp_input+0x8c>
	pbuf_free(p);
    491c:	4630      	mov	r0, r6
    491e:	4b2f      	ldr	r3, [pc, #188]	; (49dc <icmp_input+0x13c>)
    4920:	4798      	blx	r3
	return;
    4922:	e7e5      	b.n	48f0 <icmp_input+0x50>
			pbuf_free(p);
    4924:	4630      	mov	r0, r6
    4926:	4b2d      	ldr	r3, [pc, #180]	; (49dc <icmp_input+0x13c>)
    4928:	4798      	blx	r3
			return;
    492a:	e7e1      	b.n	48f0 <icmp_input+0x50>
			r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
    492c:	2200      	movs	r2, #0
    492e:	8931      	ldrh	r1, [r6, #8]
    4930:	2002      	movs	r0, #2
    4932:	4b2c      	ldr	r3, [pc, #176]	; (49e4 <icmp_input+0x144>)
    4934:	4798      	blx	r3
			if (r == NULL) {
    4936:	4681      	mov	r9, r0
    4938:	2800      	cmp	r0, #0
    493a:	d0ef      	beq.n	491c <icmp_input+0x7c>
			if (pbuf_copy(r, p) != ERR_OK) {
    493c:	4631      	mov	r1, r6
    493e:	4b2a      	ldr	r3, [pc, #168]	; (49e8 <icmp_input+0x148>)
    4940:	4798      	blx	r3
    4942:	2800      	cmp	r0, #0
    4944:	d1ea      	bne.n	491c <icmp_input+0x7c>
			iphdr = (struct ip_hdr *)r->payload;
    4946:	f8d9 7004 	ldr.w	r7, [r9, #4]
			if (pbuf_header(r, -hlen)) {
    494a:	4629      	mov	r1, r5
    494c:	4648      	mov	r0, r9
    494e:	4b20      	ldr	r3, [pc, #128]	; (49d0 <icmp_input+0x130>)
    4950:	4798      	blx	r3
    4952:	2800      	cmp	r0, #0
    4954:	d1e2      	bne.n	491c <icmp_input+0x7c>
			pbuf_free(p);
    4956:	4630      	mov	r0, r6
    4958:	4b20      	ldr	r3, [pc, #128]	; (49dc <icmp_input+0x13c>)
    495a:	4798      	blx	r3
			p = r;
    495c:	464e      	mov	r6, r9
    495e:	e006      	b.n	496e <icmp_input+0xce>
			if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    4960:	f06f 0121 	mvn.w	r1, #33	; 0x21
    4964:	4630      	mov	r0, r6
    4966:	4b1a      	ldr	r3, [pc, #104]	; (49d0 <icmp_input+0x130>)
    4968:	4798      	blx	r3
    496a:	2800      	cmp	r0, #0
    496c:	d1d6      	bne.n	491c <icmp_input+0x7c>
		iecho = (struct icmp_echo_hdr *)p->payload;
    496e:	6872      	ldr	r2, [r6, #4]
		ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    4970:	4b18      	ldr	r3, [pc, #96]	; (49d4 <icmp_input+0x134>)
    4972:	681b      	ldr	r3, [r3, #0]
    4974:	60fb      	str	r3, [r7, #12]
		ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    4976:	4b1d      	ldr	r3, [pc, #116]	; (49ec <icmp_input+0x14c>)
    4978:	681b      	ldr	r3, [r3, #0]
    497a:	613b      	str	r3, [r7, #16]
		ICMPH_TYPE_SET(iecho, ICMP_ER);
    497c:	2300      	movs	r3, #0
    497e:	7013      	strb	r3, [r2, #0]
		if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
    4980:	8853      	ldrh	r3, [r2, #2]
    4982:	f64f 71f6 	movw	r1, #65526	; 0xfff6
    4986:	428b      	cmp	r3, r1
			iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
    4988:	bf8c      	ite	hi
    498a:	3309      	addhi	r3, #9
			iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
    498c:	3308      	addls	r3, #8
    498e:	8053      	strh	r3, [r2, #2]
		IPH_TTL_SET(iphdr, ICMP_TTL);
    4990:	23ff      	movs	r3, #255	; 0xff
    4992:	723b      	strb	r3, [r7, #8]
		IPH_CHKSUM_SET(iphdr, 0);
    4994:	2300      	movs	r3, #0
    4996:	72bb      	strb	r3, [r7, #10]
    4998:	72fb      	strb	r3, [r7, #11]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    499a:	2114      	movs	r1, #20
    499c:	4638      	mov	r0, r7
    499e:	4b14      	ldr	r3, [pc, #80]	; (49f0 <icmp_input+0x150>)
    49a0:	4798      	blx	r3
    49a2:	8178      	strh	r0, [r7, #10]
		if (pbuf_header(p, hlen)) {
    49a4:	4621      	mov	r1, r4
    49a6:	4630      	mov	r0, r6
    49a8:	4b09      	ldr	r3, [pc, #36]	; (49d0 <icmp_input+0x130>)
    49aa:	4798      	blx	r3
    49ac:	b118      	cbz	r0, 49b6 <icmp_input+0x116>
	pbuf_free(p);
    49ae:	4630      	mov	r0, r6
    49b0:	4b0a      	ldr	r3, [pc, #40]	; (49dc <icmp_input+0x13c>)
    49b2:	4798      	blx	r3
	return;
    49b4:	e79c      	b.n	48f0 <icmp_input+0x50>
			ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL, ICMP_TTL, 0, IP_PROTO_ICMP, inp);
    49b6:	f8cd 8008 	str.w	r8, [sp, #8]
    49ba:	2301      	movs	r3, #1
    49bc:	9301      	str	r3, [sp, #4]
    49be:	2200      	movs	r2, #0
    49c0:	9200      	str	r2, [sp, #0]
    49c2:	23ff      	movs	r3, #255	; 0xff
    49c4:	4903      	ldr	r1, [pc, #12]	; (49d4 <icmp_input+0x134>)
    49c6:	4630      	mov	r0, r6
    49c8:	4c0a      	ldr	r4, [pc, #40]	; (49f4 <icmp_input+0x154>)
    49ca:	47a0      	blx	r4
    49cc:	e7ef      	b.n	49ae <icmp_input+0x10e>
    49ce:	bf00      	nop
    49d0:	00005bf5 	.word	0x00005bf5
    49d4:	20008334 	.word	0x20008334
    49d8:	00004ef9 	.word	0x00004ef9
    49dc:	00005c89 	.word	0x00005c89
    49e0:	00004b39 	.word	0x00004b39
    49e4:	00005cf1 	.word	0x00005cf1
    49e8:	00005f15 	.word	0x00005f15
    49ec:	2000832c 	.word	0x2000832c
    49f0:	00004b29 	.word	0x00004b29
    49f4:	00004dbd 	.word	0x00004dbd

000049f8 <icmp_dest_unreach>:
{
    49f8:	b508      	push	{r3, lr}
	icmp_send_response(p, ICMP_DUR, t);
    49fa:	460a      	mov	r2, r1
    49fc:	2103      	movs	r1, #3
    49fe:	4b01      	ldr	r3, [pc, #4]	; (4a04 <icmp_dest_unreach+0xc>)
    4a00:	4798      	blx	r3
    4a02:	bd08      	pop	{r3, pc}
    4a04:	000047f5 	.word	0x000047f5

00004a08 <icmp_time_exceeded>:
{
    4a08:	b508      	push	{r3, lr}
	icmp_send_response(p, ICMP_TE, t);
    4a0a:	460a      	mov	r2, r1
    4a0c:	210b      	movs	r1, #11
    4a0e:	4b01      	ldr	r3, [pc, #4]	; (4a14 <icmp_time_exceeded+0xc>)
    4a10:	4798      	blx	r3
    4a12:	bd08      	pop	{r3, pc}
    4a14:	000047f5 	.word	0x000047f5

00004a18 <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */

static u16_t lwip_standard_chksum(void *dataptr, int len)
{
    4a18:	b410      	push	{r4}
    4a1a:	b083      	sub	sp, #12
	u8_t * pb = (u8_t *)dataptr;
	u16_t *ps, t = 0;
    4a1c:	2300      	movs	r3, #0
    4a1e:	f8ad 3006 	strh.w	r3, [sp, #6]
	u32_t  sum = 0;
	int    odd = ((mem_ptr_t)pb & 1);

	/* Get aligned to u16_t */
	if (odd && len > 0) {
    4a22:	f010 0401 	ands.w	r4, r0, #1
    4a26:	d007      	beq.n	4a38 <lwip_standard_chksum+0x20>
    4a28:	4299      	cmp	r1, r3
    4a2a:	dd2a      	ble.n	4a82 <lwip_standard_chksum+0x6a>
		((u8_t *)&t)[1] = *pb++;
    4a2c:	1c43      	adds	r3, r0, #1
    4a2e:	7802      	ldrb	r2, [r0, #0]
    4a30:	f88d 2007 	strb.w	r2, [sp, #7]
		len--;
    4a34:	3901      	subs	r1, #1
    4a36:	e000      	b.n	4a3a <lwip_standard_chksum+0x22>
	u8_t * pb = (u8_t *)dataptr;
    4a38:	4603      	mov	r3, r0
	}

	/* Add the bulk of the data */
	ps = (u16_t *)(void *)pb;
	while (len > 1) {
    4a3a:	2901      	cmp	r1, #1
    4a3c:	dd1f      	ble.n	4a7e <lwip_standard_chksum+0x66>
	u8_t * pb = (u8_t *)dataptr;
    4a3e:	2200      	movs	r2, #0
		sum += *ps++;
    4a40:	f833 0b02 	ldrh.w	r0, [r3], #2
    4a44:	4402      	add	r2, r0
		len -= 2;
    4a46:	3902      	subs	r1, #2
	while (len > 1) {
    4a48:	2901      	cmp	r1, #1
    4a4a:	dcf9      	bgt.n	4a40 <lwip_standard_chksum+0x28>
	}

	/* Consume left-over byte, if any */
	if (len > 0) {
    4a4c:	2900      	cmp	r1, #0
		((u8_t *)&t)[0] = *(u8_t *)ps;
    4a4e:	bfc4      	itt	gt
    4a50:	781b      	ldrbgt	r3, [r3, #0]
    4a52:	f88d 3006 	strbgt.w	r3, [sp, #6]
	}

	/* Add end bytes */
	sum += t;
    4a56:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    4a5a:	4402      	add	r2, r0

	/* Fold 32-bit sum to 16 bits
	   calling this twice is propably faster than if statements... */
	sum = FOLD_U32T(sum);
    4a5c:	b290      	uxth	r0, r2
    4a5e:	eb00 4212 	add.w	r2, r0, r2, lsr #16
	sum = FOLD_U32T(sum);
    4a62:	b290      	uxth	r0, r2
    4a64:	eb00 4012 	add.w	r0, r0, r2, lsr #16

	/* Swap if alignment was odd */
	if (odd) {
    4a68:	b124      	cbz	r4, 4a74 <lwip_standard_chksum+0x5c>
		sum = SWAP_BYTES_IN_WORD(sum);
    4a6a:	0203      	lsls	r3, r0, #8
    4a6c:	b29b      	uxth	r3, r3
    4a6e:	f3c0 2007 	ubfx	r0, r0, #8, #8
    4a72:	4318      	orrs	r0, r3
	}

	return (u16_t)sum;
    4a74:	b280      	uxth	r0, r0
}
    4a76:	b003      	add	sp, #12
    4a78:	f85d 4b04 	ldr.w	r4, [sp], #4
    4a7c:	4770      	bx	lr
	u32_t  sum = 0;
    4a7e:	2200      	movs	r2, #0
    4a80:	e7e4      	b.n	4a4c <lwip_standard_chksum+0x34>
	while (len > 1) {
    4a82:	2901      	cmp	r1, #1
	u8_t * pb = (u8_t *)dataptr;
    4a84:	bfc8      	it	gt
    4a86:	4603      	movgt	r3, r0
	while (len > 1) {
    4a88:	dcd9      	bgt.n	4a3e <lwip_standard_chksum+0x26>
	sum = FOLD_U32T(sum);
    4a8a:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    4a8e:	e7ec      	b.n	4a6a <lwip_standard_chksum+0x52>

00004a90 <inet_chksum_pseudo>:
 * @param proto ip protocol (used for checksum of pseudo header)
 * @param proto_len length of the ip data part (used for checksum of pseudo header)
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t inet_chksum_pseudo(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t proto, u16_t proto_len)
{
    4a90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    4a94:	468a      	mov	sl, r1
    4a96:	4691      	mov	r9, r2
    4a98:	4698      	mov	r8, r3
	u8_t         swapped;

	acc     = 0;
	swapped = 0;
	/* iterate through all pbuf in chain */
	for (q = p; q != NULL; q = q->next) {
    4a9a:	2800      	cmp	r0, #0
    4a9c:	d03e      	beq.n	4b1c <inet_chksum_pseudo+0x8c>
    4a9e:	4605      	mov	r5, r0
    4aa0:	2600      	movs	r6, #0
    4aa2:	4634      	mov	r4, r6
		LWIP_DEBUGF(INET_DEBUG,
		            ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n", (void *)q, (void *)q->next));
		acc += LWIP_CHKSUM(q->payload, q->len);
    4aa4:	4f1e      	ldr	r7, [pc, #120]	; (4b20 <inet_chksum_pseudo+0x90>)
    4aa6:	e001      	b.n	4aac <inet_chksum_pseudo+0x1c>
	for (q = p; q != NULL; q = q->next) {
    4aa8:	682d      	ldr	r5, [r5, #0]
    4aaa:	b19d      	cbz	r5, 4ad4 <inet_chksum_pseudo+0x44>
		acc += LWIP_CHKSUM(q->payload, q->len);
    4aac:	8969      	ldrh	r1, [r5, #10]
    4aae:	6868      	ldr	r0, [r5, #4]
    4ab0:	47b8      	blx	r7
    4ab2:	4404      	add	r4, r0
		/*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
		/* just executing this next line is probably faster that the if statement needed
		   to check whether we really need to execute it, and does no harm */
		acc = FOLD_U32T(acc);
    4ab4:	b2a0      	uxth	r0, r4
    4ab6:	eb00 4414 	add.w	r4, r0, r4, lsr #16
		if (q->len % 2 != 0) {
    4aba:	896b      	ldrh	r3, [r5, #10]
    4abc:	f013 0f01 	tst.w	r3, #1
    4ac0:	d0f2      	beq.n	4aa8 <inet_chksum_pseudo+0x18>
			swapped = 1 - swapped;
    4ac2:	f1c6 0601 	rsb	r6, r6, #1
    4ac6:	b2f6      	uxtb	r6, r6
			acc     = SWAP_BYTES_IN_WORD(acc);
    4ac8:	0223      	lsls	r3, r4, #8
    4aca:	b29b      	uxth	r3, r3
    4acc:	f3c4 2407 	ubfx	r4, r4, #8, #8
    4ad0:	431c      	orrs	r4, r3
    4ad2:	e7e9      	b.n	4aa8 <inet_chksum_pseudo+0x18>
		}
		/*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
	}

	if (swapped) {
    4ad4:	b126      	cbz	r6, 4ae0 <inet_chksum_pseudo+0x50>
		acc = SWAP_BYTES_IN_WORD(acc);
    4ad6:	0223      	lsls	r3, r4, #8
    4ad8:	b29b      	uxth	r3, r3
    4ada:	f3c4 2407 	ubfx	r4, r4, #8, #8
    4ade:	431c      	orrs	r4, r3
	}
	addr = ip4_addr_get_u32(src);
    4ae0:	f8da 2000 	ldr.w	r2, [sl]
	acc += (addr & 0xffffUL);
	acc += ((addr >> 16) & 0xffffUL);
	addr = ip4_addr_get_u32(dest);
    4ae4:	f8d9 3000 	ldr.w	r3, [r9]
	acc += (addr & 0xffffUL);
	acc += ((addr >> 16) & 0xffffUL);
    4ae8:	0c18      	lsrs	r0, r3, #16
    4aea:	fa10 f083 	uxtah	r0, r0, r3
    4aee:	fa10 f082 	uxtah	r0, r0, r2
    4af2:	eb00 4012 	add.w	r0, r0, r2, lsr #16
    4af6:	4404      	add	r4, r0
	acc += (u32_t)htons((u16_t)proto);
    4af8:	4640      	mov	r0, r8
    4afa:	4d0a      	ldr	r5, [pc, #40]	; (4b24 <inet_chksum_pseudo+0x94>)
    4afc:	47a8      	blx	r5
    4afe:	4404      	add	r4, r0
	acc += (u32_t)htons(proto_len);
    4b00:	f8bd 0020 	ldrh.w	r0, [sp, #32]
    4b04:	47a8      	blx	r5
    4b06:	4420      	add	r0, r4

	/* Fold 32-bit sum to 16 bits
	   calling this twice is propably faster than if statements... */
	acc = FOLD_U32T(acc);
    4b08:	b284      	uxth	r4, r0
    4b0a:	eb04 4410 	add.w	r4, r4, r0, lsr #16
	acc = FOLD_U32T(acc);
    4b0e:	b2a0      	uxth	r0, r4
    4b10:	eb00 4014 	add.w	r0, r0, r4, lsr #16
	LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%" X32_F "\n", acc));
	return (u16_t) ~(acc & 0xffffUL);
    4b14:	43c0      	mvns	r0, r0
}
    4b16:	b280      	uxth	r0, r0
    4b18:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	acc     = 0;
    4b1c:	2400      	movs	r4, #0
    4b1e:	e7df      	b.n	4ae0 <inet_chksum_pseudo+0x50>
    4b20:	00004a19 	.word	0x00004a19
    4b24:	00002ea5 	.word	0x00002ea5

00004b28 <inet_chksum>:
 * @param len length of the buffer to calculate the checksum
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t inet_chksum(void *dataptr, u16_t len)
{
    4b28:	b508      	push	{r3, lr}
	return ~LWIP_CHKSUM(dataptr, len);
    4b2a:	4b02      	ldr	r3, [pc, #8]	; (4b34 <inet_chksum+0xc>)
    4b2c:	4798      	blx	r3
    4b2e:	43c0      	mvns	r0, r0
}
    4b30:	b280      	uxth	r0, r0
    4b32:	bd08      	pop	{r3, pc}
    4b34:	00004a19 	.word	0x00004a19

00004b38 <inet_chksum_pbuf>:
 *
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t inet_chksum_pbuf(struct pbuf *p)
{
    4b38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct pbuf *q;
	u8_t         swapped;

	acc     = 0;
	swapped = 0;
	for (q = p; q != NULL; q = q->next) {
    4b3a:	b318      	cbz	r0, 4b84 <inet_chksum_pbuf+0x4c>
    4b3c:	4605      	mov	r5, r0
    4b3e:	2600      	movs	r6, #0
    4b40:	4634      	mov	r4, r6
		acc += LWIP_CHKSUM(q->payload, q->len);
    4b42:	4f11      	ldr	r7, [pc, #68]	; (4b88 <inet_chksum_pbuf+0x50>)
    4b44:	e001      	b.n	4b4a <inet_chksum_pbuf+0x12>
	for (q = p; q != NULL; q = q->next) {
    4b46:	682d      	ldr	r5, [r5, #0]
    4b48:	b19d      	cbz	r5, 4b72 <inet_chksum_pbuf+0x3a>
		acc += LWIP_CHKSUM(q->payload, q->len);
    4b4a:	8969      	ldrh	r1, [r5, #10]
    4b4c:	6868      	ldr	r0, [r5, #4]
    4b4e:	47b8      	blx	r7
    4b50:	4420      	add	r0, r4
		acc = FOLD_U32T(acc);
    4b52:	b284      	uxth	r4, r0
    4b54:	eb04 4410 	add.w	r4, r4, r0, lsr #16
		if (q->len % 2 != 0) {
    4b58:	896b      	ldrh	r3, [r5, #10]
    4b5a:	f013 0f01 	tst.w	r3, #1
    4b5e:	d0f2      	beq.n	4b46 <inet_chksum_pbuf+0xe>
			swapped = 1 - swapped;
    4b60:	f1c6 0601 	rsb	r6, r6, #1
    4b64:	b2f6      	uxtb	r6, r6
			acc     = SWAP_BYTES_IN_WORD(acc);
    4b66:	0223      	lsls	r3, r4, #8
    4b68:	b29b      	uxth	r3, r3
    4b6a:	f3c4 2407 	ubfx	r4, r4, #8, #8
    4b6e:	431c      	orrs	r4, r3
    4b70:	e7e9      	b.n	4b46 <inet_chksum_pbuf+0xe>
		}
	}

	if (swapped) {
    4b72:	b126      	cbz	r6, 4b7e <inet_chksum_pbuf+0x46>
		acc = SWAP_BYTES_IN_WORD(acc);
    4b74:	0223      	lsls	r3, r4, #8
    4b76:	b29b      	uxth	r3, r3
    4b78:	f3c4 2407 	ubfx	r4, r4, #8, #8
    4b7c:	431c      	orrs	r4, r3
	}
	return (u16_t) ~(acc & 0xffffUL);
    4b7e:	43e0      	mvns	r0, r4
}
    4b80:	b280      	uxth	r0, r0
    4b82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	acc     = 0;
    4b84:	2400      	movs	r4, #0
    4b86:	e7fa      	b.n	4b7e <inet_chksum_pbuf+0x46>
    4b88:	00004a19 	.word	0x00004a19

00004b8c <ip_route>:
		return netif;
	}
#endif

	/* iterate through netifs */
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    4b8c:	4b0e      	ldr	r3, [pc, #56]	; (4bc8 <ip_route+0x3c>)
    4b8e:	681b      	ldr	r3, [r3, #0]
    4b90:	b973      	cbnz	r3, 4bb0 <ip_route+0x24>
				/* return netif on which to forward IP packet */
				return netif;
			}
		}
	}
	if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    4b92:	4b0e      	ldr	r3, [pc, #56]	; (4bcc <ip_route+0x40>)
    4b94:	681b      	ldr	r3, [r3, #0]
    4b96:	b133      	cbz	r3, 4ba6 <ip_route+0x1a>
    4b98:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
    4b9c:	f002 0201 	and.w	r2, r2, #1
		             ip4_addr2_16(dest),
		             ip4_addr3_16(dest),
		             ip4_addr4_16(dest)));
		IP_STATS_INC(ip.rterr);
		snmp_inc_ipoutnoroutes();
		return NULL;
    4ba0:	2a00      	cmp	r2, #0
    4ba2:	bf08      	it	eq
    4ba4:	2300      	moveq	r3, #0
	}
	/* no matching netif found, use default netif */
	return netif_default;
}
    4ba6:	4618      	mov	r0, r3
    4ba8:	4770      	bx	lr
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    4baa:	681b      	ldr	r3, [r3, #0]
    4bac:	2b00      	cmp	r3, #0
    4bae:	d0f0      	beq.n	4b92 <ip_route+0x6>
		if (netif_is_up(netif)) {
    4bb0:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
    4bb4:	f012 0f01 	tst.w	r2, #1
    4bb8:	d0f7      	beq.n	4baa <ip_route+0x1e>
			if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
    4bba:	6802      	ldr	r2, [r0, #0]
    4bbc:	6859      	ldr	r1, [r3, #4]
    4bbe:	404a      	eors	r2, r1
    4bc0:	6899      	ldr	r1, [r3, #8]
    4bc2:	420a      	tst	r2, r1
    4bc4:	d1f1      	bne.n	4baa <ip_route+0x1e>
    4bc6:	e7ee      	b.n	4ba6 <ip_route+0x1a>
    4bc8:	200092f0 	.word	0x200092f0
    4bcc:	200092f4 	.word	0x200092f4

00004bd0 <ip_input>:
 * @param inp the netif on which this packet was received
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t ip_input(struct pbuf *p, struct netif *inp)
{
    4bd0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4bd4:	4606      	mov	r6, r0

	IP_STATS_INC(ip.recv);
	snmp_inc_ipinreceives();

	/* identify the IP header */
	iphdr = (struct ip_hdr *)p->payload;
    4bd6:	f8d0 9004 	ldr.w	r9, [r0, #4]
	if (IPH_V(iphdr) != 4) {
    4bda:	f899 5000 	ldrb.w	r5, [r9]
    4bde:	092b      	lsrs	r3, r5, #4
    4be0:	2b04      	cmp	r3, #4
    4be2:	d004      	beq.n	4bee <ip_input+0x1e>
		LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING,
		            ("IP packet dropped due to bad version number %" U16_F "\n", IPH_V(iphdr)));
		ip_debug_print(p);
		pbuf_free(p);
    4be4:	4b65      	ldr	r3, [pc, #404]	; (4d7c <ip_input+0x1ac>)
    4be6:	4798      	blx	r3
	current_header = NULL;
	ip_addr_set_any(&current_iphdr_src);
	ip_addr_set_any(&current_iphdr_dest);

	return ERR_OK;
}
    4be8:	2000      	movs	r0, #0
    4bea:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4bee:	4688      	mov	r8, r1
	iphdr_hlen = IPH_HL(iphdr);
    4bf0:	f005 050f 	and.w	r5, r5, #15
	iphdr_hlen *= 4;
    4bf4:	00ad      	lsls	r5, r5, #2
	iphdr_len = ntohs(IPH_LEN(iphdr));
    4bf6:	f8b9 0002 	ldrh.w	r0, [r9, #2]
    4bfa:	4b61      	ldr	r3, [pc, #388]	; (4d80 <ip_input+0x1b0>)
    4bfc:	4798      	blx	r3
    4bfe:	4604      	mov	r4, r0
	if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    4c00:	8973      	ldrh	r3, [r6, #10]
    4c02:	42ab      	cmp	r3, r5
    4c04:	d302      	bcc.n	4c0c <ip_input+0x3c>
    4c06:	8933      	ldrh	r3, [r6, #8]
    4c08:	4283      	cmp	r3, r0
    4c0a:	d203      	bcs.n	4c14 <ip_input+0x44>
		pbuf_free(p);
    4c0c:	4630      	mov	r0, r6
    4c0e:	4b5b      	ldr	r3, [pc, #364]	; (4d7c <ip_input+0x1ac>)
    4c10:	4798      	blx	r3
		return ERR_OK;
    4c12:	e7e9      	b.n	4be8 <ip_input+0x18>
	if (inet_chksum(iphdr, iphdr_hlen) != 0) {
    4c14:	4629      	mov	r1, r5
    4c16:	4648      	mov	r0, r9
    4c18:	4b5a      	ldr	r3, [pc, #360]	; (4d84 <ip_input+0x1b4>)
    4c1a:	4798      	blx	r3
    4c1c:	b990      	cbnz	r0, 4c44 <ip_input+0x74>
	pbuf_realloc(p, iphdr_len);
    4c1e:	4621      	mov	r1, r4
    4c20:	4630      	mov	r0, r6
    4c22:	4b59      	ldr	r3, [pc, #356]	; (4d88 <ip_input+0x1b8>)
    4c24:	4798      	blx	r3
	ip_addr_copy(current_iphdr_dest, iphdr->dest);
    4c26:	f8d9 2010 	ldr.w	r2, [r9, #16]
    4c2a:	4b58      	ldr	r3, [pc, #352]	; (4d8c <ip_input+0x1bc>)
    4c2c:	601a      	str	r2, [r3, #0]
	ip_addr_copy(current_iphdr_src, iphdr->src);
    4c2e:	f8d9 200c 	ldr.w	r2, [r9, #12]
    4c32:	4b57      	ldr	r3, [pc, #348]	; (4d90 <ip_input+0x1c0>)
    4c34:	601a      	str	r2, [r3, #0]
		netif     = inp;
    4c36:	4644      	mov	r4, r8
		int first = 1;
    4c38:	2701      	movs	r7, #1
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    4c3a:	f8df b150 	ldr.w	fp, [pc, #336]	; 4d8c <ip_input+0x1bc>
				netif = netif_list;
    4c3e:	f8df a178 	ldr.w	sl, [pc, #376]	; 4db8 <ip_input+0x1e8>
    4c42:	e00b      	b.n	4c5c <ip_input+0x8c>
		pbuf_free(p);
    4c44:	4630      	mov	r0, r6
    4c46:	4b4d      	ldr	r3, [pc, #308]	; (4d7c <ip_input+0x1ac>)
    4c48:	4798      	blx	r3
		return ERR_OK;
    4c4a:	e7cd      	b.n	4be8 <ip_input+0x18>
			if (first) {
    4c4c:	b1ff      	cbz	r7, 4c8e <ip_input+0xbe>
				netif = netif_list;
    4c4e:	f8da 4000 	ldr.w	r4, [sl]
			if (netif == inp) {
    4c52:	4544      	cmp	r4, r8
				netif = netif->next;
    4c54:	bf08      	it	eq
    4c56:	6824      	ldreq	r4, [r4, #0]
    4c58:	2700      	movs	r7, #0
		} while (netif != NULL);
    4c5a:	b1d4      	cbz	r4, 4c92 <ip_input+0xc2>
			if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    4c5c:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    4c60:	f013 0f01 	tst.w	r3, #1
    4c64:	d0f2      	beq.n	4c4c <ip_input+0x7c>
    4c66:	f114 0f04 	cmn.w	r4, #4
    4c6a:	d0ef      	beq.n	4c4c <ip_input+0x7c>
    4c6c:	6863      	ldr	r3, [r4, #4]
    4c6e:	2b00      	cmp	r3, #0
    4c70:	d0ec      	beq.n	4c4c <ip_input+0x7c>
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    4c72:	f8db 0000 	ldr.w	r0, [fp]
    4c76:	4283      	cmp	r3, r0
    4c78:	d004      	beq.n	4c84 <ip_input+0xb4>
				    ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
    4c7a:	4621      	mov	r1, r4
    4c7c:	4b45      	ldr	r3, [pc, #276]	; (4d94 <ip_input+0x1c4>)
    4c7e:	4798      	blx	r3
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    4c80:	2800      	cmp	r0, #0
    4c82:	d0e3      	beq.n	4c4c <ip_input+0x7c>
	if (netif == NULL) {
    4c84:	b12c      	cbz	r4, 4c92 <ip_input+0xc2>
	if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
    4c86:	4b42      	ldr	r3, [pc, #264]	; (4d90 <ip_input+0x1c0>)
    4c88:	6818      	ldr	r0, [r3, #0]
    4c8a:	b1c0      	cbz	r0, 4cbe <ip_input+0xee>
    4c8c:	e00a      	b.n	4ca4 <ip_input+0xd4>
				netif = netif->next;
    4c8e:	6824      	ldr	r4, [r4, #0]
    4c90:	e7df      	b.n	4c52 <ip_input+0x82>
		if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
    4c92:	f899 3009 	ldrb.w	r3, [r9, #9]
    4c96:	2b11      	cmp	r3, #17
    4c98:	d049      	beq.n	4d2e <ip_input+0x15e>
	if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
    4c9a:	4b3d      	ldr	r3, [pc, #244]	; (4d90 <ip_input+0x1c0>)
    4c9c:	6818      	ldr	r0, [r3, #0]
    4c9e:	2800      	cmp	r0, #0
    4ca0:	d050      	beq.n	4d44 <ip_input+0x174>
    4ca2:	2400      	movs	r4, #0
		if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) || (ip_addr_ismulticast(&current_iphdr_src))) {
    4ca4:	4641      	mov	r1, r8
    4ca6:	4b3b      	ldr	r3, [pc, #236]	; (4d94 <ip_input+0x1c4>)
    4ca8:	4798      	blx	r3
    4caa:	2800      	cmp	r0, #0
    4cac:	d146      	bne.n	4d3c <ip_input+0x16c>
    4cae:	4b38      	ldr	r3, [pc, #224]	; (4d90 <ip_input+0x1c0>)
    4cb0:	681b      	ldr	r3, [r3, #0]
    4cb2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    4cb6:	2be0      	cmp	r3, #224	; 0xe0
    4cb8:	d040      	beq.n	4d3c <ip_input+0x16c>
	if (netif == NULL) {
    4cba:	2c00      	cmp	r4, #0
    4cbc:	d042      	beq.n	4d44 <ip_input+0x174>
	if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
    4cbe:	f8b9 3006 	ldrh.w	r3, [r9, #6]
    4cc2:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    4cc6:	b29b      	uxth	r3, r3
    4cc8:	b13b      	cbz	r3, 4cda <ip_input+0x10a>
		p = ip_reass(p);
    4cca:	4630      	mov	r0, r6
    4ccc:	4b32      	ldr	r3, [pc, #200]	; (4d98 <ip_input+0x1c8>)
    4cce:	4798      	blx	r3
		if (p == NULL) {
    4cd0:	4606      	mov	r6, r0
    4cd2:	2800      	cmp	r0, #0
    4cd4:	d088      	beq.n	4be8 <ip_input+0x18>
		iphdr = (struct ip_hdr *)p->payload;
    4cd6:	f8d0 9004 	ldr.w	r9, [r0, #4]
	current_netif  = inp;
    4cda:	4b30      	ldr	r3, [pc, #192]	; (4d9c <ip_input+0x1cc>)
    4cdc:	f8c3 8000 	str.w	r8, [r3]
	current_header = iphdr;
    4ce0:	4b2f      	ldr	r3, [pc, #188]	; (4da0 <ip_input+0x1d0>)
    4ce2:	f8c3 9000 	str.w	r9, [r3]
	if (raw_input(p, inp) == 0)
    4ce6:	4641      	mov	r1, r8
    4ce8:	4630      	mov	r0, r6
    4cea:	4b2e      	ldr	r3, [pc, #184]	; (4da4 <ip_input+0x1d4>)
    4cec:	4798      	blx	r3
    4cee:	2800      	cmp	r0, #0
    4cf0:	d130      	bne.n	4d54 <ip_input+0x184>
		switch (IPH_PROTO(iphdr)) {
    4cf2:	f899 3009 	ldrb.w	r3, [r9, #9]
    4cf6:	2b06      	cmp	r3, #6
    4cf8:	d036      	beq.n	4d68 <ip_input+0x198>
    4cfa:	2b11      	cmp	r3, #17
    4cfc:	d026      	beq.n	4d4c <ip_input+0x17c>
    4cfe:	2b01      	cmp	r3, #1
    4d00:	d037      	beq.n	4d72 <ip_input+0x1a2>
			if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) && !ip_addr_ismulticast(&current_iphdr_dest)) {
    4d02:	4641      	mov	r1, r8
    4d04:	4b21      	ldr	r3, [pc, #132]	; (4d8c <ip_input+0x1bc>)
    4d06:	6818      	ldr	r0, [r3, #0]
    4d08:	4b22      	ldr	r3, [pc, #136]	; (4d94 <ip_input+0x1c4>)
    4d0a:	4798      	blx	r3
    4d0c:	b958      	cbnz	r0, 4d26 <ip_input+0x156>
    4d0e:	4b1f      	ldr	r3, [pc, #124]	; (4d8c <ip_input+0x1bc>)
    4d10:	681b      	ldr	r3, [r3, #0]
    4d12:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    4d16:	2be0      	cmp	r3, #224	; 0xe0
    4d18:	d005      	beq.n	4d26 <ip_input+0x156>
				p->payload = iphdr;
    4d1a:	f8c6 9004 	str.w	r9, [r6, #4]
				icmp_dest_unreach(p, ICMP_DUR_PROTO);
    4d1e:	2102      	movs	r1, #2
    4d20:	4630      	mov	r0, r6
    4d22:	4b21      	ldr	r3, [pc, #132]	; (4da8 <ip_input+0x1d8>)
    4d24:	4798      	blx	r3
			pbuf_free(p);
    4d26:	4630      	mov	r0, r6
    4d28:	4b14      	ldr	r3, [pc, #80]	; (4d7c <ip_input+0x1ac>)
    4d2a:	4798      	blx	r3
    4d2c:	e012      	b.n	4d54 <ip_input+0x184>
			if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
    4d2e:	444d      	add	r5, r9
    4d30:	886b      	ldrh	r3, [r5, #2]
    4d32:	f5b3 4f88 	cmp.w	r3, #17408	; 0x4400
    4d36:	d1b0      	bne.n	4c9a <ip_input+0xca>
				netif        = inp;
    4d38:	4644      	mov	r4, r8
    4d3a:	e7be      	b.n	4cba <ip_input+0xea>
			pbuf_free(p);
    4d3c:	4630      	mov	r0, r6
    4d3e:	4b0f      	ldr	r3, [pc, #60]	; (4d7c <ip_input+0x1ac>)
    4d40:	4798      	blx	r3
			return ERR_OK;
    4d42:	e751      	b.n	4be8 <ip_input+0x18>
		pbuf_free(p);
    4d44:	4630      	mov	r0, r6
    4d46:	4b0d      	ldr	r3, [pc, #52]	; (4d7c <ip_input+0x1ac>)
    4d48:	4798      	blx	r3
		return ERR_OK;
    4d4a:	e74d      	b.n	4be8 <ip_input+0x18>
			udp_input(p, inp);
    4d4c:	4641      	mov	r1, r8
    4d4e:	4630      	mov	r0, r6
    4d50:	4b16      	ldr	r3, [pc, #88]	; (4dac <ip_input+0x1dc>)
    4d52:	4798      	blx	r3
	current_netif  = NULL;
    4d54:	2300      	movs	r3, #0
    4d56:	4a11      	ldr	r2, [pc, #68]	; (4d9c <ip_input+0x1cc>)
    4d58:	6013      	str	r3, [r2, #0]
	current_header = NULL;
    4d5a:	4a11      	ldr	r2, [pc, #68]	; (4da0 <ip_input+0x1d0>)
    4d5c:	6013      	str	r3, [r2, #0]
	ip_addr_set_any(&current_iphdr_src);
    4d5e:	4a0c      	ldr	r2, [pc, #48]	; (4d90 <ip_input+0x1c0>)
    4d60:	6013      	str	r3, [r2, #0]
	ip_addr_set_any(&current_iphdr_dest);
    4d62:	4a0a      	ldr	r2, [pc, #40]	; (4d8c <ip_input+0x1bc>)
    4d64:	6013      	str	r3, [r2, #0]
	return ERR_OK;
    4d66:	e73f      	b.n	4be8 <ip_input+0x18>
			tcp_input(p, inp);
    4d68:	4641      	mov	r1, r8
    4d6a:	4630      	mov	r0, r6
    4d6c:	4b10      	ldr	r3, [pc, #64]	; (4db0 <ip_input+0x1e0>)
    4d6e:	4798      	blx	r3
			break;
    4d70:	e7f0      	b.n	4d54 <ip_input+0x184>
			icmp_input(p, inp);
    4d72:	4641      	mov	r1, r8
    4d74:	4630      	mov	r0, r6
    4d76:	4b0f      	ldr	r3, [pc, #60]	; (4db4 <ip_input+0x1e4>)
    4d78:	4798      	blx	r3
			break;
    4d7a:	e7eb      	b.n	4d54 <ip_input+0x184>
    4d7c:	00005c89 	.word	0x00005c89
    4d80:	00002eaf 	.word	0x00002eaf
    4d84:	00004b29 	.word	0x00004b29
    4d88:	00005e2d 	.word	0x00005e2d
    4d8c:	20008334 	.word	0x20008334
    4d90:	2000832c 	.word	0x2000832c
    4d94:	00004ef9 	.word	0x00004ef9
    4d98:	00005171 	.word	0x00005171
    4d9c:	20008330 	.word	0x20008330
    4da0:	20008338 	.word	0x20008338
    4da4:	000060b1 	.word	0x000060b1
    4da8:	000049f9 	.word	0x000049f9
    4dac:	000089e5 	.word	0x000089e5
    4db0:	00007575 	.word	0x00007575
    4db4:	000048a1 	.word	0x000048a1
    4db8:	200092f0 	.word	0x200092f0

00004dbc <ip_output_if>:
 *
 * @note ip_id: RFC791 "some host may be able to simply use
 *  unique identifiers independent of destination"
 */
err_t ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t ttl, u8_t tos, u8_t proto, struct netif *netif)
{
    4dbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4dc0:	b087      	sub	sp, #28
    4dc2:	4605      	mov	r5, r0
    4dc4:	9102      	str	r1, [sp, #8]
    4dc6:	f89d 8040 	ldrb.w	r8, [sp, #64]	; 0x40
    4dca:	f89d b044 	ldrb.w	fp, [sp, #68]	; 0x44
    4dce:	9e12      	ldr	r6, [sp, #72]	; 0x48
	LWIP_ASSERT("p->ref == 1", p->ref == 1);

	snmp_inc_ipoutrequests();

	/* Should the IP header be generated or is it already included in p? */
	if (dest != IP_HDRINCL) {
    4dd0:	9201      	str	r2, [sp, #4]
    4dd2:	2a00      	cmp	r2, #0
    4dd4:	d057      	beq.n	4e86 <ip_output_if+0xca>
    4dd6:	469a      	mov	sl, r3
    4dd8:	4617      	mov	r7, r2
			}
#endif /* CHECKSUM_GEN_IP_INLINE */
		}
#endif /* IP_OPTIONS_SEND */
		/* generate IP header */
		if (pbuf_header(p, IP_HLEN)) {
    4dda:	2114      	movs	r1, #20
    4ddc:	4b32      	ldr	r3, [pc, #200]	; (4ea8 <ip_output_if+0xec>)
    4dde:	4798      	blx	r3
    4de0:	2800      	cmp	r0, #0
    4de2:	d15d      	bne.n	4ea0 <ip_output_if+0xe4>
			IP_STATS_INC(ip.err);
			snmp_inc_ipoutdiscards();
			return ERR_BUF;
		}

		iphdr = (struct ip_hdr *)p->payload;
    4de4:	686c      	ldr	r4, [r5, #4]
		LWIP_ASSERT("check that first pbuf can hold struct ip_hdr", (p->len >= sizeof(struct ip_hdr)));

		IPH_TTL_SET(iphdr, ttl);
    4de6:	f884 a008 	strb.w	sl, [r4, #8]
		IPH_PROTO_SET(iphdr, proto);
    4dea:	f884 b009 	strb.w	fp, [r4, #9]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

		/* dest cannot be NULL here */
		ip_addr_copy(iphdr->dest, *dest);
    4dee:	683b      	ldr	r3, [r7, #0]
    4df0:	6123      	str	r3, [r4, #16]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    4df2:	b29a      	uxth	r2, r3
    4df4:	9203      	str	r2, [sp, #12]
		chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
    4df6:	ea4f 4913 	mov.w	r9, r3, lsr #16
#endif /* CHECKSUM_GEN_IP_INLINE */

		IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    4dfa:	2345      	movs	r3, #69	; 0x45
    4dfc:	7023      	strb	r3, [r4, #0]
		IPH_TOS_SET(iphdr, tos);
    4dfe:	f884 8001 	strb.w	r8, [r4, #1]
		chk_sum += LWIP_MAKE_U16(proto, ttl);
    4e02:	ea4a 2a0b 	orr.w	sl, sl, fp, lsl #8
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    4e06:	ea4f 2808 	mov.w	r8, r8, lsl #8
    4e0a:	ea48 0803 	orr.w	r8, r8, r3
    4e0e:	eb0a 0b08 	add.w	fp, sl, r8
#endif /* CHECKSUM_GEN_IP_INLINE */
		IPH_LEN_SET(iphdr, htons(p->tot_len));
    4e12:	8928      	ldrh	r0, [r5, #8]
    4e14:	4f25      	ldr	r7, [pc, #148]	; (4eac <ip_output_if+0xf0>)
    4e16:	47b8      	blx	r7
    4e18:	4682      	mov	sl, r0
    4e1a:	8060      	strh	r0, [r4, #2]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
		IPH_OFFSET_SET(iphdr, 0);
    4e1c:	2300      	movs	r3, #0
    4e1e:	71a3      	strb	r3, [r4, #6]
    4e20:	71e3      	strb	r3, [r4, #7]
		IPH_ID_SET(iphdr, htons(ip_id));
    4e22:	f8df 8090 	ldr.w	r8, [pc, #144]	; 4eb4 <ip_output_if+0xf8>
    4e26:	f8b8 0000 	ldrh.w	r0, [r8]
    4e2a:	47b8      	blx	r7
    4e2c:	80a0      	strh	r0, [r4, #4]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
		++ip_id;
    4e2e:	f8b8 3000 	ldrh.w	r3, [r8]
    4e32:	3301      	adds	r3, #1
    4e34:	f8a8 3000 	strh.w	r3, [r8]

		if (ip_addr_isany(src)) {
    4e38:	9b02      	ldr	r3, [sp, #8]
    4e3a:	b10b      	cbz	r3, 4e40 <ip_output_if+0x84>
    4e3c:	681b      	ldr	r3, [r3, #0]
    4e3e:	bb03      	cbnz	r3, 4e82 <ip_output_if+0xc6>
			ip_addr_copy(iphdr->src, netif->ip_addr);
    4e40:	6873      	ldr	r3, [r6, #4]
    4e42:	60e3      	str	r3, [r4, #12]
			/* src cannot be NULL here */
			ip_addr_copy(iphdr->src, *src);
		}

#if CHECKSUM_GEN_IP_INLINE
		chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
    4e44:	68e2      	ldr	r2, [r4, #12]
		chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
    4e46:	fa1b f382 	uxtah	r3, fp, r2
    4e4a:	eb03 4312 	add.w	r3, r3, r2, lsr #16
    4e4e:	9a03      	ldr	r2, [sp, #12]
    4e50:	4413      	add	r3, r2
    4e52:	444b      	add	r3, r9
    4e54:	449a      	add	sl, r3
    4e56:	4450      	add	r0, sl
		chk_sum        = (chk_sum >> 16) + (chk_sum & 0xFFFF);
    4e58:	fa1f fa80 	uxth.w	sl, r0
    4e5c:	eb0a 4010 	add.w	r0, sl, r0, lsr #16
		chk_sum        = (chk_sum >> 16) + chk_sum;
    4e60:	eb00 4010 	add.w	r0, r0, r0, lsr #16
		chk_sum        = ~chk_sum;
		iphdr->_chksum = chk_sum; /* network order */
    4e64:	43c0      	mvns	r0, r0
    4e66:	8160      	strh	r0, [r4, #10]
	}
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
	/* don't fragment if interface has mtu set to 0 [loopif] */
	if (netif->mtu && (p->tot_len > netif->mtu)) {
    4e68:	8db3      	ldrh	r3, [r6, #44]	; 0x2c
    4e6a:	b113      	cbz	r3, 4e72 <ip_output_if+0xb6>
    4e6c:	892a      	ldrh	r2, [r5, #8]
    4e6e:	429a      	cmp	r2, r3
    4e70:	d810      	bhi.n	4e94 <ip_output_if+0xd8>
		return ip_frag(p, netif, dest);
	}
#endif /* IP_FRAG */

	LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
	return netif->output(netif, p, dest);
    4e72:	6973      	ldr	r3, [r6, #20]
    4e74:	9a01      	ldr	r2, [sp, #4]
    4e76:	4629      	mov	r1, r5
    4e78:	4630      	mov	r0, r6
    4e7a:	4798      	blx	r3
}
    4e7c:	b007      	add	sp, #28
    4e7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ip_addr_copy(iphdr->src, *src);
    4e82:	60e3      	str	r3, [r4, #12]
    4e84:	e7de      	b.n	4e44 <ip_output_if+0x88>
		ip_addr_copy(dest_addr, iphdr->dest);
    4e86:	6843      	ldr	r3, [r0, #4]
    4e88:	691b      	ldr	r3, [r3, #16]
    4e8a:	aa06      	add	r2, sp, #24
    4e8c:	f842 3d04 	str.w	r3, [r2, #-4]!
    4e90:	9201      	str	r2, [sp, #4]
    4e92:	e7e9      	b.n	4e68 <ip_output_if+0xac>
		return ip_frag(p, netif, dest);
    4e94:	9a01      	ldr	r2, [sp, #4]
    4e96:	4631      	mov	r1, r6
    4e98:	4628      	mov	r0, r5
    4e9a:	4b05      	ldr	r3, [pc, #20]	; (4eb0 <ip_output_if+0xf4>)
    4e9c:	4798      	blx	r3
    4e9e:	e7ed      	b.n	4e7c <ip_output_if+0xc0>
			return ERR_BUF;
    4ea0:	f06f 0001 	mvn.w	r0, #1
    4ea4:	e7ea      	b.n	4e7c <ip_output_if+0xc0>
    4ea6:	bf00      	nop
    4ea8:	00005bf5 	.word	0x00005bf5
    4eac:	00002ea5 	.word	0x00002ea5
    4eb0:	000054cd 	.word	0x000054cd
    4eb4:	2000162c 	.word	0x2000162c

00004eb8 <ip_output>:
 *
 * @return ERR_RTE if no route is found
 *         see ip_output_if() for more return values
 */
err_t ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t ttl, u8_t tos, u8_t proto)
{
    4eb8:	b5f0      	push	{r4, r5, r6, r7, lr}
    4eba:	b085      	sub	sp, #20
    4ebc:	4605      	mov	r5, r0
    4ebe:	460e      	mov	r6, r1
    4ec0:	4614      	mov	r4, r2
    4ec2:	461f      	mov	r7, r3

	/* pbufs passed to IP must have a ref-count of 1 as their payload pointer
	   gets altered as the packet is passed down the stack */
	LWIP_ASSERT("p->ref == 1", p->ref == 1);

	if ((netif = ip_route(dest)) == NULL) {
    4ec4:	4610      	mov	r0, r2
    4ec6:	4b0a      	ldr	r3, [pc, #40]	; (4ef0 <ip_output+0x38>)
    4ec8:	4798      	blx	r3
    4eca:	b170      	cbz	r0, 4eea <ip_output+0x32>
		             ip4_addr4_16(dest)));
		IP_STATS_INC(ip.rterr);
		return ERR_RTE;
	}

	return ip_output_if(p, src, dest, ttl, tos, proto, netif);
    4ecc:	9002      	str	r0, [sp, #8]
    4ece:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    4ed2:	9301      	str	r3, [sp, #4]
    4ed4:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
    4ed8:	9300      	str	r3, [sp, #0]
    4eda:	463b      	mov	r3, r7
    4edc:	4622      	mov	r2, r4
    4ede:	4631      	mov	r1, r6
    4ee0:	4628      	mov	r0, r5
    4ee2:	4c04      	ldr	r4, [pc, #16]	; (4ef4 <ip_output+0x3c>)
    4ee4:	47a0      	blx	r4
}
    4ee6:	b005      	add	sp, #20
    4ee8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_RTE;
    4eea:	f06f 0003 	mvn.w	r0, #3
    4eee:	e7fa      	b.n	4ee6 <ip_output+0x2e>
    4ef0:	00004b8d 	.word	0x00004b8d
    4ef4:	00004dbd 	.word	0x00004dbd

00004ef8 <ip4_addr_isbroadcast>:
{
	ip_addr_t ipaddr;
	ip4_addr_set_u32(&ipaddr, addr);

	/* all ones (broadcast) or all zeroes (old skool broadcast) */
	if ((~addr == IPADDR_ANY) || (addr == IPADDR_ANY)) {
    4ef8:	1e43      	subs	r3, r0, #1
    4efa:	f113 0f03 	cmn.w	r3, #3
    4efe:	d812      	bhi.n	4f26 <ip4_addr_isbroadcast+0x2e>
		return 1;
		/* no broadcast support on this network interface? */
	} else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
    4f00:	f891 3035 	ldrb.w	r3, [r1, #53]	; 0x35
    4f04:	f013 0f02 	tst.w	r3, #2
    4f08:	d00f      	beq.n	4f2a <ip4_addr_isbroadcast+0x32>
		/* the given address cannot be a broadcast address
		 * nor can we check against any broadcast addresses */
		return 0;
		/* address matches network interface address exactly? => no broadcast */
	} else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    4f0a:	684b      	ldr	r3, [r1, #4]
    4f0c:	4298      	cmp	r0, r3
    4f0e:	d00e      	beq.n	4f2e <ip4_addr_isbroadcast+0x36>
		return 0;
		/*  on the same (sub) network... */
	} else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
    4f10:	688a      	ldr	r2, [r1, #8]
    4f12:	4043      	eors	r3, r0
    4f14:	4213      	tst	r3, r2
    4f16:	d10c      	bne.n	4f32 <ip4_addr_isbroadcast+0x3a>
	           /* ...and host identifier bits are all ones? =>... */
	           && ((addr & ~ip4_addr_get_u32(&netif->netmask))
    4f18:	43d2      	mvns	r2, r2
    4f1a:	ea32 0300 	bics.w	r3, r2, r0
		return 1;
    4f1e:	bf0c      	ite	eq
    4f20:	2001      	moveq	r0, #1
    4f22:	2000      	movne	r0, #0
    4f24:	4770      	bx	lr
    4f26:	2001      	movs	r0, #1
    4f28:	4770      	bx	lr
		return 0;
    4f2a:	2000      	movs	r0, #0
    4f2c:	4770      	bx	lr
		return 0;
    4f2e:	2000      	movs	r0, #0
    4f30:	4770      	bx	lr
	               == (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
		/* => network broadcast address */
		return 1;
	} else {
		return 0;
    4f32:	2000      	movs	r0, #0
	}
}
    4f34:	4770      	bx	lr
	...

00004f38 <ipaddr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
    4f38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4f3c:	b085      	sub	sp, #20
    4f3e:	9101      	str	r1, [sp, #4]
	u8_t  rem;
	u8_t  n;
	u8_t  i;
	int   len = 0;

	s_addr = ip4_addr_get_u32(addr);
    4f40:	6803      	ldr	r3, [r0, #0]
    4f42:	f10d 0c10 	add.w	ip, sp, #16
    4f46:	f84c 3d04 	str.w	r3, [ip, #-4]!

	rp = buf;
    4f4a:	460c      	mov	r4, r1
	int   len = 0;
    4f4c:	f04f 0800 	mov.w	r8, #0
    4f50:	46c1      	mov	r9, r8
	ap = (u8_t *)&s_addr;
	for (n = 0; n < 4; n++) {
		i = 0;
		do {
			rem = *ap % (u8_t)10;
    4f52:	4f27      	ldr	r7, [pc, #156]	; (4ff0 <ipaddr_ntoa_r+0xb8>)
    4f54:	f102 0e01 	add.w	lr, r2, #1
			*rp++ = inv[i];
		}
		if (len++ >= buflen) {
			return NULL;
		}
		*rp++ = '.';
    4f58:	f04f 0b2e 	mov.w	fp, #46	; 0x2e
    4f5c:	4666      	mov	r6, ip
    4f5e:	f89c 3000 	ldrb.w	r3, [ip]
	int   len = 0;
    4f62:	4648      	mov	r0, r9
    4f64:	469a      	mov	sl, r3
    4f66:	e000      	b.n	4f6a <ipaddr_ntoa_r+0x32>
			inv[i++] = '0' + rem;
    4f68:	4628      	mov	r0, r5
			rem = *ap % (u8_t)10;
    4f6a:	fba7 310a 	umull	r3, r1, r7, sl
    4f6e:	08c9      	lsrs	r1, r1, #3
    4f70:	eb01 0381 	add.w	r3, r1, r1, lsl #2
    4f74:	ebaa 0343 	sub.w	r3, sl, r3, lsl #1
			inv[i++] = '0' + rem;
    4f78:	1c45      	adds	r5, r0, #1
    4f7a:	b2ed      	uxtb	r5, r5
    4f7c:	3330      	adds	r3, #48	; 0x30
    4f7e:	f10d 0a10 	add.w	sl, sp, #16
    4f82:	4482      	add	sl, r0
    4f84:	f80a 3c08 	strb.w	r3, [sl, #-8]
		} while (*ap);
    4f88:	f001 0aff 	and.w	sl, r1, #255	; 0xff
    4f8c:	2900      	cmp	r1, #0
    4f8e:	d1eb      	bne.n	4f68 <ipaddr_ntoa_r+0x30>
    4f90:	f886 9000 	strb.w	r9, [r6]
    4f94:	f10c 0c01 	add.w	ip, ip, #1
		while (i--) {
    4f98:	b1ad      	cbz	r5, 4fc6 <ipaddr_ntoa_r+0x8e>
			if (len++ >= buflen) {
    4f9a:	f108 0101 	add.w	r1, r8, #1
    4f9e:	4542      	cmp	r2, r8
    4fa0:	dd21      	ble.n	4fe6 <ipaddr_ntoa_r+0xae>
    4fa2:	ab02      	add	r3, sp, #8
    4fa4:	181d      	adds	r5, r3, r0
    4fa6:	1e63      	subs	r3, r4, #1
    4fa8:	4420      	add	r0, r4
    4faa:	1c9e      	adds	r6, r3, #2
			*rp++ = inv[i];
    4fac:	f815 4901 	ldrb.w	r4, [r5], #-1
    4fb0:	f803 4f01 	strb.w	r4, [r3, #1]!
		while (i--) {
    4fb4:	4298      	cmp	r0, r3
    4fb6:	d008      	beq.n	4fca <ipaddr_ntoa_r+0x92>
			if (len++ >= buflen) {
    4fb8:	3101      	adds	r1, #1
    4fba:	4571      	cmp	r1, lr
    4fbc:	d1f5      	bne.n	4faa <ipaddr_ntoa_r+0x72>
				return NULL;
    4fbe:	2000      	movs	r0, #0
		ap++;
	}
	*--rp = 0;
	return buf;
}
    4fc0:	b005      	add	sp, #20
    4fc2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		while (i--) {
    4fc6:	4641      	mov	r1, r8
    4fc8:	4626      	mov	r6, r4
		if (len++ >= buflen) {
    4fca:	f101 0801 	add.w	r8, r1, #1
    4fce:	428a      	cmp	r2, r1
    4fd0:	dd0b      	ble.n	4fea <ipaddr_ntoa_r+0xb2>
		*rp++ = '.';
    4fd2:	1c74      	adds	r4, r6, #1
    4fd4:	f886 b000 	strb.w	fp, [r6]
	for (n = 0; n < 4; n++) {
    4fd8:	ab04      	add	r3, sp, #16
    4fda:	459c      	cmp	ip, r3
    4fdc:	d1be      	bne.n	4f5c <ipaddr_ntoa_r+0x24>
	*--rp = 0;
    4fde:	2300      	movs	r3, #0
    4fe0:	7033      	strb	r3, [r6, #0]
	return buf;
    4fe2:	9801      	ldr	r0, [sp, #4]
    4fe4:	e7ec      	b.n	4fc0 <ipaddr_ntoa_r+0x88>
				return NULL;
    4fe6:	2000      	movs	r0, #0
    4fe8:	e7ea      	b.n	4fc0 <ipaddr_ntoa_r+0x88>
			return NULL;
    4fea:	2000      	movs	r0, #0
    4fec:	e7e8      	b.n	4fc0 <ipaddr_ntoa_r+0x88>
    4fee:	bf00      	nop
    4ff0:	cccccccd 	.word	0xcccccccd

00004ff4 <ip_reass_free_complete_datagram>:
 * @param ipr datagram to free
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    4ff4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    4ff8:	4681      	mov	r9, r0
    4ffa:	468a      	mov	sl, r1
		LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
	}

	snmp_inc_ipreasmfails();
#if LWIP_ICMP
	iprh = (struct ip_reass_helper *)ipr->p->payload;
    4ffc:	6845      	ldr	r5, [r0, #4]
    4ffe:	686b      	ldr	r3, [r5, #4]
	if (iprh->start == 0) {
    5000:	889a      	ldrh	r2, [r3, #4]
    5002:	b322      	cbz	r2, 504e <ip_reass_free_complete_datagram+0x5a>
	u16_t                   pbufs_freed = 0;
    5004:	2400      	movs	r4, #0
	}
#endif /* LWIP_ICMP */

	/* First, free all received pbufs.  The individual pbufs need to be released
	   separately as they have not yet been chained */
	p = ipr->p;
    5006:	f8d9 6004 	ldr.w	r6, [r9, #4]
	while (p != NULL) {
    500a:	b16e      	cbz	r6, 5028 <ip_reass_free_complete_datagram+0x34>
		struct pbuf *pcur;
		iprh = (struct ip_reass_helper *)p->payload;
		pcur = p;
		/* get the next pointer before freeing */
		p    = iprh->next_pbuf;
		clen = pbuf_clen(pcur);
    500c:	f8df 8090 	ldr.w	r8, [pc, #144]	; 50a0 <ip_reass_free_complete_datagram+0xac>
		LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
		pbufs_freed += clen;
		pbuf_free(pcur);
    5010:	4f1f      	ldr	r7, [pc, #124]	; (5090 <ip_reass_free_complete_datagram+0x9c>)
		iprh = (struct ip_reass_helper *)p->payload;
    5012:	6873      	ldr	r3, [r6, #4]
		p    = iprh->next_pbuf;
    5014:	681d      	ldr	r5, [r3, #0]
		clen = pbuf_clen(pcur);
    5016:	4630      	mov	r0, r6
    5018:	47c0      	blx	r8
		pbufs_freed += clen;
    501a:	4404      	add	r4, r0
    501c:	b2a4      	uxth	r4, r4
		pbuf_free(pcur);
    501e:	4630      	mov	r0, r6
    5020:	47b8      	blx	r7
		p    = iprh->next_pbuf;
    5022:	462e      	mov	r6, r5
	while (p != NULL) {
    5024:	2d00      	cmp	r5, #0
    5026:	d1f4      	bne.n	5012 <ip_reass_free_complete_datagram+0x1e>
 */
static void ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{

	/* dequeue the reass struct  */
	if (reassdatagrams == ipr) {
    5028:	4b1a      	ldr	r3, [pc, #104]	; (5094 <ip_reass_free_complete_datagram+0xa0>)
    502a:	681b      	ldr	r3, [r3, #0]
    502c:	4599      	cmp	r9, r3
    502e:	d029      	beq.n	5084 <ip_reass_free_complete_datagram+0x90>
		/* it was the first in the list */
		reassdatagrams = ipr->next;
	} else {
		/* it wasn't the first, so it must have a valid 'prev' */
		LWIP_ASSERT("sanity check linked list", prev != NULL);
		prev->next = ipr->next;
    5030:	f8d9 3000 	ldr.w	r3, [r9]
    5034:	f8ca 3000 	str.w	r3, [sl]
	}

	/* now we can free the ip_reass struct */
	memp_free(MEMP_REASSDATA, ipr);
    5038:	4649      	mov	r1, r9
    503a:	2005      	movs	r0, #5
    503c:	4b16      	ldr	r3, [pc, #88]	; (5098 <ip_reass_free_complete_datagram+0xa4>)
    503e:	4798      	blx	r3
	ip_reass_pbufcount -= pbufs_freed;
    5040:	4a14      	ldr	r2, [pc, #80]	; (5094 <ip_reass_free_complete_datagram+0xa0>)
    5042:	8893      	ldrh	r3, [r2, #4]
    5044:	1b1b      	subs	r3, r3, r4
    5046:	8093      	strh	r3, [r2, #4]
}
    5048:	4620      	mov	r0, r4
    504a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		ipr->p = iprh->next_pbuf;
    504e:	681b      	ldr	r3, [r3, #0]
    5050:	6043      	str	r3, [r0, #4]
		SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    5052:	686a      	ldr	r2, [r5, #4]
    5054:	4603      	mov	r3, r0
    5056:	f853 1f08 	ldr.w	r1, [r3, #8]!
    505a:	685e      	ldr	r6, [r3, #4]
    505c:	689c      	ldr	r4, [r3, #8]
    505e:	68d8      	ldr	r0, [r3, #12]
    5060:	6011      	str	r1, [r2, #0]
    5062:	6056      	str	r6, [r2, #4]
    5064:	6094      	str	r4, [r2, #8]
    5066:	60d0      	str	r0, [r2, #12]
    5068:	6919      	ldr	r1, [r3, #16]
    506a:	6111      	str	r1, [r2, #16]
		icmp_time_exceeded(p, ICMP_TE_FRAG);
    506c:	2101      	movs	r1, #1
    506e:	4628      	mov	r0, r5
    5070:	4b0a      	ldr	r3, [pc, #40]	; (509c <ip_reass_free_complete_datagram+0xa8>)
    5072:	4798      	blx	r3
		clen = pbuf_clen(p);
    5074:	4628      	mov	r0, r5
    5076:	4b0a      	ldr	r3, [pc, #40]	; (50a0 <ip_reass_free_complete_datagram+0xac>)
    5078:	4798      	blx	r3
		pbufs_freed += clen;
    507a:	b284      	uxth	r4, r0
		pbuf_free(p);
    507c:	4628      	mov	r0, r5
    507e:	4b04      	ldr	r3, [pc, #16]	; (5090 <ip_reass_free_complete_datagram+0x9c>)
    5080:	4798      	blx	r3
    5082:	e7c0      	b.n	5006 <ip_reass_free_complete_datagram+0x12>
		reassdatagrams = ipr->next;
    5084:	f8d9 2000 	ldr.w	r2, [r9]
    5088:	4b02      	ldr	r3, [pc, #8]	; (5094 <ip_reass_free_complete_datagram+0xa0>)
    508a:	601a      	str	r2, [r3, #0]
    508c:	e7d4      	b.n	5038 <ip_reass_free_complete_datagram+0x44>
    508e:	bf00      	nop
    5090:	00005c89 	.word	0x00005c89
    5094:	20001630 	.word	0x20001630
    5098:	000059c1 	.word	0x000059c1
    509c:	00004a09 	.word	0x00004a09
    50a0:	00005e8d 	.word	0x00005e8d

000050a4 <ip_reass_remove_oldest_datagram>:
{
    50a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    50a8:	4605      	mov	r5, r0
    50aa:	4688      	mov	r8, r1
	int                  pbufs_freed = 0, pbufs_freed_current;
    50ac:	2600      	movs	r6, #0
		r               = reassdatagrams;
    50ae:	4f19      	ldr	r7, [pc, #100]	; (5114 <ip_reass_remove_oldest_datagram+0x70>)
			pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    50b0:	f8df 9064 	ldr.w	r9, [pc, #100]	; 5118 <ip_reass_remove_oldest_datagram+0x74>
    50b4:	e022      	b.n	50fc <ip_reass_remove_oldest_datagram+0x58>
				other_datagrams++;
    50b6:	3401      	adds	r4, #1
				if (oldest == NULL) {
    50b8:	b1b8      	cbz	r0, 50ea <ip_reass_remove_oldest_datagram+0x46>
				} else if (r->timer <= oldest->timer) {
    50ba:	f893 c01f 	ldrb.w	ip, [r3, #31]
    50be:	7fc2      	ldrb	r2, [r0, #31]
    50c0:	4594      	cmp	ip, r2
    50c2:	bf98      	it	ls
    50c4:	4618      	movls	r0, r3
			if (r->next != NULL) {
    50c6:	681a      	ldr	r2, [r3, #0]
    50c8:	b18a      	cbz	r2, 50ee <ip_reass_remove_oldest_datagram+0x4a>
    50ca:	4619      	mov	r1, r3
    50cc:	4613      	mov	r3, r2
			if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    50ce:	695a      	ldr	r2, [r3, #20]
    50d0:	4572      	cmp	r2, lr
    50d2:	d1f0      	bne.n	50b6 <ip_reass_remove_oldest_datagram+0x12>
    50d4:	f8d5 c010 	ldr.w	ip, [r5, #16]
    50d8:	699a      	ldr	r2, [r3, #24]
    50da:	4562      	cmp	r2, ip
    50dc:	d1eb      	bne.n	50b6 <ip_reass_remove_oldest_datagram+0x12>
    50de:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
    50e2:	88aa      	ldrh	r2, [r5, #4]
    50e4:	4594      	cmp	ip, r2
    50e6:	d1e6      	bne.n	50b6 <ip_reass_remove_oldest_datagram+0x12>
    50e8:	e7ed      	b.n	50c6 <ip_reass_remove_oldest_datagram+0x22>
    50ea:	4618      	mov	r0, r3
    50ec:	e7eb      	b.n	50c6 <ip_reass_remove_oldest_datagram+0x22>
		if (oldest != NULL) {
    50ee:	b108      	cbz	r0, 50f4 <ip_reass_remove_oldest_datagram+0x50>
			pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    50f0:	47c8      	blx	r9
			pbufs_freed += pbufs_freed_current;
    50f2:	4406      	add	r6, r0
	} while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
    50f4:	4546      	cmp	r6, r8
    50f6:	da09      	bge.n	510c <ip_reass_remove_oldest_datagram+0x68>
    50f8:	2c01      	cmp	r4, #1
    50fa:	dd07      	ble.n	510c <ip_reass_remove_oldest_datagram+0x68>
		r               = reassdatagrams;
    50fc:	683b      	ldr	r3, [r7, #0]
		while (r != NULL) {
    50fe:	b12b      	cbz	r3, 510c <ip_reass_remove_oldest_datagram+0x68>
			if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    5100:	f8d5 e00c 	ldr.w	lr, [r5, #12]
    5104:	2400      	movs	r4, #0
    5106:	4621      	mov	r1, r4
    5108:	4620      	mov	r0, r4
    510a:	e7e0      	b.n	50ce <ip_reass_remove_oldest_datagram+0x2a>
}
    510c:	4630      	mov	r0, r6
    510e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    5112:	bf00      	nop
    5114:	20001630 	.word	0x20001630
    5118:	00004ff5 	.word	0x00004ff5

0000511c <ipfrag_free_pbuf_custom>:
}

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void ipfrag_free_pbuf_custom(struct pbuf *p)
{
    511c:	b510      	push	{r4, lr}
    511e:	4604      	mov	r4, r0
	struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref *)p;
	LWIP_ASSERT("pcr != NULL", pcr != NULL);
	LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
	if (pcr->original != NULL) {
    5120:	6940      	ldr	r0, [r0, #20]
    5122:	b108      	cbz	r0, 5128 <ipfrag_free_pbuf_custom+0xc>
		pbuf_free(pcr->original);
    5124:	4b03      	ldr	r3, [pc, #12]	; (5134 <ipfrag_free_pbuf_custom+0x18>)
    5126:	4798      	blx	r3
	memp_free(MEMP_FRAG_PBUF, p);
    5128:	4621      	mov	r1, r4
    512a:	2006      	movs	r0, #6
    512c:	4b02      	ldr	r3, [pc, #8]	; (5138 <ipfrag_free_pbuf_custom+0x1c>)
    512e:	4798      	blx	r3
    5130:	bd10      	pop	{r4, pc}
    5132:	bf00      	nop
    5134:	00005c89 	.word	0x00005c89
    5138:	000059c1 	.word	0x000059c1

0000513c <ip_reass_tmr>:
	r = reassdatagrams;
    513c:	4b0a      	ldr	r3, [pc, #40]	; (5168 <ip_reass_tmr+0x2c>)
    513e:	6818      	ldr	r0, [r3, #0]
	while (r != NULL) {
    5140:	b188      	cbz	r0, 5166 <ip_reass_tmr+0x2a>
{
    5142:	b570      	push	{r4, r5, r6, lr}
	while (r != NULL) {
    5144:	2400      	movs	r4, #0
			ip_reass_free_complete_datagram(tmp, prev);
    5146:	4e09      	ldr	r6, [pc, #36]	; (516c <ip_reass_tmr+0x30>)
    5148:	e004      	b.n	5154 <ip_reass_tmr+0x18>
			r = r->next;
    514a:	6805      	ldr	r5, [r0, #0]
			ip_reass_free_complete_datagram(tmp, prev);
    514c:	4621      	mov	r1, r4
    514e:	47b0      	blx	r6
			r = r->next;
    5150:	4628      	mov	r0, r5
	while (r != NULL) {
    5152:	b138      	cbz	r0, 5164 <ip_reass_tmr+0x28>
		if (r->timer > 0) {
    5154:	7fc3      	ldrb	r3, [r0, #31]
    5156:	2b00      	cmp	r3, #0
    5158:	d0f7      	beq.n	514a <ip_reass_tmr+0xe>
			r->timer--;
    515a:	3b01      	subs	r3, #1
    515c:	77c3      	strb	r3, [r0, #31]
    515e:	4604      	mov	r4, r0
			r    = r->next;
    5160:	6800      	ldr	r0, [r0, #0]
    5162:	e7f6      	b.n	5152 <ip_reass_tmr+0x16>
    5164:	bd70      	pop	{r4, r5, r6, pc}
    5166:	4770      	bx	lr
    5168:	20001630 	.word	0x20001630
    516c:	00004ff5 	.word	0x00004ff5

00005170 <ip_reass>:
{
    5170:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5174:	b083      	sub	sp, #12
    5176:	4607      	mov	r7, r0
	fraghdr = (struct ip_hdr *)p->payload;
    5178:	6846      	ldr	r6, [r0, #4]
	if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    517a:	7833      	ldrb	r3, [r6, #0]
    517c:	f003 030f 	and.w	r3, r3, #15
    5180:	2b05      	cmp	r3, #5
    5182:	d122      	bne.n	51ca <ip_reass+0x5a>
	offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    5184:	88f0      	ldrh	r0, [r6, #6]
    5186:	4ca0      	ldr	r4, [pc, #640]	; (5408 <ip_reass+0x298>)
    5188:	47a0      	blx	r4
    518a:	4683      	mov	fp, r0
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    518c:	8870      	ldrh	r0, [r6, #2]
    518e:	47a0      	blx	r4
    5190:	9001      	str	r0, [sp, #4]
    5192:	f896 a000 	ldrb.w	sl, [r6]
	clen = pbuf_clen(p);
    5196:	4638      	mov	r0, r7
    5198:	4b9c      	ldr	r3, [pc, #624]	; (540c <ip_reass+0x29c>)
    519a:	4798      	blx	r3
    519c:	4680      	mov	r8, r0
	if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    519e:	4b9c      	ldr	r3, [pc, #624]	; (5410 <ip_reass+0x2a0>)
    51a0:	889b      	ldrh	r3, [r3, #4]
    51a2:	4403      	add	r3, r0
    51a4:	2b0a      	cmp	r3, #10
    51a6:	dc06      	bgt.n	51b6 <ip_reass+0x46>
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    51a8:	4b99      	ldr	r3, [pc, #612]	; (5410 <ip_reass+0x2a0>)
    51aa:	681c      	ldr	r4, [r3, #0]
    51ac:	2c00      	cmp	r4, #0
    51ae:	d079      	beq.n	52a4 <ip_reass+0x134>
		if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    51b0:	68f2      	ldr	r2, [r6, #12]
    51b2:	2500      	movs	r5, #0
    51b4:	e014      	b.n	51e0 <ip_reass+0x70>
		if (!ip_reass_remove_oldest_datagram(fraghdr, clen) || ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
    51b6:	4601      	mov	r1, r0
    51b8:	4630      	mov	r0, r6
    51ba:	4b96      	ldr	r3, [pc, #600]	; (5414 <ip_reass+0x2a4>)
    51bc:	4798      	blx	r3
    51be:	b120      	cbz	r0, 51ca <ip_reass+0x5a>
    51c0:	4b93      	ldr	r3, [pc, #588]	; (5410 <ip_reass+0x2a0>)
    51c2:	889b      	ldrh	r3, [r3, #4]
    51c4:	4443      	add	r3, r8
    51c6:	2b0a      	cmp	r3, #10
    51c8:	ddee      	ble.n	51a8 <ip_reass+0x38>
	pbuf_free(p);
    51ca:	4638      	mov	r0, r7
    51cc:	4b92      	ldr	r3, [pc, #584]	; (5418 <ip_reass+0x2a8>)
    51ce:	4798      	blx	r3
	return NULL;
    51d0:	f04f 0800 	mov.w	r8, #0
    51d4:	e101      	b.n	53da <ip_reass+0x26a>
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    51d6:	6823      	ldr	r3, [r4, #0]
    51d8:	4625      	mov	r5, r4
    51da:	2b00      	cmp	r3, #0
    51dc:	d062      	beq.n	52a4 <ip_reass+0x134>
    51de:	461c      	mov	r4, r3
		if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    51e0:	6963      	ldr	r3, [r4, #20]
    51e2:	4293      	cmp	r3, r2
    51e4:	d1f7      	bne.n	51d6 <ip_reass+0x66>
    51e6:	6933      	ldr	r3, [r6, #16]
    51e8:	69a1      	ldr	r1, [r4, #24]
    51ea:	4299      	cmp	r1, r3
    51ec:	d1f3      	bne.n	51d6 <ip_reass+0x66>
    51ee:	89a1      	ldrh	r1, [r4, #12]
    51f0:	88b3      	ldrh	r3, [r6, #4]
    51f2:	4299      	cmp	r1, r3
    51f4:	d1ef      	bne.n	51d6 <ip_reass+0x66>
	if (ipr == NULL) {
    51f6:	2c00      	cmp	r4, #0
    51f8:	d053      	beq.n	52a2 <ip_reass+0x132>
		if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    51fa:	88f0      	ldrh	r0, [r6, #6]
    51fc:	4b82      	ldr	r3, [pc, #520]	; (5408 <ip_reass+0x298>)
    51fe:	4798      	blx	r3
    5200:	f3c0 000c 	ubfx	r0, r0, #0, #13
    5204:	2800      	cmp	r0, #0
    5206:	f000 8084 	beq.w	5312 <ip_reass+0x1a2>
	ip_reass_pbufcount += clen;
    520a:	4b81      	ldr	r3, [pc, #516]	; (5410 <ip_reass+0x2a0>)
    520c:	889a      	ldrh	r2, [r3, #4]
    520e:	4490      	add	r8, r2
    5210:	f8a3 8004 	strh.w	r8, [r3, #4]
	if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    5214:	88f3      	ldrh	r3, [r6, #6]
    5216:	f013 0f20 	tst.w	r3, #32
    521a:	d10c      	bne.n	5236 <ip_reass+0xc6>
		ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    521c:	7fa3      	ldrb	r3, [r4, #30]
    521e:	f043 0301 	orr.w	r3, r3, #1
    5222:	77a3      	strb	r3, [r4, #30]
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    5224:	f00a 0a0f 	and.w	sl, sl, #15
    5228:	9b01      	ldr	r3, [sp, #4]
    522a:	eba3 098a 	sub.w	r9, r3, sl, lsl #2
		ipr->datagram_len = offset + len;
    522e:	eb09 0bcb 	add.w	fp, r9, fp, lsl #3
    5232:	f8a4 b01c 	strh.w	fp, [r4, #28]
	fraghdr = (struct ip_hdr *)new_p->payload;
    5236:	687e      	ldr	r6, [r7, #4]
	len     = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    5238:	8870      	ldrh	r0, [r6, #2]
    523a:	f8df 91cc 	ldr.w	r9, [pc, #460]	; 5408 <ip_reass+0x298>
    523e:	47c8      	blx	r9
    5240:	f896 8000 	ldrb.w	r8, [r6]
    5244:	f008 080f 	and.w	r8, r8, #15
    5248:	eba0 0888 	sub.w	r8, r0, r8, lsl #2
    524c:	fa1f f888 	uxth.w	r8, r8
	offset  = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    5250:	88f0      	ldrh	r0, [r6, #6]
    5252:	47c8      	blx	r9
    5254:	f3c0 000c 	ubfx	r0, r0, #0, #13
    5258:	00c0      	lsls	r0, r0, #3
	iprh            = (struct ip_reass_helper *)new_p->payload;
    525a:	f8d7 c004 	ldr.w	ip, [r7, #4]
	iprh->next_pbuf = NULL;
    525e:	2300      	movs	r3, #0
    5260:	f88c 3000 	strb.w	r3, [ip]
    5264:	f88c 3001 	strb.w	r3, [ip, #1]
    5268:	f88c 3002 	strb.w	r3, [ip, #2]
    526c:	f88c 3003 	strb.w	r3, [ip, #3]
	iprh->start     = offset;
    5270:	f8ac 0004 	strh.w	r0, [ip, #4]
	iprh->end       = offset + len;
    5274:	4480      	add	r8, r0
    5276:	fa1f f888 	uxth.w	r8, r8
    527a:	f8ac 8006 	strh.w	r8, [ip, #6]
	for (q = ipr->p; q != NULL;) {
    527e:	6862      	ldr	r2, [r4, #4]
    5280:	2a00      	cmp	r2, #0
    5282:	f000 809a 	beq.w	53ba <ip_reass+0x24a>
		iprh_tmp = (struct ip_reass_helper *)q->payload;
    5286:	6853      	ldr	r3, [r2, #4]
		if (iprh->start < iprh_tmp->start) {
    5288:	8899      	ldrh	r1, [r3, #4]
    528a:	4288      	cmp	r0, r1
    528c:	f0c0 80ad 	bcc.w	53ea <ip_reass+0x27a>
		} else if (iprh->start == iprh_tmp->start) {
    5290:	f000 8097 	beq.w	53c2 <ip_reass+0x252>
		} else if (iprh->start < iprh_tmp->end) {
    5294:	88da      	ldrh	r2, [r3, #6]
    5296:	4282      	cmp	r2, r0
    5298:	f200 8093 	bhi.w	53c2 <ip_reass+0x252>
    529c:	f04f 0e01 	mov.w	lr, #1
    52a0:	e078      	b.n	5394 <ip_reass+0x224>
    52a2:	462c      	mov	r4, r5
	ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    52a4:	2005      	movs	r0, #5
    52a6:	4b5d      	ldr	r3, [pc, #372]	; (541c <ip_reass+0x2ac>)
    52a8:	4798      	blx	r3
	if (ipr == NULL) {
    52aa:	4681      	mov	r9, r0
    52ac:	b318      	cbz	r0, 52f6 <ip_reass+0x186>
	memset(ipr, 0, sizeof(struct ip_reassdata));
    52ae:	2220      	movs	r2, #32
    52b0:	2100      	movs	r1, #0
    52b2:	4648      	mov	r0, r9
    52b4:	4b5a      	ldr	r3, [pc, #360]	; (5420 <ip_reass+0x2b0>)
    52b6:	4798      	blx	r3
	ipr->timer = IP_REASS_MAXAGE;
    52b8:	2303      	movs	r3, #3
    52ba:	f889 301f 	strb.w	r3, [r9, #31]
	ipr->next      = reassdatagrams;
    52be:	4b54      	ldr	r3, [pc, #336]	; (5410 <ip_reass+0x2a0>)
    52c0:	681a      	ldr	r2, [r3, #0]
    52c2:	f8c9 2000 	str.w	r2, [r9]
	reassdatagrams = ipr;
    52c6:	f8c3 9000 	str.w	r9, [r3]
	SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    52ca:	6832      	ldr	r2, [r6, #0]
    52cc:	6875      	ldr	r5, [r6, #4]
    52ce:	68b0      	ldr	r0, [r6, #8]
    52d0:	68f1      	ldr	r1, [r6, #12]
    52d2:	f8c9 2008 	str.w	r2, [r9, #8]
    52d6:	f8c9 500c 	str.w	r5, [r9, #12]
    52da:	f8c9 0010 	str.w	r0, [r9, #16]
    52de:	f8c9 1014 	str.w	r1, [r9, #20]
    52e2:	6932      	ldr	r2, [r6, #16]
    52e4:	f8c9 2018 	str.w	r2, [r9, #24]
		if (ipr == NULL) {
    52e8:	f1b9 0f00 	cmp.w	r9, #0
    52ec:	f43f af6d 	beq.w	51ca <ip_reass+0x5a>
    52f0:	4625      	mov	r5, r4
	return ipr;
    52f2:	464c      	mov	r4, r9
    52f4:	e789      	b.n	520a <ip_reass+0x9a>
		if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
    52f6:	4641      	mov	r1, r8
    52f8:	4630      	mov	r0, r6
    52fa:	4b46      	ldr	r3, [pc, #280]	; (5414 <ip_reass+0x2a4>)
    52fc:	4798      	blx	r3
    52fe:	4580      	cmp	r8, r0
    5300:	f73f af63 	bgt.w	51ca <ip_reass+0x5a>
			ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    5304:	2005      	movs	r0, #5
    5306:	4b45      	ldr	r3, [pc, #276]	; (541c <ip_reass+0x2ac>)
    5308:	4798      	blx	r3
		if (ipr == NULL)
    530a:	4681      	mov	r9, r0
    530c:	2800      	cmp	r0, #0
    530e:	d1ce      	bne.n	52ae <ip_reass+0x13e>
    5310:	e75b      	b.n	51ca <ip_reass+0x5a>
		if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    5312:	89e0      	ldrh	r0, [r4, #14]
    5314:	4b3c      	ldr	r3, [pc, #240]	; (5408 <ip_reass+0x298>)
    5316:	4798      	blx	r3
    5318:	f3c0 000c 	ubfx	r0, r0, #0, #13
    531c:	2800      	cmp	r0, #0
    531e:	f43f af74 	beq.w	520a <ip_reass+0x9a>
			SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    5322:	6832      	ldr	r2, [r6, #0]
    5324:	f8d6 e004 	ldr.w	lr, [r6, #4]
    5328:	68b0      	ldr	r0, [r6, #8]
    532a:	68f1      	ldr	r1, [r6, #12]
    532c:	60a2      	str	r2, [r4, #8]
    532e:	f8c4 e00c 	str.w	lr, [r4, #12]
    5332:	6120      	str	r0, [r4, #16]
    5334:	6161      	str	r1, [r4, #20]
    5336:	6932      	ldr	r2, [r6, #16]
    5338:	61a2      	str	r2, [r4, #24]
    533a:	e766      	b.n	520a <ip_reass+0x9a>
			iprh->next_pbuf = q;
    533c:	f8cc 6000 	str.w	r6, [ip]
			if (iprh_prev != NULL) {
    5340:	2b00      	cmp	r3, #0
    5342:	d056      	beq.n	53f2 <ip_reass+0x282>
				if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
    5344:	88d9      	ldrh	r1, [r3, #6]
    5346:	4281      	cmp	r1, r0
    5348:	d83b      	bhi.n	53c2 <ip_reass+0x252>
    534a:	8892      	ldrh	r2, [r2, #4]
    534c:	4542      	cmp	r2, r8
    534e:	d338      	bcc.n	53c2 <ip_reass+0x252>
				iprh_prev->next_pbuf = new_p;
    5350:	601f      	str	r7, [r3, #0]
	if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    5352:	7fa3      	ldrb	r3, [r4, #30]
    5354:	f013 0f01 	tst.w	r3, #1
    5358:	d03d      	beq.n	53d6 <ip_reass+0x266>
		if (valid) {
    535a:	f1be 0f00 	cmp.w	lr, #0
    535e:	d03a      	beq.n	53d6 <ip_reass+0x266>
			if (((struct ip_reass_helper *)ipr->p->payload)->start != 0) {
    5360:	6860      	ldr	r0, [r4, #4]
    5362:	6843      	ldr	r3, [r0, #4]
    5364:	889b      	ldrh	r3, [r3, #4]
    5366:	2b00      	cmp	r3, #0
    5368:	d135      	bne.n	53d6 <ip_reass+0x266>
				q         = iprh->next_pbuf;
    536a:	f8dc 3000 	ldr.w	r3, [ip]
				while (q != NULL) {
    536e:	2b00      	cmp	r3, #0
    5370:	d058      	beq.n	5424 <ip_reass+0x2b4>
					iprh = (struct ip_reass_helper *)q->payload;
    5372:	685b      	ldr	r3, [r3, #4]
					if (iprh_prev->end != iprh->start) {
    5374:	8899      	ldrh	r1, [r3, #4]
    5376:	f8bc 2006 	ldrh.w	r2, [ip, #6]
    537a:	4291      	cmp	r1, r2
    537c:	d12b      	bne.n	53d6 <ip_reass+0x266>
					q         = iprh->next_pbuf;
    537e:	681a      	ldr	r2, [r3, #0]
				while (q != NULL) {
    5380:	2a00      	cmp	r2, #0
    5382:	d04f      	beq.n	5424 <ip_reass+0x2b4>
					iprh = (struct ip_reass_helper *)q->payload;
    5384:	6852      	ldr	r2, [r2, #4]
					if (iprh_prev->end != iprh->start) {
    5386:	88d9      	ldrh	r1, [r3, #6]
    5388:	8893      	ldrh	r3, [r2, #4]
    538a:	4299      	cmp	r1, r3
    538c:	d123      	bne.n	53d6 <ip_reass+0x266>
					iprh = (struct ip_reass_helper *)q->payload;
    538e:	4613      	mov	r3, r2
    5390:	e7f5      	b.n	537e <ip_reass+0x20e>
		iprh_tmp = (struct ip_reass_helper *)q->payload;
    5392:	4613      	mov	r3, r2
		q         = iprh_tmp->next_pbuf;
    5394:	681e      	ldr	r6, [r3, #0]
	for (q = ipr->p; q != NULL;) {
    5396:	b376      	cbz	r6, 53f6 <ip_reass+0x286>
		iprh_tmp = (struct ip_reass_helper *)q->payload;
    5398:	6872      	ldr	r2, [r6, #4]
		if (iprh->start < iprh_tmp->start) {
    539a:	8891      	ldrh	r1, [r2, #4]
    539c:	4288      	cmp	r0, r1
    539e:	d3cd      	bcc.n	533c <ip_reass+0x1cc>
		} else if (iprh->start == iprh_tmp->start) {
    53a0:	4288      	cmp	r0, r1
    53a2:	d00e      	beq.n	53c2 <ip_reass+0x252>
		} else if (iprh->start < iprh_tmp->end) {
    53a4:	88d6      	ldrh	r6, [r2, #6]
    53a6:	4286      	cmp	r6, r0
    53a8:	d80b      	bhi.n	53c2 <ip_reass+0x252>
			if (iprh_prev != NULL) {
    53aa:	2b00      	cmp	r3, #0
    53ac:	d0f1      	beq.n	5392 <ip_reass+0x222>
				if (iprh_prev->end != iprh_tmp->start) {
    53ae:	88db      	ldrh	r3, [r3, #6]
					valid = 0;
    53b0:	428b      	cmp	r3, r1
    53b2:	bf18      	it	ne
    53b4:	f04f 0e00 	movne.w	lr, #0
    53b8:	e7eb      	b.n	5392 <ip_reass+0x222>
	int                     valid = 1;
    53ba:	f04f 0e01 	mov.w	lr, #1
			ipr->p = new_p;
    53be:	6067      	str	r7, [r4, #4]
    53c0:	e7c7      	b.n	5352 <ip_reass+0x1e2>
	ip_reass_pbufcount -= pbuf_clen(new_p);
    53c2:	4638      	mov	r0, r7
    53c4:	4b11      	ldr	r3, [pc, #68]	; (540c <ip_reass+0x29c>)
    53c6:	4798      	blx	r3
    53c8:	4a11      	ldr	r2, [pc, #68]	; (5410 <ip_reass+0x2a0>)
    53ca:	8893      	ldrh	r3, [r2, #4]
    53cc:	1a18      	subs	r0, r3, r0
    53ce:	8090      	strh	r0, [r2, #4]
	pbuf_free(new_p);
    53d0:	4638      	mov	r0, r7
    53d2:	4b11      	ldr	r3, [pc, #68]	; (5418 <ip_reass+0x2a8>)
    53d4:	4798      	blx	r3
	return NULL;
    53d6:	f04f 0800 	mov.w	r8, #0
}
    53da:	4640      	mov	r0, r8
    53dc:	b003      	add	sp, #12
    53de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		reassdatagrams = ipr->next;
    53e2:	6822      	ldr	r2, [r4, #0]
    53e4:	4b0a      	ldr	r3, [pc, #40]	; (5410 <ip_reass+0x2a0>)
    53e6:	601a      	str	r2, [r3, #0]
    53e8:	e056      	b.n	5498 <ip_reass+0x328>
			iprh->next_pbuf = q;
    53ea:	f8cc 2000 	str.w	r2, [ip]
	int                     valid = 1;
    53ee:	f04f 0e01 	mov.w	lr, #1
				ipr->p = new_p;
    53f2:	6067      	str	r7, [r4, #4]
    53f4:	e7ad      	b.n	5352 <ip_reass+0x1e2>
		if (iprh_prev != NULL) {
    53f6:	2b00      	cmp	r3, #0
    53f8:	d0e1      	beq.n	53be <ip_reass+0x24e>
			iprh_prev->next_pbuf = new_p;
    53fa:	601f      	str	r7, [r3, #0]
			if (iprh_prev->end != iprh->start) {
    53fc:	88da      	ldrh	r2, [r3, #6]
    53fe:	f8bc 3004 	ldrh.w	r3, [ip, #4]
    5402:	429a      	cmp	r2, r3
    5404:	d1e7      	bne.n	53d6 <ip_reass+0x266>
    5406:	e7a4      	b.n	5352 <ip_reass+0x1e2>
    5408:	00002eaf 	.word	0x00002eaf
    540c:	00005e8d 	.word	0x00005e8d
    5410:	20001630 	.word	0x20001630
    5414:	000050a5 	.word	0x000050a5
    5418:	00005c89 	.word	0x00005c89
    541c:	00005979 	.word	0x00005979
    5420:	00009fc5 	.word	0x00009fc5
		ipr->datagram_len += IP_HLEN;
    5424:	8ba3      	ldrh	r3, [r4, #28]
    5426:	3314      	adds	r3, #20
    5428:	83a3      	strh	r3, [r4, #28]
		r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
    542a:	6847      	ldr	r7, [r0, #4]
    542c:	683e      	ldr	r6, [r7, #0]
		SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    542e:	4623      	mov	r3, r4
    5430:	f853 2f08 	ldr.w	r2, [r3, #8]!
    5434:	f8d3 e004 	ldr.w	lr, [r3, #4]
    5438:	6898      	ldr	r0, [r3, #8]
    543a:	68d9      	ldr	r1, [r3, #12]
    543c:	603a      	str	r2, [r7, #0]
    543e:	f8c7 e004 	str.w	lr, [r7, #4]
    5442:	60b8      	str	r0, [r7, #8]
    5444:	60f9      	str	r1, [r7, #12]
    5446:	691a      	ldr	r2, [r3, #16]
    5448:	613a      	str	r2, [r7, #16]
		IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    544a:	8ba0      	ldrh	r0, [r4, #28]
    544c:	4b18      	ldr	r3, [pc, #96]	; (54b0 <ip_reass+0x340>)
    544e:	4798      	blx	r3
    5450:	8078      	strh	r0, [r7, #2]
		IPH_OFFSET_SET(fraghdr, 0);
    5452:	2300      	movs	r3, #0
    5454:	71bb      	strb	r3, [r7, #6]
    5456:	71fb      	strb	r3, [r7, #7]
		IPH_CHKSUM_SET(fraghdr, 0);
    5458:	72bb      	strb	r3, [r7, #10]
    545a:	72fb      	strb	r3, [r7, #11]
		IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    545c:	2114      	movs	r1, #20
    545e:	4638      	mov	r0, r7
    5460:	4b14      	ldr	r3, [pc, #80]	; (54b4 <ip_reass+0x344>)
    5462:	4798      	blx	r3
    5464:	8178      	strh	r0, [r7, #10]
		p = ipr->p;
    5466:	f8d4 8004 	ldr.w	r8, [r4, #4]
		while (r != NULL) {
    546a:	b17e      	cbz	r6, 548c <ip_reass+0x31c>
			pbuf_header(r, -IP_HLEN);
    546c:	f06f 0b13 	mvn.w	fp, #19
    5470:	f8df a050 	ldr.w	sl, [pc, #80]	; 54c4 <ip_reass+0x354>
			pbuf_cat(p, r);
    5474:	f8df 9050 	ldr.w	r9, [pc, #80]	; 54c8 <ip_reass+0x358>
			iprh = (struct ip_reass_helper *)r->payload;
    5478:	6877      	ldr	r7, [r6, #4]
			pbuf_header(r, -IP_HLEN);
    547a:	4659      	mov	r1, fp
    547c:	4630      	mov	r0, r6
    547e:	47d0      	blx	sl
			pbuf_cat(p, r);
    5480:	4631      	mov	r1, r6
    5482:	4640      	mov	r0, r8
    5484:	47c8      	blx	r9
			r = iprh->next_pbuf;
    5486:	683e      	ldr	r6, [r7, #0]
		while (r != NULL) {
    5488:	2e00      	cmp	r6, #0
    548a:	d1f5      	bne.n	5478 <ip_reass+0x308>
	if (reassdatagrams == ipr) {
    548c:	4b0a      	ldr	r3, [pc, #40]	; (54b8 <ip_reass+0x348>)
    548e:	681b      	ldr	r3, [r3, #0]
    5490:	429c      	cmp	r4, r3
    5492:	d0a6      	beq.n	53e2 <ip_reass+0x272>
		prev->next = ipr->next;
    5494:	6823      	ldr	r3, [r4, #0]
    5496:	602b      	str	r3, [r5, #0]
	memp_free(MEMP_REASSDATA, ipr);
    5498:	4621      	mov	r1, r4
    549a:	2005      	movs	r0, #5
    549c:	4b07      	ldr	r3, [pc, #28]	; (54bc <ip_reass+0x34c>)
    549e:	4798      	blx	r3
		ip_reass_pbufcount -= pbuf_clen(p);
    54a0:	4640      	mov	r0, r8
    54a2:	4b07      	ldr	r3, [pc, #28]	; (54c0 <ip_reass+0x350>)
    54a4:	4798      	blx	r3
    54a6:	4a04      	ldr	r2, [pc, #16]	; (54b8 <ip_reass+0x348>)
    54a8:	8893      	ldrh	r3, [r2, #4]
    54aa:	1a18      	subs	r0, r3, r0
    54ac:	8090      	strh	r0, [r2, #4]
		return p;
    54ae:	e794      	b.n	53da <ip_reass+0x26a>
    54b0:	00002ea5 	.word	0x00002ea5
    54b4:	00004b29 	.word	0x00004b29
    54b8:	20001630 	.word	0x20001630
    54bc:	000059c1 	.word	0x000059c1
    54c0:	00005e8d 	.word	0x00005e8d
    54c4:	00005bf5 	.word	0x00005bf5
    54c8:	00005ead 	.word	0x00005ead

000054cc <ip_frag>:
 * @param dest destination ip address to which to send
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
    54cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    54d0:	b091      	sub	sp, #68	; 0x44
    54d2:	4605      	mov	r5, r0
    54d4:	910d      	str	r1, [sp, #52]	; 0x34
    54d6:	920e      	str	r2, [sp, #56]	; 0x38
	struct ip_hdr *original_iphdr;
#endif
	struct ip_hdr *iphdr;
	u16_t          nfb;
	u16_t          left, cop;
	u16_t          mtu = netif->mtu;
    54d8:	8d8c      	ldrh	r4, [r1, #44]	; 0x2c

	/* Copy the IP header in it */
	iphdr = (struct ip_hdr *)rambuf->payload;
	SMEMCPY(iphdr, p->payload, IP_HLEN);
#else  /* IP_FRAG_USES_STATIC_BUF */
	original_iphdr = (struct ip_hdr *)p->payload;
    54da:	f8d0 b004 	ldr.w	fp, [r0, #4]
	iphdr          = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

	/* Save original offset */
	tmp = ntohs(IPH_OFFSET(iphdr));
    54de:	f8bb 0006 	ldrh.w	r0, [fp, #6]
    54e2:	4b65      	ldr	r3, [pc, #404]	; (5678 <ip_frag+0x1ac>)
    54e4:	4798      	blx	r3
	ofo = tmp & IP_OFFMASK;
    54e6:	f3c0 030c 	ubfx	r3, r0, #0, #13
    54ea:	9307      	str	r3, [sp, #28]
	omf = tmp & IP_MF;
    54ec:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
    54f0:	930b      	str	r3, [sp, #44]	; 0x2c

	left = p->tot_len - IP_HLEN;
    54f2:	f8b5 9008 	ldrh.w	r9, [r5, #8]
    54f6:	f1a9 0914 	sub.w	r9, r9, #20
    54fa:	fa1f f389 	uxth.w	r3, r9
    54fe:	9305      	str	r3, [sp, #20]

	nfb = (mtu - IP_HLEN) / 8;
    5500:	f1a4 0314 	sub.w	r3, r4, #20
    5504:	930a      	str	r3, [sp, #40]	; 0x28
    5506:	2b00      	cmp	r3, #0
    5508:	bfb8      	it	lt
    550a:	3307      	addlt	r3, #7
    550c:	f3c3 03cf 	ubfx	r3, r3, #3, #16
    5510:	930c      	str	r3, [sp, #48]	; 0x30

	while (left) {
    5512:	9a05      	ldr	r2, [sp, #20]
    5514:	2a00      	cmp	r2, #0
    5516:	f000 80a9 	beq.w	566c <ip_frag+0x1a0>
		if (!last) {
			tmp = tmp | IP_MF;
		}

		/* Fill this fragment */
		cop = last ? left : nfb * 8;
    551a:	00db      	lsls	r3, r3, #3
    551c:	b29b      	uxth	r3, r3
    551e:	930f      	str	r3, [sp, #60]	; 0x3c
    5520:	2400      	movs	r4, #0
    5522:	2614      	movs	r6, #20
	return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
    5524:	f8df a170 	ldr.w	sl, [pc, #368]	; 5698 <ip_frag+0x1cc>
			if (pcr == NULL) {
				pbuf_free(rambuf);
				return ERR_MEM;
			}
			/* Mirror this pbuf, although we might not need all of it. */
			newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
    5528:	f8df 9170 	ldr.w	r9, [pc, #368]	; 569c <ip_frag+0x1d0>
			if (newpbuf == NULL) {
				ip_frag_free_pbuf_custom_ref(pcr);
				pbuf_free(rambuf);
				return ERR_MEM;
			}
			pbuf_ref(p);
    552c:	f8df 8170 	ldr.w	r8, [pc, #368]	; 56a0 <ip_frag+0x1d4>
    5530:	e052      	b.n	55d8 <ip_frag+0x10c>
	return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
    5532:	2006      	movs	r0, #6
    5534:	47d0      	blx	sl
			if (pcr == NULL) {
    5536:	4607      	mov	r7, r0
    5538:	2800      	cmp	r0, #0
    553a:	f000 8083 	beq.w	5644 <ip_frag+0x178>
			newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
    553e:	9401      	str	r4, [sp, #4]
    5540:	686b      	ldr	r3, [r5, #4]
    5542:	9300      	str	r3, [sp, #0]
    5544:	4603      	mov	r3, r0
    5546:	2202      	movs	r2, #2
    5548:	4621      	mov	r1, r4
    554a:	2003      	movs	r0, #3
    554c:	47c8      	blx	r9
			if (newpbuf == NULL) {
    554e:	9003      	str	r0, [sp, #12]
    5550:	2800      	cmp	r0, #0
    5552:	d07f      	beq.n	5654 <ip_frag+0x188>
			pbuf_ref(p);
    5554:	4628      	mov	r0, r5
    5556:	47c0      	blx	r8
			pcr->original                = p;
    5558:	617d      	str	r5, [r7, #20]
			pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
    555a:	4b48      	ldr	r3, [pc, #288]	; (567c <ip_frag+0x1b0>)
    555c:	613b      	str	r3, [r7, #16]

			/* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
			 * so that it is removed when pbuf_dechain is later called on rambuf.
			 */
			pbuf_cat(rambuf, newpbuf);
    555e:	9903      	ldr	r1, [sp, #12]
    5560:	9804      	ldr	r0, [sp, #16]
    5562:	4b47      	ldr	r3, [pc, #284]	; (5680 <ip_frag+0x1b4>)
    5564:	4798      	blx	r3
			left_to_copy -= newpbuflen;
    5566:	1b36      	subs	r6, r6, r4
    5568:	b2b6      	uxth	r6, r6
			if (left_to_copy) {
    556a:	b15e      	cbz	r6, 5584 <ip_frag+0xb8>
				p = p->next;
    556c:	682d      	ldr	r5, [r5, #0]
			newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
    556e:	896c      	ldrh	r4, [r5, #10]
    5570:	42b4      	cmp	r4, r6
    5572:	bf28      	it	cs
    5574:	4634      	movcs	r4, r6
    5576:	b2a4      	uxth	r4, r4
			if (!newpbuflen) {
    5578:	2c00      	cmp	r4, #0
    557a:	d1da      	bne.n	5532 <ip_frag+0x66>
				p = p->next;
    557c:	682d      	ldr	r5, [r5, #0]
		while (left_to_copy) {
    557e:	2e00      	cmp	r6, #0
    5580:	d1f5      	bne.n	556e <ip_frag+0xa2>
    5582:	4634      	mov	r4, r6
		poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

		/* Correct header */
		IPH_OFFSET_SET(iphdr, htons(tmp));
    5584:	9808      	ldr	r0, [sp, #32]
    5586:	4e3f      	ldr	r6, [pc, #252]	; (5684 <ip_frag+0x1b8>)
    5588:	47b0      	blx	r6
    558a:	9f09      	ldr	r7, [sp, #36]	; 0x24
    558c:	80f8      	strh	r0, [r7, #6]
		IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    558e:	9b06      	ldr	r3, [sp, #24]
    5590:	f103 0014 	add.w	r0, r3, #20
    5594:	b280      	uxth	r0, r0
    5596:	47b0      	blx	r6
    5598:	8078      	strh	r0, [r7, #2]
		IPH_CHKSUM_SET(iphdr, 0);
    559a:	2300      	movs	r3, #0
    559c:	72bb      	strb	r3, [r7, #10]
    559e:	4638      	mov	r0, r7
    55a0:	72fb      	strb	r3, [r7, #11]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    55a2:	2114      	movs	r1, #20
    55a4:	4b38      	ldr	r3, [pc, #224]	; (5688 <ip_frag+0x1bc>)
    55a6:	4798      	blx	r3
    55a8:	8178      	strh	r0, [r7, #10]
		}
#else  /* IP_FRAG_USES_STATIC_BUF */
        /* No need for separate header pbuf - we allowed room for it in rambuf
         * when allocated.
         */
        netif->output(netif, rambuf, dest);
    55aa:	980d      	ldr	r0, [sp, #52]	; 0x34
    55ac:	6943      	ldr	r3, [r0, #20]
    55ae:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    55b0:	9e04      	ldr	r6, [sp, #16]
    55b2:	4631      	mov	r1, r6
    55b4:	4798      	blx	r3
         * recreate it next time round the loop. If we're lucky the hardware
         * will have already sent the packet, the free will really free, and
         * there will be zero memory penalty.
         */

        pbuf_free(rambuf);
    55b6:	4630      	mov	r0, r6
    55b8:	4b34      	ldr	r3, [pc, #208]	; (568c <ip_frag+0x1c0>)
    55ba:	4798      	blx	r3
#endif /* IP_FRAG_USES_STATIC_BUF */
		left -= cop;
    55bc:	9a05      	ldr	r2, [sp, #20]
    55be:	9b06      	ldr	r3, [sp, #24]
    55c0:	1ad3      	subs	r3, r2, r3
    55c2:	b29b      	uxth	r3, r3
    55c4:	461a      	mov	r2, r3
    55c6:	9305      	str	r3, [sp, #20]
		ofo += nfb;
    55c8:	9b07      	ldr	r3, [sp, #28]
    55ca:	990c      	ldr	r1, [sp, #48]	; 0x30
    55cc:	440b      	add	r3, r1
    55ce:	b29b      	uxth	r3, r3
    55d0:	9307      	str	r3, [sp, #28]
    55d2:	4626      	mov	r6, r4
	while (left) {
    55d4:	2a00      	cmp	r2, #0
    55d6:	d047      	beq.n	5668 <ip_frag+0x19c>
		tmp = omf | (IP_OFFMASK & (ofo));
    55d8:	9b07      	ldr	r3, [sp, #28]
    55da:	f3c3 030c 	ubfx	r3, r3, #0, #13
    55de:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    55e0:	4313      	orrs	r3, r2
    55e2:	9308      	str	r3, [sp, #32]
		if (!last) {
    55e4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    55e6:	9905      	ldr	r1, [sp, #20]
    55e8:	428a      	cmp	r2, r1
			tmp = tmp | IP_MF;
    55ea:	bfbd      	ittte	lt
    55ec:	f443 5300 	orrlt.w	r3, r3, #8192	; 0x2000
    55f0:	9308      	strlt	r3, [sp, #32]
		cop = last ? left : nfb * 8;
    55f2:	9b0f      	ldrlt	r3, [sp, #60]	; 0x3c
    55f4:	9b05      	ldrge	r3, [sp, #20]
    55f6:	9306      	str	r3, [sp, #24]
		rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    55f8:	2200      	movs	r2, #0
    55fa:	2114      	movs	r1, #20
    55fc:	2002      	movs	r0, #2
    55fe:	4b24      	ldr	r3, [pc, #144]	; (5690 <ip_frag+0x1c4>)
    5600:	4798      	blx	r3
		if (rambuf == NULL) {
    5602:	9004      	str	r0, [sp, #16]
    5604:	2800      	cmp	r0, #0
    5606:	d033      	beq.n	5670 <ip_frag+0x1a4>
		SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    5608:	6843      	ldr	r3, [r0, #4]
    560a:	f8db 2000 	ldr.w	r2, [fp]
    560e:	f8db 7004 	ldr.w	r7, [fp, #4]
    5612:	f8db 0008 	ldr.w	r0, [fp, #8]
    5616:	f8db 100c 	ldr.w	r1, [fp, #12]
    561a:	601a      	str	r2, [r3, #0]
    561c:	605f      	str	r7, [r3, #4]
    561e:	6098      	str	r0, [r3, #8]
    5620:	60d9      	str	r1, [r3, #12]
    5622:	f8db 2010 	ldr.w	r2, [fp, #16]
    5626:	611a      	str	r2, [r3, #16]
		iphdr = (struct ip_hdr *)rambuf->payload;
    5628:	9b04      	ldr	r3, [sp, #16]
    562a:	685b      	ldr	r3, [r3, #4]
    562c:	9309      	str	r3, [sp, #36]	; 0x24
		p->payload = (u8_t *)p->payload + poff;
    562e:	686b      	ldr	r3, [r5, #4]
    5630:	4433      	add	r3, r6
    5632:	606b      	str	r3, [r5, #4]
		p->len -= poff;
    5634:	896b      	ldrh	r3, [r5, #10]
    5636:	1b9e      	subs	r6, r3, r6
    5638:	816e      	strh	r6, [r5, #10]
		while (left_to_copy) {
    563a:	9b06      	ldr	r3, [sp, #24]
    563c:	2b00      	cmp	r3, #0
    563e:	d0a1      	beq.n	5584 <ip_frag+0xb8>
    5640:	461e      	mov	r6, r3
    5642:	e794      	b.n	556e <ip_frag+0xa2>
				pbuf_free(rambuf);
    5644:	9804      	ldr	r0, [sp, #16]
    5646:	4b11      	ldr	r3, [pc, #68]	; (568c <ip_frag+0x1c0>)
    5648:	4798      	blx	r3
				return ERR_MEM;
    564a:	f04f 30ff 	mov.w	r0, #4294967295
#if IP_FRAG_USES_STATIC_BUF
	pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
	snmp_inc_ipfragoks();
	return ERR_OK;
}
    564e:	b011      	add	sp, #68	; 0x44
    5650:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	memp_free(MEMP_FRAG_PBUF, p);
    5654:	4639      	mov	r1, r7
    5656:	2006      	movs	r0, #6
    5658:	4b0e      	ldr	r3, [pc, #56]	; (5694 <ip_frag+0x1c8>)
    565a:	4798      	blx	r3
				pbuf_free(rambuf);
    565c:	9804      	ldr	r0, [sp, #16]
    565e:	4b0b      	ldr	r3, [pc, #44]	; (568c <ip_frag+0x1c0>)
    5660:	4798      	blx	r3
				return ERR_MEM;
    5662:	f04f 30ff 	mov.w	r0, #4294967295
    5666:	e7f2      	b.n	564e <ip_frag+0x182>
	return ERR_OK;
    5668:	2000      	movs	r0, #0
    566a:	e7f0      	b.n	564e <ip_frag+0x182>
    566c:	2000      	movs	r0, #0
    566e:	e7ee      	b.n	564e <ip_frag+0x182>
			return ERR_MEM;
    5670:	f04f 30ff 	mov.w	r0, #4294967295
    5674:	e7eb      	b.n	564e <ip_frag+0x182>
    5676:	bf00      	nop
    5678:	00002eaf 	.word	0x00002eaf
    567c:	0000511d 	.word	0x0000511d
    5680:	00005ead 	.word	0x00005ead
    5684:	00002ea5 	.word	0x00002ea5
    5688:	00004b29 	.word	0x00004b29
    568c:	00005c89 	.word	0x00005c89
    5690:	00005cf1 	.word	0x00005cf1
    5694:	000059c1 	.word	0x000059c1
    5698:	00005979 	.word	0x00005979
    569c:	00005b95 	.word	0x00005b95
    56a0:	00005ea3 	.word	0x00005ea3

000056a4 <mem_init>:
	struct mem *mem;

	LWIP_ASSERT("Sanity check alignment", (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

	/* align the heap */
	ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    56a4:	4b0a      	ldr	r3, [pc, #40]	; (56d0 <mem_init+0x2c>)
    56a6:	f023 0303 	bic.w	r3, r3, #3
    56aa:	4a0a      	ldr	r2, [pc, #40]	; (56d4 <mem_init+0x30>)
    56ac:	6013      	str	r3, [r2, #0]
	/* initialize the start of the heap */
	mem       = (struct mem *)(void *)ram;
	mem->next = MEM_SIZE_ALIGNED;
    56ae:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
    56b2:	8019      	strh	r1, [r3, #0]
	mem->prev = 0;
    56b4:	2000      	movs	r0, #0
    56b6:	8058      	strh	r0, [r3, #2]
	mem->used = 0;
    56b8:	7118      	strb	r0, [r3, #4]
	/* initialize the end of the heap */
	ram_end       = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
    56ba:	1858      	adds	r0, r3, r1
    56bc:	6050      	str	r0, [r2, #4]
	ram_end->used = 1;
    56be:	2001      	movs	r0, #1
    56c0:	f883 0fa4 	strb.w	r0, [r3, #4004]	; 0xfa4
	ram_end->next = MEM_SIZE_ALIGNED;
    56c4:	f8a3 1fa0 	strh.w	r1, [r3, #4000]	; 0xfa0
	ram_end->prev = MEM_SIZE_ALIGNED;
    56c8:	f8a3 1fa2 	strh.w	r1, [r3, #4002]	; 0xfa2

	/* initialize the lowest-free pointer to the start of the heap */
	lfree = (struct mem *)(void *)ram;
    56cc:	6093      	str	r3, [r2, #8]
    56ce:	4770      	bx	lr
    56d0:	2000833f 	.word	0x2000833f
    56d4:	20001638 	.word	0x20001638

000056d8 <mem_free>:
void mem_free(void *rmem)
{
	struct mem *mem;
	LWIP_MEM_FREE_DECL_PROTECT();

	if (rmem == NULL) {
    56d8:	2800      	cmp	r0, #0
    56da:	d03f      	beq.n	575c <mem_free+0x84>
    56dc:	4603      	mov	r3, r0
	}
	LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) == 0);

	LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram && (u8_t *)rmem < (u8_t *)ram_end);

	if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    56de:	4a20      	ldr	r2, [pc, #128]	; (5760 <mem_free+0x88>)
    56e0:	6812      	ldr	r2, [r2, #0]
    56e2:	4290      	cmp	r0, r2
    56e4:	d33a      	bcc.n	575c <mem_free+0x84>
    56e6:	491e      	ldr	r1, [pc, #120]	; (5760 <mem_free+0x88>)
    56e8:	6848      	ldr	r0, [r1, #4]
    56ea:	4283      	cmp	r3, r0
    56ec:	d236      	bcs.n	575c <mem_free+0x84>
{
    56ee:	b470      	push	{r4, r5, r6}
		return;
	}
	/* protect the heap from concurrent access */
	LWIP_MEM_FREE_PROTECT();
	/* Get the corresponding struct mem ... */
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    56f0:	f1a3 0108 	sub.w	r1, r3, #8
	/* ... which has to be in a used state ... */
	LWIP_ASSERT("mem_free: mem->used", mem->used);
	/* ... and is now unused. */
	mem->used = 0;
    56f4:	2400      	movs	r4, #0
    56f6:	f803 4c04 	strb.w	r4, [r3, #-4]

	if (mem < lfree) {
    56fa:	4c19      	ldr	r4, [pc, #100]	; (5760 <mem_free+0x88>)
    56fc:	68a4      	ldr	r4, [r4, #8]
    56fe:	42a1      	cmp	r1, r4
		/* the newly freed struct is now the lowest */
		lfree = mem;
    5700:	bf3c      	itt	cc
    5702:	4c17      	ldrcc	r4, [pc, #92]	; (5760 <mem_free+0x88>)
    5704:	60a1      	strcc	r1, [r4, #8]
	nmem = (struct mem *)(void *)&ram[mem->next];
    5706:	f833 5c08 	ldrh.w	r5, [r3, #-8]
    570a:	1954      	adds	r4, r2, r5
	if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    570c:	42a1      	cmp	r1, r4
    570e:	d010      	beq.n	5732 <mem_free+0x5a>
    5710:	7926      	ldrb	r6, [r4, #4]
    5712:	b976      	cbnz	r6, 5732 <mem_free+0x5a>
    5714:	42a0      	cmp	r0, r4
    5716:	d00c      	beq.n	5732 <mem_free+0x5a>
		if (lfree == nmem) {
    5718:	4811      	ldr	r0, [pc, #68]	; (5760 <mem_free+0x88>)
    571a:	6880      	ldr	r0, [r0, #8]
    571c:	4284      	cmp	r4, r0
			lfree = mem;
    571e:	bf04      	itt	eq
    5720:	480f      	ldreq	r0, [pc, #60]	; (5760 <mem_free+0x88>)
    5722:	6081      	streq	r1, [r0, #8]
		mem->next                                      = nmem->next;
    5724:	5b50      	ldrh	r0, [r2, r5]
    5726:	f823 0c08 	strh.w	r0, [r3, #-8]
		((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    572a:	5b50      	ldrh	r0, [r2, r5]
    572c:	4410      	add	r0, r2
    572e:	1a8c      	subs	r4, r1, r2
    5730:	8044      	strh	r4, [r0, #2]
	pmem = (struct mem *)(void *)&ram[mem->prev];
    5732:	f833 0c06 	ldrh.w	r0, [r3, #-6]
    5736:	1814      	adds	r4, r2, r0
	if (pmem != mem && pmem->used == 0) {
    5738:	42a1      	cmp	r1, r4
    573a:	d00e      	beq.n	575a <mem_free+0x82>
    573c:	7925      	ldrb	r5, [r4, #4]
    573e:	b965      	cbnz	r5, 575a <mem_free+0x82>
		if (lfree == mem) {
    5740:	4d07      	ldr	r5, [pc, #28]	; (5760 <mem_free+0x88>)
    5742:	68ad      	ldr	r5, [r5, #8]
    5744:	42a9      	cmp	r1, r5
			lfree = pmem;
    5746:	bf04      	itt	eq
    5748:	4905      	ldreq	r1, [pc, #20]	; (5760 <mem_free+0x88>)
    574a:	608c      	streq	r4, [r1, #8]
		pmem->next                                    = mem->next;
    574c:	f833 1c08 	ldrh.w	r1, [r3, #-8]
    5750:	5211      	strh	r1, [r2, r0]
		((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    5752:	f833 3c08 	ldrh.w	r3, [r3, #-8]
    5756:	441a      	add	r2, r3
    5758:	8050      	strh	r0, [r2, #2]
	plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_FREE_UNPROTECT();
}
    575a:	bc70      	pop	{r4, r5, r6}
    575c:	4770      	bx	lr
    575e:	bf00      	nop
    5760:	20001638 	.word	0x20001638

00005764 <mem_trim>:
	/* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
	LWIP_MEM_FREE_DECL_PROTECT();

	/* Expand the size of the allocated memory region so that we can
	   adjust for alignment. */
	newsize = LWIP_MEM_ALIGN_SIZE(newsize);
    5764:	3103      	adds	r1, #3
    5766:	f64f 73fc 	movw	r3, #65532	; 0xfffc
    576a:	400b      	ands	r3, r1
    576c:	2b0c      	cmp	r3, #12
    576e:	bf38      	it	cc
    5770:	230c      	movcc	r3, #12
	if (newsize < MIN_SIZE_ALIGNED) {
		/* every data block must be at least MIN_SIZE_ALIGNED long */
		newsize = MIN_SIZE_ALIGNED;
	}

	if (newsize > MEM_SIZE_ALIGNED) {
    5772:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
    5776:	d852      	bhi.n	581e <mem_trim+0xba>
		return NULL;
	}

	LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram && (u8_t *)rmem < (u8_t *)ram_end);

	if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    5778:	4a2b      	ldr	r2, [pc, #172]	; (5828 <mem_trim+0xc4>)
    577a:	6812      	ldr	r2, [r2, #0]
    577c:	4282      	cmp	r2, r0
    577e:	d82b      	bhi.n	57d8 <mem_trim+0x74>
    5780:	4929      	ldr	r1, [pc, #164]	; (5828 <mem_trim+0xc4>)
    5782:	6849      	ldr	r1, [r1, #4]
    5784:	4288      	cmp	r0, r1
    5786:	d227      	bcs.n	57d8 <mem_trim+0x74>
{
    5788:	b4f0      	push	{r4, r5, r6, r7}
		MEM_STATS_INC(illegal);
		SYS_ARCH_UNPROTECT(lev);
		return rmem;
	}
	/* Get the corresponding struct mem ... */
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    578a:	f1a0 0408 	sub.w	r4, r0, #8
	/* ... and its offset pointer */
	ptr = (mem_size_t)((u8_t *)mem - ram);
    578e:	1aa4      	subs	r4, r4, r2
    5790:	b2a4      	uxth	r4, r4

	size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    5792:	f830 5c08 	ldrh.w	r5, [r0, #-8]
    5796:	f1a5 0108 	sub.w	r1, r5, #8
    579a:	1b09      	subs	r1, r1, r4
    579c:	b289      	uxth	r1, r1
	LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
	if (newsize > size) {
    579e:	4299      	cmp	r1, r3
    57a0:	d33f      	bcc.n	5822 <mem_trim+0xbe>
		/* not supported */
		return NULL;
	}
	if (newsize == size) {
    57a2:	d018      	beq.n	57d6 <mem_trim+0x72>
	}

	/* protect the heap from concurrent access */
	LWIP_MEM_FREE_PROTECT();

	mem2 = (struct mem *)(void *)&ram[mem->next];
    57a4:	1956      	adds	r6, r2, r5
	if (mem2->used == 0) {
    57a6:	7937      	ldrb	r7, [r6, #4]
    57a8:	b9df      	cbnz	r7, 57e2 <mem_trim+0x7e>
		/* The next struct is unused, we can simply move it at little */
		mem_size_t next;
		/* remember the old next pointer */
		next = mem2->next;
    57aa:	5b55      	ldrh	r5, [r2, r5]
		/* create new struct mem which is moved directly after the shrinked mem */
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    57ac:	f104 0108 	add.w	r1, r4, #8
    57b0:	440b      	add	r3, r1
    57b2:	b29b      	uxth	r3, r3
		if (lfree == mem2) {
    57b4:	491c      	ldr	r1, [pc, #112]	; (5828 <mem_trim+0xc4>)
    57b6:	6889      	ldr	r1, [r1, #8]
    57b8:	428e      	cmp	r6, r1
    57ba:	d00e      	beq.n	57da <mem_trim+0x76>
			lfree = (struct mem *)(void *)&ram[ptr2];
		}
		mem2       = (struct mem *)(void *)&ram[ptr2];
    57bc:	18d1      	adds	r1, r2, r3
		mem2->used = 0;
    57be:	2600      	movs	r6, #0
    57c0:	710e      	strb	r6, [r1, #4]
		/* restore the next pointer */
		mem2->next = next;
    57c2:	52d5      	strh	r5, [r2, r3]
		/* link it back to mem */
		mem2->prev = ptr;
    57c4:	804c      	strh	r4, [r1, #2]
		/* link mem to it */
		mem->next = ptr2;
    57c6:	f820 3c08 	strh.w	r3, [r0, #-8]
		/* last thing to restore linked list: as we have moved mem2,
		 * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
		 * the end of the heap */
		if (mem2->next != MEM_SIZE_ALIGNED) {
    57ca:	5ad1      	ldrh	r1, [r2, r3]
    57cc:	f5b1 6f7a 	cmp.w	r1, #4000	; 0xfa0
    57d0:	d001      	beq.n	57d6 <mem_trim+0x72>
			((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    57d2:	440a      	add	r2, r1
    57d4:	8053      	strh	r3, [r2, #2]
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_FREE_UNPROTECT();
	return rmem;
}
    57d6:	bcf0      	pop	{r4, r5, r6, r7}
    57d8:	4770      	bx	lr
			lfree = (struct mem *)(void *)&ram[ptr2];
    57da:	18d1      	adds	r1, r2, r3
    57dc:	4e12      	ldr	r6, [pc, #72]	; (5828 <mem_trim+0xc4>)
    57de:	60b1      	str	r1, [r6, #8]
    57e0:	e7ec      	b.n	57bc <mem_trim+0x58>
	} else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
    57e2:	f103 0514 	add.w	r5, r3, #20
    57e6:	428d      	cmp	r5, r1
    57e8:	d8f5      	bhi.n	57d6 <mem_trim+0x72>
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    57ea:	f104 0108 	add.w	r1, r4, #8
    57ee:	440b      	add	r3, r1
    57f0:	b29b      	uxth	r3, r3
		mem2 = (struct mem *)(void *)&ram[ptr2];
    57f2:	18d1      	adds	r1, r2, r3
		if (mem2 < lfree) {
    57f4:	4d0c      	ldr	r5, [pc, #48]	; (5828 <mem_trim+0xc4>)
    57f6:	68ad      	ldr	r5, [r5, #8]
    57f8:	42a9      	cmp	r1, r5
			lfree = mem2;
    57fa:	bf3c      	itt	cc
    57fc:	4d0a      	ldrcc	r5, [pc, #40]	; (5828 <mem_trim+0xc4>)
    57fe:	60a9      	strcc	r1, [r5, #8]
		mem2->used = 0;
    5800:	2500      	movs	r5, #0
    5802:	710d      	strb	r5, [r1, #4]
		mem2->next = mem->next;
    5804:	f830 5c08 	ldrh.w	r5, [r0, #-8]
    5808:	52d5      	strh	r5, [r2, r3]
		mem2->prev = ptr;
    580a:	804c      	strh	r4, [r1, #2]
		mem->next  = ptr2;
    580c:	f820 3c08 	strh.w	r3, [r0, #-8]
		if (mem2->next != MEM_SIZE_ALIGNED) {
    5810:	5ad1      	ldrh	r1, [r2, r3]
    5812:	f5b1 6f7a 	cmp.w	r1, #4000	; 0xfa0
    5816:	d0de      	beq.n	57d6 <mem_trim+0x72>
			((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    5818:	440a      	add	r2, r1
    581a:	8053      	strh	r3, [r2, #2]
    581c:	e7db      	b.n	57d6 <mem_trim+0x72>
		return NULL;
    581e:	2000      	movs	r0, #0
    5820:	4770      	bx	lr
		return NULL;
    5822:	2000      	movs	r0, #0
    5824:	e7d7      	b.n	57d6 <mem_trim+0x72>
    5826:	bf00      	nop
    5828:	20001638 	.word	0x20001638

0000582c <mem_malloc>:
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	u8_t        local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_ALLOC_DECL_PROTECT();

	if (size == 0) {
    582c:	2800      	cmp	r0, #0
    582e:	d05f      	beq.n	58f0 <mem_malloc+0xc4>
{
    5830:	b5f0      	push	{r4, r5, r6, r7, lr}
    5832:	4603      	mov	r3, r0
		return NULL;
	}

	/* Expand the size of the allocated memory region so that we can
	   adjust for alignment. */
	size = LWIP_MEM_ALIGN_SIZE(size);
    5834:	3303      	adds	r3, #3
    5836:	f64f 74fc 	movw	r4, #65532	; 0xfffc
    583a:	401c      	ands	r4, r3
    583c:	2c0c      	cmp	r4, #12
    583e:	bf38      	it	cc
    5840:	240c      	movcc	r4, #12
	if (size < MIN_SIZE_ALIGNED) {
		/* every data block must be at least MIN_SIZE_ALIGNED long */
		size = MIN_SIZE_ALIGNED;
	}

	if (size > MEM_SIZE_ALIGNED) {
    5842:	f5b4 6f7a 	cmp.w	r4, #4000	; 0xfa0
    5846:	d855      	bhi.n	58f4 <mem_malloc+0xc8>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

		/* Scan through the heap searching for a free block that is big enough,
		 * beginning with the lowest free block.
		 */
		for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    5848:	4b2c      	ldr	r3, [pc, #176]	; (58fc <mem_malloc+0xd0>)
    584a:	689f      	ldr	r7, [r3, #8]
    584c:	6819      	ldr	r1, [r3, #0]
    584e:	1a7b      	subs	r3, r7, r1
    5850:	b29b      	uxth	r3, r3
    5852:	f5c4 657a 	rsb	r5, r4, #4000	; 0xfa0
    5856:	42ab      	cmp	r3, r5
    5858:	da4e      	bge.n	58f8 <mem_malloc+0xcc>
				local_mem_free_count = 1;
				break;
			}
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

			if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    585a:	f06f 0c07 	mvn.w	ip, #7
    585e:	46a6      	mov	lr, r4
    5860:	e00e      	b.n	5880 <mem_malloc+0x54>
					 * take care of this).
					 * -> near fit or excact fit: do not split, no mem2 creation
					 * also can't move mem->next directly behind mem, since mem->next
					 * will always be used at this point!
					 */
					mem->used = 1;
    5862:	2301      	movs	r3, #1
    5864:	7103      	strb	r3, [r0, #4]
					MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
				}
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
			mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
				if (mem == lfree) {
    5866:	4b25      	ldr	r3, [pc, #148]	; (58fc <mem_malloc+0xd0>)
    5868:	689b      	ldr	r3, [r3, #8]
    586a:	4298      	cmp	r0, r3
    586c:	d02f      	beq.n	58ce <mem_malloc+0xa2>
				            (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
				LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
				            ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
				LWIP_ASSERT("mem_malloc: sanity check alignment", (((mem_ptr_t)mem) & (MEM_ALIGNMENT - 1)) == 0);

				return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    586e:	3008      	adds	r0, #8
    5870:	bdf0      	pop	{r4, r5, r6, r7, pc}
			mem            = (struct mem *)(void *)&ram[ptr];
    5872:	4603      	mov	r3, r0
    5874:	e037      	b.n	58e6 <mem_malloc+0xba>
    5876:	4603      	mov	r3, r0
    5878:	e035      	b.n	58e6 <mem_malloc+0xba>
		     ptr = ((struct mem *)(void *)&ram[ptr])->next) {
    587a:	8803      	ldrh	r3, [r0, #0]
		for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    587c:	42ab      	cmp	r3, r5
    587e:	da35      	bge.n	58ec <mem_malloc+0xc0>
			mem            = (struct mem *)(void *)&ram[ptr];
    5880:	18c8      	adds	r0, r1, r3
			if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    5882:	7902      	ldrb	r2, [r0, #4]
    5884:	2a00      	cmp	r2, #0
    5886:	d1f8      	bne.n	587a <mem_malloc+0x4e>
    5888:	ebac 0203 	sub.w	r2, ip, r3
    588c:	5ace      	ldrh	r6, [r1, r3]
    588e:	4432      	add	r2, r6
    5890:	4676      	mov	r6, lr
    5892:	42a2      	cmp	r2, r4
    5894:	d3f1      	bcc.n	587a <mem_malloc+0x4e>
				if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
    5896:	3614      	adds	r6, #20
    5898:	42b2      	cmp	r2, r6
    589a:	d3e2      	bcc.n	5862 <mem_malloc+0x36>
					ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
    589c:	f104 0208 	add.w	r2, r4, #8
    58a0:	441a      	add	r2, r3
    58a2:	b292      	uxth	r2, r2
					mem2       = (struct mem *)(void *)&ram[ptr2];
    58a4:	188c      	adds	r4, r1, r2
					mem2->used = 0;
    58a6:	2500      	movs	r5, #0
    58a8:	7125      	strb	r5, [r4, #4]
					mem2->next = mem->next;
    58aa:	8805      	ldrh	r5, [r0, #0]
    58ac:	528d      	strh	r5, [r1, r2]
					mem2->prev = ptr;
    58ae:	8063      	strh	r3, [r4, #2]
					mem->next = ptr2;
    58b0:	8002      	strh	r2, [r0, #0]
					mem->used = 1;
    58b2:	2301      	movs	r3, #1
    58b4:	7103      	strb	r3, [r0, #4]
					if (mem2->next != MEM_SIZE_ALIGNED) {
    58b6:	5a8b      	ldrh	r3, [r1, r2]
    58b8:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
    58bc:	d0d3      	beq.n	5866 <mem_malloc+0x3a>
						((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    58be:	4419      	add	r1, r3
    58c0:	804a      	strh	r2, [r1, #2]
				if (mem == lfree) {
    58c2:	4287      	cmp	r7, r0
    58c4:	d1d3      	bne.n	586e <mem_malloc+0x42>
					while (cur->used && cur != ram_end) {
    58c6:	7903      	ldrb	r3, [r0, #4]
    58c8:	2b00      	cmp	r3, #0
    58ca:	d0d2      	beq.n	5872 <mem_malloc+0x46>
				if (mem == lfree) {
    58cc:	4603      	mov	r3, r0
					while (cur->used && cur != ram_end) {
    58ce:	4a0b      	ldr	r2, [pc, #44]	; (58fc <mem_malloc+0xd0>)
    58d0:	6851      	ldr	r1, [r2, #4]
    58d2:	4288      	cmp	r0, r1
    58d4:	d0cf      	beq.n	5876 <mem_malloc+0x4a>
						cur = (struct mem *)(void *)&ram[cur->next];
    58d6:	6814      	ldr	r4, [r2, #0]
    58d8:	881b      	ldrh	r3, [r3, #0]
    58da:	4423      	add	r3, r4
					while (cur->used && cur != ram_end) {
    58dc:	791a      	ldrb	r2, [r3, #4]
    58de:	b112      	cbz	r2, 58e6 <mem_malloc+0xba>
    58e0:	428b      	cmp	r3, r1
    58e2:	d1f9      	bne.n	58d8 <mem_malloc+0xac>
						cur = (struct mem *)(void *)&ram[cur->next];
    58e4:	460b      	mov	r3, r1
					lfree = cur;
    58e6:	4a05      	ldr	r2, [pc, #20]	; (58fc <mem_malloc+0xd0>)
    58e8:	6093      	str	r3, [r2, #8]
    58ea:	e7c0      	b.n	586e <mem_malloc+0x42>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %" S16_F " bytes\n", (s16_t)size));
	MEM_STATS_INC(err);
	LWIP_MEM_ALLOC_UNPROTECT();
	sys_mutex_unlock(&mem_mutex);
	return NULL;
    58ec:	2000      	movs	r0, #0
    58ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return NULL;
    58f0:	2000      	movs	r0, #0
    58f2:	4770      	bx	lr
		return NULL;
    58f4:	2000      	movs	r0, #0
    58f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return NULL;
    58f8:	2000      	movs	r0, #0
    58fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    58fc:	20001638 	.word	0x20001638

00005900 <memp_init>:
 * Initialize this module.
 *
 * Carves out memp_memory into linked lists for each pool-type.
 */
void memp_init(void)
{
    5900:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		MEMP_STATS_AVAIL(err, i, 0);
		MEMP_STATS_AVAIL(avail, i, memp_num[i]);
	}

#if !MEMP_SEPARATE_POOLS
	memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
    5904:	4f19      	ldr	r7, [pc, #100]	; (596c <memp_init+0x6c>)
    5906:	f027 0703 	bic.w	r7, r7, #3
    590a:	4b19      	ldr	r3, [pc, #100]	; (5970 <memp_init+0x70>)
    590c:	f503 7655 	add.w	r6, r3, #852	; 0x354
    5910:	f8df c060 	ldr.w	ip, [pc, #96]	; 5974 <memp_init+0x74>
    5914:	f10c 0e14 	add.w	lr, ip, #20
    5918:	f503 795f 	add.w	r9, r3, #892	; 0x37c
#endif /* !MEMP_SEPARATE_POOLS */
	/* for every pool: */
	for (i = 0; i < MEMP_MAX; ++i) {
		memp_tab[i] = NULL;
    591c:	f04f 0a00 	mov.w	sl, #0
    5920:	e015      	b.n	594e <memp_init+0x4e>
#endif /* MEMP_SEPARATE_POOLS */
		/* create a linked list of memp elements */
		for (j = 0; j < memp_num[i]; ++j) {
			memp->next  = memp_tab[i];
			memp_tab[i] = memp;
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    5922:	4603      	mov	r3, r0
			memp->next  = memp_tab[i];
    5924:	6019      	str	r1, [r3, #0]
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    5926:	1958      	adds	r0, r3, r5
    5928:	3201      	adds	r2, #1
			memp_tab[i] = memp;
    592a:	4619      	mov	r1, r3
		for (j = 0; j < memp_num[i]; ++j) {
    592c:	b293      	uxth	r3, r2
    592e:	429c      	cmp	r4, r3
    5930:	d8f7      	bhi.n	5922 <memp_init+0x22>
    5932:	3c01      	subs	r4, #1
    5934:	b2a4      	uxth	r4, r4
    5936:	fb04 5305 	mla	r3, r4, r5, r5
    593a:	fb04 7405 	mla	r4, r4, r5, r7
    593e:	f8c8 4000 	str.w	r4, [r8]
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    5942:	441f      	add	r7, r3
    5944:	3604      	adds	r6, #4
    5946:	f10e 0e02 	add.w	lr, lr, #2
	for (i = 0; i < MEMP_MAX; ++i) {
    594a:	45b1      	cmp	r9, r6
    594c:	d00c      	beq.n	5968 <memp_init+0x68>
    594e:	46b0      	mov	r8, r6
		memp_tab[i] = NULL;
    5950:	f8c6 a000 	str.w	sl, [r6]
		for (j = 0; j < memp_num[i]; ++j) {
    5954:	f83c 4b02 	ldrh.w	r4, [ip], #2
    5958:	2c00      	cmp	r4, #0
    595a:	d0f3      	beq.n	5944 <memp_init+0x44>
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    595c:	f8be 5000 	ldrh.w	r5, [lr]
    5960:	463b      	mov	r3, r7
    5962:	2200      	movs	r2, #0
    5964:	4611      	mov	r1, r2
    5966:	e7dd      	b.n	5924 <memp_init+0x24>
#if MEMP_OVERFLOW_CHECK
	memp_overflow_init();
	/* check everything a first time to see if it worked */
	memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
    5968:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    596c:	20001647 	.word	0x20001647
    5970:	20007c14 	.word	0x20007c14
    5974:	0000c2a0 	.word	0x0000c2a0

00005978 <memp_malloc>:
#endif
{
	struct memp *memp;
	SYS_ARCH_DECL_PROTECT(old_level);

	LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    5978:	2809      	cmp	r0, #9
    597a:	d80d      	bhi.n	5998 <memp_malloc+0x20>
	SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
	memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

	memp = memp_tab[type];
    597c:	4b0b      	ldr	r3, [pc, #44]	; (59ac <memp_malloc+0x34>)
    597e:	eb03 0380 	add.w	r3, r3, r0, lsl #2
    5982:	f8d3 3354 	ldr.w	r3, [r3, #852]	; 0x354

	if (memp != NULL) {
    5986:	b12b      	cbz	r3, 5994 <memp_malloc+0x1c>
		memp_tab[type] = memp->next;
    5988:	6819      	ldr	r1, [r3, #0]
    598a:	4a08      	ldr	r2, [pc, #32]	; (59ac <memp_malloc+0x34>)
    598c:	eb02 0280 	add.w	r2, r2, r0, lsl #2
    5990:	f8c2 1354 	str.w	r1, [r2, #852]	; 0x354
	}

	SYS_ARCH_UNPROTECT(old_level);

	return memp;
}
    5994:	4618      	mov	r0, r3
    5996:	4770      	bx	lr
{
    5998:	b510      	push	{r4, lr}
	LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    599a:	4b05      	ldr	r3, [pc, #20]	; (59b0 <memp_malloc+0x38>)
    599c:	f240 1289 	movw	r2, #393	; 0x189
    59a0:	4904      	ldr	r1, [pc, #16]	; (59b4 <memp_malloc+0x3c>)
    59a2:	4805      	ldr	r0, [pc, #20]	; (59b8 <memp_malloc+0x40>)
    59a4:	4c05      	ldr	r4, [pc, #20]	; (59bc <memp_malloc+0x44>)
    59a6:	47a0      	blx	r4
    59a8:	e7fe      	b.n	59a8 <memp_malloc+0x30>
    59aa:	bf00      	nop
    59ac:	20007c14 	.word	0x20007c14
    59b0:	0000c2c8 	.word	0x0000c2c8
    59b4:	0000c2ec 	.word	0x0000c2ec
    59b8:	0000b2e8 	.word	0x0000b2e8
    59bc:	00009fd5 	.word	0x00009fd5

000059c0 <memp_free>:
void memp_free(memp_t type, void *mem)
{
	struct memp *memp;
	SYS_ARCH_DECL_PROTECT(old_level);

	if (mem == NULL) {
    59c0:	b139      	cbz	r1, 59d2 <memp_free+0x12>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

	MEMP_STATS_DEC(used, type);

	memp->next     = memp_tab[type];
    59c2:	4b04      	ldr	r3, [pc, #16]	; (59d4 <memp_free+0x14>)
    59c4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    59c8:	f8d0 3354 	ldr.w	r3, [r0, #852]	; 0x354
    59cc:	600b      	str	r3, [r1, #0]
	memp_tab[type] = memp;
    59ce:	f8c0 1354 	str.w	r1, [r0, #852]	; 0x354
    59d2:	4770      	bx	lr
    59d4:	20007c14 	.word	0x20007c14

000059d8 <netif_init>:
	return ERR_OK;
}
#endif /* LWIP_HAVE_LOOPIF */

void netif_init(void)
{
    59d8:	4770      	bx	lr
	...

000059dc <netif_set_ipaddr>:
 *
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
    59dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    59de:	4604      	mov	r4, r0
#if LWIP_TCP
	struct tcp_pcb *       pcb;
	struct tcp_pcb_listen *lpcb;

	/* address is actually being changed? */
	if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    59e0:	2900      	cmp	r1, #0
    59e2:	d027      	beq.n	5a34 <netif_set_ipaddr+0x58>
    59e4:	460d      	mov	r5, r1
    59e6:	680a      	ldr	r2, [r1, #0]
    59e8:	6843      	ldr	r3, [r0, #4]
    59ea:	429a      	cmp	r2, r3
    59ec:	d011      	beq.n	5a12 <netif_set_ipaddr+0x36>
		/* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
		pcb = tcp_active_pcbs;
    59ee:	4b12      	ldr	r3, [pc, #72]	; (5a38 <netif_set_ipaddr+0x5c>)
    59f0:	6818      	ldr	r0, [r3, #0]
		while (pcb != NULL) {
    59f2:	b158      	cbz	r0, 5a0c <netif_set_ipaddr+0x30>
#endif /* LWIP_AUTOIP */
			) {
				/* this connection must be aborted */
				struct tcp_pcb *next = pcb->next;
				LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
				tcp_abort(pcb);
    59f4:	4f11      	ldr	r7, [pc, #68]	; (5a3c <netif_set_ipaddr+0x60>)
    59f6:	e003      	b.n	5a00 <netif_set_ipaddr+0x24>
				struct tcp_pcb *next = pcb->next;
    59f8:	68c6      	ldr	r6, [r0, #12]
				tcp_abort(pcb);
    59fa:	47b8      	blx	r7
				pcb = next;
    59fc:	4630      	mov	r0, r6
		while (pcb != NULL) {
    59fe:	b128      	cbz	r0, 5a0c <netif_set_ipaddr+0x30>
			if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
    5a00:	6802      	ldr	r2, [r0, #0]
    5a02:	6863      	ldr	r3, [r4, #4]
    5a04:	429a      	cmp	r2, r3
    5a06:	d0f7      	beq.n	59f8 <netif_set_ipaddr+0x1c>
			} else {
				pcb = pcb->next;
    5a08:	68c0      	ldr	r0, [r0, #12]
    5a0a:	e7f8      	b.n	59fe <netif_set_ipaddr+0x22>
			}
		}
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    5a0c:	4b0c      	ldr	r3, [pc, #48]	; (5a40 <netif_set_ipaddr+0x64>)
    5a0e:	681b      	ldr	r3, [r3, #0]
    5a10:	b92b      	cbnz	r3, 5a1e <netif_set_ipaddr+0x42>
	}
#endif
	snmp_delete_ipaddridx_tree(netif);
	snmp_delete_iprteidx_tree(0, netif);
	/* set new IP address to netif */
	ip_addr_set(&(netif->ip_addr), ipaddr);
    5a12:	682b      	ldr	r3, [r5, #0]
    5a14:	6063      	str	r3, [r4, #4]
	             netif->name[1],
	             ip4_addr1_16(&netif->ip_addr),
	             ip4_addr2_16(&netif->ip_addr),
	             ip4_addr3_16(&netif->ip_addr),
	             ip4_addr4_16(&netif->ip_addr)));
}
    5a16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    5a18:	68db      	ldr	r3, [r3, #12]
    5a1a:	2b00      	cmp	r3, #0
    5a1c:	d0f9      	beq.n	5a12 <netif_set_ipaddr+0x36>
			if ((!(ip_addr_isany(&(lpcb->local_ip)))) && (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
    5a1e:	2b00      	cmp	r3, #0
    5a20:	d0fa      	beq.n	5a18 <netif_set_ipaddr+0x3c>
    5a22:	681a      	ldr	r2, [r3, #0]
    5a24:	2a00      	cmp	r2, #0
    5a26:	d0f7      	beq.n	5a18 <netif_set_ipaddr+0x3c>
    5a28:	6861      	ldr	r1, [r4, #4]
    5a2a:	428a      	cmp	r2, r1
				ip_addr_set(&(lpcb->local_ip), ipaddr);
    5a2c:	bf04      	itt	eq
    5a2e:	682a      	ldreq	r2, [r5, #0]
    5a30:	601a      	streq	r2, [r3, #0]
    5a32:	e7f1      	b.n	5a18 <netif_set_ipaddr+0x3c>
	ip_addr_set(&(netif->ip_addr), ipaddr);
    5a34:	2300      	movs	r3, #0
    5a36:	e7ed      	b.n	5a14 <netif_set_ipaddr+0x38>
    5a38:	20009300 	.word	0x20009300
    5a3c:	00006a1d 	.word	0x00006a1d
    5a40:	20009308 	.word	0x20009308

00005a44 <netif_set_addr>:
{
    5a44:	b570      	push	{r4, r5, r6, lr}
    5a46:	4604      	mov	r4, r0
    5a48:	4616      	mov	r6, r2
    5a4a:	461d      	mov	r5, r3
	netif_set_ipaddr(netif, ipaddr);
    5a4c:	4b06      	ldr	r3, [pc, #24]	; (5a68 <netif_set_addr+0x24>)
    5a4e:	4798      	blx	r3
 */
void netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
	snmp_delete_iprteidx_tree(0, netif);
	/* set new netmask to netif */
	ip_addr_set(&(netif->netmask), netmask);
    5a50:	b12e      	cbz	r6, 5a5e <netif_set_addr+0x1a>
    5a52:	6833      	ldr	r3, [r6, #0]
    5a54:	60a3      	str	r3, [r4, #8]
	ip_addr_set(&(netif->gw), gw);
    5a56:	b125      	cbz	r5, 5a62 <netif_set_addr+0x1e>
    5a58:	682b      	ldr	r3, [r5, #0]
    5a5a:	60e3      	str	r3, [r4, #12]
    5a5c:	bd70      	pop	{r4, r5, r6, pc}
	ip_addr_set(&(netif->netmask), netmask);
    5a5e:	2300      	movs	r3, #0
    5a60:	e7f8      	b.n	5a54 <netif_set_addr+0x10>
	ip_addr_set(&(netif->gw), gw);
    5a62:	2300      	movs	r3, #0
    5a64:	e7f9      	b.n	5a5a <netif_set_addr+0x16>
    5a66:	bf00      	nop
    5a68:	000059dd 	.word	0x000059dd

00005a6c <netif_add>:
{
    5a6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5a6e:	4604      	mov	r4, r0
	ip_addr_set_zero(&netif->ip_addr);
    5a70:	2500      	movs	r5, #0
    5a72:	6045      	str	r5, [r0, #4]
	ip_addr_set_zero(&netif->netmask);
    5a74:	6085      	str	r5, [r0, #8]
	ip_addr_set_zero(&netif->gw);
    5a76:	60c5      	str	r5, [r0, #12]
	netif->flags = 0;
    5a78:	f880 5035 	strb.w	r5, [r0, #53]	; 0x35
	netif->dhcp = NULL;
    5a7c:	6285      	str	r5, [r0, #40]	; 0x28
	netif->status_callback = NULL;
    5a7e:	61c5      	str	r5, [r0, #28]
	netif->link_callback = NULL;
    5a80:	6205      	str	r5, [r0, #32]
	netif->state = state;
    5a82:	9d06      	ldr	r5, [sp, #24]
    5a84:	6245      	str	r5, [r0, #36]	; 0x24
	netif->num   = netif_num++;
    5a86:	4e0b      	ldr	r6, [pc, #44]	; (5ab4 <netif_add+0x48>)
    5a88:	7835      	ldrb	r5, [r6, #0]
    5a8a:	1c6f      	adds	r7, r5, #1
    5a8c:	7037      	strb	r7, [r6, #0]
    5a8e:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
	netif->input = input;
    5a92:	9d08      	ldr	r5, [sp, #32]
    5a94:	6105      	str	r5, [r0, #16]
	netif_set_addr(netif, ipaddr, netmask, gw);
    5a96:	4d08      	ldr	r5, [pc, #32]	; (5ab8 <netif_add+0x4c>)
    5a98:	47a8      	blx	r5
	if (init(netif) != ERR_OK) {
    5a9a:	4620      	mov	r0, r4
    5a9c:	9b07      	ldr	r3, [sp, #28]
    5a9e:	4798      	blx	r3
    5aa0:	b928      	cbnz	r0, 5aae <netif_add+0x42>
	netif->next = netif_list;
    5aa2:	4b06      	ldr	r3, [pc, #24]	; (5abc <netif_add+0x50>)
    5aa4:	681a      	ldr	r2, [r3, #0]
    5aa6:	6022      	str	r2, [r4, #0]
	netif_list  = netif;
    5aa8:	601c      	str	r4, [r3, #0]
	return netif;
    5aaa:	4620      	mov	r0, r4
    5aac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return NULL;
    5aae:	2000      	movs	r0, #0
}
    5ab0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5ab2:	bf00      	nop
    5ab4:	20007f90 	.word	0x20007f90
    5ab8:	00005a45 	.word	0x00005a45
    5abc:	200092f0 	.word	0x200092f0

00005ac0 <netif_set_gw>:
	ip_addr_set(&(netif->gw), gw);
    5ac0:	b111      	cbz	r1, 5ac8 <netif_set_gw+0x8>
    5ac2:	680b      	ldr	r3, [r1, #0]
    5ac4:	60c3      	str	r3, [r0, #12]
    5ac6:	4770      	bx	lr
    5ac8:	2300      	movs	r3, #0
    5aca:	e7fb      	b.n	5ac4 <netif_set_gw+0x4>

00005acc <netif_set_netmask>:
	ip_addr_set(&(netif->netmask), netmask);
    5acc:	b111      	cbz	r1, 5ad4 <netif_set_netmask+0x8>
    5ace:	680b      	ldr	r3, [r1, #0]
    5ad0:	6083      	str	r3, [r0, #8]
    5ad2:	4770      	bx	lr
    5ad4:	2300      	movs	r3, #0
    5ad6:	e7fb      	b.n	5ad0 <netif_set_netmask+0x4>

00005ad8 <netif_set_default>:
		snmp_delete_iprteidx_tree(1, netif);
	} else {
		/* install default route */
		snmp_insert_iprteidx_tree(1, netif);
	}
	netif_default = netif;
    5ad8:	4b01      	ldr	r3, [pc, #4]	; (5ae0 <netif_set_default+0x8>)
    5ada:	6018      	str	r0, [r3, #0]
    5adc:	4770      	bx	lr
    5ade:	bf00      	nop
    5ae0:	200092f4 	.word	0x200092f4

00005ae4 <netif_set_up>:
 *
 * @see dhcp_start()
 */
void netif_set_up(struct netif *netif)
{
	if (!(netif->flags & NETIF_FLAG_UP)) {
    5ae4:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
    5ae8:	f013 0f01 	tst.w	r3, #1
    5aec:	d114      	bne.n	5b18 <netif_set_up+0x34>
{
    5aee:	b510      	push	{r4, lr}
    5af0:	4604      	mov	r4, r0
		netif->flags |= NETIF_FLAG_UP;
    5af2:	f043 0301 	orr.w	r3, r3, #1
    5af6:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35

#if LWIP_SNMP
		snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

		NETIF_STATUS_CALLBACK(netif);
    5afa:	69c3      	ldr	r3, [r0, #28]
    5afc:	b103      	cbz	r3, 5b00 <netif_set_up+0x1c>
    5afe:	4798      	blx	r3

		if (netif->flags & NETIF_FLAG_LINK_UP) {
#if LWIP_ARP
			/* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
			if (netif->flags & (NETIF_FLAG_ETHARP)) {
    5b00:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    5b04:	f003 0330 	and.w	r3, r3, #48	; 0x30
    5b08:	2b30      	cmp	r3, #48	; 0x30
    5b0a:	d000      	beq.n	5b0e <netif_set_up+0x2a>
    5b0c:	bd10      	pop	{r4, pc}
				etharp_gratuitous(netif);
    5b0e:	1d21      	adds	r1, r4, #4
    5b10:	4620      	mov	r0, r4
    5b12:	4b02      	ldr	r3, [pc, #8]	; (5b1c <netif_set_up+0x38>)
    5b14:	4798      	blx	r3
				igmp_report_groups(netif);
			}
#endif /* LWIP_IGMP */
		}
	}
}
    5b16:	e7f9      	b.n	5b0c <netif_set_up+0x28>
    5b18:	4770      	bx	lr
    5b1a:	bf00      	nop
    5b1c:	00009099 	.word	0x00009099

00005b20 <netif_set_down>:
 *
 * @see dhcp_start()
 */
void netif_set_down(struct netif *netif)
{
	if (netif->flags & NETIF_FLAG_UP) {
    5b20:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
    5b24:	f013 0f01 	tst.w	r3, #1
    5b28:	d010      	beq.n	5b4c <netif_set_down+0x2c>
{
    5b2a:	b510      	push	{r4, lr}
    5b2c:	4604      	mov	r4, r0
		netif->flags &= ~NETIF_FLAG_UP;
    5b2e:	f023 0201 	bic.w	r2, r3, #1
    5b32:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
#if LWIP_SNMP
		snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
		if (netif->flags & NETIF_FLAG_ETHARP) {
    5b36:	f013 0f20 	tst.w	r3, #32
    5b3a:	d104      	bne.n	5b46 <netif_set_down+0x26>
			etharp_cleanup_netif(netif);
		}
#endif /* LWIP_ARP */
		NETIF_STATUS_CALLBACK(netif);
    5b3c:	69e3      	ldr	r3, [r4, #28]
    5b3e:	b10b      	cbz	r3, 5b44 <netif_set_down+0x24>
    5b40:	4620      	mov	r0, r4
    5b42:	4798      	blx	r3
    5b44:	bd10      	pop	{r4, pc}
			etharp_cleanup_netif(netif);
    5b46:	4b02      	ldr	r3, [pc, #8]	; (5b50 <netif_set_down+0x30>)
    5b48:	4798      	blx	r3
    5b4a:	e7f7      	b.n	5b3c <netif_set_down+0x1c>
    5b4c:	4770      	bx	lr
    5b4e:	bf00      	nop
    5b50:	00009069 	.word	0x00009069

00005b54 <netif_set_status_callback>:
/**
 * Set callback to be called when interface is brought up/down
 */
void netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback)
{
	if (netif) {
    5b54:	b100      	cbz	r0, 5b58 <netif_set_status_callback+0x4>
		netif->status_callback = status_callback;
    5b56:	61c1      	str	r1, [r0, #28]
    5b58:	4770      	bx	lr

00005b5a <netif_set_link_callback>:
/**
 * Set callback to be called when link is brought up/down
 */
void netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback)
{
	if (netif) {
    5b5a:	b100      	cbz	r0, 5b5e <netif_set_link_callback+0x4>
		netif->link_callback = link_callback;
    5b5c:	6201      	str	r1, [r0, #32]
    5b5e:	4770      	bx	lr

00005b60 <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
    void
    pbuf_free_ooseq(void)
{
    5b60:	b510      	push	{r4, lr}
	struct tcp_pcb *pcb;
	SYS_ARCH_DECL_PROTECT(old_level);

	SYS_ARCH_PROTECT(old_level);
	pbuf_free_ooseq_pending = 0;
    5b62:	2200      	movs	r2, #0
    5b64:	4b08      	ldr	r3, [pc, #32]	; (5b88 <pbuf_free_ooseq+0x28>)
    5b66:	701a      	strb	r2, [r3, #0]
	SYS_ARCH_UNPROTECT(old_level);

	for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    5b68:	4b08      	ldr	r3, [pc, #32]	; (5b8c <pbuf_free_ooseq+0x2c>)
    5b6a:	681c      	ldr	r4, [r3, #0]
    5b6c:	b15c      	cbz	r4, 5b86 <pbuf_free_ooseq+0x26>
		if (NULL != pcb->ooseq) {
    5b6e:	6f60      	ldr	r0, [r4, #116]	; 0x74
    5b70:	b920      	cbnz	r0, 5b7c <pbuf_free_ooseq+0x1c>
	for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    5b72:	68e4      	ldr	r4, [r4, #12]
    5b74:	b13c      	cbz	r4, 5b86 <pbuf_free_ooseq+0x26>
		if (NULL != pcb->ooseq) {
    5b76:	6f60      	ldr	r0, [r4, #116]	; 0x74
    5b78:	2800      	cmp	r0, #0
    5b7a:	d0fa      	beq.n	5b72 <pbuf_free_ooseq+0x12>
			/** Free the ooseq pbufs of one PCB only */
			LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
			tcp_segs_free(pcb->ooseq);
    5b7c:	4b04      	ldr	r3, [pc, #16]	; (5b90 <pbuf_free_ooseq+0x30>)
    5b7e:	4798      	blx	r3
			pcb->ooseq = NULL;
    5b80:	2300      	movs	r3, #0
    5b82:	6763      	str	r3, [r4, #116]	; 0x74
			return;
    5b84:	bd10      	pop	{r4, pc}
    5b86:	bd10      	pop	{r4, pc}
    5b88:	200092f8 	.word	0x200092f8
    5b8c:	20009300 	.word	0x20009300
    5b90:	000061cd 	.word	0x000061cd

00005b94 <pbuf_alloced_custom>:
 * @param payload_mem_len the size of the 'payload_mem' buffer, must be at least
 *        big enough to hold 'length' plus the header size
 */
struct pbuf *pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p, void *payload_mem,
                                 u16_t payload_mem_len)
{
    5b94:	b470      	push	{r4, r5, r6}
    5b96:	9c03      	ldr	r4, [sp, #12]
	u16_t offset;
	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%" U16_F ")\n", length));

	/* determine header offset */
	switch (l) {
    5b98:	2803      	cmp	r0, #3
    5b9a:	d826      	bhi.n	5bea <pbuf_alloced_custom+0x56>
    5b9c:	e8df f000 	tbb	[pc, r0]
    5ba0:	06040208 	.word	0x06040208
		/* add room for transport (often TCP) layer header */
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
		break;
	case PBUF_IP:
		/* add room for IP layer header */
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    5ba4:	2022      	movs	r0, #34	; 0x22
    5ba6:	e004      	b.n	5bb2 <pbuf_alloced_custom+0x1e>
		break;
	case PBUF_LINK:
		/* add room for link layer header */
		offset = PBUF_LINK_HLEN;
    5ba8:	200e      	movs	r0, #14
		break;
    5baa:	e002      	b.n	5bb2 <pbuf_alloced_custom+0x1e>
	case PBUF_RAW:
		offset = 0;
    5bac:	2000      	movs	r0, #0
		break;
    5bae:	e000      	b.n	5bb2 <pbuf_alloced_custom+0x1e>
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    5bb0:	2036      	movs	r0, #54	; 0x36
	default:
		LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
		return NULL;
	}

	if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
    5bb2:	3003      	adds	r0, #3
    5bb4:	f020 0503 	bic.w	r5, r0, #3
    5bb8:	440d      	add	r5, r1
    5bba:	f8bd 6010 	ldrh.w	r6, [sp, #16]
    5bbe:	42b5      	cmp	r5, r6
    5bc0:	dc15      	bgt.n	5bee <pbuf_alloced_custom+0x5a>
		LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING,
		            ("pbuf_alloced_custom(length=%" U16_F ") buffer too short\n", length));
		return NULL;
	}

	p->pbuf.next = NULL;
    5bc2:	2500      	movs	r5, #0
    5bc4:	601d      	str	r5, [r3, #0]
	if (payload_mem != NULL) {
    5bc6:	b16c      	cbz	r4, 5be4 <pbuf_alloced_custom+0x50>
		p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
    5bc8:	f020 0003 	bic.w	r0, r0, #3
    5bcc:	4420      	add	r0, r4
    5bce:	6058      	str	r0, [r3, #4]
	} else {
		p->pbuf.payload = NULL;
	}
	p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
    5bd0:	2002      	movs	r0, #2
    5bd2:	7358      	strb	r0, [r3, #13]
	p->pbuf.len = p->pbuf.tot_len = length;
    5bd4:	8119      	strh	r1, [r3, #8]
    5bd6:	8159      	strh	r1, [r3, #10]
	p->pbuf.type                  = type;
    5bd8:	731a      	strb	r2, [r3, #12]
	p->pbuf.ref                   = 1;
    5bda:	2201      	movs	r2, #1
    5bdc:	81da      	strh	r2, [r3, #14]
	return &p->pbuf;
    5bde:	4618      	mov	r0, r3
}
    5be0:	bc70      	pop	{r4, r5, r6}
    5be2:	4770      	bx	lr
		p->pbuf.payload = NULL;
    5be4:	2000      	movs	r0, #0
    5be6:	6058      	str	r0, [r3, #4]
    5be8:	e7f2      	b.n	5bd0 <pbuf_alloced_custom+0x3c>
		return NULL;
    5bea:	2000      	movs	r0, #0
    5bec:	e7f8      	b.n	5be0 <pbuf_alloced_custom+0x4c>
		return NULL;
    5bee:	2000      	movs	r0, #0
    5bf0:	e7f6      	b.n	5be0 <pbuf_alloced_custom+0x4c>
	...

00005bf4 <pbuf_header>:
	u16_t type;
	void *payload;
	u16_t increment_magnitude;

	LWIP_ASSERT("p != NULL", p != NULL);
	if ((header_size_increment == 0) || (p == NULL)) {
    5bf4:	2900      	cmp	r1, #0
    5bf6:	d035      	beq.n	5c64 <pbuf_header+0x70>
    5bf8:	460b      	mov	r3, r1
    5bfa:	2800      	cmp	r0, #0
    5bfc:	d034      	beq.n	5c68 <pbuf_header+0x74>
{
    5bfe:	b510      	push	{r4, lr}
		return 0;
	}

	if (header_size_increment < 0) {
    5c00:	2900      	cmp	r1, #0
    5c02:	db0b      	blt.n	5c1c <pbuf_header+0x28>
		increment_magnitude = -header_size_increment;
		/* Check that we aren't going to move off the end of the pbuf */
		LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
	} else {
		increment_magnitude = header_size_increment;
    5c04:	b28c      	uxth	r4, r1
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
	}

	type = p->type;
    5c06:	7b01      	ldrb	r1, [r0, #12]
	/* remember current payload pointer */
	payload = p->payload;
    5c08:	6842      	ldr	r2, [r0, #4]

	/* pbuf types containing payloads? */
	if (type == PBUF_RAM || type == PBUF_POOL) {
    5c0a:	b1a1      	cbz	r1, 5c36 <pbuf_header+0x42>
    5c0c:	2903      	cmp	r1, #3
    5c0e:	d012      	beq.n	5c36 <pbuf_header+0x42>
			p->payload = payload;
			/* bail out unsuccesfully */
			return 1;
		}
		/* pbuf types refering to external payloads? */
	} else if (type == PBUF_REF || type == PBUF_ROM) {
    5c10:	3901      	subs	r1, #1
    5c12:	b289      	uxth	r1, r1
    5c14:	2901      	cmp	r1, #1
    5c16:	d91d      	bls.n	5c54 <pbuf_header+0x60>
			return 1;
		}
	} else {
		/* Unknown type */
		LWIP_ASSERT("bad pbuf type", 0);
		return 1;
    5c18:	2001      	movs	r0, #1
    5c1a:	bd10      	pop	{r4, pc}
		increment_magnitude = -header_size_increment;
    5c1c:	424c      	negs	r4, r1
    5c1e:	b2a4      	uxth	r4, r4
		LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    5c20:	8942      	ldrh	r2, [r0, #10]
    5c22:	42a2      	cmp	r2, r4
    5c24:	d2ef      	bcs.n	5c06 <pbuf_header+0x12>
    5c26:	4b14      	ldr	r3, [pc, #80]	; (5c78 <pbuf_header+0x84>)
    5c28:	f240 2202 	movw	r2, #514	; 0x202
    5c2c:	4913      	ldr	r1, [pc, #76]	; (5c7c <pbuf_header+0x88>)
    5c2e:	4814      	ldr	r0, [pc, #80]	; (5c80 <pbuf_header+0x8c>)
    5c30:	4c14      	ldr	r4, [pc, #80]	; (5c84 <pbuf_header+0x90>)
    5c32:	47a0      	blx	r4
    5c34:	e7fe      	b.n	5c34 <pbuf_header+0x40>
		p->payload = (u8_t *)p->payload - header_size_increment;
    5c36:	1ad2      	subs	r2, r2, r3
		if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
    5c38:	f100 0110 	add.w	r1, r0, #16
    5c3c:	428a      	cmp	r2, r1
    5c3e:	d315      	bcc.n	5c6c <pbuf_header+0x78>
		p->payload = (u8_t *)p->payload - header_size_increment;
    5c40:	6042      	str	r2, [r0, #4]
	}
	/* modify pbuf length fields */
	p->len += header_size_increment;
    5c42:	b29b      	uxth	r3, r3
    5c44:	8942      	ldrh	r2, [r0, #10]
    5c46:	441a      	add	r2, r3
    5c48:	8142      	strh	r2, [r0, #10]
	p->tot_len += header_size_increment;
    5c4a:	8902      	ldrh	r2, [r0, #8]
    5c4c:	4413      	add	r3, r2
    5c4e:	8103      	strh	r3, [r0, #8]

	LWIP_DEBUGF(
	    PBUF_DEBUG | LWIP_DBG_TRACE,
	    ("pbuf_header: old %p new %p (%" S16_F ")\n", (void *)payload, (void *)p->payload, header_size_increment));

	return 0;
    5c50:	2000      	movs	r0, #0
    5c52:	bd10      	pop	{r4, pc}
		if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    5c54:	2b00      	cmp	r3, #0
    5c56:	da0b      	bge.n	5c70 <pbuf_header+0x7c>
    5c58:	8941      	ldrh	r1, [r0, #10]
    5c5a:	42a1      	cmp	r1, r4
    5c5c:	d30a      	bcc.n	5c74 <pbuf_header+0x80>
			p->payload = (u8_t *)p->payload - header_size_increment;
    5c5e:	1ad2      	subs	r2, r2, r3
    5c60:	6042      	str	r2, [r0, #4]
    5c62:	e7ee      	b.n	5c42 <pbuf_header+0x4e>
		return 0;
    5c64:	2000      	movs	r0, #0
    5c66:	4770      	bx	lr
    5c68:	2000      	movs	r0, #0
    5c6a:	4770      	bx	lr
			return 1;
    5c6c:	2001      	movs	r0, #1
    5c6e:	bd10      	pop	{r4, pc}
			return 1;
    5c70:	2001      	movs	r0, #1
    5c72:	bd10      	pop	{r4, pc}
    5c74:	2001      	movs	r0, #1
}
    5c76:	bd10      	pop	{r4, pc}
    5c78:	0000c30c 	.word	0x0000c30c
    5c7c:	0000c330 	.word	0x0000c330
    5c80:	0000b2e8 	.word	0x0000b2e8
    5c84:	00009fd5 	.word	0x00009fd5

00005c88 <pbuf_free>:
 * 2->1->1 becomes 1->1->1
 * 1->1->1 becomes .......
 *
 */
u8_t pbuf_free(struct pbuf *p)
{
    5c88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u16_t        type;
	struct pbuf *q;
	u8_t         count;

	if (p == NULL) {
    5c8c:	b338      	cbz	r0, 5cde <pbuf_free+0x56>
    5c8e:	4601      	mov	r1, r0
    5c90:	2400      	movs	r4, #0
					/* is this a ROM or RAM referencing pbuf? */
				} else if (type == PBUF_ROM || type == PBUF_REF) {
					memp_free(MEMP_PBUF, p);
					/* type == PBUF_RAM */
				} else {
					mem_free(p);
    5c92:	4d15      	ldr	r5, [pc, #84]	; (5ce8 <pbuf_free+0x60>)
					memp_free(MEMP_PBUF, p);
    5c94:	f04f 0808 	mov.w	r8, #8
    5c98:	4e14      	ldr	r6, [pc, #80]	; (5cec <pbuf_free+0x64>)
    5c9a:	e006      	b.n	5caa <pbuf_free+0x22>
				pc->custom_free_function(p);
    5c9c:	690b      	ldr	r3, [r1, #16]
    5c9e:	4608      	mov	r0, r1
    5ca0:	4798      	blx	r3
				}
			}
			count++;
    5ca2:	3401      	adds	r4, #1
    5ca4:	b2e4      	uxtb	r4, r4
			/* proceed to next pbuf */
			p = q;
    5ca6:	4639      	mov	r1, r7
	while (p != NULL) {
    5ca8:	b1d7      	cbz	r7, 5ce0 <pbuf_free+0x58>
		ref = --(p->ref);
    5caa:	89cb      	ldrh	r3, [r1, #14]
    5cac:	3b01      	subs	r3, #1
    5cae:	b29b      	uxth	r3, r3
    5cb0:	81cb      	strh	r3, [r1, #14]
		if (ref == 0) {
    5cb2:	b9ab      	cbnz	r3, 5ce0 <pbuf_free+0x58>
			q = p->next;
    5cb4:	680f      	ldr	r7, [r1, #0]
			if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
    5cb6:	7b4b      	ldrb	r3, [r1, #13]
    5cb8:	f013 0f02 	tst.w	r3, #2
    5cbc:	d1ee      	bne.n	5c9c <pbuf_free+0x14>
			type = p->type;
    5cbe:	7b0b      	ldrb	r3, [r1, #12]
				if (type == PBUF_POOL) {
    5cc0:	2b03      	cmp	r3, #3
    5cc2:	d006      	beq.n	5cd2 <pbuf_free+0x4a>
				} else if (type == PBUF_ROM || type == PBUF_REF) {
    5cc4:	3b01      	subs	r3, #1
    5cc6:	b29b      	uxth	r3, r3
    5cc8:	2b01      	cmp	r3, #1
    5cca:	d905      	bls.n	5cd8 <pbuf_free+0x50>
					mem_free(p);
    5ccc:	4608      	mov	r0, r1
    5cce:	47a8      	blx	r5
    5cd0:	e7e7      	b.n	5ca2 <pbuf_free+0x1a>
					memp_free(MEMP_PBUF_POOL, p);
    5cd2:	2009      	movs	r0, #9
    5cd4:	47b0      	blx	r6
    5cd6:	e7e4      	b.n	5ca2 <pbuf_free+0x1a>
					memp_free(MEMP_PBUF, p);
    5cd8:	4640      	mov	r0, r8
    5cda:	47b0      	blx	r6
    5cdc:	e7e1      	b.n	5ca2 <pbuf_free+0x1a>
		return 0;
    5cde:	2400      	movs	r4, #0
		}
	}
	PERF_STOP("pbuf_free");
	/* return number of de-allocated pbufs */
	return count;
}
    5ce0:	4620      	mov	r0, r4
    5ce2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5ce6:	bf00      	nop
    5ce8:	000056d9 	.word	0x000056d9
    5cec:	000059c1 	.word	0x000059c1

00005cf0 <pbuf_alloc>:
{
    5cf0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	switch (layer) {
    5cf4:	2803      	cmp	r0, #3
    5cf6:	f200 808d 	bhi.w	5e14 <pbuf_alloc+0x124>
    5cfa:	e8df f000 	tbb	[pc, r0]
    5cfe:	0208      	.short	0x0208
    5d00:	0604      	.short	0x0604
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    5d02:	2422      	movs	r4, #34	; 0x22
    5d04:	e004      	b.n	5d10 <pbuf_alloc+0x20>
		offset = PBUF_LINK_HLEN;
    5d06:	240e      	movs	r4, #14
		break;
    5d08:	e002      	b.n	5d10 <pbuf_alloc+0x20>
		offset = 0;
    5d0a:	2400      	movs	r4, #0
		break;
    5d0c:	e000      	b.n	5d10 <pbuf_alloc+0x20>
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    5d0e:	2436      	movs	r4, #54	; 0x36
    5d10:	4617      	mov	r7, r2
    5d12:	460d      	mov	r5, r1
	switch (type) {
    5d14:	2a03      	cmp	r2, #3
    5d16:	d87f      	bhi.n	5e18 <pbuf_alloc+0x128>
    5d18:	e8df f002 	tbb	[pc, r2]
    5d1c:	026f6f51 	.word	0x026f6f51
		p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    5d20:	2009      	movs	r0, #9
    5d22:	4b3e      	ldr	r3, [pc, #248]	; (5e1c <pbuf_alloc+0x12c>)
    5d24:	4798      	blx	r3
		if (p == NULL) {
    5d26:	4606      	mov	r6, r0
    5d28:	2800      	cmp	r0, #0
    5d2a:	d03c      	beq.n	5da6 <pbuf_alloc+0xb6>
		p->type = type;
    5d2c:	2303      	movs	r3, #3
    5d2e:	7303      	strb	r3, [r0, #12]
		p->next = NULL;
    5d30:	2300      	movs	r3, #0
    5d32:	6003      	str	r3, [r0, #0]
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    5d34:	1903      	adds	r3, r0, r4
    5d36:	3313      	adds	r3, #19
    5d38:	f023 0303 	bic.w	r3, r3, #3
    5d3c:	6043      	str	r3, [r0, #4]
		p->tot_len = length;
    5d3e:	8105      	strh	r5, [r0, #8]
		p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    5d40:	3403      	adds	r4, #3
    5d42:	f024 0403 	bic.w	r4, r4, #3
    5d46:	f5c4 64bd 	rsb	r4, r4, #1512	; 0x5e8
    5d4a:	3404      	adds	r4, #4
    5d4c:	42ac      	cmp	r4, r5
    5d4e:	bfa8      	it	ge
    5d50:	462c      	movge	r4, r5
    5d52:	8144      	strh	r4, [r0, #10]
		p->ref = 1;
    5d54:	2301      	movs	r3, #1
    5d56:	81c3      	strh	r3, [r0, #14]
		rem_len = length - p->len;
    5d58:	b2a4      	uxth	r4, r4
    5d5a:	1b2d      	subs	r5, r5, r4
		while (rem_len > 0) {
    5d5c:	2d00      	cmp	r5, #0
    5d5e:	dd45      	ble.n	5dec <pbuf_alloc+0xfc>
    5d60:	4682      	mov	sl, r0
			q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    5d62:	f04f 0809 	mov.w	r8, #9
    5d66:	4f2d      	ldr	r7, [pc, #180]	; (5e1c <pbuf_alloc+0x12c>)
			q->type  = type;
    5d68:	f04f 0903 	mov.w	r9, #3
			q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    5d6c:	4640      	mov	r0, r8
    5d6e:	47b8      	blx	r7
			if (q == NULL) {
    5d70:	4604      	mov	r4, r0
    5d72:	b1e0      	cbz	r0, 5dae <pbuf_alloc+0xbe>
			q->type  = type;
    5d74:	f880 900c 	strb.w	r9, [r0, #12]
			q->flags = 0;
    5d78:	2300      	movs	r3, #0
    5d7a:	7343      	strb	r3, [r0, #13]
			q->next  = NULL;
    5d7c:	6003      	str	r3, [r0, #0]
			r->next = q;
    5d7e:	f8ca 0000 	str.w	r0, [sl]
			q->tot_len = (u16_t)rem_len;
    5d82:	b2ab      	uxth	r3, r5
    5d84:	8103      	strh	r3, [r0, #8]
			q->len     = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    5d86:	f240 52ec 	movw	r2, #1516	; 0x5ec
    5d8a:	4293      	cmp	r3, r2
    5d8c:	bf28      	it	cs
    5d8e:	4613      	movcs	r3, r2
    5d90:	8143      	strh	r3, [r0, #10]
			q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    5d92:	f100 0210 	add.w	r2, r0, #16
    5d96:	6042      	str	r2, [r0, #4]
			q->ref = 1;
    5d98:	2201      	movs	r2, #1
    5d9a:	81c2      	strh	r2, [r0, #14]
			rem_len -= q->len;
    5d9c:	1aed      	subs	r5, r5, r3
			r = q;
    5d9e:	4682      	mov	sl, r0
		while (rem_len > 0) {
    5da0:	2d00      	cmp	r5, #0
    5da2:	dce3      	bgt.n	5d6c <pbuf_alloc+0x7c>
    5da4:	e022      	b.n	5dec <pbuf_alloc+0xfc>
	pbuf_free_ooseq_pending = 1;
    5da6:	2201      	movs	r2, #1
    5da8:	4b1d      	ldr	r3, [pc, #116]	; (5e20 <pbuf_alloc+0x130>)
    5daa:	701a      	strb	r2, [r3, #0]
    5dac:	e022      	b.n	5df4 <pbuf_alloc+0x104>
    5dae:	2201      	movs	r2, #1
    5db0:	4b1b      	ldr	r3, [pc, #108]	; (5e20 <pbuf_alloc+0x130>)
    5db2:	701a      	strb	r2, [r3, #0]
				pbuf_free(p);
    5db4:	4630      	mov	r0, r6
    5db6:	4b1b      	ldr	r3, [pc, #108]	; (5e24 <pbuf_alloc+0x134>)
    5db8:	4798      	blx	r3
				return NULL;
    5dba:	4626      	mov	r6, r4
    5dbc:	e01a      	b.n	5df4 <pbuf_alloc+0x104>
		p = (struct pbuf *)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    5dbe:	f104 0013 	add.w	r0, r4, #19
    5dc2:	f020 0003 	bic.w	r0, r0, #3
    5dc6:	1ccb      	adds	r3, r1, #3
    5dc8:	f023 0303 	bic.w	r3, r3, #3
    5dcc:	4418      	add	r0, r3
    5dce:	b280      	uxth	r0, r0
    5dd0:	4b15      	ldr	r3, [pc, #84]	; (5e28 <pbuf_alloc+0x138>)
    5dd2:	4798      	blx	r3
		if (p == NULL) {
    5dd4:	4606      	mov	r6, r0
    5dd6:	b168      	cbz	r0, 5df4 <pbuf_alloc+0x104>
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
    5dd8:	4404      	add	r4, r0
    5dda:	3413      	adds	r4, #19
    5ddc:	f024 0403 	bic.w	r4, r4, #3
    5de0:	6044      	str	r4, [r0, #4]
		p->len = p->tot_len = length;
    5de2:	8105      	strh	r5, [r0, #8]
    5de4:	8145      	strh	r5, [r0, #10]
		p->next             = NULL;
    5de6:	2300      	movs	r3, #0
    5de8:	6003      	str	r3, [r0, #0]
		p->type             = type;
    5dea:	7303      	strb	r3, [r0, #12]
	p->ref = 1;
    5dec:	2301      	movs	r3, #1
    5dee:	81f3      	strh	r3, [r6, #14]
	p->flags = 0;
    5df0:	2300      	movs	r3, #0
    5df2:	7373      	strb	r3, [r6, #13]
}
    5df4:	4630      	mov	r0, r6
    5df6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		p = (struct pbuf *)memp_malloc(MEMP_PBUF);
    5dfa:	2008      	movs	r0, #8
    5dfc:	4b07      	ldr	r3, [pc, #28]	; (5e1c <pbuf_alloc+0x12c>)
    5dfe:	4798      	blx	r3
		if (p == NULL) {
    5e00:	4606      	mov	r6, r0
    5e02:	2800      	cmp	r0, #0
    5e04:	d0f6      	beq.n	5df4 <pbuf_alloc+0x104>
		p->payload = NULL;
    5e06:	2300      	movs	r3, #0
    5e08:	6043      	str	r3, [r0, #4]
		p->len = p->tot_len = length;
    5e0a:	8105      	strh	r5, [r0, #8]
    5e0c:	8145      	strh	r5, [r0, #10]
		p->next             = NULL;
    5e0e:	6003      	str	r3, [r0, #0]
		p->type             = type;
    5e10:	7307      	strb	r7, [r0, #12]
		break;
    5e12:	e7eb      	b.n	5dec <pbuf_alloc+0xfc>
		return NULL;
    5e14:	2600      	movs	r6, #0
    5e16:	e7ed      	b.n	5df4 <pbuf_alloc+0x104>
		return NULL;
    5e18:	2600      	movs	r6, #0
    5e1a:	e7eb      	b.n	5df4 <pbuf_alloc+0x104>
    5e1c:	00005979 	.word	0x00005979
    5e20:	200092f8 	.word	0x200092f8
    5e24:	00005c89 	.word	0x00005c89
    5e28:	0000582d 	.word	0x0000582d

00005e2c <pbuf_realloc>:
	if (new_len >= p->tot_len) {
    5e2c:	8902      	ldrh	r2, [r0, #8]
    5e2e:	428a      	cmp	r2, r1
    5e30:	d926      	bls.n	5e80 <pbuf_realloc+0x54>
{
    5e32:	b538      	push	{r3, r4, r5, lr}
    5e34:	4604      	mov	r4, r0
	while (rem_len > q->len) {
    5e36:	8943      	ldrh	r3, [r0, #10]
    5e38:	4299      	cmp	r1, r3
    5e3a:	d91f      	bls.n	5e7c <pbuf_realloc+0x50>
    5e3c:	460d      	mov	r5, r1
		q->tot_len += (u16_t)grow;
    5e3e:	1a89      	subs	r1, r1, r2
		rem_len -= q->len;
    5e40:	1aeb      	subs	r3, r5, r3
    5e42:	b29d      	uxth	r5, r3
		q->tot_len += (u16_t)grow;
    5e44:	8923      	ldrh	r3, [r4, #8]
    5e46:	440b      	add	r3, r1
    5e48:	8123      	strh	r3, [r4, #8]
		q = q->next;
    5e4a:	6824      	ldr	r4, [r4, #0]
	while (rem_len > q->len) {
    5e4c:	8963      	ldrh	r3, [r4, #10]
    5e4e:	42ab      	cmp	r3, r5
    5e50:	d3f6      	bcc.n	5e40 <pbuf_realloc+0x14>
	if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    5e52:	7b22      	ldrb	r2, [r4, #12]
    5e54:	b94a      	cbnz	r2, 5e6a <pbuf_realloc+0x3e>
    5e56:	429d      	cmp	r5, r3
    5e58:	d007      	beq.n	5e6a <pbuf_realloc+0x3e>
		q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    5e5a:	6863      	ldr	r3, [r4, #4]
    5e5c:	1b1b      	subs	r3, r3, r4
    5e5e:	18e9      	adds	r1, r5, r3
    5e60:	b289      	uxth	r1, r1
    5e62:	4620      	mov	r0, r4
    5e64:	4b07      	ldr	r3, [pc, #28]	; (5e84 <pbuf_realloc+0x58>)
    5e66:	4798      	blx	r3
    5e68:	4604      	mov	r4, r0
	q->len     = rem_len;
    5e6a:	8165      	strh	r5, [r4, #10]
	q->tot_len = q->len;
    5e6c:	8125      	strh	r5, [r4, #8]
	if (q->next != NULL) {
    5e6e:	6820      	ldr	r0, [r4, #0]
    5e70:	b108      	cbz	r0, 5e76 <pbuf_realloc+0x4a>
		pbuf_free(q->next);
    5e72:	4b05      	ldr	r3, [pc, #20]	; (5e88 <pbuf_realloc+0x5c>)
    5e74:	4798      	blx	r3
	q->next = NULL;
    5e76:	2300      	movs	r3, #0
    5e78:	6023      	str	r3, [r4, #0]
    5e7a:	bd38      	pop	{r3, r4, r5, pc}
	while (rem_len > q->len) {
    5e7c:	460d      	mov	r5, r1
    5e7e:	e7e8      	b.n	5e52 <pbuf_realloc+0x26>
    5e80:	4770      	bx	lr
    5e82:	bf00      	nop
    5e84:	00005765 	.word	0x00005765
    5e88:	00005c89 	.word	0x00005c89

00005e8c <pbuf_clen>:
u8_t pbuf_clen(struct pbuf *p)
{
	u8_t len;

	len = 0;
	while (p != NULL) {
    5e8c:	4603      	mov	r3, r0
    5e8e:	b130      	cbz	r0, 5e9e <pbuf_clen+0x12>
    5e90:	2000      	movs	r0, #0
		++len;
    5e92:	3001      	adds	r0, #1
    5e94:	b2c0      	uxtb	r0, r0
		p = p->next;
    5e96:	681b      	ldr	r3, [r3, #0]
	while (p != NULL) {
    5e98:	2b00      	cmp	r3, #0
    5e9a:	d1fa      	bne.n	5e92 <pbuf_clen+0x6>
    5e9c:	4770      	bx	lr
	len = 0;
    5e9e:	2000      	movs	r0, #0
	}
	return len;
}
    5ea0:	4770      	bx	lr

00005ea2 <pbuf_ref>:
 */
void pbuf_ref(struct pbuf *p)
{
	SYS_ARCH_DECL_PROTECT(old_level);
	/* pbuf given? */
	if (p != NULL) {
    5ea2:	b110      	cbz	r0, 5eaa <pbuf_ref+0x8>
		SYS_ARCH_PROTECT(old_level);
		++(p->ref);
    5ea4:	89c3      	ldrh	r3, [r0, #14]
    5ea6:	3301      	adds	r3, #1
    5ea8:	81c3      	strh	r3, [r0, #14]
    5eaa:	4770      	bx	lr

00005eac <pbuf_cat>:
 *
 * @see pbuf_chain()
 */

void pbuf_cat(struct pbuf *h, struct pbuf *t)
{
    5eac:	b510      	push	{r4, lr}
	struct pbuf *p;

	LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)", ((h != NULL) && (t != NULL)), return;);
    5eae:	b128      	cbz	r0, 5ebc <pbuf_cat+0x10>
    5eb0:	4602      	mov	r2, r0
    5eb2:	b119      	cbz	r1, 5ebc <pbuf_cat+0x10>

	/* proceed to last pbuf of chain */
	for (p = h; p->next != NULL; p = p->next) {
    5eb4:	6803      	ldr	r3, [r0, #0]
    5eb6:	b953      	cbnz	r3, 5ece <pbuf_cat+0x22>
    5eb8:	4603      	mov	r3, r0
    5eba:	e010      	b.n	5ede <pbuf_cat+0x32>
	LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)", ((h != NULL) && (t != NULL)), return;);
    5ebc:	4b0b      	ldr	r3, [pc, #44]	; (5eec <pbuf_cat+0x40>)
    5ebe:	f240 22df 	movw	r2, #735	; 0x2df
    5ec2:	490b      	ldr	r1, [pc, #44]	; (5ef0 <pbuf_cat+0x44>)
    5ec4:	480b      	ldr	r0, [pc, #44]	; (5ef4 <pbuf_cat+0x48>)
    5ec6:	4c0c      	ldr	r4, [pc, #48]	; (5ef8 <pbuf_cat+0x4c>)
    5ec8:	47a0      	blx	r4
    5eca:	e7fe      	b.n	5eca <pbuf_cat+0x1e>
	for (p = h; p->next != NULL; p = p->next) {
    5ecc:	4603      	mov	r3, r0
		/* add total length of second chain to all totals of first chain */
		p->tot_len += t->tot_len;
    5ece:	8910      	ldrh	r0, [r2, #8]
    5ed0:	890c      	ldrh	r4, [r1, #8]
    5ed2:	4420      	add	r0, r4
    5ed4:	8110      	strh	r0, [r2, #8]
	for (p = h; p->next != NULL; p = p->next) {
    5ed6:	6818      	ldr	r0, [r3, #0]
    5ed8:	461a      	mov	r2, r3
    5eda:	2800      	cmp	r0, #0
    5edc:	d1f6      	bne.n	5ecc <pbuf_cat+0x20>
	}
	/* { p is last pbuf of first h chain, p->next == NULL } */
	LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
	LWIP_ASSERT("p->next == NULL", p->next == NULL);
	/* add total length of second chain to last pbuf total of first chain */
	p->tot_len += t->tot_len;
    5ede:	891a      	ldrh	r2, [r3, #8]
    5ee0:	8908      	ldrh	r0, [r1, #8]
    5ee2:	4402      	add	r2, r0
    5ee4:	811a      	strh	r2, [r3, #8]
	/* chain last pbuf of head (p) with first of tail (t) */
	p->next = t;
    5ee6:	6019      	str	r1, [r3, #0]
    5ee8:	bd10      	pop	{r4, pc}
    5eea:	bf00      	nop
    5eec:	0000c30c 	.word	0x0000c30c
    5ef0:	0000c350 	.word	0x0000c350
    5ef4:	0000b2e8 	.word	0x0000b2e8
    5ef8:	00009fd5 	.word	0x00009fd5

00005efc <pbuf_chain>:
 * The ->next field of the last pbuf of the head chain is adjusted.
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void pbuf_chain(struct pbuf *h, struct pbuf *t)
{
    5efc:	b510      	push	{r4, lr}
    5efe:	460c      	mov	r4, r1
	pbuf_cat(h, t);
    5f00:	4b02      	ldr	r3, [pc, #8]	; (5f0c <pbuf_chain+0x10>)
    5f02:	4798      	blx	r3
	/* t is now referenced by h */
	pbuf_ref(t);
    5f04:	4620      	mov	r0, r4
    5f06:	4b02      	ldr	r3, [pc, #8]	; (5f10 <pbuf_chain+0x14>)
    5f08:	4798      	blx	r3
    5f0a:	bd10      	pop	{r4, pc}
    5f0c:	00005ead 	.word	0x00005ead
    5f10:	00005ea3 	.word	0x00005ea3

00005f14 <pbuf_copy>:
 * @return ERR_OK if pbuf was copied
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
    5f14:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	u16_t offset_to = 0, offset_from = 0, len;

	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n", (void *)p_to, (void *)p_from));

	/* is the target big enough to hold the source? */
	LWIP_ERROR("pbuf_copy: target not big enough to hold source",
    5f18:	b130      	cbz	r0, 5f28 <pbuf_copy+0x14>
    5f1a:	460d      	mov	r5, r1
    5f1c:	4604      	mov	r4, r0
    5f1e:	b119      	cbz	r1, 5f28 <pbuf_copy+0x14>
    5f20:	8902      	ldrh	r2, [r0, #8]
    5f22:	890b      	ldrh	r3, [r1, #8]
    5f24:	429a      	cmp	r2, r3
    5f26:	d207      	bcs.n	5f38 <pbuf_copy+0x24>
    5f28:	4b33      	ldr	r3, [pc, #204]	; (5ff8 <pbuf_copy+0xe4>)
    5f2a:	f240 324b 	movw	r2, #843	; 0x34b
    5f2e:	4933      	ldr	r1, [pc, #204]	; (5ffc <pbuf_copy+0xe8>)
    5f30:	4833      	ldr	r0, [pc, #204]	; (6000 <pbuf_copy+0xec>)
    5f32:	4c34      	ldr	r4, [pc, #208]	; (6004 <pbuf_copy+0xf0>)
    5f34:	47a0      	blx	r4
    5f36:	e7fe      	b.n	5f36 <pbuf_copy+0x22>
    5f38:	f04f 0a00 	mov.w	sl, #0
    5f3c:	4657      	mov	r7, sl
			len = p_from->len - offset_from;
		} else {
			/* current p_from does not fit into current p_to */
			len = p_to->len - offset_to;
		}
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    5f3e:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 6010 <pbuf_copy+0xfc>
		offset_from += len;
		LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
		LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
		if (offset_from >= p_from->len) {
			/* on to next p_from (if any) */
			offset_from = 0;
    5f42:	46d0      	mov	r8, sl
    5f44:	e02d      	b.n	5fa2 <pbuf_copy+0x8e>
			p_from      = p_from->next;
		}
		if (offset_to == p_to->len) {
			/* on to next p_to (if any) */
			offset_to = 0;
			p_to      = p_to->next;
    5f46:	6824      	ldr	r4, [r4, #0]
			LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
    5f48:	b10c      	cbz	r4, 5f4e <pbuf_copy+0x3a>
			offset_to = 0;
    5f4a:	4647      	mov	r7, r8
    5f4c:	e047      	b.n	5fde <pbuf_copy+0xca>
			LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
    5f4e:	b915      	cbnz	r5, 5f56 <pbuf_copy+0x42>
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_to->next == NULL), return ERR_VAL;);
		}
	} while (p_from);
	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
	return ERR_OK;
}
    5f50:	2000      	movs	r0, #0
    5f52:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
    5f56:	4b28      	ldr	r3, [pc, #160]	; (5ff8 <pbuf_copy+0xe4>)
    5f58:	f240 3265 	movw	r2, #869	; 0x365
    5f5c:	492a      	ldr	r1, [pc, #168]	; (6008 <pbuf_copy+0xf4>)
    5f5e:	4828      	ldr	r0, [pc, #160]	; (6000 <pbuf_copy+0xec>)
    5f60:	4c28      	ldr	r4, [pc, #160]	; (6004 <pbuf_copy+0xf0>)
    5f62:	47a0      	blx	r4
    5f64:	e7fe      	b.n	5f64 <pbuf_copy+0x50>
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_from->next == NULL), return ERR_VAL;);
    5f66:	682b      	ldr	r3, [r5, #0]
    5f68:	2b00      	cmp	r3, #0
    5f6a:	d03e      	beq.n	5fea <pbuf_copy+0xd6>
    5f6c:	4b22      	ldr	r3, [pc, #136]	; (5ff8 <pbuf_copy+0xe4>)
    5f6e:	f240 326a 	movw	r2, #874	; 0x36a
    5f72:	4926      	ldr	r1, [pc, #152]	; (600c <pbuf_copy+0xf8>)
    5f74:	4822      	ldr	r0, [pc, #136]	; (6000 <pbuf_copy+0xec>)
    5f76:	4c23      	ldr	r4, [pc, #140]	; (6004 <pbuf_copy+0xf0>)
    5f78:	47a0      	blx	r4
    5f7a:	e7fe      	b.n	5f7a <pbuf_copy+0x66>
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_to->next == NULL), return ERR_VAL;);
    5f7c:	4b1e      	ldr	r3, [pc, #120]	; (5ff8 <pbuf_copy+0xe4>)
    5f7e:	f240 326e 	movw	r2, #878	; 0x36e
    5f82:	4922      	ldr	r1, [pc, #136]	; (600c <pbuf_copy+0xf8>)
    5f84:	481e      	ldr	r0, [pc, #120]	; (6000 <pbuf_copy+0xec>)
    5f86:	4c1f      	ldr	r4, [pc, #124]	; (6004 <pbuf_copy+0xf0>)
    5f88:	47a0      	blx	r4
    5f8a:	e7fe      	b.n	5f8a <pbuf_copy+0x76>
		if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    5f8c:	2c00      	cmp	r4, #0
    5f8e:	d0df      	beq.n	5f50 <pbuf_copy+0x3c>
    5f90:	8962      	ldrh	r2, [r4, #10]
    5f92:	8923      	ldrh	r3, [r4, #8]
    5f94:	429a      	cmp	r2, r3
    5f96:	d1db      	bne.n	5f50 <pbuf_copy+0x3c>
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_to->next == NULL), return ERR_VAL;);
    5f98:	6823      	ldr	r3, [r4, #0]
    5f9a:	2b00      	cmp	r3, #0
    5f9c:	d1ee      	bne.n	5f7c <pbuf_copy+0x68>
	} while (p_from);
    5f9e:	2d00      	cmp	r5, #0
    5fa0:	d0d6      	beq.n	5f50 <pbuf_copy+0x3c>
		if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    5fa2:	8963      	ldrh	r3, [r4, #10]
    5fa4:	896a      	ldrh	r2, [r5, #10]
    5fa6:	1bd8      	subs	r0, r3, r7
    5fa8:	eba2 010a 	sub.w	r1, r2, sl
    5fac:	4288      	cmp	r0, r1
			len = p_from->len - offset_from;
    5fae:	bfa7      	ittee	ge
    5fb0:	460a      	movge	r2, r1
    5fb2:	b296      	uxthge	r6, r2
			len = p_to->len - offset_to;
    5fb4:	1bdb      	sublt	r3, r3, r7
    5fb6:	b29e      	uxthlt	r6, r3
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    5fb8:	6860      	ldr	r0, [r4, #4]
    5fba:	6869      	ldr	r1, [r5, #4]
    5fbc:	4632      	mov	r2, r6
    5fbe:	4451      	add	r1, sl
    5fc0:	4438      	add	r0, r7
    5fc2:	47c8      	blx	r9
		offset_to += len;
    5fc4:	4437      	add	r7, r6
    5fc6:	b2bf      	uxth	r7, r7
		offset_from += len;
    5fc8:	4456      	add	r6, sl
    5fca:	fa1f fa86 	uxth.w	sl, r6
		if (offset_from >= p_from->len) {
    5fce:	896b      	ldrh	r3, [r5, #10]
    5fd0:	4553      	cmp	r3, sl
			p_from      = p_from->next;
    5fd2:	bf9c      	itt	ls
    5fd4:	682d      	ldrls	r5, [r5, #0]
			offset_from = 0;
    5fd6:	46c2      	movls	sl, r8
		if (offset_to == p_to->len) {
    5fd8:	8963      	ldrh	r3, [r4, #10]
    5fda:	42bb      	cmp	r3, r7
    5fdc:	d0b3      	beq.n	5f46 <pbuf_copy+0x32>
		if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
    5fde:	2d00      	cmp	r5, #0
    5fe0:	d0d4      	beq.n	5f8c <pbuf_copy+0x78>
    5fe2:	896a      	ldrh	r2, [r5, #10]
    5fe4:	892b      	ldrh	r3, [r5, #8]
    5fe6:	429a      	cmp	r2, r3
    5fe8:	d0bd      	beq.n	5f66 <pbuf_copy+0x52>
		if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    5fea:	2c00      	cmp	r4, #0
    5fec:	d0d9      	beq.n	5fa2 <pbuf_copy+0x8e>
    5fee:	8962      	ldrh	r2, [r4, #10]
    5ff0:	8923      	ldrh	r3, [r4, #8]
    5ff2:	429a      	cmp	r2, r3
    5ff4:	d1d5      	bne.n	5fa2 <pbuf_copy+0x8e>
    5ff6:	e7cf      	b.n	5f98 <pbuf_copy+0x84>
    5ff8:	0000c30c 	.word	0x0000c30c
    5ffc:	0000c388 	.word	0x0000c388
    6000:	0000b2e8 	.word	0x0000b2e8
    6004:	00009fd5 	.word	0x00009fd5
    6008:	0000c3b8 	.word	0x0000c3b8
    600c:	0000c3c8 	.word	0x0000c3c8
    6010:	00009faf 	.word	0x00009faf

00006014 <pbuf_copy_partial>:
 * than buf->tot_len will be copied, irrespective of len
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
    6014:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct pbuf *p;
	u16_t        left;
	u16_t        buf_copy_len;
	u16_t        copied_total = 0;

	LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    6018:	b158      	cbz	r0, 6032 <pbuf_copy_partial+0x1e>
    601a:	460f      	mov	r7, r1
    601c:	4692      	mov	sl, r2
    601e:	4605      	mov	r5, r0
	LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    6020:	b179      	cbz	r1, 6042 <pbuf_copy_partial+0x2e>
	if ((buf == NULL) || (dataptr == NULL)) {
		return 0;
	}

	/* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
	for (p = buf; len != 0 && p != NULL; p = p->next) {
    6022:	4616      	mov	r6, r2
    6024:	2a00      	cmp	r2, #0
    6026:	d033      	beq.n	6090 <pbuf_copy_partial+0x7c>
    6028:	2600      	movs	r6, #0
			/* copy from this buffer. maybe only partially. */
			buf_copy_len = p->len - offset;
			if (buf_copy_len > len)
				buf_copy_len = len;
			/* copy the necessary parts of the buffer */
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    602a:	f8df 9080 	ldr.w	r9, [pc, #128]	; 60ac <pbuf_copy_partial+0x98>
			copied_total += buf_copy_len;
			left += buf_copy_len;
			len -= buf_copy_len;
			offset = 0;
    602e:	46b0      	mov	r8, r6
    6030:	e026      	b.n	6080 <pbuf_copy_partial+0x6c>
	LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    6032:	4b19      	ldr	r3, [pc, #100]	; (6098 <pbuf_copy_partial+0x84>)
    6034:	f240 3287 	movw	r2, #903	; 0x387
    6038:	4918      	ldr	r1, [pc, #96]	; (609c <pbuf_copy_partial+0x88>)
    603a:	4819      	ldr	r0, [pc, #100]	; (60a0 <pbuf_copy_partial+0x8c>)
    603c:	4c19      	ldr	r4, [pc, #100]	; (60a4 <pbuf_copy_partial+0x90>)
    603e:	47a0      	blx	r4
    6040:	e7fe      	b.n	6040 <pbuf_copy_partial+0x2c>
	LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    6042:	4b15      	ldr	r3, [pc, #84]	; (6098 <pbuf_copy_partial+0x84>)
    6044:	f44f 7262 	mov.w	r2, #904	; 0x388
    6048:	4917      	ldr	r1, [pc, #92]	; (60a8 <pbuf_copy_partial+0x94>)
    604a:	4815      	ldr	r0, [pc, #84]	; (60a0 <pbuf_copy_partial+0x8c>)
    604c:	4c15      	ldr	r4, [pc, #84]	; (60a4 <pbuf_copy_partial+0x90>)
    604e:	47a0      	blx	r4
    6050:	e7fe      	b.n	6050 <pbuf_copy_partial+0x3c>
			buf_copy_len = p->len - offset;
    6052:	896c      	ldrh	r4, [r5, #10]
    6054:	1ae4      	subs	r4, r4, r3
    6056:	b2a4      	uxth	r4, r4
    6058:	4554      	cmp	r4, sl
    605a:	bf28      	it	cs
    605c:	4654      	movcs	r4, sl
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    605e:	6869      	ldr	r1, [r5, #4]
    6060:	4622      	mov	r2, r4
    6062:	4419      	add	r1, r3
    6064:	19b8      	adds	r0, r7, r6
    6066:	47c8      	blx	r9
			copied_total += buf_copy_len;
    6068:	4426      	add	r6, r4
    606a:	b2b6      	uxth	r6, r6
			len -= buf_copy_len;
    606c:	ebaa 0404 	sub.w	r4, sl, r4
    6070:	fa1f fa84 	uxth.w	sl, r4
			offset = 0;
    6074:	4643      	mov	r3, r8
	for (p = buf; len != 0 && p != NULL; p = p->next) {
    6076:	682d      	ldr	r5, [r5, #0]
    6078:	f1ba 0f00 	cmp.w	sl, #0
    607c:	d008      	beq.n	6090 <pbuf_copy_partial+0x7c>
    607e:	b13d      	cbz	r5, 6090 <pbuf_copy_partial+0x7c>
		if ((offset != 0) && (offset >= p->len)) {
    6080:	2b00      	cmp	r3, #0
    6082:	d0e6      	beq.n	6052 <pbuf_copy_partial+0x3e>
    6084:	896a      	ldrh	r2, [r5, #10]
    6086:	429a      	cmp	r2, r3
    6088:	d8e3      	bhi.n	6052 <pbuf_copy_partial+0x3e>
			offset -= p->len;
    608a:	1a9b      	subs	r3, r3, r2
    608c:	b29b      	uxth	r3, r3
    608e:	e7f2      	b.n	6076 <pbuf_copy_partial+0x62>
		}
	}
	return copied_total;
}
    6090:	4630      	mov	r0, r6
    6092:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6096:	bf00      	nop
    6098:	0000c30c 	.word	0x0000c30c
    609c:	0000c3f4 	.word	0x0000c3f4
    60a0:	0000b2e8 	.word	0x0000b2e8
    60a4:	00009fd5 	.word	0x00009fd5
    60a8:	0000c414 	.word	0x0000c414
    60ac:	00009faf 	.word	0x00009faf

000060b0 <raw_input>:
 * @return - 0 if packet is not eaten (pbuf is still referenced by the
 *           caller).
 *
 */
u8_t raw_input(struct pbuf *p, struct netif *inp)
{
    60b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	u8_t            eaten = 0;

	LWIP_UNUSED_ARG(inp);

	iphdr = (struct ip_hdr *)p->payload;
	proto = IPH_PROTO(iphdr);
    60b4:	6843      	ldr	r3, [r0, #4]
    60b6:	7a5e      	ldrb	r6, [r3, #9]

	prev = NULL;
	pcb  = raw_pcbs;
    60b8:	4b18      	ldr	r3, [pc, #96]	; (611c <raw_input+0x6c>)
    60ba:	681c      	ldr	r4, [r3, #0]
	/* loop through all raw pcbs until the packet is eaten by one */
	/* this allows multiple pcbs to match against the packet by design */
	while ((eaten == 0) && (pcb != NULL)) {
    60bc:	b35c      	cbz	r4, 6116 <raw_input+0x66>
    60be:	4682      	mov	sl, r0
    60c0:	2500      	movs	r5, #0
#endif /* IP_SOF_BROADCAST_RECV */
			{
				/* receive callback function available? */
				if (pcb->recv != NULL) {
					/* the receive callback function did not eat the packet? */
					if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
    60c2:	f8df 805c 	ldr.w	r8, [pc, #92]	; 6120 <raw_input+0x70>
		    && (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
    60c6:	f8df 905c 	ldr.w	r9, [pc, #92]	; 6124 <raw_input+0x74>
    60ca:	e003      	b.n	60d4 <raw_input+0x24>
				/* no receive callback function was set for this raw PCB */
			}
			/* drop the packet */
		}
		prev = pcb;
		pcb  = pcb->next;
    60cc:	68e3      	ldr	r3, [r4, #12]
    60ce:	4625      	mov	r5, r4
	while ((eaten == 0) && (pcb != NULL)) {
    60d0:	b1f3      	cbz	r3, 6110 <raw_input+0x60>
		pcb  = pcb->next;
    60d2:	461c      	mov	r4, r3
		if ((pcb->protocol == proto)
    60d4:	7c23      	ldrb	r3, [r4, #16]
    60d6:	42b3      	cmp	r3, r6
    60d8:	d1f8      	bne.n	60cc <raw_input+0x1c>
		    && (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
    60da:	b12c      	cbz	r4, 60e8 <raw_input+0x38>
    60dc:	6823      	ldr	r3, [r4, #0]
    60de:	b11b      	cbz	r3, 60e8 <raw_input+0x38>
    60e0:	f8d9 2000 	ldr.w	r2, [r9]
    60e4:	4293      	cmp	r3, r2
    60e6:	d1f1      	bne.n	60cc <raw_input+0x1c>
				if (pcb->recv != NULL) {
    60e8:	6967      	ldr	r7, [r4, #20]
    60ea:	2f00      	cmp	r7, #0
    60ec:	d0ee      	beq.n	60cc <raw_input+0x1c>
					if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
    60ee:	4643      	mov	r3, r8
    60f0:	4652      	mov	r2, sl
    60f2:	4621      	mov	r1, r4
    60f4:	69a0      	ldr	r0, [r4, #24]
    60f6:	47b8      	blx	r7
    60f8:	2800      	cmp	r0, #0
    60fa:	d0e7      	beq.n	60cc <raw_input+0x1c>
						if (prev != NULL) {
    60fc:	b12d      	cbz	r5, 610a <raw_input+0x5a>
							prev->next = pcb->next;
    60fe:	68e3      	ldr	r3, [r4, #12]
    6100:	60eb      	str	r3, [r5, #12]
							pcb->next  = raw_pcbs;
    6102:	4b06      	ldr	r3, [pc, #24]	; (611c <raw_input+0x6c>)
    6104:	681a      	ldr	r2, [r3, #0]
    6106:	60e2      	str	r2, [r4, #12]
							raw_pcbs   = pcb;
    6108:	601c      	str	r4, [r3, #0]
		pcb  = pcb->next;
    610a:	2001      	movs	r0, #1
	}
	return eaten;
}
    610c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6110:	2000      	movs	r0, #0
    6112:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	u8_t            eaten = 0;
    6116:	2000      	movs	r0, #0
    6118:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    611c:	20007f94 	.word	0x20007f94
    6120:	2000832c 	.word	0x2000832c
    6124:	20008334 	.word	0x20008334

00006128 <tcp_init>:

/**
 * Initialize this module.
 */
void tcp_init(void)
{
    6128:	4770      	bx	lr

0000612a <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
    612a:	b470      	push	{r4, r5, r6}
    612c:	4602      	mov	r2, r0
	u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    612e:	6a85      	ldr	r5, [r0, #40]	; 0x28
    6130:	8d84      	ldrh	r4, [r0, #44]	; 0x2c

	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    6132:	6b01      	ldr	r1, [r0, #48]	; 0x30
	u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    6134:	1963      	adds	r3, r4, r5
    6136:	1a58      	subs	r0, r3, r1
	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    6138:	8ed3      	ldrh	r3, [r2, #54]	; 0x36
    613a:	f640 3668 	movw	r6, #2920	; 0xb68
    613e:	42b3      	cmp	r3, r6
    6140:	bf94      	ite	ls
    6142:	1ac3      	subls	r3, r0, r3
    6144:	1b83      	subhi	r3, r0, r6
    6146:	2b00      	cmp	r3, #0
    6148:	db02      	blt.n	6150 <tcp_update_rcv_ann_wnd+0x26>
		/* we can advertise more window */
		pcb->rcv_ann_wnd = pcb->rcv_wnd;
    614a:	85d4      	strh	r4, [r2, #46]	; 0x2e
			LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
			pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
		}
		return 0;
	}
}
    614c:	bc70      	pop	{r4, r5, r6}
    614e:	4770      	bx	lr
		if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
    6150:	1a6b      	subs	r3, r5, r1
    6152:	2b00      	cmp	r3, #0
    6154:	dd03      	ble.n	615e <tcp_update_rcv_ann_wnd+0x34>
			pcb->rcv_ann_wnd = 0;
    6156:	2300      	movs	r3, #0
    6158:	85d3      	strh	r3, [r2, #46]	; 0x2e
		return 0;
    615a:	4618      	mov	r0, r3
    615c:	e7f6      	b.n	614c <tcp_update_rcv_ann_wnd+0x22>
			u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
    615e:	1b49      	subs	r1, r1, r5
			pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    6160:	85d1      	strh	r1, [r2, #46]	; 0x2e
		return 0;
    6162:	2000      	movs	r0, #0
    6164:	e7f2      	b.n	614c <tcp_update_rcv_ann_wnd+0x22>
	...

00006168 <tcp_recved>:
 *
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
    6168:	b510      	push	{r4, lr}
    616a:	4604      	mov	r4, r0

	/* pcb->state LISTEN not allowed here */
	LWIP_ASSERT("don't call tcp_recved for listen-pcbs", pcb->state != LISTEN);
	LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n", len <= 0xffff - pcb->rcv_wnd);

	pcb->rcv_wnd += len;
    616c:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
    616e:	4419      	add	r1, r3
    6170:	b289      	uxth	r1, r1
	if (pcb->rcv_wnd > TCP_WND) {
    6172:	f241 63d0 	movw	r3, #5840	; 0x16d0
    6176:	4299      	cmp	r1, r3
	pcb->rcv_wnd += len;
    6178:	bf92      	itee	ls
    617a:	8581      	strhls	r1, [r0, #44]	; 0x2c
		pcb->rcv_wnd = TCP_WND;
    617c:	f241 63d0 	movwhi	r3, #5840	; 0x16d0
    6180:	8583      	strhhi	r3, [r0, #44]	; 0x2c
	}

	wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    6182:	4b07      	ldr	r3, [pc, #28]	; (61a0 <tcp_recved+0x38>)
    6184:	4798      	blx	r3

	/* If the change in the right edge of window is significant (default
	 * watermark is TCP_WND/4), then send an explicit update now.
	 * Otherwise wait for a packet to be sent in the normal course of
	 * events (or more window to be available later) */
	if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    6186:	f240 53b3 	movw	r3, #1459	; 0x5b3
    618a:	4298      	cmp	r0, r3
    618c:	dc00      	bgt.n	6190 <tcp_recved+0x28>
    618e:	bd10      	pop	{r4, pc}
		tcp_ack_now(pcb);
    6190:	7fa3      	ldrb	r3, [r4, #30]
    6192:	f043 0302 	orr.w	r3, r3, #2
    6196:	77a3      	strb	r3, [r4, #30]
		tcp_output(pcb);
    6198:	4620      	mov	r0, r4
    619a:	4b02      	ldr	r3, [pc, #8]	; (61a4 <tcp_recved+0x3c>)
    619c:	4798      	blx	r3
	LWIP_DEBUGF(TCP_DEBUG,
	            ("tcp_recved: recveived %" U16_F " bytes, wnd %" U16_F " (%" U16_F ").\n",
	             len,
	             pcb->rcv_wnd,
	             TCP_WND - pcb->rcv_wnd));
}
    619e:	e7f6      	b.n	618e <tcp_recved+0x26>
    61a0:	0000612b 	.word	0x0000612b
    61a4:	00008209 	.word	0x00008209

000061a8 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void tcp_seg_free(struct tcp_seg *seg)
{
	if (seg != NULL) {
    61a8:	b150      	cbz	r0, 61c0 <tcp_seg_free+0x18>
{
    61aa:	b510      	push	{r4, lr}
    61ac:	4604      	mov	r4, r0
		if (seg->p != NULL) {
    61ae:	6840      	ldr	r0, [r0, #4]
    61b0:	b108      	cbz	r0, 61b6 <tcp_seg_free+0xe>
			pbuf_free(seg->p);
    61b2:	4b04      	ldr	r3, [pc, #16]	; (61c4 <tcp_seg_free+0x1c>)
    61b4:	4798      	blx	r3
#if TCP_DEBUG
			seg->p = NULL;
#endif /* TCP_DEBUG */
		}
		memp_free(MEMP_TCP_SEG, seg);
    61b6:	4621      	mov	r1, r4
    61b8:	2004      	movs	r0, #4
    61ba:	4b03      	ldr	r3, [pc, #12]	; (61c8 <tcp_seg_free+0x20>)
    61bc:	4798      	blx	r3
    61be:	bd10      	pop	{r4, pc}
    61c0:	4770      	bx	lr
    61c2:	bf00      	nop
    61c4:	00005c89 	.word	0x00005c89
    61c8:	000059c1 	.word	0x000059c1

000061cc <tcp_segs_free>:
	while (seg != NULL) {
    61cc:	b148      	cbz	r0, 61e2 <tcp_segs_free+0x16>
{
    61ce:	b538      	push	{r3, r4, r5, lr}
    61d0:	4603      	mov	r3, r0
		tcp_seg_free(seg);
    61d2:	4d04      	ldr	r5, [pc, #16]	; (61e4 <tcp_segs_free+0x18>)
		struct tcp_seg *next = seg->next;
    61d4:	681c      	ldr	r4, [r3, #0]
		tcp_seg_free(seg);
    61d6:	4618      	mov	r0, r3
    61d8:	47a8      	blx	r5
		seg = next;
    61da:	4623      	mov	r3, r4
	while (seg != NULL) {
    61dc:	2c00      	cmp	r4, #0
    61de:	d1f9      	bne.n	61d4 <tcp_segs_free+0x8>
    61e0:	bd38      	pop	{r3, r4, r5, pc}
    61e2:	4770      	bx	lr
    61e4:	000061a9 	.word	0x000061a9

000061e8 <tcp_seg_copy>:
 *
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *tcp_seg_copy(struct tcp_seg *seg)
{
    61e8:	b538      	push	{r3, r4, r5, lr}
    61ea:	4605      	mov	r5, r0
	struct tcp_seg *cseg;

	cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    61ec:	2004      	movs	r0, #4
    61ee:	4b09      	ldr	r3, [pc, #36]	; (6214 <tcp_seg_copy+0x2c>)
    61f0:	4798      	blx	r3
	if (cseg == NULL) {
    61f2:	4604      	mov	r4, r0
    61f4:	b160      	cbz	r0, 6210 <tcp_seg_copy+0x28>
		return NULL;
	}
	SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
    61f6:	682b      	ldr	r3, [r5, #0]
    61f8:	6868      	ldr	r0, [r5, #4]
    61fa:	68a9      	ldr	r1, [r5, #8]
    61fc:	68ea      	ldr	r2, [r5, #12]
    61fe:	6023      	str	r3, [r4, #0]
    6200:	6060      	str	r0, [r4, #4]
    6202:	60a1      	str	r1, [r4, #8]
    6204:	60e2      	str	r2, [r4, #12]
    6206:	692b      	ldr	r3, [r5, #16]
    6208:	6123      	str	r3, [r4, #16]
	pbuf_ref(cseg->p);
    620a:	6860      	ldr	r0, [r4, #4]
    620c:	4b02      	ldr	r3, [pc, #8]	; (6218 <tcp_seg_copy+0x30>)
    620e:	4798      	blx	r3
	return cseg;
}
    6210:	4620      	mov	r0, r4
    6212:	bd38      	pop	{r3, r4, r5, pc}
    6214:	00005979 	.word	0x00005979
    6218:	00005ea3 	.word	0x00005ea3

0000621c <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void tcp_pcb_purge(struct tcp_pcb *pcb)
{
	if (pcb->state != CLOSED && pcb->state != TIME_WAIT && pcb->state != LISTEN) {
    621c:	7e03      	ldrb	r3, [r0, #24]
    621e:	2b01      	cmp	r3, #1
    6220:	d91a      	bls.n	6258 <tcp_pcb_purge+0x3c>
    6222:	2b0a      	cmp	r3, #10
    6224:	d018      	beq.n	6258 <tcp_pcb_purge+0x3c>
{
    6226:	b570      	push	{r4, r5, r6, lr}
    6228:	4604      	mov	r4, r0
				}
			}
		}
#endif /* TCP_LISTEN_BACKLOG */

		if (pcb->refused_data != NULL) {
    622a:	6f80      	ldr	r0, [r0, #120]	; 0x78
    622c:	b118      	cbz	r0, 6236 <tcp_pcb_purge+0x1a>
			LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
			pbuf_free(pcb->refused_data);
    622e:	4b0b      	ldr	r3, [pc, #44]	; (625c <tcp_pcb_purge+0x40>)
    6230:	4798      	blx	r3
			pcb->refused_data = NULL;
    6232:	2300      	movs	r3, #0
    6234:	67a3      	str	r3, [r4, #120]	; 0x78
		}
#if TCP_QUEUE_OOSEQ
		if (pcb->ooseq != NULL) {
			LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
		}
		tcp_segs_free(pcb->ooseq);
    6236:	6f60      	ldr	r0, [r4, #116]	; 0x74
    6238:	4e09      	ldr	r6, [pc, #36]	; (6260 <tcp_pcb_purge+0x44>)
    623a:	47b0      	blx	r6
		pcb->ooseq = NULL;
    623c:	2500      	movs	r5, #0
    623e:	6765      	str	r5, [r4, #116]	; 0x74
#endif /* TCP_QUEUE_OOSEQ */

		/* Stop the retransmission timer as it will expect data on unacked
		   queue if it fires */
		pcb->rtime = -1;
    6240:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6244:	86a3      	strh	r3, [r4, #52]	; 0x34

		tcp_segs_free(pcb->unsent);
    6246:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    6248:	47b0      	blx	r6
		tcp_segs_free(pcb->unacked);
    624a:	6f20      	ldr	r0, [r4, #112]	; 0x70
    624c:	47b0      	blx	r6
		pcb->unacked = pcb->unsent = NULL;
    624e:	66e5      	str	r5, [r4, #108]	; 0x6c
    6250:	6725      	str	r5, [r4, #112]	; 0x70
#if TCP_OVERSIZE
		pcb->unsent_oversize = 0;
    6252:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
    6256:	bd70      	pop	{r4, r5, r6, pc}
    6258:	4770      	bx	lr
    625a:	bf00      	nop
    625c:	00005c89 	.word	0x00005c89
    6260:	000061cd 	.word	0x000061cd

00006264 <tcp_slowtmr>:
{
    6264:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6268:	b083      	sub	sp, #12
	++tcp_ticks;
    626a:	4ab6      	ldr	r2, [pc, #728]	; (6544 <tcp_slowtmr+0x2e0>)
    626c:	6813      	ldr	r3, [r2, #0]
    626e:	3301      	adds	r3, #1
    6270:	6013      	str	r3, [r2, #0]
	++tcp_timer_ctr;
    6272:	4ab5      	ldr	r2, [pc, #724]	; (6548 <tcp_slowtmr+0x2e4>)
    6274:	7813      	ldrb	r3, [r2, #0]
    6276:	3301      	adds	r3, #1
    6278:	7013      	strb	r3, [r2, #0]
		if (pcb->last_timer == tcp_timer_ctr) {
    627a:	4615      	mov	r5, r2
				tcp_active_pcbs_changed = 0;
    627c:	4fb3      	ldr	r7, [pc, #716]	; (654c <tcp_slowtmr+0x2e8>)
			if ((u32_t)(tcp_ticks - pcb->tmr) > (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
    627e:	f8df b2f8 	ldr.w	fp, [pc, #760]	; 6578 <tcp_slowtmr+0x314>
	pcb  = tcp_active_pcbs;
    6282:	4bb3      	ldr	r3, [pc, #716]	; (6550 <tcp_slowtmr+0x2ec>)
    6284:	681c      	ldr	r4, [r3, #0]
	while (pcb != NULL) {
    6286:	2c00      	cmp	r4, #0
    6288:	f000 817d 	beq.w	6586 <tcp_slowtmr+0x322>
    628c:	2600      	movs	r6, #0
    628e:	e003      	b.n	6298 <tcp_slowtmr+0x34>
			pcb = pcb->next;
    6290:	68e4      	ldr	r4, [r4, #12]
	while (pcb != NULL) {
    6292:	2c00      	cmp	r4, #0
    6294:	f000 8177 	beq.w	6586 <tcp_slowtmr+0x322>
		if (pcb->last_timer == tcp_timer_ctr) {
    6298:	782b      	ldrb	r3, [r5, #0]
    629a:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    629e:	429a      	cmp	r2, r3
    62a0:	d0f6      	beq.n	6290 <tcp_slowtmr+0x2c>
		pcb->last_timer = tcp_timer_ctr;
    62a2:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
		if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    62a6:	7e22      	ldrb	r2, [r4, #24]
    62a8:	2a02      	cmp	r2, #2
    62aa:	d023      	beq.n	62f4 <tcp_slowtmr+0x90>
		} else if (pcb->nrtx == TCP_MAXRTX) {
    62ac:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
    62b0:	2b0c      	cmp	r3, #12
    62b2:	d061      	beq.n	6378 <tcp_slowtmr+0x114>
			if (pcb->persist_backoff > 0) {
    62b4:	f894 8095 	ldrb.w	r8, [r4, #149]	; 0x95
    62b8:	f1b8 0f00 	cmp.w	r8, #0
    62bc:	d026      	beq.n	630c <tcp_slowtmr+0xa8>
				pcb->persist_cnt++;
    62be:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
    62c2:	3301      	adds	r3, #1
    62c4:	b2db      	uxtb	r3, r3
    62c6:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    62ca:	4aa2      	ldr	r2, [pc, #648]	; (6554 <tcp_slowtmr+0x2f0>)
    62cc:	4442      	add	r2, r8
    62ce:	7bd2      	ldrb	r2, [r2, #15]
    62d0:	429a      	cmp	r2, r3
    62d2:	d874      	bhi.n	63be <tcp_slowtmr+0x15a>
					pcb->persist_cnt = 0;
    62d4:	2300      	movs	r3, #0
    62d6:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
					if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
    62da:	f1b8 0f06 	cmp.w	r8, #6
						pcb->persist_backoff++;
    62de:	bf9c      	itt	ls
    62e0:	f108 0801 	addls.w	r8, r8, #1
    62e4:	f884 8095 	strbls.w	r8, [r4, #149]	; 0x95
					tcp_zero_window_probe(pcb);
    62e8:	4620      	mov	r0, r4
    62ea:	4b9b      	ldr	r3, [pc, #620]	; (6558 <tcp_slowtmr+0x2f4>)
    62ec:	4798      	blx	r3
		pcb_remove = 0;
    62ee:	f04f 0800 	mov.w	r8, #0
    62f2:	e043      	b.n	637c <tcp_slowtmr+0x118>
		if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    62f4:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
    62f8:	2b06      	cmp	r3, #6
    62fa:	f000 8090 	beq.w	641e <tcp_slowtmr+0x1ba>
		} else if (pcb->nrtx == TCP_MAXRTX) {
    62fe:	2b0c      	cmp	r3, #12
    6300:	d1d8      	bne.n	62b4 <tcp_slowtmr+0x50>
		pcb_reset  = 0;
    6302:	f04f 0900 	mov.w	r9, #0
		} else if (pcb->nrtx == TCP_MAXRTX) {
    6306:	f04f 0801 	mov.w	r8, #1
    630a:	e08f      	b.n	642c <tcp_slowtmr+0x1c8>
				if (pcb->rtime >= 0) {
    630c:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
    6310:	2900      	cmp	r1, #0
					++pcb->rtime;
    6312:	bfa4      	itt	ge
    6314:	3101      	addge	r1, #1
    6316:	86a1      	strhge	r1, [r4, #52]	; 0x34
				if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
    6318:	6f21      	ldr	r1, [r4, #112]	; 0x70
    631a:	b379      	cbz	r1, 637c <tcp_slowtmr+0x118>
    631c:	f9b4 0034 	ldrsh.w	r0, [r4, #52]	; 0x34
    6320:	f9b4 1044 	ldrsh.w	r1, [r4, #68]	; 0x44
    6324:	4288      	cmp	r0, r1
    6326:	db29      	blt.n	637c <tcp_slowtmr+0x118>
					if (pcb->state != SYN_SENT) {
    6328:	2a02      	cmp	r2, #2
    632a:	d00c      	beq.n	6346 <tcp_slowtmr+0xe2>
						pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
    632c:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
    6330:	f9b4 2042 	ldrsh.w	r2, [r4, #66]	; 0x42
    6334:	eb02 02e1 	add.w	r2, r2, r1, asr #3
    6338:	4986      	ldr	r1, [pc, #536]	; (6554 <tcp_slowtmr+0x2f0>)
    633a:	440b      	add	r3, r1
    633c:	7e1b      	ldrb	r3, [r3, #24]
    633e:	fa02 f303 	lsl.w	r3, r2, r3
    6342:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
					pcb->rtime = 0;
    6346:	2300      	movs	r3, #0
    6348:	86a3      	strh	r3, [r4, #52]	; 0x34
					eff_wnd       = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    634a:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
    634e:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
					pcb->ssthresh = eff_wnd >> 1;
    6352:	4293      	cmp	r3, r2
    6354:	bf28      	it	cs
    6356:	4613      	movcs	r3, r2
    6358:	085b      	lsrs	r3, r3, #1
    635a:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
					if (pcb->ssthresh < (pcb->mss << 1)) {
    635e:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
    6360:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
						pcb->ssthresh = (pcb->mss << 1);
    6364:	bfbc      	itt	lt
    6366:	0053      	lsllt	r3, r2, #1
    6368:	f8a4 304e 	strhlt.w	r3, [r4, #78]	; 0x4e
					pcb->cwnd = pcb->mss;
    636c:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
					tcp_rexmit_rto(pcb);
    6370:	4620      	mov	r0, r4
    6372:	4b7a      	ldr	r3, [pc, #488]	; (655c <tcp_slowtmr+0x2f8>)
    6374:	4798      	blx	r3
    6376:	e001      	b.n	637c <tcp_slowtmr+0x118>
			++pcb_remove;
    6378:	f04f 0801 	mov.w	r8, #1
		if (pcb->state == FIN_WAIT_2) {
    637c:	7e23      	ldrb	r3, [r4, #24]
    637e:	2b06      	cmp	r3, #6
    6380:	d020      	beq.n	63c4 <tcp_slowtmr+0x160>
		if (ip_get_option(pcb, SOF_KEEPALIVE) && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    6382:	7a22      	ldrb	r2, [r4, #8]
    6384:	f012 0f08 	tst.w	r2, #8
    6388:	d04e      	beq.n	6428 <tcp_slowtmr+0x1c4>
    638a:	2b04      	cmp	r3, #4
    638c:	d001      	beq.n	6392 <tcp_slowtmr+0x12e>
    638e:	2b07      	cmp	r3, #7
    6390:	d17f      	bne.n	6492 <tcp_slowtmr+0x22e>
			if ((u32_t)(tcp_ticks - pcb->tmr) > (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
    6392:	4b6c      	ldr	r3, [pc, #432]	; (6544 <tcp_slowtmr+0x2e0>)
    6394:	681a      	ldr	r2, [r3, #0]
    6396:	6a63      	ldr	r3, [r4, #36]	; 0x24
    6398:	1ad2      	subs	r2, r2, r3
    639a:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
    639e:	f501 2324 	add.w	r3, r1, #671744	; 0xa4000
    63a2:	f603 43b8 	addw	r3, r3, #3256	; 0xcb8
    63a6:	fbab 0303 	umull	r0, r3, fp, r3
    63aa:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
    63ae:	d91e      	bls.n	63ee <tcp_slowtmr+0x18a>
				++pcb_remove;
    63b0:	f108 0801 	add.w	r8, r8, #1
    63b4:	fa5f f888 	uxtb.w	r8, r8
				++pcb_reset;
    63b8:	f04f 0901 	mov.w	r9, #1
    63bc:	e036      	b.n	642c <tcp_slowtmr+0x1c8>
		pcb_remove = 0;
    63be:	f04f 0800 	mov.w	r8, #0
    63c2:	e7db      	b.n	637c <tcp_slowtmr+0x118>
			if (pcb->flags & TF_RXCLOSED) {
    63c4:	7fa3      	ldrb	r3, [r4, #30]
    63c6:	f013 0f10 	tst.w	r3, #16
    63ca:	d009      	beq.n	63e0 <tcp_slowtmr+0x17c>
				if ((u32_t)(tcp_ticks - pcb->tmr) > TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
    63cc:	4b5d      	ldr	r3, [pc, #372]	; (6544 <tcp_slowtmr+0x2e0>)
    63ce:	681b      	ldr	r3, [r3, #0]
    63d0:	6a62      	ldr	r2, [r4, #36]	; 0x24
    63d2:	1a9b      	subs	r3, r3, r2
    63d4:	2b28      	cmp	r3, #40	; 0x28
    63d6:	d903      	bls.n	63e0 <tcp_slowtmr+0x17c>
					++pcb_remove;
    63d8:	f108 0801 	add.w	r8, r8, #1
    63dc:	fa5f f888 	uxtb.w	r8, r8
		if (pcb->ooseq != NULL && (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    63e0:	6f60      	ldr	r0, [r4, #116]	; 0x74
    63e2:	2800      	cmp	r0, #0
    63e4:	f000 80f1 	beq.w	65ca <tcp_slowtmr+0x366>
		pcb_reset  = 0;
    63e8:	f04f 0900 	mov.w	r9, #0
    63ec:	e020      	b.n	6430 <tcp_slowtmr+0x1cc>
			           > (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb)) / TCP_SLOW_INTERVAL) {
    63ee:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
    63f2:	485b      	ldr	r0, [pc, #364]	; (6560 <tcp_slowtmr+0x2fc>)
    63f4:	fb00 1303 	mla	r3, r0, r3, r1
    63f8:	fbab 1303 	umull	r1, r3, fp, r3
			} else if ((u32_t)(tcp_ticks - pcb->tmr)
    63fc:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
    6400:	d802      	bhi.n	6408 <tcp_slowtmr+0x1a4>
		pcb_reset  = 0;
    6402:	f04f 0900 	mov.w	r9, #0
    6406:	e011      	b.n	642c <tcp_slowtmr+0x1c8>
				tcp_keepalive(pcb);
    6408:	4620      	mov	r0, r4
    640a:	4b56      	ldr	r3, [pc, #344]	; (6564 <tcp_slowtmr+0x300>)
    640c:	4798      	blx	r3
				pcb->keep_cnt_sent++;
    640e:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
    6412:	3301      	adds	r3, #1
    6414:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
		pcb_reset  = 0;
    6418:	f04f 0900 	mov.w	r9, #0
    641c:	e006      	b.n	642c <tcp_slowtmr+0x1c8>
    641e:	f04f 0900 	mov.w	r9, #0
    6422:	f04f 0801 	mov.w	r8, #1
    6426:	e001      	b.n	642c <tcp_slowtmr+0x1c8>
    6428:	f04f 0900 	mov.w	r9, #0
		if (pcb->ooseq != NULL && (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    642c:	6f60      	ldr	r0, [r4, #116]	; 0x74
    642e:	b150      	cbz	r0, 6446 <tcp_slowtmr+0x1e2>
    6430:	4b44      	ldr	r3, [pc, #272]	; (6544 <tcp_slowtmr+0x2e0>)
    6432:	681a      	ldr	r2, [r3, #0]
    6434:	6a63      	ldr	r3, [r4, #36]	; 0x24
    6436:	1ad2      	subs	r2, r2, r3
    6438:	f9b4 3044 	ldrsh.w	r3, [r4, #68]	; 0x44
    643c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    6440:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
    6444:	d228      	bcs.n	6498 <tcp_slowtmr+0x234>
		if (pcb->state == SYN_RCVD) {
    6446:	7e23      	ldrb	r3, [r4, #24]
    6448:	2b03      	cmp	r3, #3
    644a:	d02a      	beq.n	64a2 <tcp_slowtmr+0x23e>
		if (pcb->state == LAST_ACK) {
    644c:	2b09      	cmp	r3, #9
    644e:	d033      	beq.n	64b8 <tcp_slowtmr+0x254>
		if (pcb_remove) {
    6450:	f1b8 0f00 	cmp.w	r8, #0
    6454:	d13b      	bne.n	64ce <tcp_slowtmr+0x26a>
			pcb  = pcb->next;
    6456:	f8d4 800c 	ldr.w	r8, [r4, #12]
			++prev->polltmr;
    645a:	7fe3      	ldrb	r3, [r4, #31]
    645c:	3301      	adds	r3, #1
    645e:	b2db      	uxtb	r3, r3
    6460:	77e3      	strb	r3, [r4, #31]
			if (prev->polltmr >= prev->pollinterval) {
    6462:	f894 2020 	ldrb.w	r2, [r4, #32]
    6466:	429a      	cmp	r2, r3
    6468:	f200 808a 	bhi.w	6580 <tcp_slowtmr+0x31c>
				prev->polltmr = 0;
    646c:	2300      	movs	r3, #0
    646e:	77e3      	strb	r3, [r4, #31]
				tcp_active_pcbs_changed = 0;
    6470:	703b      	strb	r3, [r7, #0]
				TCP_EVENT_POLL(prev, err);
    6472:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    6476:	2b00      	cmp	r3, #0
    6478:	d05b      	beq.n	6532 <tcp_slowtmr+0x2ce>
    647a:	4621      	mov	r1, r4
    647c:	6920      	ldr	r0, [r4, #16]
    647e:	4798      	blx	r3
				if (tcp_active_pcbs_changed) {
    6480:	783b      	ldrb	r3, [r7, #0]
    6482:	2b00      	cmp	r3, #0
    6484:	f47f aefd 	bne.w	6282 <tcp_slowtmr+0x1e>
				if (err == ERR_OK) {
    6488:	2800      	cmp	r0, #0
    648a:	d052      	beq.n	6532 <tcp_slowtmr+0x2ce>
    648c:	4626      	mov	r6, r4
			pcb  = pcb->next;
    648e:	4644      	mov	r4, r8
    6490:	e6ff      	b.n	6292 <tcp_slowtmr+0x2e>
		pcb_reset  = 0;
    6492:	f04f 0900 	mov.w	r9, #0
    6496:	e7c9      	b.n	642c <tcp_slowtmr+0x1c8>
			tcp_segs_free(pcb->ooseq);
    6498:	4b33      	ldr	r3, [pc, #204]	; (6568 <tcp_slowtmr+0x304>)
    649a:	4798      	blx	r3
			pcb->ooseq = NULL;
    649c:	2300      	movs	r3, #0
    649e:	6763      	str	r3, [r4, #116]	; 0x74
    64a0:	e7d1      	b.n	6446 <tcp_slowtmr+0x1e2>
			if ((u32_t)(tcp_ticks - pcb->tmr) > TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
    64a2:	4b28      	ldr	r3, [pc, #160]	; (6544 <tcp_slowtmr+0x2e0>)
    64a4:	681b      	ldr	r3, [r3, #0]
    64a6:	6a62      	ldr	r2, [r4, #36]	; 0x24
    64a8:	1a9b      	subs	r3, r3, r2
    64aa:	2b28      	cmp	r3, #40	; 0x28
    64ac:	d9d0      	bls.n	6450 <tcp_slowtmr+0x1ec>
				++pcb_remove;
    64ae:	f108 0801 	add.w	r8, r8, #1
    64b2:	fa5f f888 	uxtb.w	r8, r8
    64b6:	e7cb      	b.n	6450 <tcp_slowtmr+0x1ec>
			if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    64b8:	4b22      	ldr	r3, [pc, #136]	; (6544 <tcp_slowtmr+0x2e0>)
    64ba:	681b      	ldr	r3, [r3, #0]
    64bc:	6a62      	ldr	r2, [r4, #36]	; 0x24
    64be:	1a9b      	subs	r3, r3, r2
    64c0:	2bf0      	cmp	r3, #240	; 0xf0
				++pcb_remove;
    64c2:	bf84      	itt	hi
    64c4:	f108 0801 	addhi.w	r8, r8, #1
    64c8:	fa5f f888 	uxtbhi.w	r8, r8
    64cc:	e7c0      	b.n	6450 <tcp_slowtmr+0x1ec>
			tcp_pcb_purge(pcb);
    64ce:	4620      	mov	r0, r4
    64d0:	4b26      	ldr	r3, [pc, #152]	; (656c <tcp_slowtmr+0x308>)
    64d2:	4798      	blx	r3
			if (prev != NULL) {
    64d4:	b1ee      	cbz	r6, 6512 <tcp_slowtmr+0x2ae>
				prev->next = pcb->next;
    64d6:	68e3      	ldr	r3, [r4, #12]
    64d8:	60f3      	str	r3, [r6, #12]
			if (pcb_reset) {
    64da:	f1b9 0f00 	cmp.w	r9, #0
    64de:	d11c      	bne.n	651a <tcp_slowtmr+0x2b6>
			err_fn  = pcb->errf;
    64e0:	f8d4 808c 	ldr.w	r8, [r4, #140]	; 0x8c
			err_arg = pcb->callback_arg;
    64e4:	f8d4 a010 	ldr.w	sl, [r4, #16]
			pcb     = pcb->next;
    64e8:	f8d4 900c 	ldr.w	r9, [r4, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    64ec:	4621      	mov	r1, r4
    64ee:	2002      	movs	r0, #2
    64f0:	4b1f      	ldr	r3, [pc, #124]	; (6570 <tcp_slowtmr+0x30c>)
    64f2:	4798      	blx	r3
			tcp_active_pcbs_changed = 0;
    64f4:	2300      	movs	r3, #0
    64f6:	703b      	strb	r3, [r7, #0]
			TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
    64f8:	f1b8 0f00 	cmp.w	r8, #0
    64fc:	d01f      	beq.n	653e <tcp_slowtmr+0x2da>
    64fe:	f06f 0109 	mvn.w	r1, #9
    6502:	4650      	mov	r0, sl
    6504:	47c0      	blx	r8
			if (tcp_active_pcbs_changed) {
    6506:	783b      	ldrb	r3, [r7, #0]
    6508:	2b00      	cmp	r3, #0
    650a:	f47f aeba 	bne.w	6282 <tcp_slowtmr+0x1e>
			pcb     = pcb->next;
    650e:	464c      	mov	r4, r9
    6510:	e6bf      	b.n	6292 <tcp_slowtmr+0x2e>
				tcp_active_pcbs = pcb->next;
    6512:	68e3      	ldr	r3, [r4, #12]
    6514:	4a0e      	ldr	r2, [pc, #56]	; (6550 <tcp_slowtmr+0x2ec>)
    6516:	6013      	str	r3, [r2, #0]
    6518:	e7df      	b.n	64da <tcp_slowtmr+0x276>
				tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    651a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    651c:	6d20      	ldr	r0, [r4, #80]	; 0x50
    651e:	8ba3      	ldrh	r3, [r4, #28]
    6520:	9301      	str	r3, [sp, #4]
    6522:	8b63      	ldrh	r3, [r4, #26]
    6524:	9300      	str	r3, [sp, #0]
    6526:	1d23      	adds	r3, r4, #4
    6528:	4622      	mov	r2, r4
    652a:	f8df 8050 	ldr.w	r8, [pc, #80]	; 657c <tcp_slowtmr+0x318>
    652e:	47c0      	blx	r8
    6530:	e7d6      	b.n	64e0 <tcp_slowtmr+0x27c>
					tcp_output(prev);
    6532:	4620      	mov	r0, r4
    6534:	4b0f      	ldr	r3, [pc, #60]	; (6574 <tcp_slowtmr+0x310>)
    6536:	4798      	blx	r3
    6538:	4626      	mov	r6, r4
			pcb  = pcb->next;
    653a:	4644      	mov	r4, r8
    653c:	e6a9      	b.n	6292 <tcp_slowtmr+0x2e>
			pcb     = pcb->next;
    653e:	464c      	mov	r4, r9
    6540:	e6a7      	b.n	6292 <tcp_slowtmr+0x2e>
    6542:	bf00      	nop
    6544:	20009304 	.word	0x20009304
    6548:	20007f98 	.word	0x20007f98
    654c:	200092fc 	.word	0x200092fc
    6550:	20009300 	.word	0x20009300
    6554:	0000c46c 	.word	0x0000c46c
    6558:	000086d9 	.word	0x000086d9
    655c:	00008581 	.word	0x00008581
    6560:	000124f8 	.word	0x000124f8
    6564:	0000866d 	.word	0x0000866d
    6568:	000061cd 	.word	0x000061cd
    656c:	0000621d 	.word	0x0000621d
    6570:	000059c1 	.word	0x000059c1
    6574:	00008209 	.word	0x00008209
    6578:	10624dd3 	.word	0x10624dd3
    657c:	000084dd 	.word	0x000084dd
    6580:	4626      	mov	r6, r4
			pcb  = pcb->next;
    6582:	4644      	mov	r4, r8
    6584:	e685      	b.n	6292 <tcp_slowtmr+0x2e>
	pcb  = tcp_tw_pcbs;
    6586:	4b14      	ldr	r3, [pc, #80]	; (65d8 <tcp_slowtmr+0x374>)
    6588:	681c      	ldr	r4, [r3, #0]
	while (pcb != NULL) {
    658a:	b30c      	cbz	r4, 65d0 <tcp_slowtmr+0x36c>
    658c:	2500      	movs	r5, #0
		if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    658e:	4e13      	ldr	r6, [pc, #76]	; (65dc <tcp_slowtmr+0x378>)
			tcp_pcb_purge(pcb);
    6590:	f8df 8050 	ldr.w	r8, [pc, #80]	; 65e4 <tcp_slowtmr+0x380>
			memp_free(MEMP_TCP_PCB, pcb2);
    6594:	4f12      	ldr	r7, [pc, #72]	; (65e0 <tcp_slowtmr+0x37c>)
    6596:	e006      	b.n	65a6 <tcp_slowtmr+0x342>
				tcp_tw_pcbs = pcb->next;
    6598:	68e2      	ldr	r2, [r4, #12]
    659a:	4b0f      	ldr	r3, [pc, #60]	; (65d8 <tcp_slowtmr+0x374>)
    659c:	601a      	str	r2, [r3, #0]
    659e:	e00d      	b.n	65bc <tcp_slowtmr+0x358>
			pcb  = pcb->next;
    65a0:	4625      	mov	r5, r4
    65a2:	68e4      	ldr	r4, [r4, #12]
	while (pcb != NULL) {
    65a4:	b1a4      	cbz	r4, 65d0 <tcp_slowtmr+0x36c>
		if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    65a6:	6a62      	ldr	r2, [r4, #36]	; 0x24
    65a8:	6833      	ldr	r3, [r6, #0]
    65aa:	1a9b      	subs	r3, r3, r2
		if (pcb_remove) {
    65ac:	2bf0      	cmp	r3, #240	; 0xf0
    65ae:	d9f7      	bls.n	65a0 <tcp_slowtmr+0x33c>
			tcp_pcb_purge(pcb);
    65b0:	4620      	mov	r0, r4
    65b2:	47c0      	blx	r8
			if (prev != NULL) {
    65b4:	2d00      	cmp	r5, #0
    65b6:	d0ef      	beq.n	6598 <tcp_slowtmr+0x334>
				prev->next = pcb->next;
    65b8:	68e3      	ldr	r3, [r4, #12]
    65ba:	60eb      	str	r3, [r5, #12]
			pcb  = pcb->next;
    65bc:	f8d4 900c 	ldr.w	r9, [r4, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    65c0:	4621      	mov	r1, r4
    65c2:	2002      	movs	r0, #2
    65c4:	47b8      	blx	r7
			pcb  = pcb->next;
    65c6:	464c      	mov	r4, r9
    65c8:	e7ec      	b.n	65a4 <tcp_slowtmr+0x340>
		pcb_reset  = 0;
    65ca:	f04f 0900 	mov.w	r9, #0
    65ce:	e73f      	b.n	6450 <tcp_slowtmr+0x1ec>
}
    65d0:	b003      	add	sp, #12
    65d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    65d6:	bf00      	nop
    65d8:	20009314 	.word	0x20009314
    65dc:	20009304 	.word	0x20009304
    65e0:	000059c1 	.word	0x000059c1
    65e4:	0000621d 	.word	0x0000621d

000065e8 <tcp_pcb_remove>:
 *
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
    65e8:	b510      	push	{r4, lr}
    65ea:	460c      	mov	r4, r1
	TCP_RMV(pcblist, pcb);
    65ec:	6802      	ldr	r2, [r0, #0]
    65ee:	428a      	cmp	r2, r1
    65f0:	d00b      	beq.n	660a <tcp_pcb_remove+0x22>
    65f2:	4b18      	ldr	r3, [pc, #96]	; (6654 <tcp_pcb_remove+0x6c>)
    65f4:	601a      	str	r2, [r3, #0]
    65f6:	b17a      	cbz	r2, 6618 <tcp_pcb_remove+0x30>
    65f8:	68d3      	ldr	r3, [r2, #12]
    65fa:	4299      	cmp	r1, r3
    65fc:	d01d      	beq.n	663a <tcp_pcb_remove+0x52>
    65fe:	b1f3      	cbz	r3, 663e <tcp_pcb_remove+0x56>
    6600:	68da      	ldr	r2, [r3, #12]
    6602:	4294      	cmp	r4, r2
    6604:	d004      	beq.n	6610 <tcp_pcb_remove+0x28>
    6606:	4613      	mov	r3, r2
    6608:	e7f9      	b.n	65fe <tcp_pcb_remove+0x16>
    660a:	68d3      	ldr	r3, [r2, #12]
    660c:	6003      	str	r3, [r0, #0]
    660e:	e003      	b.n	6618 <tcp_pcb_remove+0x30>
    6610:	4a10      	ldr	r2, [pc, #64]	; (6654 <tcp_pcb_remove+0x6c>)
    6612:	6013      	str	r3, [r2, #0]
    6614:	68e2      	ldr	r2, [r4, #12]
    6616:	60da      	str	r2, [r3, #12]
    6618:	2300      	movs	r3, #0
    661a:	60e3      	str	r3, [r4, #12]

	tcp_pcb_purge(pcb);
    661c:	4620      	mov	r0, r4
    661e:	4b0e      	ldr	r3, [pc, #56]	; (6658 <tcp_pcb_remove+0x70>)
    6620:	4798      	blx	r3

	/* if there is an outstanding delayed ACKs, send it */
	if (pcb->state != TIME_WAIT && pcb->state != LISTEN && pcb->flags & TF_ACK_DELAY) {
    6622:	7e23      	ldrb	r3, [r4, #24]
    6624:	2b0a      	cmp	r3, #10
    6626:	d005      	beq.n	6634 <tcp_pcb_remove+0x4c>
    6628:	2b01      	cmp	r3, #1
    662a:	d003      	beq.n	6634 <tcp_pcb_remove+0x4c>
    662c:	7fa3      	ldrb	r3, [r4, #30]
    662e:	f013 0f01 	tst.w	r3, #1
    6632:	d108      	bne.n	6646 <tcp_pcb_remove+0x5e>
#if TCP_QUEUE_OOSEQ
		LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
	}

	pcb->state = CLOSED;
    6634:	2300      	movs	r3, #0
    6636:	7623      	strb	r3, [r4, #24]
    6638:	bd10      	pop	{r4, pc}
	TCP_RMV(pcblist, pcb);
    663a:	4613      	mov	r3, r2
    663c:	e7ea      	b.n	6614 <tcp_pcb_remove+0x2c>
    663e:	2200      	movs	r2, #0
    6640:	4b04      	ldr	r3, [pc, #16]	; (6654 <tcp_pcb_remove+0x6c>)
    6642:	601a      	str	r2, [r3, #0]
    6644:	e7e8      	b.n	6618 <tcp_pcb_remove+0x30>
		pcb->flags |= TF_ACK_NOW;
    6646:	f043 0302 	orr.w	r3, r3, #2
    664a:	77a3      	strb	r3, [r4, #30]
		tcp_output(pcb);
    664c:	4620      	mov	r0, r4
    664e:	4b03      	ldr	r3, [pc, #12]	; (665c <tcp_pcb_remove+0x74>)
    6650:	4798      	blx	r3
    6652:	e7ef      	b.n	6634 <tcp_pcb_remove+0x4c>
    6654:	2000930c 	.word	0x2000930c
    6658:	0000621d 	.word	0x0000621d
    665c:	00008209 	.word	0x00008209

00006660 <tcp_close_shutdown>:
{
    6660:	b530      	push	{r4, r5, lr}
    6662:	b083      	sub	sp, #12
    6664:	4604      	mov	r4, r0
	if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    6666:	b121      	cbz	r1, 6672 <tcp_close_shutdown+0x12>
    6668:	7e03      	ldrb	r3, [r0, #24]
    666a:	2b04      	cmp	r3, #4
    666c:	d00b      	beq.n	6686 <tcp_close_shutdown+0x26>
    666e:	2b07      	cmp	r3, #7
    6670:	d009      	beq.n	6686 <tcp_close_shutdown+0x26>
	switch (pcb->state) {
    6672:	7e23      	ldrb	r3, [r4, #24]
    6674:	2b07      	cmp	r3, #7
    6676:	f200 80ae 	bhi.w	67d6 <tcp_close_shutdown+0x176>
    667a:	e8df f003 	tbb	[pc, r3]
    667e:	774e      	.short	0x774e
    6680:	ac9a8c80 	.word	0xac9a8c80
    6684:	a3ac      	.short	0xa3ac
		if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
    6686:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    6688:	b1e3      	cbz	r3, 66c4 <tcp_close_shutdown+0x64>
			tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    668a:	8ba3      	ldrh	r3, [r4, #28]
    668c:	9301      	str	r3, [sp, #4]
    668e:	8b63      	ldrh	r3, [r4, #26]
    6690:	9300      	str	r3, [sp, #0]
    6692:	1d23      	adds	r3, r4, #4
    6694:	4622      	mov	r2, r4
    6696:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    6698:	6d20      	ldr	r0, [r4, #80]	; 0x50
    669a:	4d51      	ldr	r5, [pc, #324]	; (67e0 <tcp_close_shutdown+0x180>)
    669c:	47a8      	blx	r5
			tcp_pcb_purge(pcb);
    669e:	4620      	mov	r0, r4
    66a0:	4b50      	ldr	r3, [pc, #320]	; (67e4 <tcp_close_shutdown+0x184>)
    66a2:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    66a4:	4b50      	ldr	r3, [pc, #320]	; (67e8 <tcp_close_shutdown+0x188>)
    66a6:	681a      	ldr	r2, [r3, #0]
    66a8:	4294      	cmp	r4, r2
    66aa:	d011      	beq.n	66d0 <tcp_close_shutdown+0x70>
    66ac:	4b4f      	ldr	r3, [pc, #316]	; (67ec <tcp_close_shutdown+0x18c>)
    66ae:	601a      	str	r2, [r3, #0]
    66b0:	b1aa      	cbz	r2, 66de <tcp_close_shutdown+0x7e>
    66b2:	68d3      	ldr	r3, [r2, #12]
    66b4:	429c      	cmp	r4, r3
    66b6:	d020      	beq.n	66fa <tcp_close_shutdown+0x9a>
    66b8:	b30b      	cbz	r3, 66fe <tcp_close_shutdown+0x9e>
    66ba:	68da      	ldr	r2, [r3, #12]
    66bc:	4294      	cmp	r4, r2
    66be:	d00a      	beq.n	66d6 <tcp_close_shutdown+0x76>
    66c0:	4613      	mov	r3, r2
    66c2:	e7f9      	b.n	66b8 <tcp_close_shutdown+0x58>
		if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
    66c4:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    66c6:	f241 63d0 	movw	r3, #5840	; 0x16d0
    66ca:	429a      	cmp	r2, r3
    66cc:	d1dd      	bne.n	668a <tcp_close_shutdown+0x2a>
    66ce:	e7d0      	b.n	6672 <tcp_close_shutdown+0x12>
			TCP_RMV_ACTIVE(pcb);
    66d0:	68d2      	ldr	r2, [r2, #12]
    66d2:	601a      	str	r2, [r3, #0]
    66d4:	e003      	b.n	66de <tcp_close_shutdown+0x7e>
    66d6:	4a45      	ldr	r2, [pc, #276]	; (67ec <tcp_close_shutdown+0x18c>)
    66d8:	6013      	str	r3, [r2, #0]
    66da:	68e2      	ldr	r2, [r4, #12]
    66dc:	60da      	str	r2, [r3, #12]
    66de:	2300      	movs	r3, #0
    66e0:	60e3      	str	r3, [r4, #12]
    66e2:	2201      	movs	r2, #1
    66e4:	4b42      	ldr	r3, [pc, #264]	; (67f0 <tcp_close_shutdown+0x190>)
    66e6:	701a      	strb	r2, [r3, #0]
			if (pcb->state == ESTABLISHED) {
    66e8:	7e23      	ldrb	r3, [r4, #24]
    66ea:	2b04      	cmp	r3, #4
    66ec:	d00b      	beq.n	6706 <tcp_close_shutdown+0xa6>
				memp_free(MEMP_TCP_PCB, pcb);
    66ee:	4621      	mov	r1, r4
    66f0:	2002      	movs	r0, #2
    66f2:	4b40      	ldr	r3, [pc, #256]	; (67f4 <tcp_close_shutdown+0x194>)
    66f4:	4798      	blx	r3
			return ERR_OK;
    66f6:	2300      	movs	r3, #0
    66f8:	e02f      	b.n	675a <tcp_close_shutdown+0xfa>
			TCP_RMV_ACTIVE(pcb);
    66fa:	4613      	mov	r3, r2
    66fc:	e7ed      	b.n	66da <tcp_close_shutdown+0x7a>
    66fe:	2200      	movs	r2, #0
    6700:	4b3a      	ldr	r3, [pc, #232]	; (67ec <tcp_close_shutdown+0x18c>)
    6702:	601a      	str	r2, [r3, #0]
    6704:	e7eb      	b.n	66de <tcp_close_shutdown+0x7e>
				pcb->state = TIME_WAIT;
    6706:	230a      	movs	r3, #10
    6708:	7623      	strb	r3, [r4, #24]
				TCP_REG(&tcp_tw_pcbs, pcb);
    670a:	4b3b      	ldr	r3, [pc, #236]	; (67f8 <tcp_close_shutdown+0x198>)
    670c:	681a      	ldr	r2, [r3, #0]
    670e:	60e2      	str	r2, [r4, #12]
    6710:	601c      	str	r4, [r3, #0]
    6712:	4b3a      	ldr	r3, [pc, #232]	; (67fc <tcp_close_shutdown+0x19c>)
    6714:	4798      	blx	r3
			return ERR_OK;
    6716:	2300      	movs	r3, #0
    6718:	e01f      	b.n	675a <tcp_close_shutdown+0xfa>
		if (pcb->local_port != 0) {
    671a:	8b63      	ldrh	r3, [r4, #26]
    671c:	b1c3      	cbz	r3, 6750 <tcp_close_shutdown+0xf0>
			TCP_RMV(&tcp_bound_pcbs, pcb);
    671e:	4b38      	ldr	r3, [pc, #224]	; (6800 <tcp_close_shutdown+0x1a0>)
    6720:	681a      	ldr	r2, [r3, #0]
    6722:	4294      	cmp	r4, r2
    6724:	d00b      	beq.n	673e <tcp_close_shutdown+0xde>
    6726:	4b31      	ldr	r3, [pc, #196]	; (67ec <tcp_close_shutdown+0x18c>)
    6728:	601a      	str	r2, [r3, #0]
    672a:	b17a      	cbz	r2, 674c <tcp_close_shutdown+0xec>
    672c:	68d3      	ldr	r3, [r2, #12]
    672e:	429c      	cmp	r4, r3
    6730:	d016      	beq.n	6760 <tcp_close_shutdown+0x100>
    6732:	b1bb      	cbz	r3, 6764 <tcp_close_shutdown+0x104>
    6734:	68da      	ldr	r2, [r3, #12]
    6736:	4294      	cmp	r4, r2
    6738:	d004      	beq.n	6744 <tcp_close_shutdown+0xe4>
    673a:	4613      	mov	r3, r2
    673c:	e7f9      	b.n	6732 <tcp_close_shutdown+0xd2>
    673e:	68d2      	ldr	r2, [r2, #12]
    6740:	601a      	str	r2, [r3, #0]
    6742:	e003      	b.n	674c <tcp_close_shutdown+0xec>
    6744:	4a29      	ldr	r2, [pc, #164]	; (67ec <tcp_close_shutdown+0x18c>)
    6746:	6013      	str	r3, [r2, #0]
    6748:	68e2      	ldr	r2, [r4, #12]
    674a:	60da      	str	r2, [r3, #12]
    674c:	2300      	movs	r3, #0
    674e:	60e3      	str	r3, [r4, #12]
		memp_free(MEMP_TCP_PCB, pcb);
    6750:	4621      	mov	r1, r4
    6752:	2002      	movs	r0, #2
    6754:	4b27      	ldr	r3, [pc, #156]	; (67f4 <tcp_close_shutdown+0x194>)
    6756:	4798      	blx	r3
		err = ERR_OK;
    6758:	2300      	movs	r3, #0
}
    675a:	4618      	mov	r0, r3
    675c:	b003      	add	sp, #12
    675e:	bd30      	pop	{r4, r5, pc}
			TCP_RMV(&tcp_bound_pcbs, pcb);
    6760:	4613      	mov	r3, r2
    6762:	e7f1      	b.n	6748 <tcp_close_shutdown+0xe8>
    6764:	2200      	movs	r2, #0
    6766:	4b21      	ldr	r3, [pc, #132]	; (67ec <tcp_close_shutdown+0x18c>)
    6768:	601a      	str	r2, [r3, #0]
    676a:	e7ef      	b.n	674c <tcp_close_shutdown+0xec>
		tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
    676c:	4621      	mov	r1, r4
    676e:	4825      	ldr	r0, [pc, #148]	; (6804 <tcp_close_shutdown+0x1a4>)
    6770:	4b25      	ldr	r3, [pc, #148]	; (6808 <tcp_close_shutdown+0x1a8>)
    6772:	4798      	blx	r3
		memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    6774:	4621      	mov	r1, r4
    6776:	2003      	movs	r0, #3
    6778:	4b1e      	ldr	r3, [pc, #120]	; (67f4 <tcp_close_shutdown+0x194>)
    677a:	4798      	blx	r3
		break;
    677c:	e7ec      	b.n	6758 <tcp_close_shutdown+0xf8>
		TCP_PCB_REMOVE_ACTIVE(pcb);
    677e:	4621      	mov	r1, r4
    6780:	4819      	ldr	r0, [pc, #100]	; (67e8 <tcp_close_shutdown+0x188>)
    6782:	4b21      	ldr	r3, [pc, #132]	; (6808 <tcp_close_shutdown+0x1a8>)
    6784:	4798      	blx	r3
    6786:	2201      	movs	r2, #1
    6788:	4b19      	ldr	r3, [pc, #100]	; (67f0 <tcp_close_shutdown+0x190>)
    678a:	701a      	strb	r2, [r3, #0]
		memp_free(MEMP_TCP_PCB, pcb);
    678c:	4621      	mov	r1, r4
    678e:	2002      	movs	r0, #2
    6790:	4b18      	ldr	r3, [pc, #96]	; (67f4 <tcp_close_shutdown+0x194>)
    6792:	4798      	blx	r3
		break;
    6794:	e7e0      	b.n	6758 <tcp_close_shutdown+0xf8>
		err = tcp_send_fin(pcb);
    6796:	4620      	mov	r0, r4
    6798:	4b1c      	ldr	r3, [pc, #112]	; (680c <tcp_close_shutdown+0x1ac>)
    679a:	4798      	blx	r3
		if (err == ERR_OK) {
    679c:	4603      	mov	r3, r0
    679e:	2800      	cmp	r0, #0
    67a0:	d1db      	bne.n	675a <tcp_close_shutdown+0xfa>
			pcb->state = FIN_WAIT_1;
    67a2:	2305      	movs	r3, #5
    67a4:	7623      	strb	r3, [r4, #24]
	if (pcb != NULL && err == ERR_OK) {
    67a6:	b1c4      	cbz	r4, 67da <tcp_close_shutdown+0x17a>
		tcp_output(pcb);
    67a8:	4620      	mov	r0, r4
    67aa:	4b19      	ldr	r3, [pc, #100]	; (6810 <tcp_close_shutdown+0x1b0>)
    67ac:	4798      	blx	r3
	return err;
    67ae:	2300      	movs	r3, #0
    67b0:	e7d3      	b.n	675a <tcp_close_shutdown+0xfa>
		err = tcp_send_fin(pcb);
    67b2:	4620      	mov	r0, r4
    67b4:	4b15      	ldr	r3, [pc, #84]	; (680c <tcp_close_shutdown+0x1ac>)
    67b6:	4798      	blx	r3
		if (err == ERR_OK) {
    67b8:	4603      	mov	r3, r0
    67ba:	2800      	cmp	r0, #0
    67bc:	d1cd      	bne.n	675a <tcp_close_shutdown+0xfa>
			pcb->state = FIN_WAIT_1;
    67be:	2305      	movs	r3, #5
    67c0:	7623      	strb	r3, [r4, #24]
    67c2:	e7f0      	b.n	67a6 <tcp_close_shutdown+0x146>
		err = tcp_send_fin(pcb);
    67c4:	4620      	mov	r0, r4
    67c6:	4b11      	ldr	r3, [pc, #68]	; (680c <tcp_close_shutdown+0x1ac>)
    67c8:	4798      	blx	r3
		if (err == ERR_OK) {
    67ca:	4603      	mov	r3, r0
    67cc:	2800      	cmp	r0, #0
    67ce:	d1c4      	bne.n	675a <tcp_close_shutdown+0xfa>
			pcb->state = LAST_ACK;
    67d0:	2309      	movs	r3, #9
    67d2:	7623      	strb	r3, [r4, #24]
    67d4:	e7e7      	b.n	67a6 <tcp_close_shutdown+0x146>
		err = ERR_OK;
    67d6:	2300      	movs	r3, #0
    67d8:	e7bf      	b.n	675a <tcp_close_shutdown+0xfa>
	if (pcb != NULL && err == ERR_OK) {
    67da:	2300      	movs	r3, #0
    67dc:	e7bd      	b.n	675a <tcp_close_shutdown+0xfa>
    67de:	bf00      	nop
    67e0:	000084dd 	.word	0x000084dd
    67e4:	0000621d 	.word	0x0000621d
    67e8:	20009300 	.word	0x20009300
    67ec:	2000930c 	.word	0x2000930c
    67f0:	200092fc 	.word	0x200092fc
    67f4:	000059c1 	.word	0x000059c1
    67f8:	20009314 	.word	0x20009314
    67fc:	00008821 	.word	0x00008821
    6800:	20009310 	.word	0x20009310
    6804:	20009308 	.word	0x20009308
    6808:	000065e9 	.word	0x000065e9
    680c:	00008141 	.word	0x00008141
    6810:	00008209 	.word	0x00008209

00006814 <tcp_close>:
{
    6814:	b508      	push	{r3, lr}
	if (pcb->state != LISTEN) {
    6816:	7e03      	ldrb	r3, [r0, #24]
    6818:	2b01      	cmp	r3, #1
    681a:	d003      	beq.n	6824 <tcp_close+0x10>
		pcb->flags |= TF_RXCLOSED;
    681c:	7f83      	ldrb	r3, [r0, #30]
    681e:	f043 0310 	orr.w	r3, r3, #16
    6822:	7783      	strb	r3, [r0, #30]
	return tcp_close_shutdown(pcb, 1);
    6824:	2101      	movs	r1, #1
    6826:	4b01      	ldr	r3, [pc, #4]	; (682c <tcp_close+0x18>)
    6828:	4798      	blx	r3
}
    682a:	bd08      	pop	{r3, pc}
    682c:	00006661 	.word	0x00006661

00006830 <tcp_recv_null>:
{
    6830:	b510      	push	{r4, lr}
    6832:	4608      	mov	r0, r1
	if (p != NULL) {
    6834:	b142      	cbz	r2, 6848 <tcp_recv_null+0x18>
    6836:	4614      	mov	r4, r2
		tcp_recved(pcb, p->tot_len);
    6838:	8911      	ldrh	r1, [r2, #8]
    683a:	4b06      	ldr	r3, [pc, #24]	; (6854 <tcp_recv_null+0x24>)
    683c:	4798      	blx	r3
		pbuf_free(p);
    683e:	4620      	mov	r0, r4
    6840:	4b05      	ldr	r3, [pc, #20]	; (6858 <tcp_recv_null+0x28>)
    6842:	4798      	blx	r3
	return ERR_OK;
    6844:	2000      	movs	r0, #0
    6846:	bd10      	pop	{r4, pc}
	} else if (err == ERR_OK) {
    6848:	b10b      	cbz	r3, 684e <tcp_recv_null+0x1e>
	return ERR_OK;
    684a:	2000      	movs	r0, #0
}
    684c:	bd10      	pop	{r4, pc}
		return tcp_close(pcb);
    684e:	4b03      	ldr	r3, [pc, #12]	; (685c <tcp_recv_null+0x2c>)
    6850:	4798      	blx	r3
    6852:	bd10      	pop	{r4, pc}
    6854:	00006169 	.word	0x00006169
    6858:	00005c89 	.word	0x00005c89
    685c:	00006815 	.word	0x00006815

00006860 <tcp_process_refused_data>:
{
    6860:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6862:	4604      	mov	r4, r0
	u8_t  refused_flags = pcb->refused_data->flags;
    6864:	6f86      	ldr	r6, [r0, #120]	; 0x78
    6866:	7b77      	ldrb	r7, [r6, #13]
	pcb->refused_data         = NULL;
    6868:	2300      	movs	r3, #0
    686a:	6783      	str	r3, [r0, #120]	; 0x78
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    686c:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
    6870:	b1e5      	cbz	r5, 68ac <tcp_process_refused_data+0x4c>
    6872:	4632      	mov	r2, r6
    6874:	4601      	mov	r1, r0
    6876:	6900      	ldr	r0, [r0, #16]
    6878:	47a8      	blx	r5
    687a:	4605      	mov	r5, r0
	if (err == ERR_OK) {
    687c:	b9f5      	cbnz	r5, 68bc <tcp_process_refused_data+0x5c>
		if (refused_flags & PBUF_FLAG_TCP_FIN) {
    687e:	f017 0f20 	tst.w	r7, #32
    6882:	d020      	beq.n	68c6 <tcp_process_refused_data+0x66>
			if (pcb->rcv_wnd != TCP_WND) {
    6884:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    6886:	f241 62d0 	movw	r2, #5840	; 0x16d0
    688a:	4293      	cmp	r3, r2
				pcb->rcv_wnd++;
    688c:	bf1c      	itt	ne
    688e:	3301      	addne	r3, #1
    6890:	85a3      	strhne	r3, [r4, #44]	; 0x2c
			TCP_EVENT_CLOSED(pcb, err);
    6892:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
    6896:	b1b6      	cbz	r6, 68c6 <tcp_process_refused_data+0x66>
    6898:	2300      	movs	r3, #0
    689a:	461a      	mov	r2, r3
    689c:	4621      	mov	r1, r4
    689e:	6920      	ldr	r0, [r4, #16]
    68a0:	47b0      	blx	r6
				return ERR_ABRT;
    68a2:	f110 0f0a 	cmn.w	r0, #10
    68a6:	bf08      	it	eq
    68a8:	4605      	moveq	r5, r0
    68aa:	e00c      	b.n	68c6 <tcp_process_refused_data+0x66>
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    68ac:	2300      	movs	r3, #0
    68ae:	4632      	mov	r2, r6
    68b0:	4601      	mov	r1, r0
    68b2:	4618      	mov	r0, r3
    68b4:	4d05      	ldr	r5, [pc, #20]	; (68cc <tcp_process_refused_data+0x6c>)
    68b6:	47a8      	blx	r5
    68b8:	4605      	mov	r5, r0
    68ba:	e7df      	b.n	687c <tcp_process_refused_data+0x1c>
	} else if (err == ERR_ABRT) {
    68bc:	f115 0f0a 	cmn.w	r5, #10
		pcb->refused_data = refused_data;
    68c0:	bf1c      	itt	ne
    68c2:	67a6      	strne	r6, [r4, #120]	; 0x78
	return ERR_OK;
    68c4:	2500      	movne	r5, #0
}
    68c6:	4628      	mov	r0, r5
    68c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    68ca:	bf00      	nop
    68cc:	00006831 	.word	0x00006831

000068d0 <tcp_fasttmr>:
{
    68d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	++tcp_timer_ctr;
    68d4:	4a18      	ldr	r2, [pc, #96]	; (6938 <tcp_fasttmr+0x68>)
    68d6:	7813      	ldrb	r3, [r2, #0]
    68d8:	3301      	adds	r3, #1
    68da:	7013      	strb	r3, [r2, #0]
	pcb = tcp_active_pcbs;
    68dc:	4f17      	ldr	r7, [pc, #92]	; (693c <tcp_fasttmr+0x6c>)
		if (pcb->last_timer != tcp_timer_ctr) {
    68de:	4615      	mov	r5, r2
				tcp_output(pcb);
    68e0:	f8df 8064 	ldr.w	r8, [pc, #100]	; 6948 <tcp_fasttmr+0x78>
				tcp_active_pcbs_changed = 0;
    68e4:	4e16      	ldr	r6, [pc, #88]	; (6940 <tcp_fasttmr+0x70>)
	pcb = tcp_active_pcbs;
    68e6:	683c      	ldr	r4, [r7, #0]
	while (pcb != NULL) {
    68e8:	b31c      	cbz	r4, 6932 <tcp_fasttmr+0x62>
		if (pcb->last_timer != tcp_timer_ctr) {
    68ea:	782b      	ldrb	r3, [r5, #0]
    68ec:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    68f0:	429a      	cmp	r2, r3
    68f2:	d100      	bne.n	68f6 <tcp_fasttmr+0x26>
    68f4:	e7fe      	b.n	68f4 <tcp_fasttmr+0x24>
			pcb->last_timer = tcp_timer_ctr;
    68f6:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
			if (pcb->flags & TF_ACK_DELAY) {
    68fa:	7fa3      	ldrb	r3, [r4, #30]
    68fc:	f013 0f01 	tst.w	r3, #1
    6900:	d10d      	bne.n	691e <tcp_fasttmr+0x4e>
			next = pcb->next;
    6902:	f8d4 900c 	ldr.w	r9, [r4, #12]
			if (pcb->refused_data != NULL) {
    6906:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    6908:	b13b      	cbz	r3, 691a <tcp_fasttmr+0x4a>
				tcp_active_pcbs_changed = 0;
    690a:	2300      	movs	r3, #0
    690c:	7033      	strb	r3, [r6, #0]
				tcp_process_refused_data(pcb);
    690e:	4620      	mov	r0, r4
    6910:	4b0c      	ldr	r3, [pc, #48]	; (6944 <tcp_fasttmr+0x74>)
    6912:	4798      	blx	r3
				if (tcp_active_pcbs_changed) {
    6914:	7833      	ldrb	r3, [r6, #0]
    6916:	2b00      	cmp	r3, #0
    6918:	d1e5      	bne.n	68e6 <tcp_fasttmr+0x16>
{
    691a:	464c      	mov	r4, r9
    691c:	e7e4      	b.n	68e8 <tcp_fasttmr+0x18>
				tcp_ack_now(pcb);
    691e:	f043 0302 	orr.w	r3, r3, #2
    6922:	77a3      	strb	r3, [r4, #30]
				tcp_output(pcb);
    6924:	4620      	mov	r0, r4
    6926:	47c0      	blx	r8
				pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    6928:	7fa3      	ldrb	r3, [r4, #30]
    692a:	f023 0303 	bic.w	r3, r3, #3
    692e:	77a3      	strb	r3, [r4, #30]
    6930:	e7e7      	b.n	6902 <tcp_fasttmr+0x32>
    6932:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6936:	bf00      	nop
    6938:	20007f98 	.word	0x20007f98
    693c:	20009300 	.word	0x20009300
    6940:	200092fc 	.word	0x200092fc
    6944:	00006861 	.word	0x00006861
    6948:	00008209 	.word	0x00008209

0000694c <tcp_tmr>:
{
    694c:	b508      	push	{r3, lr}
	tcp_fasttmr();
    694e:	4b07      	ldr	r3, [pc, #28]	; (696c <tcp_tmr+0x20>)
    6950:	4798      	blx	r3
	if (++tcp_timer & 1) {
    6952:	4a07      	ldr	r2, [pc, #28]	; (6970 <tcp_tmr+0x24>)
    6954:	7853      	ldrb	r3, [r2, #1]
    6956:	3301      	adds	r3, #1
    6958:	b2db      	uxtb	r3, r3
    695a:	7053      	strb	r3, [r2, #1]
    695c:	f013 0f01 	tst.w	r3, #1
    6960:	d100      	bne.n	6964 <tcp_tmr+0x18>
    6962:	bd08      	pop	{r3, pc}
		tcp_slowtmr();
    6964:	4b03      	ldr	r3, [pc, #12]	; (6974 <tcp_tmr+0x28>)
    6966:	4798      	blx	r3
}
    6968:	e7fb      	b.n	6962 <tcp_tmr+0x16>
    696a:	bf00      	nop
    696c:	000068d1 	.word	0x000068d1
    6970:	20007f98 	.word	0x20007f98
    6974:	00006265 	.word	0x00006265

00006978 <tcp_abandon>:
{
    6978:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    697c:	b083      	sub	sp, #12
    697e:	4604      	mov	r4, r0
	if (pcb->state == TIME_WAIT) {
    6980:	7e03      	ldrb	r3, [r0, #24]
    6982:	2b0a      	cmp	r3, #10
    6984:	d027      	beq.n	69d6 <tcp_abandon+0x5e>
    6986:	460e      	mov	r6, r1
		seqno = pcb->snd_nxt;
    6988:	f8d0 8050 	ldr.w	r8, [r0, #80]	; 0x50
		ackno = pcb->rcv_nxt;
    698c:	f8d0 9028 	ldr.w	r9, [r0, #40]	; 0x28
		errf = pcb->errf;
    6990:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c
		errf_arg = pcb->callback_arg;
    6994:	6907      	ldr	r7, [r0, #16]
		TCP_PCB_REMOVE_ACTIVE(pcb);
    6996:	4601      	mov	r1, r0
    6998:	4819      	ldr	r0, [pc, #100]	; (6a00 <tcp_abandon+0x88>)
    699a:	4b1a      	ldr	r3, [pc, #104]	; (6a04 <tcp_abandon+0x8c>)
    699c:	4798      	blx	r3
    699e:	2201      	movs	r2, #1
    69a0:	4b19      	ldr	r3, [pc, #100]	; (6a08 <tcp_abandon+0x90>)
    69a2:	701a      	strb	r2, [r3, #0]
		if (pcb->unacked != NULL) {
    69a4:	6f20      	ldr	r0, [r4, #112]	; 0x70
    69a6:	b108      	cbz	r0, 69ac <tcp_abandon+0x34>
			tcp_segs_free(pcb->unacked);
    69a8:	4b18      	ldr	r3, [pc, #96]	; (6a0c <tcp_abandon+0x94>)
    69aa:	4798      	blx	r3
		if (pcb->unsent != NULL) {
    69ac:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    69ae:	b108      	cbz	r0, 69b4 <tcp_abandon+0x3c>
			tcp_segs_free(pcb->unsent);
    69b0:	4b16      	ldr	r3, [pc, #88]	; (6a0c <tcp_abandon+0x94>)
    69b2:	4798      	blx	r3
		if (pcb->ooseq != NULL) {
    69b4:	6f60      	ldr	r0, [r4, #116]	; 0x74
    69b6:	b108      	cbz	r0, 69bc <tcp_abandon+0x44>
			tcp_segs_free(pcb->ooseq);
    69b8:	4b14      	ldr	r3, [pc, #80]	; (6a0c <tcp_abandon+0x94>)
    69ba:	4798      	blx	r3
		if (reset) {
    69bc:	b9a6      	cbnz	r6, 69e8 <tcp_abandon+0x70>
		memp_free(MEMP_TCP_PCB, pcb);
    69be:	4621      	mov	r1, r4
    69c0:	2002      	movs	r0, #2
    69c2:	4b13      	ldr	r3, [pc, #76]	; (6a10 <tcp_abandon+0x98>)
    69c4:	4798      	blx	r3
		TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    69c6:	b11d      	cbz	r5, 69d0 <tcp_abandon+0x58>
    69c8:	f06f 0109 	mvn.w	r1, #9
    69cc:	4638      	mov	r0, r7
    69ce:	47a8      	blx	r5
}
    69d0:	b003      	add	sp, #12
    69d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    69d6:	4601      	mov	r1, r0
    69d8:	480e      	ldr	r0, [pc, #56]	; (6a14 <tcp_abandon+0x9c>)
    69da:	4b0a      	ldr	r3, [pc, #40]	; (6a04 <tcp_abandon+0x8c>)
    69dc:	4798      	blx	r3
		memp_free(MEMP_TCP_PCB, pcb);
    69de:	4621      	mov	r1, r4
    69e0:	2002      	movs	r0, #2
    69e2:	4b0b      	ldr	r3, [pc, #44]	; (6a10 <tcp_abandon+0x98>)
    69e4:	4798      	blx	r3
    69e6:	e7f3      	b.n	69d0 <tcp_abandon+0x58>
			tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    69e8:	8ba3      	ldrh	r3, [r4, #28]
    69ea:	9301      	str	r3, [sp, #4]
    69ec:	8b63      	ldrh	r3, [r4, #26]
    69ee:	9300      	str	r3, [sp, #0]
    69f0:	1d23      	adds	r3, r4, #4
    69f2:	4622      	mov	r2, r4
    69f4:	4649      	mov	r1, r9
    69f6:	4640      	mov	r0, r8
    69f8:	4e07      	ldr	r6, [pc, #28]	; (6a18 <tcp_abandon+0xa0>)
    69fa:	47b0      	blx	r6
    69fc:	e7df      	b.n	69be <tcp_abandon+0x46>
    69fe:	bf00      	nop
    6a00:	20009300 	.word	0x20009300
    6a04:	000065e9 	.word	0x000065e9
    6a08:	200092fc 	.word	0x200092fc
    6a0c:	000061cd 	.word	0x000061cd
    6a10:	000059c1 	.word	0x000059c1
    6a14:	20009314 	.word	0x20009314
    6a18:	000084dd 	.word	0x000084dd

00006a1c <tcp_abort>:
{
    6a1c:	b508      	push	{r3, lr}
	tcp_abandon(pcb, 1);
    6a1e:	2101      	movs	r1, #1
    6a20:	4b01      	ldr	r3, [pc, #4]	; (6a28 <tcp_abort+0xc>)
    6a22:	4798      	blx	r3
    6a24:	bd08      	pop	{r3, pc}
    6a26:	bf00      	nop
    6a28:	00006979 	.word	0x00006979

00006a2c <tcp_next_iss>:
 */
u32_t tcp_next_iss(void)
{
	static u32_t iss = 6510;

	iss += tcp_ticks; /* XXX */
    6a2c:	4b03      	ldr	r3, [pc, #12]	; (6a3c <tcp_next_iss+0x10>)
    6a2e:	6858      	ldr	r0, [r3, #4]
    6a30:	4a03      	ldr	r2, [pc, #12]	; (6a40 <tcp_next_iss+0x14>)
    6a32:	6812      	ldr	r2, [r2, #0]
    6a34:	4410      	add	r0, r2
    6a36:	6058      	str	r0, [r3, #4]
	return iss;
}
    6a38:	4770      	bx	lr
    6a3a:	bf00      	nop
    6a3c:	20000004 	.word	0x20000004
    6a40:	20009304 	.word	0x20009304

00006a44 <tcp_alloc>:
{
    6a44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6a46:	4605      	mov	r5, r0
	pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    6a48:	2002      	movs	r0, #2
    6a4a:	4b3e      	ldr	r3, [pc, #248]	; (6b44 <tcp_alloc+0x100>)
    6a4c:	4798      	blx	r3
	if (pcb == NULL) {
    6a4e:	4604      	mov	r4, r0
    6a50:	2800      	cmp	r0, #0
    6a52:	d03b      	beq.n	6acc <tcp_alloc+0x88>
		memset(pcb, 0, sizeof(struct tcp_pcb));
    6a54:	2298      	movs	r2, #152	; 0x98
    6a56:	2100      	movs	r1, #0
    6a58:	4620      	mov	r0, r4
    6a5a:	4b3b      	ldr	r3, [pc, #236]	; (6b48 <tcp_alloc+0x104>)
    6a5c:	4798      	blx	r3
		pcb->prio         = prio;
    6a5e:	7665      	strb	r5, [r4, #25]
		pcb->snd_buf      = TCP_SND_BUF;
    6a60:	f640 3368 	movw	r3, #2920	; 0xb68
    6a64:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
		pcb->snd_queuelen = 0;
    6a68:	2500      	movs	r5, #0
    6a6a:	f8a4 5068 	strh.w	r5, [r4, #104]	; 0x68
		pcb->rcv_wnd      = TCP_WND;
    6a6e:	f241 63d0 	movw	r3, #5840	; 0x16d0
    6a72:	85a3      	strh	r3, [r4, #44]	; 0x2c
		pcb->rcv_ann_wnd  = TCP_WND;
    6a74:	85e3      	strh	r3, [r4, #46]	; 0x2e
		pcb->tos          = 0;
    6a76:	7265      	strb	r5, [r4, #9]
		pcb->ttl          = TCP_TTL;
    6a78:	23ff      	movs	r3, #255	; 0xff
    6a7a:	72a3      	strb	r3, [r4, #10]
		pcb->mss        = (TCP_MSS > 536) ? 536 : TCP_MSS;
    6a7c:	f44f 7306 	mov.w	r3, #536	; 0x218
    6a80:	86e3      	strh	r3, [r4, #54]	; 0x36
		pcb->rto        = 3000 / TCP_SLOW_INTERVAL;
    6a82:	2306      	movs	r3, #6
    6a84:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
		pcb->sa         = 0;
    6a88:	f8a4 5040 	strh.w	r5, [r4, #64]	; 0x40
		pcb->sv         = 3000 / TCP_SLOW_INTERVAL;
    6a8c:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
		pcb->rtime      = -1;
    6a90:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6a94:	86a3      	strh	r3, [r4, #52]	; 0x34
		pcb->cwnd       = 1;
    6a96:	2301      	movs	r3, #1
    6a98:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		iss             = tcp_next_iss();
    6a9c:	4b2b      	ldr	r3, [pc, #172]	; (6b4c <tcp_alloc+0x108>)
    6a9e:	4798      	blx	r3
		pcb->snd_wl2    = iss;
    6aa0:	65a0      	str	r0, [r4, #88]	; 0x58
		pcb->snd_nxt    = iss;
    6aa2:	6520      	str	r0, [r4, #80]	; 0x50
		pcb->lastack    = iss;
    6aa4:	64a0      	str	r0, [r4, #72]	; 0x48
		pcb->snd_lbb    = iss;
    6aa6:	65e0      	str	r0, [r4, #92]	; 0x5c
		pcb->tmr        = tcp_ticks;
    6aa8:	4b29      	ldr	r3, [pc, #164]	; (6b50 <tcp_alloc+0x10c>)
    6aaa:	681b      	ldr	r3, [r3, #0]
    6aac:	6263      	str	r3, [r4, #36]	; 0x24
		pcb->last_timer = tcp_timer_ctr;
    6aae:	4b29      	ldr	r3, [pc, #164]	; (6b54 <tcp_alloc+0x110>)
    6ab0:	781b      	ldrb	r3, [r3, #0]
    6ab2:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
		pcb->polltmr = 0;
    6ab6:	77e5      	strb	r5, [r4, #31]
		pcb->recv = tcp_recv_null;
    6ab8:	4b27      	ldr	r3, [pc, #156]	; (6b58 <tcp_alloc+0x114>)
    6aba:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
		pcb->keep_idle = TCP_KEEPIDLE_DEFAULT;
    6abe:	4b27      	ldr	r3, [pc, #156]	; (6b5c <tcp_alloc+0x118>)
    6ac0:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
		pcb->keep_cnt_sent = 0;
    6ac4:	f884 5096 	strb.w	r5, [r4, #150]	; 0x96
}
    6ac8:	4620      	mov	r0, r4
    6aca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    6acc:	4b24      	ldr	r3, [pc, #144]	; (6b60 <tcp_alloc+0x11c>)
    6ace:	681b      	ldr	r3, [r3, #0]
    6ad0:	b17b      	cbz	r3, 6af2 <tcp_alloc+0xae>
		if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6ad2:	4a1f      	ldr	r2, [pc, #124]	; (6b50 <tcp_alloc+0x10c>)
    6ad4:	6810      	ldr	r0, [r2, #0]
    6ad6:	2100      	movs	r1, #0
    6ad8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    6ada:	1a82      	subs	r2, r0, r2
    6adc:	428a      	cmp	r2, r1
			inactivity = tcp_ticks - pcb->tmr;
    6ade:	bf24      	itt	cs
    6ae0:	4611      	movcs	r1, r2
		if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6ae2:	461c      	movcs	r4, r3
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    6ae4:	68db      	ldr	r3, [r3, #12]
    6ae6:	2b00      	cmp	r3, #0
    6ae8:	d1f6      	bne.n	6ad8 <tcp_alloc+0x94>
	if (inactive != NULL) {
    6aea:	b114      	cbz	r4, 6af2 <tcp_alloc+0xae>
		tcp_abort(inactive);
    6aec:	4620      	mov	r0, r4
    6aee:	4b1d      	ldr	r3, [pc, #116]	; (6b64 <tcp_alloc+0x120>)
    6af0:	4798      	blx	r3
		pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    6af2:	2002      	movs	r0, #2
    6af4:	4b13      	ldr	r3, [pc, #76]	; (6b44 <tcp_alloc+0x100>)
    6af6:	4798      	blx	r3
		if (pcb == NULL) {
    6af8:	4604      	mov	r4, r0
    6afa:	2800      	cmp	r0, #0
    6afc:	d1aa      	bne.n	6a54 <tcp_alloc+0x10>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    6afe:	4b1a      	ldr	r3, [pc, #104]	; (6b68 <tcp_alloc+0x124>)
    6b00:	681b      	ldr	r3, [r3, #0]
    6b02:	b1bb      	cbz	r3, 6b34 <tcp_alloc+0xf0>
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6b04:	4a12      	ldr	r2, [pc, #72]	; (6b50 <tcp_alloc+0x10c>)
    6b06:	6817      	ldr	r7, [r2, #0]
    6b08:	2600      	movs	r6, #0
    6b0a:	207f      	movs	r0, #127	; 0x7f
    6b0c:	e001      	b.n	6b12 <tcp_alloc+0xce>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    6b0e:	68db      	ldr	r3, [r3, #12]
    6b10:	b163      	cbz	r3, 6b2c <tcp_alloc+0xe8>
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6b12:	7e5a      	ldrb	r2, [r3, #25]
    6b14:	4295      	cmp	r5, r2
    6b16:	d3fa      	bcc.n	6b0e <tcp_alloc+0xca>
    6b18:	4282      	cmp	r2, r0
    6b1a:	d8f8      	bhi.n	6b0e <tcp_alloc+0xca>
    6b1c:	6a59      	ldr	r1, [r3, #36]	; 0x24
    6b1e:	1a79      	subs	r1, r7, r1
    6b20:	42b1      	cmp	r1, r6
    6b22:	d3f4      	bcc.n	6b0e <tcp_alloc+0xca>
			mprio      = pcb->prio;
    6b24:	4610      	mov	r0, r2
			inactivity = tcp_ticks - pcb->tmr;
    6b26:	460e      	mov	r6, r1
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6b28:	461c      	mov	r4, r3
    6b2a:	e7f0      	b.n	6b0e <tcp_alloc+0xca>
	if (inactive != NULL) {
    6b2c:	b114      	cbz	r4, 6b34 <tcp_alloc+0xf0>
		tcp_abort(inactive);
    6b2e:	4620      	mov	r0, r4
    6b30:	4b0c      	ldr	r3, [pc, #48]	; (6b64 <tcp_alloc+0x120>)
    6b32:	4798      	blx	r3
			pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    6b34:	2002      	movs	r0, #2
    6b36:	4b03      	ldr	r3, [pc, #12]	; (6b44 <tcp_alloc+0x100>)
    6b38:	4798      	blx	r3
	if (pcb != NULL) {
    6b3a:	4604      	mov	r4, r0
    6b3c:	2800      	cmp	r0, #0
    6b3e:	d0c3      	beq.n	6ac8 <tcp_alloc+0x84>
    6b40:	e788      	b.n	6a54 <tcp_alloc+0x10>
    6b42:	bf00      	nop
    6b44:	00005979 	.word	0x00005979
    6b48:	00009fc5 	.word	0x00009fc5
    6b4c:	00006a2d 	.word	0x00006a2d
    6b50:	20009304 	.word	0x20009304
    6b54:	20007f98 	.word	0x20007f98
    6b58:	00006831 	.word	0x00006831
    6b5c:	006ddd00 	.word	0x006ddd00
    6b60:	20009314 	.word	0x20009314
    6b64:	00006a1d 	.word	0x00006a1d
    6b68:	20009300 	.word	0x20009300

00006b6c <tcp_eff_send_mss>:
 * Calcluates the effective send mss that can be used for a specific IP address
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
    6b6c:	b510      	push	{r4, lr}
    6b6e:	4604      	mov	r4, r0
	u16_t         mss_s;
	struct netif *outif;

	outif = ip_route(addr);
    6b70:	4608      	mov	r0, r1
    6b72:	4b07      	ldr	r3, [pc, #28]	; (6b90 <tcp_eff_send_mss+0x24>)
    6b74:	4798      	blx	r3
	if ((outif != NULL) && (outif->mtu != 0)) {
    6b76:	b138      	cbz	r0, 6b88 <tcp_eff_send_mss+0x1c>
    6b78:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
    6b7a:	b138      	cbz	r0, 6b8c <tcp_eff_send_mss+0x20>
		mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    6b7c:	3828      	subs	r0, #40	; 0x28
		/* RFC 1122, chap 4.2.2.6:
		 * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
		 * We correct for TCP options in tcp_write(), and don't support IP options.
		 */
		sendmss = LWIP_MIN(sendmss, mss_s);
    6b7e:	b280      	uxth	r0, r0
    6b80:	42a0      	cmp	r0, r4
    6b82:	bf28      	it	cs
    6b84:	4620      	movcs	r0, r4
    6b86:	bd10      	pop	{r4, pc}
    6b88:	4620      	mov	r0, r4
    6b8a:	bd10      	pop	{r4, pc}
    6b8c:	4620      	mov	r0, r4
	}
	return sendmss;
}
    6b8e:	bd10      	pop	{r4, pc}
    6b90:	00004b8d 	.word	0x00004b8d

00006b94 <tcp_parseopt>:
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void tcp_parseopt(struct tcp_pcb *pcb)
{
    6b94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6b96:	4605      	mov	r5, r0
	u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
	u32_t tsval;
#endif

	opts = (u8_t *)tcphdr + TCP_HLEN;
    6b98:	4b22      	ldr	r3, [pc, #136]	; (6c24 <tcp_parseopt+0x90>)
    6b9a:	681c      	ldr	r4, [r3, #0]

	/* Parse the TCP MSS option, if present. */
	if (TCPH_HDRLEN(tcphdr) > 0x5) {
    6b9c:	89a0      	ldrh	r0, [r4, #12]
    6b9e:	4b22      	ldr	r3, [pc, #136]	; (6c28 <tcp_parseopt+0x94>)
    6ba0:	4798      	blx	r3
    6ba2:	f3c0 300f 	ubfx	r0, r0, #12, #16
    6ba6:	2805      	cmp	r0, #5
    6ba8:	d800      	bhi.n	6bac <tcp_parseopt+0x18>
    6baa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    6bac:	4b1d      	ldr	r3, [pc, #116]	; (6c24 <tcp_parseopt+0x90>)
    6bae:	681b      	ldr	r3, [r3, #0]
    6bb0:	8998      	ldrh	r0, [r3, #12]
    6bb2:	4b1d      	ldr	r3, [pc, #116]	; (6c28 <tcp_parseopt+0x94>)
    6bb4:	4798      	blx	r3
    6bb6:	0b06      	lsrs	r6, r0, #12
    6bb8:	3e05      	subs	r6, #5
    6bba:	00b6      	lsls	r6, r6, #2
    6bbc:	b2b6      	uxth	r6, r6
		for (c = 0; c < max_c;) {
    6bbe:	2e00      	cmp	r6, #0
    6bc0:	d0f3      	beq.n	6baa <tcp_parseopt+0x16>
	opts = (u8_t *)tcphdr + TCP_HLEN;
    6bc2:	f104 0214 	add.w	r2, r4, #20
    6bc6:	2300      	movs	r3, #0
					return;
				}
				/* An MSS option with the right option length. */
				mss = (opts[c + 2] << 8) | opts[c + 3];
				/* Limit the mss to the configured TCP_MSS and prevent division by zero */
				pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    6bc8:	f240 57b3 	movw	r7, #1459	; 0x5b3
    6bcc:	f240 54b4 	movw	r4, #1460	; 0x5b4
    6bd0:	e003      	b.n	6bda <tcp_parseopt+0x46>
				++c;
    6bd2:	3301      	adds	r3, #1
    6bd4:	b29b      	uxth	r3, r3
		for (c = 0; c < max_c;) {
    6bd6:	429e      	cmp	r6, r3
    6bd8:	d9e7      	bls.n	6baa <tcp_parseopt+0x16>
			opt = opts[c];
    6bda:	4618      	mov	r0, r3
			switch (opt) {
    6bdc:	5cd1      	ldrb	r1, [r2, r3]
    6bde:	2901      	cmp	r1, #1
    6be0:	d0f7      	beq.n	6bd2 <tcp_parseopt+0x3e>
    6be2:	2900      	cmp	r1, #0
    6be4:	d0e1      	beq.n	6baa <tcp_parseopt+0x16>
    6be6:	2902      	cmp	r1, #2
    6be8:	d006      	beq.n	6bf8 <tcp_parseopt+0x64>
				c += 0x0A;
				break;
#endif
			default:
				LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
				if (opts[c + 1] == 0) {
    6bea:	4410      	add	r0, r2
    6bec:	7841      	ldrb	r1, [r0, #1]
    6bee:	2900      	cmp	r1, #0
    6bf0:	d0db      	beq.n	6baa <tcp_parseopt+0x16>
					   and we don't process them further. */
					return;
				}
				/* All other options have a length field, so that we easily
				   can skip past them. */
				c += opts[c + 1];
    6bf2:	440b      	add	r3, r1
    6bf4:	b29b      	uxth	r3, r3
    6bf6:	e7ee      	b.n	6bd6 <tcp_parseopt+0x42>
				if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
    6bf8:	18d1      	adds	r1, r2, r3
    6bfa:	7849      	ldrb	r1, [r1, #1]
    6bfc:	2904      	cmp	r1, #4
    6bfe:	d1d4      	bne.n	6baa <tcp_parseopt+0x16>
    6c00:	1d19      	adds	r1, r3, #4
    6c02:	42b1      	cmp	r1, r6
    6c04:	dcd1      	bgt.n	6baa <tcp_parseopt+0x16>
				mss = (opts[c + 2] << 8) | opts[c + 3];
    6c06:	4410      	add	r0, r2
    6c08:	f890 e002 	ldrb.w	lr, [r0, #2]
    6c0c:	78c1      	ldrb	r1, [r0, #3]
    6c0e:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
				pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    6c12:	1e48      	subs	r0, r1, #1
    6c14:	b280      	uxth	r0, r0
    6c16:	42b8      	cmp	r0, r7
    6c18:	bf88      	it	hi
    6c1a:	4621      	movhi	r1, r4
    6c1c:	86e9      	strh	r1, [r5, #54]	; 0x36
				c += 0x04;
    6c1e:	3304      	adds	r3, #4
    6c20:	b29b      	uxth	r3, r3
				break;
    6c22:	e7d8      	b.n	6bd6 <tcp_parseopt+0x42>
    6c24:	20007f9c 	.word	0x20007f9c
    6c28:	00002eaf 	.word	0x00002eaf

00006c2c <tcp_oos_insert_segment>:
{
    6c2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6c30:	4605      	mov	r5, r0
    6c32:	4689      	mov	r9, r1
	if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    6c34:	6903      	ldr	r3, [r0, #16]
    6c36:	8998      	ldrh	r0, [r3, #12]
    6c38:	4b2a      	ldr	r3, [pc, #168]	; (6ce4 <tcp_oos_insert_segment+0xb8>)
    6c3a:	4798      	blx	r3
    6c3c:	f010 0f01 	tst.w	r0, #1
    6c40:	d116      	bne.n	6c70 <tcp_oos_insert_segment+0x44>
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    6c42:	f1b9 0f00 	cmp.w	r9, #0
    6c46:	d04a      	beq.n	6cde <tcp_oos_insert_segment+0xb2>
    6c48:	f8d9 2010 	ldr.w	r2, [r9, #16]
    6c4c:	892b      	ldrh	r3, [r5, #8]
    6c4e:	6851      	ldr	r1, [r2, #4]
    6c50:	1a5b      	subs	r3, r3, r1
    6c52:	4925      	ldr	r1, [pc, #148]	; (6ce8 <tcp_oos_insert_segment+0xbc>)
    6c54:	6849      	ldr	r1, [r1, #4]
    6c56:	440b      	add	r3, r1
    6c58:	f8b9 1008 	ldrh.w	r1, [r9, #8]
    6c5c:	1a5b      	subs	r3, r3, r1
    6c5e:	2b00      	cmp	r3, #0
    6c60:	bfb8      	it	lt
    6c62:	464c      	movlt	r4, r9
    6c64:	db29      	blt.n	6cba <tcp_oos_insert_segment+0x8e>
			if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    6c66:	4f1f      	ldr	r7, [pc, #124]	; (6ce4 <tcp_oos_insert_segment+0xb8>)
				TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    6c68:	f8df 808c 	ldr.w	r8, [pc, #140]	; 6cf8 <tcp_oos_insert_segment+0xcc>
			tcp_seg_free(old_seg);
    6c6c:	4e1f      	ldr	r6, [pc, #124]	; (6cec <tcp_oos_insert_segment+0xc0>)
    6c6e:	e015      	b.n	6c9c <tcp_oos_insert_segment+0x70>
		tcp_segs_free(next);
    6c70:	4648      	mov	r0, r9
    6c72:	4b1f      	ldr	r3, [pc, #124]	; (6cf0 <tcp_oos_insert_segment+0xc4>)
    6c74:	4798      	blx	r3
		next = NULL;
    6c76:	2400      	movs	r4, #0
    6c78:	e02e      	b.n	6cd8 <tcp_oos_insert_segment+0xac>
			next    = next->next;
    6c7a:	f8d9 4000 	ldr.w	r4, [r9]
			tcp_seg_free(old_seg);
    6c7e:	4648      	mov	r0, r9
    6c80:	47b0      	blx	r6
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    6c82:	b364      	cbz	r4, 6cde <tcp_oos_insert_segment+0xb2>
    6c84:	6922      	ldr	r2, [r4, #16]
    6c86:	892b      	ldrh	r3, [r5, #8]
    6c88:	4917      	ldr	r1, [pc, #92]	; (6ce8 <tcp_oos_insert_segment+0xbc>)
    6c8a:	6849      	ldr	r1, [r1, #4]
    6c8c:	440b      	add	r3, r1
    6c8e:	6851      	ldr	r1, [r2, #4]
    6c90:	1a5b      	subs	r3, r3, r1
    6c92:	8921      	ldrh	r1, [r4, #8]
    6c94:	1a5b      	subs	r3, r3, r1
    6c96:	2b00      	cmp	r3, #0
    6c98:	db0f      	blt.n	6cba <tcp_oos_insert_segment+0x8e>
			next    = next->next;
    6c9a:	46a1      	mov	r9, r4
			if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    6c9c:	8990      	ldrh	r0, [r2, #12]
    6c9e:	47b8      	blx	r7
    6ca0:	f010 0f01 	tst.w	r0, #1
    6ca4:	d0e9      	beq.n	6c7a <tcp_oos_insert_segment+0x4e>
				TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    6ca6:	f8d5 a010 	ldr.w	sl, [r5, #16]
    6caa:	f8ba 400c 	ldrh.w	r4, [sl, #12]
    6cae:	2001      	movs	r0, #1
    6cb0:	47c0      	blx	r8
    6cb2:	4320      	orrs	r0, r4
    6cb4:	f8aa 000c 	strh.w	r0, [sl, #12]
    6cb8:	e7df      	b.n	6c7a <tcp_oos_insert_segment+0x4e>
		if (next && TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
    6cba:	4b0b      	ldr	r3, [pc, #44]	; (6ce8 <tcp_oos_insert_segment+0xbc>)
    6cbc:	6859      	ldr	r1, [r3, #4]
    6cbe:	6923      	ldr	r3, [r4, #16]
    6cc0:	685a      	ldr	r2, [r3, #4]
    6cc2:	892b      	ldrh	r3, [r5, #8]
    6cc4:	440b      	add	r3, r1
    6cc6:	1a9b      	subs	r3, r3, r2
    6cc8:	2b00      	cmp	r3, #0
    6cca:	dd05      	ble.n	6cd8 <tcp_oos_insert_segment+0xac>
			cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    6ccc:	1a52      	subs	r2, r2, r1
    6cce:	b291      	uxth	r1, r2
    6cd0:	8129      	strh	r1, [r5, #8]
			pbuf_realloc(cseg->p, cseg->len);
    6cd2:	6868      	ldr	r0, [r5, #4]
    6cd4:	4b07      	ldr	r3, [pc, #28]	; (6cf4 <tcp_oos_insert_segment+0xc8>)
    6cd6:	4798      	blx	r3
	cseg->next = next;
    6cd8:	602c      	str	r4, [r5, #0]
}
    6cda:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		next = NULL;
    6cde:	2400      	movs	r4, #0
    6ce0:	e7fa      	b.n	6cd8 <tcp_oos_insert_segment+0xac>
    6ce2:	bf00      	nop
    6ce4:	00002eaf 	.word	0x00002eaf
    6ce8:	20007f9c 	.word	0x20007f9c
    6cec:	000061a9 	.word	0x000061a9
    6cf0:	000061cd 	.word	0x000061cd
    6cf4:	00005e2d 	.word	0x00005e2d
    6cf8:	00002ea5 	.word	0x00002ea5

00006cfc <tcp_receive>:
{
    6cfc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6d00:	4604      	mov	r4, r0
	if (flags & TCP_ACK) {
    6d02:	4baa      	ldr	r3, [pc, #680]	; (6fac <tcp_receive+0x2b0>)
    6d04:	7a1b      	ldrb	r3, [r3, #8]
    6d06:	f013 0f10 	tst.w	r3, #16
    6d0a:	f000 8163 	beq.w	6fd4 <tcp_receive+0x2d8>
		right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    6d0e:	f8b0 5060 	ldrh.w	r5, [r0, #96]	; 0x60
    6d12:	6d80      	ldr	r0, [r0, #88]	; 0x58
		if (TCP_SEQ_LT(pcb->snd_wl1, seqno) || (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno))
    6d14:	6d62      	ldr	r2, [r4, #84]	; 0x54
    6d16:	4ba5      	ldr	r3, [pc, #660]	; (6fac <tcp_receive+0x2b0>)
    6d18:	685b      	ldr	r3, [r3, #4]
    6d1a:	1ad1      	subs	r1, r2, r3
    6d1c:	2900      	cmp	r1, #0
    6d1e:	db28      	blt.n	6d72 <tcp_receive+0x76>
    6d20:	429a      	cmp	r2, r3
    6d22:	d01b      	beq.n	6d5c <tcp_receive+0x60>
		    || (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    6d24:	4aa1      	ldr	r2, [pc, #644]	; (6fac <tcp_receive+0x2b0>)
    6d26:	68d2      	ldr	r2, [r2, #12]
    6d28:	4290      	cmp	r0, r2
    6d2a:	d01d      	beq.n	6d68 <tcp_receive+0x6c>
		if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
    6d2c:	4b9f      	ldr	r3, [pc, #636]	; (6fac <tcp_receive+0x2b0>)
    6d2e:	68da      	ldr	r2, [r3, #12]
    6d30:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    6d32:	1ad1      	subs	r1, r2, r3
    6d34:	2900      	cmp	r1, #0
    6d36:	dd41      	ble.n	6dbc <tcp_receive+0xc0>
		} else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
    6d38:	2901      	cmp	r1, #1
    6d3a:	d403      	bmi.n	6d44 <tcp_receive+0x48>
    6d3c:	6d21      	ldr	r1, [r4, #80]	; 0x50
    6d3e:	1a51      	subs	r1, r2, r1
    6d40:	2900      	cmp	r1, #0
    6d42:	dd6e      	ble.n	6e22 <tcp_receive+0x126>
			pcb->acked = 0;
    6d44:	2300      	movs	r3, #0
    6d46:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
		while (pcb->unsent != NULL
    6d4a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    6d4c:	2b00      	cmp	r3, #0
    6d4e:	f000 8139 	beq.w	6fc4 <tcp_receive+0x2c8>
		       && TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
    6d52:	4e96      	ldr	r6, [pc, #600]	; (6fac <tcp_receive+0x2b0>)
    6d54:	f8df 8268 	ldr.w	r8, [pc, #616]	; 6fc0 <tcp_receive+0x2c4>
    6d58:	4f95      	ldr	r7, [pc, #596]	; (6fb0 <tcp_receive+0x2b4>)
    6d5a:	e0f8      	b.n	6f4e <tcp_receive+0x252>
		if (TCP_SEQ_LT(pcb->snd_wl1, seqno) || (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno))
    6d5c:	4a93      	ldr	r2, [pc, #588]	; (6fac <tcp_receive+0x2b0>)
    6d5e:	68d2      	ldr	r2, [r2, #12]
    6d60:	1a82      	subs	r2, r0, r2
    6d62:	2a00      	cmp	r2, #0
    6d64:	dade      	bge.n	6d24 <tcp_receive+0x28>
    6d66:	e004      	b.n	6d72 <tcp_receive+0x76>
		    || (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    6d68:	4a90      	ldr	r2, [pc, #576]	; (6fac <tcp_receive+0x2b0>)
    6d6a:	6812      	ldr	r2, [r2, #0]
    6d6c:	89d2      	ldrh	r2, [r2, #14]
    6d6e:	42aa      	cmp	r2, r5
    6d70:	d9dc      	bls.n	6d2c <tcp_receive+0x30>
			pcb->snd_wnd = tcphdr->wnd;
    6d72:	4a8e      	ldr	r2, [pc, #568]	; (6fac <tcp_receive+0x2b0>)
    6d74:	6812      	ldr	r2, [r2, #0]
    6d76:	89d1      	ldrh	r1, [r2, #14]
    6d78:	b28e      	uxth	r6, r1
    6d7a:	f8a4 1060 	strh.w	r1, [r4, #96]	; 0x60
			if (pcb->snd_wnd_max < tcphdr->wnd) {
    6d7e:	89d2      	ldrh	r2, [r2, #14]
    6d80:	b291      	uxth	r1, r2
    6d82:	f8b4 7062 	ldrh.w	r7, [r4, #98]	; 0x62
    6d86:	428f      	cmp	r7, r1
				pcb->snd_wnd_max = tcphdr->wnd;
    6d88:	bf38      	it	cc
    6d8a:	f8a4 2062 	strhcc.w	r2, [r4, #98]	; 0x62
			pcb->snd_wl1 = seqno;
    6d8e:	6563      	str	r3, [r4, #84]	; 0x54
			pcb->snd_wl2 = ackno;
    6d90:	4b86      	ldr	r3, [pc, #536]	; (6fac <tcp_receive+0x2b0>)
    6d92:	68db      	ldr	r3, [r3, #12]
    6d94:	65a3      	str	r3, [r4, #88]	; 0x58
			if (pcb->snd_wnd == 0) {
    6d96:	b94e      	cbnz	r6, 6dac <tcp_receive+0xb0>
				if (pcb->persist_backoff == 0) {
    6d98:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
    6d9c:	2b00      	cmp	r3, #0
    6d9e:	d1c5      	bne.n	6d2c <tcp_receive+0x30>
					pcb->persist_cnt     = 0;
    6da0:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
					pcb->persist_backoff = 1;
    6da4:	2301      	movs	r3, #1
    6da6:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
    6daa:	e7bf      	b.n	6d2c <tcp_receive+0x30>
			} else if (pcb->persist_backoff > 0) {
    6dac:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
    6db0:	2b00      	cmp	r3, #0
    6db2:	d0bb      	beq.n	6d2c <tcp_receive+0x30>
				pcb->persist_backoff = 0;
    6db4:	2300      	movs	r3, #0
    6db6:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
    6dba:	e7b7      	b.n	6d2c <tcp_receive+0x30>
			pcb->acked = 0;
    6dbc:	2100      	movs	r1, #0
    6dbe:	f8a4 1064 	strh.w	r1, [r4, #100]	; 0x64
			if (tcplen == 0) {
    6dc2:	497a      	ldr	r1, [pc, #488]	; (6fac <tcp_receive+0x2b0>)
    6dc4:	8a09      	ldrh	r1, [r1, #16]
    6dc6:	b931      	cbnz	r1, 6dd6 <tcp_receive+0xda>
		right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    6dc8:	4428      	add	r0, r5
				if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
    6dca:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
    6dce:	6da5      	ldr	r5, [r4, #88]	; 0x58
    6dd0:	4429      	add	r1, r5
    6dd2:	4288      	cmp	r0, r1
    6dd4:	d003      	beq.n	6dde <tcp_receive+0xe2>
				pcb->dupacks = 0;
    6dd6:	2300      	movs	r3, #0
    6dd8:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
    6ddc:	e7b5      	b.n	6d4a <tcp_receive+0x4e>
					if (pcb->rtime >= 0) {
    6dde:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
    6de2:	2900      	cmp	r1, #0
    6de4:	dbf7      	blt.n	6dd6 <tcp_receive+0xda>
						if (pcb->lastack == ackno) {
    6de6:	429a      	cmp	r2, r3
    6de8:	d1f5      	bne.n	6dd6 <tcp_receive+0xda>
							if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
    6dea:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    6dee:	1c53      	adds	r3, r2, #1
    6df0:	b2db      	uxtb	r3, r3
    6df2:	429a      	cmp	r2, r3
								++pcb->dupacks;
    6df4:	bf38      	it	cc
    6df6:	f884 3047 	strbcc.w	r3, [r4, #71]	; 0x47
							if (pcb->dupacks > 3) {
    6dfa:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
    6dfe:	2b03      	cmp	r3, #3
    6e00:	d909      	bls.n	6e16 <tcp_receive+0x11a>
								if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    6e02:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    6e06:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    6e08:	4413      	add	r3, r2
    6e0a:	b29b      	uxth	r3, r3
    6e0c:	429a      	cmp	r2, r3
    6e0e:	d29c      	bcs.n	6d4a <tcp_receive+0x4e>
									pcb->cwnd += pcb->mss;
    6e10:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    6e14:	e799      	b.n	6d4a <tcp_receive+0x4e>
							} else if (pcb->dupacks == 3) {
    6e16:	2b03      	cmp	r3, #3
    6e18:	d197      	bne.n	6d4a <tcp_receive+0x4e>
								tcp_rexmit_fast(pcb);
    6e1a:	4620      	mov	r0, r4
    6e1c:	4b65      	ldr	r3, [pc, #404]	; (6fb4 <tcp_receive+0x2b8>)
    6e1e:	4798      	blx	r3
    6e20:	e793      	b.n	6d4a <tcp_receive+0x4e>
			if (pcb->flags & TF_INFR) {
    6e22:	7fa1      	ldrb	r1, [r4, #30]
    6e24:	f011 0f04 	tst.w	r1, #4
    6e28:	d006      	beq.n	6e38 <tcp_receive+0x13c>
				pcb->flags &= ~TF_INFR;
    6e2a:	f021 0104 	bic.w	r1, r1, #4
    6e2e:	77a1      	strb	r1, [r4, #30]
				pcb->cwnd = pcb->ssthresh;
    6e30:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
    6e34:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
			pcb->nrtx = 0;
    6e38:	2000      	movs	r0, #0
    6e3a:	f884 0046 	strb.w	r0, [r4, #70]	; 0x46
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    6e3e:	f9b4 5040 	ldrsh.w	r5, [r4, #64]	; 0x40
    6e42:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
    6e46:	eb01 01e5 	add.w	r1, r1, r5, asr #3
    6e4a:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
			pcb->acked = (u16_t)(ackno - pcb->lastack);
    6e4e:	1ad3      	subs	r3, r2, r3
    6e50:	b29b      	uxth	r3, r3
    6e52:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
			pcb->snd_buf += pcb->acked;
    6e56:	f8b4 1066 	ldrh.w	r1, [r4, #102]	; 0x66
    6e5a:	440b      	add	r3, r1
    6e5c:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
			pcb->dupacks = 0;
    6e60:	f884 0047 	strb.w	r0, [r4, #71]	; 0x47
			pcb->lastack = ackno;
    6e64:	64a2      	str	r2, [r4, #72]	; 0x48
			if (pcb->state >= ESTABLISHED) {
    6e66:	7e23      	ldrb	r3, [r4, #24]
    6e68:	2b03      	cmp	r3, #3
    6e6a:	d90c      	bls.n	6e86 <tcp_receive+0x18a>
				if (pcb->cwnd < pcb->ssthresh) {
    6e6c:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    6e70:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
    6e74:	4293      	cmp	r3, r2
    6e76:	d90e      	bls.n	6e96 <tcp_receive+0x19a>
					if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    6e78:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    6e7a:	4413      	add	r3, r2
    6e7c:	b29b      	uxth	r3, r3
    6e7e:	429a      	cmp	r2, r3
						pcb->cwnd += pcb->mss;
    6e80:	bf38      	it	cc
    6e82:	f8a4 304c 	strhcc.w	r3, [r4, #76]	; 0x4c
			while (pcb->unacked != NULL
    6e86:	6f23      	ldr	r3, [r4, #112]	; 0x70
    6e88:	2b00      	cmp	r3, #0
    6e8a:	d04b      	beq.n	6f24 <tcp_receive+0x228>
			       && TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked), ackno)) {
    6e8c:	f8df 8130 	ldr.w	r8, [pc, #304]	; 6fc0 <tcp_receive+0x2c4>
    6e90:	4e47      	ldr	r6, [pc, #284]	; (6fb0 <tcp_receive+0x2b4>)
    6e92:	4f46      	ldr	r7, [pc, #280]	; (6fac <tcp_receive+0x2b0>)
    6e94:	e018      	b.n	6ec8 <tcp_receive+0x1cc>
					u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
    6e96:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    6e98:	fb03 f303 	mul.w	r3, r3, r3
    6e9c:	fb93 f3f2 	sdiv	r3, r3, r2
    6ea0:	4413      	add	r3, r2
    6ea2:	b29b      	uxth	r3, r3
					if (new_cwnd > pcb->cwnd) {
    6ea4:	429a      	cmp	r2, r3
    6ea6:	d2ee      	bcs.n	6e86 <tcp_receive+0x18a>
						pcb->cwnd = new_cwnd;
    6ea8:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    6eac:	e7eb      	b.n	6e86 <tcp_receive+0x18a>
				pcb->snd_queuelen -= pbuf_clen(next->p);
    6eae:	6868      	ldr	r0, [r5, #4]
    6eb0:	4b41      	ldr	r3, [pc, #260]	; (6fb8 <tcp_receive+0x2bc>)
    6eb2:	4798      	blx	r3
    6eb4:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    6eb8:	1a18      	subs	r0, r3, r0
    6eba:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
				tcp_seg_free(next);
    6ebe:	4628      	mov	r0, r5
    6ec0:	4b3e      	ldr	r3, [pc, #248]	; (6fbc <tcp_receive+0x2c0>)
    6ec2:	4798      	blx	r3
			while (pcb->unacked != NULL
    6ec4:	6f23      	ldr	r3, [r4, #112]	; 0x70
    6ec6:	b36b      	cbz	r3, 6f24 <tcp_receive+0x228>
			       && TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked), ackno)) {
    6ec8:	691b      	ldr	r3, [r3, #16]
    6eca:	6858      	ldr	r0, [r3, #4]
    6ecc:	47c0      	blx	r8
    6ece:	4605      	mov	r5, r0
    6ed0:	6f23      	ldr	r3, [r4, #112]	; 0x70
    6ed2:	f8b3 9008 	ldrh.w	r9, [r3, #8]
    6ed6:	691b      	ldr	r3, [r3, #16]
    6ed8:	8998      	ldrh	r0, [r3, #12]
    6eda:	47b0      	blx	r6
    6edc:	f010 0003 	ands.w	r0, r0, #3
    6ee0:	bf18      	it	ne
    6ee2:	2001      	movne	r0, #1
    6ee4:	4448      	add	r0, r9
    6ee6:	68fb      	ldr	r3, [r7, #12]
    6ee8:	1aed      	subs	r5, r5, r3
    6eea:	4428      	add	r0, r5
    6eec:	2800      	cmp	r0, #0
    6eee:	dc12      	bgt.n	6f16 <tcp_receive+0x21a>
				next         = pcb->unacked;
    6ef0:	6f25      	ldr	r5, [r4, #112]	; 0x70
				pcb->unacked = pcb->unacked->next;
    6ef2:	682b      	ldr	r3, [r5, #0]
    6ef4:	6723      	str	r3, [r4, #112]	; 0x70
				if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    6ef6:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    6efa:	2b00      	cmp	r3, #0
    6efc:	d0d7      	beq.n	6eae <tcp_receive+0x1b2>
    6efe:	692b      	ldr	r3, [r5, #16]
    6f00:	8998      	ldrh	r0, [r3, #12]
    6f02:	47b0      	blx	r6
    6f04:	f010 0f01 	tst.w	r0, #1
    6f08:	d0d1      	beq.n	6eae <tcp_receive+0x1b2>
					pcb->acked--;
    6f0a:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    6f0e:	3b01      	subs	r3, #1
    6f10:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    6f14:	e7cb      	b.n	6eae <tcp_receive+0x1b2>
			if (pcb->unacked == NULL)
    6f16:	6f23      	ldr	r3, [r4, #112]	; 0x70
    6f18:	b123      	cbz	r3, 6f24 <tcp_receive+0x228>
				pcb->rtime = 0;
    6f1a:	2300      	movs	r3, #0
    6f1c:	86a3      	strh	r3, [r4, #52]	; 0x34
			pcb->polltmr = 0;
    6f1e:	2300      	movs	r3, #0
    6f20:	77e3      	strb	r3, [r4, #31]
    6f22:	e712      	b.n	6d4a <tcp_receive+0x4e>
				pcb->rtime = -1;
    6f24:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6f28:	86a3      	strh	r3, [r4, #52]	; 0x34
    6f2a:	e7f8      	b.n	6f1e <tcp_receive+0x222>
				pcb->unsent_oversize = 0;
    6f2c:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
    6f30:	e02c      	b.n	6f8c <tcp_receive+0x290>
			pcb->snd_queuelen -= pbuf_clen(next->p);
    6f32:	6868      	ldr	r0, [r5, #4]
    6f34:	4b20      	ldr	r3, [pc, #128]	; (6fb8 <tcp_receive+0x2bc>)
    6f36:	4798      	blx	r3
    6f38:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    6f3c:	1a18      	subs	r0, r3, r0
    6f3e:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
			tcp_seg_free(next);
    6f42:	4628      	mov	r0, r5
    6f44:	4b1d      	ldr	r3, [pc, #116]	; (6fbc <tcp_receive+0x2c0>)
    6f46:	4798      	blx	r3
		while (pcb->unsent != NULL
    6f48:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    6f4a:	2b00      	cmp	r3, #0
    6f4c:	d03a      	beq.n	6fc4 <tcp_receive+0x2c8>
		       && TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
    6f4e:	68f5      	ldr	r5, [r6, #12]
    6f50:	691b      	ldr	r3, [r3, #16]
    6f52:	6858      	ldr	r0, [r3, #4]
    6f54:	47c0      	blx	r8
    6f56:	4682      	mov	sl, r0
    6f58:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    6f5a:	f8b3 9008 	ldrh.w	r9, [r3, #8]
    6f5e:	691b      	ldr	r3, [r3, #16]
    6f60:	8998      	ldrh	r0, [r3, #12]
    6f62:	47b8      	blx	r7
    6f64:	eba5 050a 	sub.w	r5, r5, sl
    6f68:	f010 0003 	ands.w	r0, r0, #3
    6f6c:	bf18      	it	ne
    6f6e:	2001      	movne	r0, #1
    6f70:	4448      	add	r0, r9
    6f72:	1a2d      	subs	r5, r5, r0
    6f74:	2d00      	cmp	r5, #0
    6f76:	db25      	blt.n	6fc4 <tcp_receive+0x2c8>
    6f78:	68f3      	ldr	r3, [r6, #12]
    6f7a:	6d22      	ldr	r2, [r4, #80]	; 0x50
    6f7c:	1a9b      	subs	r3, r3, r2
    6f7e:	2b00      	cmp	r3, #0
    6f80:	dc20      	bgt.n	6fc4 <tcp_receive+0x2c8>
			next        = pcb->unsent;
    6f82:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
			pcb->unsent = pcb->unsent->next;
    6f84:	682b      	ldr	r3, [r5, #0]
    6f86:	66e3      	str	r3, [r4, #108]	; 0x6c
			if (pcb->unsent == NULL) {
    6f88:	2b00      	cmp	r3, #0
    6f8a:	d0cf      	beq.n	6f2c <tcp_receive+0x230>
			if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    6f8c:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    6f90:	2b00      	cmp	r3, #0
    6f92:	d0ce      	beq.n	6f32 <tcp_receive+0x236>
    6f94:	692b      	ldr	r3, [r5, #16]
    6f96:	8998      	ldrh	r0, [r3, #12]
    6f98:	47b8      	blx	r7
    6f9a:	f010 0f01 	tst.w	r0, #1
    6f9e:	d0c8      	beq.n	6f32 <tcp_receive+0x236>
				pcb->acked--;
    6fa0:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    6fa4:	3b01      	subs	r3, #1
    6fa6:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    6faa:	e7c2      	b.n	6f32 <tcp_receive+0x236>
    6fac:	20007f9c 	.word	0x20007f9c
    6fb0:	00002eaf 	.word	0x00002eaf
    6fb4:	00008611 	.word	0x00008611
    6fb8:	00005e8d 	.word	0x00005e8d
    6fbc:	000061a9 	.word	0x000061a9
    6fc0:	00002ed1 	.word	0x00002ed1
		if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
    6fc4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    6fc6:	b12b      	cbz	r3, 6fd4 <tcp_receive+0x2d8>
    6fc8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    6fca:	499a      	ldr	r1, [pc, #616]	; (7234 <tcp_receive+0x538>)
    6fcc:	68c9      	ldr	r1, [r1, #12]
    6fce:	1a52      	subs	r2, r2, r1
    6fd0:	2a00      	cmp	r2, #0
    6fd2:	db23      	blt.n	701c <tcp_receive+0x320>
	if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
    6fd4:	4b97      	ldr	r3, [pc, #604]	; (7234 <tcp_receive+0x538>)
    6fd6:	8a1b      	ldrh	r3, [r3, #16]
    6fd8:	2b00      	cmp	r3, #0
    6fda:	f000 8244 	beq.w	7466 <tcp_receive+0x76a>
    6fde:	7e22      	ldrb	r2, [r4, #24]
    6fe0:	2a06      	cmp	r2, #6
    6fe2:	f200 8240 	bhi.w	7466 <tcp_receive+0x76a>
		if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
    6fe6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    6fe8:	4a92      	ldr	r2, [pc, #584]	; (7234 <tcp_receive+0x538>)
    6fea:	6852      	ldr	r2, [r2, #4]
    6fec:	1a8d      	subs	r5, r1, r2
    6fee:	2d01      	cmp	r5, #1
    6ff0:	d405      	bmi.n	6ffe <tcp_receive+0x302>
    6ff2:	f1c2 0001 	rsb	r0, r2, #1
    6ff6:	1ac3      	subs	r3, r0, r3
    6ff8:	440b      	add	r3, r1
    6ffa:	2b00      	cmp	r3, #0
    6ffc:	dd2e      	ble.n	705c <tcp_receive+0x360>
			if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
    6ffe:	1a53      	subs	r3, r2, r1
    7000:	2b00      	cmp	r3, #0
    7002:	db54      	blt.n	70ae <tcp_receive+0x3b2>
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    7004:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    7006:	f1c3 0301 	rsb	r3, r3, #1
    700a:	4413      	add	r3, r2
    700c:	1a5b      	subs	r3, r3, r1
    700e:	2b00      	cmp	r3, #0
    7010:	dd52      	ble.n	70b8 <tcp_receive+0x3bc>
			tcp_send_empty_ack(pcb);
    7012:	4620      	mov	r0, r4
    7014:	4b88      	ldr	r3, [pc, #544]	; (7238 <tcp_receive+0x53c>)
    7016:	4798      	blx	r3
    7018:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			m = m - (pcb->sa >> 3);
    701c:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
			m = (s16_t)(tcp_ticks - pcb->rttest);
    7020:	4a86      	ldr	r2, [pc, #536]	; (723c <tcp_receive+0x540>)
    7022:	6812      	ldr	r2, [r2, #0]
    7024:	1ad3      	subs	r3, r2, r3
			m = m - (pcb->sa >> 3);
    7026:	eba3 03e1 	sub.w	r3, r3, r1, asr #3
    702a:	b29b      	uxth	r3, r3
    702c:	b218      	sxth	r0, r3
			pcb->sa += m;
    702e:	185a      	adds	r2, r3, r1
    7030:	b212      	sxth	r2, r2
    7032:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
			if (m < 0) {
    7036:	2800      	cmp	r0, #0
				m = -m;
    7038:	bfbc      	itt	lt
    703a:	425b      	neglt	r3, r3
    703c:	b218      	sxthlt	r0, r3
			m = m - (pcb->sv >> 2);
    703e:	f9b4 3042 	ldrsh.w	r3, [r4, #66]	; 0x42
			pcb->sv += m;
    7042:	eba3 03a3 	sub.w	r3, r3, r3, asr #2
    7046:	4403      	add	r3, r0
    7048:	b29b      	uxth	r3, r3
    704a:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    704e:	eb03 03e2 	add.w	r3, r3, r2, asr #3
    7052:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
			pcb->rttest = 0;
    7056:	2300      	movs	r3, #0
    7058:	63a3      	str	r3, [r4, #56]	; 0x38
    705a:	e7bb      	b.n	6fd4 <tcp_receive+0x2d8>
			off = pcb->rcv_nxt - seqno;
    705c:	462b      	mov	r3, r5
			p   = inseg.p;
    705e:	4a75      	ldr	r2, [pc, #468]	; (7234 <tcp_receive+0x538>)
    7060:	6990      	ldr	r0, [r2, #24]
			if (inseg.p->len < off) {
    7062:	8942      	ldrh	r2, [r0, #10]
    7064:	4295      	cmp	r5, r2
    7066:	dd1d      	ble.n	70a4 <tcp_receive+0x3a8>
				new_tot_len = (u16_t)(inseg.p->tot_len - off);
    7068:	8901      	ldrh	r1, [r0, #8]
    706a:	1b49      	subs	r1, r1, r5
    706c:	b289      	uxth	r1, r1
					p->len     = 0;
    706e:	2500      	movs	r5, #0
					off -= p->len;
    7070:	1a9b      	subs	r3, r3, r2
					p->tot_len = new_tot_len;
    7072:	8101      	strh	r1, [r0, #8]
					p->len     = 0;
    7074:	8145      	strh	r5, [r0, #10]
					p          = p->next;
    7076:	6800      	ldr	r0, [r0, #0]
				while (p->len < off) {
    7078:	8942      	ldrh	r2, [r0, #10]
    707a:	429a      	cmp	r2, r3
    707c:	dbf8      	blt.n	7070 <tcp_receive+0x374>
				if (pbuf_header(p, (s16_t)-off)) {
    707e:	425b      	negs	r3, r3
    7080:	b219      	sxth	r1, r3
    7082:	4b6f      	ldr	r3, [pc, #444]	; (7240 <tcp_receive+0x544>)
    7084:	4798      	blx	r3
			inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    7086:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    7088:	4b6a      	ldr	r3, [pc, #424]	; (7234 <tcp_receive+0x538>)
    708a:	6859      	ldr	r1, [r3, #4]
    708c:	8b98      	ldrh	r0, [r3, #28]
    708e:	4401      	add	r1, r0
    7090:	1a89      	subs	r1, r1, r2
    7092:	8399      	strh	r1, [r3, #28]
			inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    7094:	6a59      	ldr	r1, [r3, #36]	; 0x24
    7096:	605a      	str	r2, [r3, #4]
    7098:	604a      	str	r2, [r1, #4]
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    709a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    709c:	1a53      	subs	r3, r2, r1
    709e:	2b00      	cmp	r3, #0
    70a0:	dab0      	bge.n	7004 <tcp_receive+0x308>
    70a2:	e7b6      	b.n	7012 <tcp_receive+0x316>
				if (pbuf_header(inseg.p, (s16_t)-off)) {
    70a4:	4269      	negs	r1, r5
    70a6:	b209      	sxth	r1, r1
    70a8:	4b65      	ldr	r3, [pc, #404]	; (7240 <tcp_receive+0x544>)
    70aa:	4798      	blx	r3
    70ac:	e7eb      	b.n	7086 <tcp_receive+0x38a>
				tcp_ack_now(pcb);
    70ae:	7fa3      	ldrb	r3, [r4, #30]
    70b0:	f043 0302 	orr.w	r3, r3, #2
    70b4:	77a3      	strb	r3, [r4, #30]
    70b6:	e7ac      	b.n	7012 <tcp_receive+0x316>
			if (pcb->rcv_nxt == seqno) {
    70b8:	428a      	cmp	r2, r1
    70ba:	d013      	beq.n	70e4 <tcp_receive+0x3e8>
				tcp_send_empty_ack(pcb);
    70bc:	4620      	mov	r0, r4
    70be:	4b5e      	ldr	r3, [pc, #376]	; (7238 <tcp_receive+0x53c>)
    70c0:	4798      	blx	r3
				if (pcb->ooseq == NULL) {
    70c2:	6f66      	ldr	r6, [r4, #116]	; 0x74
    70c4:	2e00      	cmp	r6, #0
    70c6:	f000 8119 	beq.w	72fc <tcp_receive+0x600>
						if (seqno == next->tcphdr->seqno) {
    70ca:	6931      	ldr	r1, [r6, #16]
    70cc:	684a      	ldr	r2, [r1, #4]
    70ce:	4b59      	ldr	r3, [pc, #356]	; (7234 <tcp_receive+0x538>)
    70d0:	6858      	ldr	r0, [r3, #4]
    70d2:	4282      	cmp	r2, r0
    70d4:	f000 8118 	beq.w	7308 <tcp_receive+0x60c>
    70d8:	2700      	movs	r7, #0
								if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
    70da:	f100 3eff 	add.w	lr, r0, #4294967295
    70de:	f100 0c01 	add.w	ip, r0, #1
    70e2:	e134      	b.n	734e <tcp_receive+0x652>
				tcplen = TCP_TCPLEN(&inseg);
    70e4:	4e53      	ldr	r6, [pc, #332]	; (7234 <tcp_receive+0x538>)
    70e6:	8bb5      	ldrh	r5, [r6, #28]
    70e8:	6a73      	ldr	r3, [r6, #36]	; 0x24
    70ea:	8998      	ldrh	r0, [r3, #12]
    70ec:	4b55      	ldr	r3, [pc, #340]	; (7244 <tcp_receive+0x548>)
    70ee:	4798      	blx	r3
    70f0:	f010 0303 	ands.w	r3, r0, #3
    70f4:	bf18      	it	ne
    70f6:	2301      	movne	r3, #1
    70f8:	442b      	add	r3, r5
    70fa:	b29b      	uxth	r3, r3
    70fc:	8233      	strh	r3, [r6, #16]
				if (tcplen > pcb->rcv_wnd) {
    70fe:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    7100:	429a      	cmp	r2, r3
    7102:	d317      	bcc.n	7134 <tcp_receive+0x438>
				if (pcb->ooseq != NULL) {
    7104:	6f63      	ldr	r3, [r4, #116]	; 0x74
    7106:	2b00      	cmp	r3, #0
    7108:	f000 81c1 	beq.w	748e <tcp_receive+0x792>
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    710c:	4b49      	ldr	r3, [pc, #292]	; (7234 <tcp_receive+0x538>)
    710e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7110:	8998      	ldrh	r0, [r3, #12]
    7112:	4b4c      	ldr	r3, [pc, #304]	; (7244 <tcp_receive+0x548>)
    7114:	4798      	blx	r3
    7116:	f010 0f01 	tst.w	r0, #1
    711a:	d03f      	beq.n	719c <tcp_receive+0x4a0>
						while (pcb->ooseq != NULL) {
    711c:	6f60      	ldr	r0, [r4, #116]	; 0x74
    711e:	2800      	cmp	r0, #0
    7120:	f000 81b5 	beq.w	748e <tcp_receive+0x792>
							tcp_seg_free(old_ooseq);
    7124:	4d48      	ldr	r5, [pc, #288]	; (7248 <tcp_receive+0x54c>)
							pcb->ooseq                = pcb->ooseq->next;
    7126:	6803      	ldr	r3, [r0, #0]
    7128:	6763      	str	r3, [r4, #116]	; 0x74
							tcp_seg_free(old_ooseq);
    712a:	47a8      	blx	r5
						while (pcb->ooseq != NULL) {
    712c:	6f60      	ldr	r0, [r4, #116]	; 0x74
    712e:	2800      	cmp	r0, #0
    7130:	d1f9      	bne.n	7126 <tcp_receive+0x42a>
    7132:	e1ac      	b.n	748e <tcp_receive+0x792>
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    7134:	6a73      	ldr	r3, [r6, #36]	; 0x24
    7136:	8998      	ldrh	r0, [r3, #12]
    7138:	4b42      	ldr	r3, [pc, #264]	; (7244 <tcp_receive+0x548>)
    713a:	4798      	blx	r3
    713c:	f010 0f01 	tst.w	r0, #1
    7140:	d11e      	bne.n	7180 <tcp_receive+0x484>
					inseg.len = pcb->rcv_wnd;
    7142:	4b3c      	ldr	r3, [pc, #240]	; (7234 <tcp_receive+0x538>)
    7144:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    7146:	839a      	strh	r2, [r3, #28]
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    7148:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    714a:	8998      	ldrh	r0, [r3, #12]
    714c:	4b3d      	ldr	r3, [pc, #244]	; (7244 <tcp_receive+0x548>)
    714e:	4798      	blx	r3
    7150:	f010 0f02 	tst.w	r0, #2
    7154:	d003      	beq.n	715e <tcp_receive+0x462>
						inseg.len -= 1;
    7156:	4a37      	ldr	r2, [pc, #220]	; (7234 <tcp_receive+0x538>)
    7158:	8b93      	ldrh	r3, [r2, #28]
    715a:	3b01      	subs	r3, #1
    715c:	8393      	strh	r3, [r2, #28]
					pbuf_realloc(inseg.p, inseg.len);
    715e:	4d35      	ldr	r5, [pc, #212]	; (7234 <tcp_receive+0x538>)
    7160:	8ba9      	ldrh	r1, [r5, #28]
    7162:	69a8      	ldr	r0, [r5, #24]
    7164:	4b39      	ldr	r3, [pc, #228]	; (724c <tcp_receive+0x550>)
    7166:	4798      	blx	r3
					tcplen = TCP_TCPLEN(&inseg);
    7168:	8bae      	ldrh	r6, [r5, #28]
    716a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    716c:	8998      	ldrh	r0, [r3, #12]
    716e:	4b35      	ldr	r3, [pc, #212]	; (7244 <tcp_receive+0x548>)
    7170:	4798      	blx	r3
    7172:	f010 0003 	ands.w	r0, r0, #3
    7176:	bf18      	it	ne
    7178:	2001      	movne	r0, #1
    717a:	4406      	add	r6, r0
    717c:	822e      	strh	r6, [r5, #16]
    717e:	e7c1      	b.n	7104 <tcp_receive+0x408>
						TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~TCP_FIN);
    7180:	6a76      	ldr	r6, [r6, #36]	; 0x24
    7182:	89b5      	ldrh	r5, [r6, #12]
    7184:	4628      	mov	r0, r5
    7186:	4b2f      	ldr	r3, [pc, #188]	; (7244 <tcp_receive+0x548>)
    7188:	4798      	blx	r3
    718a:	f000 003e 	and.w	r0, r0, #62	; 0x3e
    718e:	4b30      	ldr	r3, [pc, #192]	; (7250 <tcp_receive+0x554>)
    7190:	4798      	blx	r3
    7192:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
    7196:	4305      	orrs	r5, r0
    7198:	81b5      	strh	r5, [r6, #12]
    719a:	e7d2      	b.n	7142 <tcp_receive+0x446>
						next = pcb->ooseq;
    719c:	f8d4 9074 	ldr.w	r9, [r4, #116]	; 0x74
						while (next && TCP_SEQ_GEQ(seqno + tcplen, next->tcphdr->seqno + next->len)) {
    71a0:	f1b9 0f00 	cmp.w	r9, #0
    71a4:	f000 8171 	beq.w	748a <tcp_receive+0x78e>
    71a8:	f8d9 2010 	ldr.w	r2, [r9, #16]
    71ac:	4921      	ldr	r1, [pc, #132]	; (7234 <tcp_receive+0x538>)
    71ae:	8a0b      	ldrh	r3, [r1, #16]
    71b0:	6849      	ldr	r1, [r1, #4]
    71b2:	440b      	add	r3, r1
    71b4:	6851      	ldr	r1, [r2, #4]
    71b6:	1a5b      	subs	r3, r3, r1
    71b8:	f8b9 1008 	ldrh.w	r1, [r9, #8]
    71bc:	1a5b      	subs	r3, r3, r1
    71be:	2b00      	cmp	r3, #0
    71c0:	f2c0 81a8 	blt.w	7514 <tcp_receive+0x818>
							if (TCPH_FLAGS(next->tcphdr) & TCP_FIN && (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    71c4:	4f1f      	ldr	r7, [pc, #124]	; (7244 <tcp_receive+0x548>)
    71c6:	4e1b      	ldr	r6, [pc, #108]	; (7234 <tcp_receive+0x538>)
								TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    71c8:	f8df 8084 	ldr.w	r8, [pc, #132]	; 7250 <tcp_receive+0x554>
    71cc:	e013      	b.n	71f6 <tcp_receive+0x4fa>
							next = next->next;
    71ce:	f8d9 5000 	ldr.w	r5, [r9]
							tcp_seg_free(prev);
    71d2:	4648      	mov	r0, r9
    71d4:	4b1c      	ldr	r3, [pc, #112]	; (7248 <tcp_receive+0x54c>)
    71d6:	4798      	blx	r3
						while (next && TCP_SEQ_GEQ(seqno + tcplen, next->tcphdr->seqno + next->len)) {
    71d8:	2d00      	cmp	r5, #0
    71da:	f000 8156 	beq.w	748a <tcp_receive+0x78e>
    71de:	692a      	ldr	r2, [r5, #16]
    71e0:	8a33      	ldrh	r3, [r6, #16]
    71e2:	6871      	ldr	r1, [r6, #4]
    71e4:	440b      	add	r3, r1
    71e6:	6851      	ldr	r1, [r2, #4]
    71e8:	1a5b      	subs	r3, r3, r1
    71ea:	8929      	ldrh	r1, [r5, #8]
    71ec:	1a5b      	subs	r3, r3, r1
    71ee:	2b00      	cmp	r3, #0
    71f0:	f2c0 8191 	blt.w	7516 <tcp_receive+0x81a>
							next = next->next;
    71f4:	46a9      	mov	r9, r5
							if (TCPH_FLAGS(next->tcphdr) & TCP_FIN && (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    71f6:	8990      	ldrh	r0, [r2, #12]
    71f8:	47b8      	blx	r7
    71fa:	f010 0f01 	tst.w	r0, #1
    71fe:	d0e6      	beq.n	71ce <tcp_receive+0x4d2>
    7200:	6a73      	ldr	r3, [r6, #36]	; 0x24
    7202:	8998      	ldrh	r0, [r3, #12]
    7204:	47b8      	blx	r7
    7206:	f010 0f02 	tst.w	r0, #2
    720a:	d1e0      	bne.n	71ce <tcp_receive+0x4d2>
								TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    720c:	f8d6 a024 	ldr.w	sl, [r6, #36]	; 0x24
    7210:	f8ba 500c 	ldrh.w	r5, [sl, #12]
    7214:	2001      	movs	r0, #1
    7216:	47c0      	blx	r8
    7218:	4328      	orrs	r0, r5
    721a:	f8aa 000c 	strh.w	r0, [sl, #12]
								tcplen = TCP_TCPLEN(&inseg);
    721e:	8bb5      	ldrh	r5, [r6, #28]
    7220:	6a73      	ldr	r3, [r6, #36]	; 0x24
    7222:	8998      	ldrh	r0, [r3, #12]
    7224:	47b8      	blx	r7
    7226:	f010 0003 	ands.w	r0, r0, #3
    722a:	bf18      	it	ne
    722c:	2001      	movne	r0, #1
    722e:	4405      	add	r5, r0
    7230:	8235      	strh	r5, [r6, #16]
    7232:	e7cc      	b.n	71ce <tcp_receive+0x4d2>
    7234:	20007f9c 	.word	0x20007f9c
    7238:	00008191 	.word	0x00008191
    723c:	20009304 	.word	0x20009304
    7240:	00005bf5 	.word	0x00005bf5
    7244:	00002eaf 	.word	0x00002eaf
    7248:	000061a9 	.word	0x000061a9
    724c:	00005e2d 	.word	0x00005e2d
    7250:	00002ea5 	.word	0x00002ea5
							recv_data = cseg->p;
    7254:	62b9      	str	r1, [r7, #40]	; 0x28
						cseg->p = NULL;
    7256:	2300      	movs	r3, #0
    7258:	606b      	str	r3, [r5, #4]
					if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    725a:	692b      	ldr	r3, [r5, #16]
    725c:	8998      	ldrh	r0, [r3, #12]
    725e:	47b0      	blx	r6
    7260:	f010 0f01 	tst.w	r0, #1
    7264:	d00a      	beq.n	727c <tcp_receive+0x580>
						recv_flags |= TF_GOT_FIN;
    7266:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    726a:	f043 0320 	orr.w	r3, r3, #32
    726e:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
						if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
    7272:	7e23      	ldrb	r3, [r4, #24]
    7274:	2b04      	cmp	r3, #4
							pcb->state = CLOSE_WAIT;
    7276:	bf04      	itt	eq
    7278:	2307      	moveq	r3, #7
    727a:	7623      	strbeq	r3, [r4, #24]
					pcb->ooseq = cseg->next;
    727c:	682b      	ldr	r3, [r5, #0]
    727e:	6763      	str	r3, [r4, #116]	; 0x74
					tcp_seg_free(cseg);
    7280:	4628      	mov	r0, r5
    7282:	4b9a      	ldr	r3, [pc, #616]	; (74ec <tcp_receive+0x7f0>)
    7284:	4798      	blx	r3
				while (pcb->ooseq != NULL && pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
    7286:	6f65      	ldr	r5, [r4, #116]	; 0x74
    7288:	2d00      	cmp	r5, #0
    728a:	d02a      	beq.n	72e2 <tcp_receive+0x5e6>
    728c:	692b      	ldr	r3, [r5, #16]
    728e:	685a      	ldr	r2, [r3, #4]
    7290:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    7292:	428a      	cmp	r2, r1
    7294:	d125      	bne.n	72e2 <tcp_receive+0x5e6>
					seqno = pcb->ooseq->tcphdr->seqno;
    7296:	607a      	str	r2, [r7, #4]
					pcb->rcv_nxt += TCP_TCPLEN(cseg);
    7298:	f8b5 9008 	ldrh.w	r9, [r5, #8]
    729c:	8998      	ldrh	r0, [r3, #12]
    729e:	47b0      	blx	r6
    72a0:	f010 0003 	ands.w	r0, r0, #3
    72a4:	bf18      	it	ne
    72a6:	2001      	movne	r0, #1
    72a8:	4448      	add	r0, r9
    72aa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    72ac:	4418      	add	r0, r3
    72ae:	62a0      	str	r0, [r4, #40]	; 0x28
					pcb->rcv_wnd -= TCP_TCPLEN(cseg);
    72b0:	f8b5 9008 	ldrh.w	r9, [r5, #8]
    72b4:	692b      	ldr	r3, [r5, #16]
    72b6:	8998      	ldrh	r0, [r3, #12]
    72b8:	47b0      	blx	r6
    72ba:	f010 0003 	ands.w	r0, r0, #3
    72be:	bf18      	it	ne
    72c0:	2001      	movne	r0, #1
    72c2:	4448      	add	r0, r9
    72c4:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    72c6:	1a18      	subs	r0, r3, r0
    72c8:	85a0      	strh	r0, [r4, #44]	; 0x2c
					tcp_update_rcv_ann_wnd(pcb);
    72ca:	4620      	mov	r0, r4
    72cc:	47c0      	blx	r8
					if (cseg->p->tot_len > 0) {
    72ce:	6869      	ldr	r1, [r5, #4]
    72d0:	890b      	ldrh	r3, [r1, #8]
    72d2:	2b00      	cmp	r3, #0
    72d4:	d0c1      	beq.n	725a <tcp_receive+0x55e>
						if (recv_data) {
    72d6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    72d8:	2800      	cmp	r0, #0
    72da:	d0bb      	beq.n	7254 <tcp_receive+0x558>
							pbuf_cat(recv_data, cseg->p);
    72dc:	4b84      	ldr	r3, [pc, #528]	; (74f0 <tcp_receive+0x7f4>)
    72de:	4798      	blx	r3
    72e0:	e7b9      	b.n	7256 <tcp_receive+0x55a>
				tcp_ack(pcb);
    72e2:	7fa3      	ldrb	r3, [r4, #30]
    72e4:	f013 0f01 	tst.w	r3, #1
    72e8:	bf1a      	itte	ne
    72ea:	f023 0301 	bicne.w	r3, r3, #1
    72ee:	f043 0302 	orrne.w	r3, r3, #2
    72f2:	f043 0301 	orreq.w	r3, r3, #1
    72f6:	77a3      	strb	r3, [r4, #30]
    72f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					pcb->ooseq = tcp_seg_copy(&inseg);
    72fc:	487d      	ldr	r0, [pc, #500]	; (74f4 <tcp_receive+0x7f8>)
    72fe:	4b7e      	ldr	r3, [pc, #504]	; (74f8 <tcp_receive+0x7fc>)
    7300:	4798      	blx	r3
    7302:	6760      	str	r0, [r4, #116]	; 0x74
    7304:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						if (seqno == next->tcphdr->seqno) {
    7308:	4635      	mov	r5, r6
    730a:	2600      	movs	r6, #0
							if (inseg.len > next->len) {
    730c:	4b7b      	ldr	r3, [pc, #492]	; (74fc <tcp_receive+0x800>)
    730e:	8b9a      	ldrh	r2, [r3, #28]
    7310:	892b      	ldrh	r3, [r5, #8]
    7312:	429a      	cmp	r2, r3
    7314:	d94f      	bls.n	73b6 <tcp_receive+0x6ba>
								cseg = tcp_seg_copy(&inseg);
    7316:	4877      	ldr	r0, [pc, #476]	; (74f4 <tcp_receive+0x7f8>)
    7318:	4b77      	ldr	r3, [pc, #476]	; (74f8 <tcp_receive+0x7fc>)
    731a:	4798      	blx	r3
								if (cseg != NULL) {
    731c:	4603      	mov	r3, r0
    731e:	2800      	cmp	r0, #0
    7320:	d049      	beq.n	73b6 <tcp_receive+0x6ba>
									if (prev != NULL) {
    7322:	b136      	cbz	r6, 7332 <tcp_receive+0x636>
										prev->next = cseg;
    7324:	6030      	str	r0, [r6, #0]
									tcp_oos_insert_segment(cseg, next);
    7326:	4629      	mov	r1, r5
    7328:	4618      	mov	r0, r3
    732a:	4b75      	ldr	r3, [pc, #468]	; (7500 <tcp_receive+0x804>)
    732c:	4798      	blx	r3
    732e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
										pcb->ooseq = cseg;
    7332:	6760      	str	r0, [r4, #116]	; 0x74
    7334:	e7f7      	b.n	7326 <tcp_receive+0x62a>
								if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
    7336:	1a83      	subs	r3, r0, r2
    7338:	2b00      	cmp	r3, #0
    733a:	db2f      	blt.n	739c <tcp_receive+0x6a0>
							if (next->next == NULL && TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    733c:	6835      	ldr	r5, [r6, #0]
    733e:	2d00      	cmp	r5, #0
    7340:	d036      	beq.n	73b0 <tcp_receive+0x6b4>
						if (seqno == next->tcphdr->seqno) {
    7342:	6929      	ldr	r1, [r5, #16]
    7344:	684a      	ldr	r2, [r1, #4]
    7346:	4637      	mov	r7, r6
    7348:	4282      	cmp	r2, r0
    734a:	d0df      	beq.n	730c <tcp_receive+0x610>
							if (next->next == NULL && TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    734c:	462e      	mov	r6, r5
							if (prev == NULL) {
    734e:	2f00      	cmp	r7, #0
    7350:	d0f1      	beq.n	7336 <tcp_receive+0x63a>
								if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
    7352:	693b      	ldr	r3, [r7, #16]
    7354:	685b      	ldr	r3, [r3, #4]
    7356:	ebae 0303 	sub.w	r3, lr, r3
    735a:	2b00      	cmp	r3, #0
    735c:	dbee      	blt.n	733c <tcp_receive+0x640>
    735e:	ebac 0302 	sub.w	r3, ip, r2
    7362:	2b00      	cmp	r3, #0
    7364:	dcea      	bgt.n	733c <tcp_receive+0x640>
									cseg = tcp_seg_copy(&inseg);
    7366:	4863      	ldr	r0, [pc, #396]	; (74f4 <tcp_receive+0x7f8>)
    7368:	4b63      	ldr	r3, [pc, #396]	; (74f8 <tcp_receive+0x7fc>)
    736a:	4798      	blx	r3
									if (cseg != NULL) {
    736c:	4604      	mov	r4, r0
    736e:	b310      	cbz	r0, 73b6 <tcp_receive+0x6ba>
										if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
    7370:	693b      	ldr	r3, [r7, #16]
    7372:	6859      	ldr	r1, [r3, #4]
    7374:	4b61      	ldr	r3, [pc, #388]	; (74fc <tcp_receive+0x800>)
    7376:	685b      	ldr	r3, [r3, #4]
    7378:	893a      	ldrh	r2, [r7, #8]
    737a:	440a      	add	r2, r1
    737c:	1ad2      	subs	r2, r2, r3
    737e:	2a00      	cmp	r2, #0
    7380:	dd05      	ble.n	738e <tcp_receive+0x692>
											prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
    7382:	1a5b      	subs	r3, r3, r1
    7384:	b299      	uxth	r1, r3
    7386:	8139      	strh	r1, [r7, #8]
											pbuf_realloc(prev->p, prev->len);
    7388:	6878      	ldr	r0, [r7, #4]
    738a:	4b5e      	ldr	r3, [pc, #376]	; (7504 <tcp_receive+0x808>)
    738c:	4798      	blx	r3
										prev->next = cseg;
    738e:	603c      	str	r4, [r7, #0]
										tcp_oos_insert_segment(cseg, next);
    7390:	4631      	mov	r1, r6
    7392:	4620      	mov	r0, r4
    7394:	4b5a      	ldr	r3, [pc, #360]	; (7500 <tcp_receive+0x804>)
    7396:	4798      	blx	r3
    7398:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
									cseg = tcp_seg_copy(&inseg);
    739c:	4855      	ldr	r0, [pc, #340]	; (74f4 <tcp_receive+0x7f8>)
    739e:	4b56      	ldr	r3, [pc, #344]	; (74f8 <tcp_receive+0x7fc>)
    73a0:	4798      	blx	r3
									if (cseg != NULL) {
    73a2:	b140      	cbz	r0, 73b6 <tcp_receive+0x6ba>
										pcb->ooseq = cseg;
    73a4:	6760      	str	r0, [r4, #116]	; 0x74
										tcp_oos_insert_segment(cseg, next);
    73a6:	4631      	mov	r1, r6
    73a8:	4b55      	ldr	r3, [pc, #340]	; (7500 <tcp_receive+0x804>)
    73aa:	4798      	blx	r3
    73ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
							if (next->next == NULL && TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    73b0:	1a82      	subs	r2, r0, r2
    73b2:	2a00      	cmp	r2, #0
    73b4:	dc01      	bgt.n	73ba <tcp_receive+0x6be>
    73b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
								if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    73ba:	8988      	ldrh	r0, [r1, #12]
    73bc:	4b52      	ldr	r3, [pc, #328]	; (7508 <tcp_receive+0x80c>)
    73be:	4798      	blx	r3
    73c0:	f010 0f01 	tst.w	r0, #1
    73c4:	d1f7      	bne.n	73b6 <tcp_receive+0x6ba>
								next->next = tcp_seg_copy(&inseg);
    73c6:	484b      	ldr	r0, [pc, #300]	; (74f4 <tcp_receive+0x7f8>)
    73c8:	4b4b      	ldr	r3, [pc, #300]	; (74f8 <tcp_receive+0x7fc>)
    73ca:	4798      	blx	r3
    73cc:	6030      	str	r0, [r6, #0]
								if (next->next != NULL) {
    73ce:	2800      	cmp	r0, #0
    73d0:	d0f1      	beq.n	73b6 <tcp_receive+0x6ba>
									if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
    73d2:	6933      	ldr	r3, [r6, #16]
    73d4:	6859      	ldr	r1, [r3, #4]
    73d6:	4b49      	ldr	r3, [pc, #292]	; (74fc <tcp_receive+0x800>)
    73d8:	685b      	ldr	r3, [r3, #4]
    73da:	8932      	ldrh	r2, [r6, #8]
    73dc:	440a      	add	r2, r1
    73de:	1ad2      	subs	r2, r2, r3
    73e0:	2a00      	cmp	r2, #0
    73e2:	dd05      	ble.n	73f0 <tcp_receive+0x6f4>
										next->len = (u16_t)(seqno - next->tcphdr->seqno);
    73e4:	1a5b      	subs	r3, r3, r1
    73e6:	b299      	uxth	r1, r3
    73e8:	8131      	strh	r1, [r6, #8]
										pbuf_realloc(next->p, next->len);
    73ea:	6870      	ldr	r0, [r6, #4]
    73ec:	4b45      	ldr	r3, [pc, #276]	; (7504 <tcp_receive+0x808>)
    73ee:	4798      	blx	r3
									if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
    73f0:	4b42      	ldr	r3, [pc, #264]	; (74fc <tcp_receive+0x800>)
    73f2:	8a1a      	ldrh	r2, [r3, #16]
    73f4:	685b      	ldr	r3, [r3, #4]
    73f6:	441a      	add	r2, r3
    73f8:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    73fa:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    73fc:	440b      	add	r3, r1
    73fe:	429a      	cmp	r2, r3
    7400:	d9d9      	bls.n	73b6 <tcp_receive+0x6ba>
										if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
    7402:	6833      	ldr	r3, [r6, #0]
    7404:	691b      	ldr	r3, [r3, #16]
    7406:	8998      	ldrh	r0, [r3, #12]
    7408:	4b3f      	ldr	r3, [pc, #252]	; (7508 <tcp_receive+0x80c>)
    740a:	4798      	blx	r3
    740c:	f010 0f01 	tst.w	r0, #1
    7410:	d11a      	bne.n	7448 <tcp_receive+0x74c>
										next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
    7412:	6832      	ldr	r2, [r6, #0]
    7414:	4d39      	ldr	r5, [pc, #228]	; (74fc <tcp_receive+0x800>)
    7416:	6869      	ldr	r1, [r5, #4]
    7418:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    741a:	1a5b      	subs	r3, r3, r1
    741c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    741e:	440b      	add	r3, r1
    7420:	8113      	strh	r3, [r2, #8]
										pbuf_realloc(next->next->p, next->next->len);
    7422:	6833      	ldr	r3, [r6, #0]
    7424:	8919      	ldrh	r1, [r3, #8]
    7426:	6858      	ldr	r0, [r3, #4]
    7428:	4b36      	ldr	r3, [pc, #216]	; (7504 <tcp_receive+0x808>)
    742a:	4798      	blx	r3
										tcplen = TCP_TCPLEN(next->next);
    742c:	6833      	ldr	r3, [r6, #0]
    742e:	891c      	ldrh	r4, [r3, #8]
    7430:	691b      	ldr	r3, [r3, #16]
    7432:	8998      	ldrh	r0, [r3, #12]
    7434:	4b34      	ldr	r3, [pc, #208]	; (7508 <tcp_receive+0x80c>)
    7436:	4798      	blx	r3
    7438:	f010 0003 	ands.w	r0, r0, #3
    743c:	bf18      	it	ne
    743e:	2001      	movne	r0, #1
    7440:	4404      	add	r4, r0
    7442:	822c      	strh	r4, [r5, #16]
    7444:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
											TCPH_FLAGS_SET(next->next->tcphdr,
    7448:	6833      	ldr	r3, [r6, #0]
    744a:	691f      	ldr	r7, [r3, #16]
    744c:	89bd      	ldrh	r5, [r7, #12]
    744e:	4628      	mov	r0, r5
    7450:	4b2d      	ldr	r3, [pc, #180]	; (7508 <tcp_receive+0x80c>)
    7452:	4798      	blx	r3
    7454:	f000 003e 	and.w	r0, r0, #62	; 0x3e
    7458:	4b2c      	ldr	r3, [pc, #176]	; (750c <tcp_receive+0x810>)
    745a:	4798      	blx	r3
    745c:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
    7460:	4305      	orrs	r5, r0
    7462:	81bd      	strh	r5, [r7, #12]
    7464:	e7d5      	b.n	7412 <tcp_receive+0x716>
		if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    7466:	4b25      	ldr	r3, [pc, #148]	; (74fc <tcp_receive+0x800>)
    7468:	685b      	ldr	r3, [r3, #4]
    746a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    746c:	1a99      	subs	r1, r3, r2
    746e:	2900      	cmp	r1, #0
    7470:	db05      	blt.n	747e <tcp_receive+0x782>
    7472:	3301      	adds	r3, #1
    7474:	1a9b      	subs	r3, r3, r2
    7476:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    7478:	1a9b      	subs	r3, r3, r2
    747a:	2b00      	cmp	r3, #0
    747c:	dd9b      	ble.n	73b6 <tcp_receive+0x6ba>
			tcp_ack_now(pcb);
    747e:	7fa3      	ldrb	r3, [r4, #30]
    7480:	f043 0302 	orr.w	r3, r3, #2
    7484:	77a3      	strb	r3, [r4, #30]
}
    7486:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
							next = next->next;
    748a:	2500      	movs	r5, #0
						pcb->ooseq = next;
    748c:	6765      	str	r5, [r4, #116]	; 0x74
				pcb->rcv_nxt = seqno + tcplen;
    748e:	4d1b      	ldr	r5, [pc, #108]	; (74fc <tcp_receive+0x800>)
    7490:	8a2a      	ldrh	r2, [r5, #16]
    7492:	686b      	ldr	r3, [r5, #4]
    7494:	4413      	add	r3, r2
    7496:	62a3      	str	r3, [r4, #40]	; 0x28
				pcb->rcv_wnd -= tcplen;
    7498:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    749a:	1a9b      	subs	r3, r3, r2
    749c:	85a3      	strh	r3, [r4, #44]	; 0x2c
				tcp_update_rcv_ann_wnd(pcb);
    749e:	4620      	mov	r0, r4
    74a0:	4b1b      	ldr	r3, [pc, #108]	; (7510 <tcp_receive+0x814>)
    74a2:	4798      	blx	r3
				if (inseg.p->tot_len > 0) {
    74a4:	69ab      	ldr	r3, [r5, #24]
    74a6:	891a      	ldrh	r2, [r3, #8]
    74a8:	b112      	cbz	r2, 74b0 <tcp_receive+0x7b4>
					recv_data = inseg.p;
    74aa:	62ab      	str	r3, [r5, #40]	; 0x28
					inseg.p = NULL;
    74ac:	2300      	movs	r3, #0
    74ae:	61ab      	str	r3, [r5, #24]
				if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    74b0:	4b12      	ldr	r3, [pc, #72]	; (74fc <tcp_receive+0x800>)
    74b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    74b4:	8998      	ldrh	r0, [r3, #12]
    74b6:	4b14      	ldr	r3, [pc, #80]	; (7508 <tcp_receive+0x80c>)
    74b8:	4798      	blx	r3
    74ba:	f010 0f01 	tst.w	r0, #1
    74be:	d006      	beq.n	74ce <tcp_receive+0x7d2>
					recv_flags |= TF_GOT_FIN;
    74c0:	4a0e      	ldr	r2, [pc, #56]	; (74fc <tcp_receive+0x800>)
    74c2:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
    74c6:	f043 0320 	orr.w	r3, r3, #32
    74ca:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
				while (pcb->ooseq != NULL && pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
    74ce:	6f65      	ldr	r5, [r4, #116]	; 0x74
    74d0:	2d00      	cmp	r5, #0
    74d2:	f43f af06 	beq.w	72e2 <tcp_receive+0x5e6>
    74d6:	692b      	ldr	r3, [r5, #16]
    74d8:	685a      	ldr	r2, [r3, #4]
    74da:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    74dc:	428a      	cmp	r2, r1
    74de:	f47f af00 	bne.w	72e2 <tcp_receive+0x5e6>
					seqno = pcb->ooseq->tcphdr->seqno;
    74e2:	4f06      	ldr	r7, [pc, #24]	; (74fc <tcp_receive+0x800>)
					pcb->rcv_nxt += TCP_TCPLEN(cseg);
    74e4:	4e08      	ldr	r6, [pc, #32]	; (7508 <tcp_receive+0x80c>)
					tcp_update_rcv_ann_wnd(pcb);
    74e6:	f8df 8028 	ldr.w	r8, [pc, #40]	; 7510 <tcp_receive+0x814>
    74ea:	e6d4      	b.n	7296 <tcp_receive+0x59a>
    74ec:	000061a9 	.word	0x000061a9
    74f0:	00005ead 	.word	0x00005ead
    74f4:	20007fb0 	.word	0x20007fb0
    74f8:	000061e9 	.word	0x000061e9
    74fc:	20007f9c 	.word	0x20007f9c
    7500:	00006c2d 	.word	0x00006c2d
    7504:	00005e2d 	.word	0x00005e2d
    7508:	00002eaf 	.word	0x00002eaf
    750c:	00002ea5 	.word	0x00002ea5
    7510:	0000612b 	.word	0x0000612b
						next = pcb->ooseq;
    7514:	464d      	mov	r5, r9
						if (next && TCP_SEQ_GT(seqno + tcplen, next->tcphdr->seqno)) {
    7516:	4b14      	ldr	r3, [pc, #80]	; (7568 <tcp_receive+0x86c>)
    7518:	6859      	ldr	r1, [r3, #4]
    751a:	692a      	ldr	r2, [r5, #16]
    751c:	6852      	ldr	r2, [r2, #4]
    751e:	8a1b      	ldrh	r3, [r3, #16]
    7520:	440b      	add	r3, r1
    7522:	1a9b      	subs	r3, r3, r2
    7524:	2b00      	cmp	r3, #0
    7526:	ddb1      	ble.n	748c <tcp_receive+0x790>
							inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
    7528:	4b0f      	ldr	r3, [pc, #60]	; (7568 <tcp_receive+0x86c>)
    752a:	1a52      	subs	r2, r2, r1
    752c:	839a      	strh	r2, [r3, #28]
							if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    752e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7530:	8998      	ldrh	r0, [r3, #12]
    7532:	4b0e      	ldr	r3, [pc, #56]	; (756c <tcp_receive+0x870>)
    7534:	4798      	blx	r3
    7536:	f010 0f02 	tst.w	r0, #2
    753a:	d003      	beq.n	7544 <tcp_receive+0x848>
								inseg.len -= 1;
    753c:	4a0a      	ldr	r2, [pc, #40]	; (7568 <tcp_receive+0x86c>)
    753e:	8b93      	ldrh	r3, [r2, #28]
    7540:	3b01      	subs	r3, #1
    7542:	8393      	strh	r3, [r2, #28]
							pbuf_realloc(inseg.p, inseg.len);
    7544:	4e08      	ldr	r6, [pc, #32]	; (7568 <tcp_receive+0x86c>)
    7546:	8bb1      	ldrh	r1, [r6, #28]
    7548:	69b0      	ldr	r0, [r6, #24]
    754a:	4b09      	ldr	r3, [pc, #36]	; (7570 <tcp_receive+0x874>)
    754c:	4798      	blx	r3
							tcplen = TCP_TCPLEN(&inseg);
    754e:	8bb7      	ldrh	r7, [r6, #28]
    7550:	6a73      	ldr	r3, [r6, #36]	; 0x24
    7552:	8998      	ldrh	r0, [r3, #12]
    7554:	4b05      	ldr	r3, [pc, #20]	; (756c <tcp_receive+0x870>)
    7556:	4798      	blx	r3
    7558:	f010 0003 	ands.w	r0, r0, #3
    755c:	bf18      	it	ne
    755e:	2001      	movne	r0, #1
    7560:	4407      	add	r7, r0
    7562:	8237      	strh	r7, [r6, #16]
    7564:	e792      	b.n	748c <tcp_receive+0x790>
    7566:	bf00      	nop
    7568:	20007f9c 	.word	0x20007f9c
    756c:	00002eaf 	.word	0x00002eaf
    7570:	00005e2d 	.word	0x00005e2d

00007574 <tcp_input>:
{
    7574:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    7578:	b083      	sub	sp, #12
    757a:	4604      	mov	r4, r0
    757c:	460d      	mov	r5, r1
	iphdr  = (struct ip_hdr *)p->payload;
    757e:	6843      	ldr	r3, [r0, #4]
    7580:	7819      	ldrb	r1, [r3, #0]
    7582:	f001 010f 	and.w	r1, r1, #15
	tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    7586:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    758a:	4a99      	ldr	r2, [pc, #612]	; (77f0 <tcp_input+0x27c>)
    758c:	6013      	str	r3, [r2, #0]
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    758e:	0089      	lsls	r1, r1, #2
    7590:	4249      	negs	r1, r1
    7592:	4b98      	ldr	r3, [pc, #608]	; (77f4 <tcp_input+0x280>)
    7594:	4798      	blx	r3
    7596:	b910      	cbnz	r0, 759e <tcp_input+0x2a>
    7598:	8923      	ldrh	r3, [r4, #8]
    759a:	2b13      	cmp	r3, #19
    759c:	d805      	bhi.n	75aa <tcp_input+0x36>
	pbuf_free(p);
    759e:	4620      	mov	r0, r4
    75a0:	4b95      	ldr	r3, [pc, #596]	; (77f8 <tcp_input+0x284>)
    75a2:	4798      	blx	r3
}
    75a4:	b003      	add	sp, #12
    75a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (ip_addr_isbroadcast(&current_iphdr_dest, inp) || ip_addr_ismulticast(&current_iphdr_dest)) {
    75aa:	4629      	mov	r1, r5
    75ac:	4b93      	ldr	r3, [pc, #588]	; (77fc <tcp_input+0x288>)
    75ae:	6818      	ldr	r0, [r3, #0]
    75b0:	4b93      	ldr	r3, [pc, #588]	; (7800 <tcp_input+0x28c>)
    75b2:	4798      	blx	r3
    75b4:	2800      	cmp	r0, #0
    75b6:	d1f2      	bne.n	759e <tcp_input+0x2a>
    75b8:	4b90      	ldr	r3, [pc, #576]	; (77fc <tcp_input+0x288>)
    75ba:	681b      	ldr	r3, [r3, #0]
    75bc:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    75c0:	2be0      	cmp	r3, #224	; 0xe0
    75c2:	d0ec      	beq.n	759e <tcp_input+0x2a>
	if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(), IP_PROTO_TCP, p->tot_len) != 0) {
    75c4:	8923      	ldrh	r3, [r4, #8]
    75c6:	9300      	str	r3, [sp, #0]
    75c8:	2306      	movs	r3, #6
    75ca:	4a8c      	ldr	r2, [pc, #560]	; (77fc <tcp_input+0x288>)
    75cc:	498d      	ldr	r1, [pc, #564]	; (7804 <tcp_input+0x290>)
    75ce:	4620      	mov	r0, r4
    75d0:	4d8d      	ldr	r5, [pc, #564]	; (7808 <tcp_input+0x294>)
    75d2:	47a8      	blx	r5
    75d4:	2800      	cmp	r0, #0
    75d6:	d1e2      	bne.n	759e <tcp_input+0x2a>
	hdrlen = TCPH_HDRLEN(tcphdr);
    75d8:	4b85      	ldr	r3, [pc, #532]	; (77f0 <tcp_input+0x27c>)
    75da:	681b      	ldr	r3, [r3, #0]
    75dc:	8998      	ldrh	r0, [r3, #12]
    75de:	4b8b      	ldr	r3, [pc, #556]	; (780c <tcp_input+0x298>)
    75e0:	4798      	blx	r3
    75e2:	0b00      	lsrs	r0, r0, #12
	if (pbuf_header(p, -(hdrlen * 4))) {
    75e4:	ebc0 3080 	rsb	r0, r0, r0, lsl #14
    75e8:	0081      	lsls	r1, r0, #2
    75ea:	b209      	sxth	r1, r1
    75ec:	4620      	mov	r0, r4
    75ee:	4b81      	ldr	r3, [pc, #516]	; (77f4 <tcp_input+0x280>)
    75f0:	4798      	blx	r3
    75f2:	2800      	cmp	r0, #0
    75f4:	d1d3      	bne.n	759e <tcp_input+0x2a>
	tcphdr->src  = ntohs(tcphdr->src);
    75f6:	4d7e      	ldr	r5, [pc, #504]	; (77f0 <tcp_input+0x27c>)
    75f8:	682f      	ldr	r7, [r5, #0]
    75fa:	8838      	ldrh	r0, [r7, #0]
    75fc:	4e83      	ldr	r6, [pc, #524]	; (780c <tcp_input+0x298>)
    75fe:	47b0      	blx	r6
    7600:	8038      	strh	r0, [r7, #0]
	tcphdr->dest = ntohs(tcphdr->dest);
    7602:	682f      	ldr	r7, [r5, #0]
    7604:	8878      	ldrh	r0, [r7, #2]
    7606:	47b0      	blx	r6
    7608:	8078      	strh	r0, [r7, #2]
	seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    760a:	682f      	ldr	r7, [r5, #0]
    760c:	6878      	ldr	r0, [r7, #4]
    760e:	f8df 8224 	ldr.w	r8, [pc, #548]	; 7834 <tcp_input+0x2c0>
    7612:	47c0      	blx	r8
    7614:	6078      	str	r0, [r7, #4]
    7616:	6068      	str	r0, [r5, #4]
	ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    7618:	682f      	ldr	r7, [r5, #0]
    761a:	68b8      	ldr	r0, [r7, #8]
    761c:	47c0      	blx	r8
    761e:	60b8      	str	r0, [r7, #8]
    7620:	60e8      	str	r0, [r5, #12]
	tcphdr->wnd           = ntohs(tcphdr->wnd);
    7622:	682f      	ldr	r7, [r5, #0]
    7624:	89f8      	ldrh	r0, [r7, #14]
    7626:	47b0      	blx	r6
    7628:	81f8      	strh	r0, [r7, #14]
	flags  = TCPH_FLAGS(tcphdr);
    762a:	682b      	ldr	r3, [r5, #0]
    762c:	8998      	ldrh	r0, [r3, #12]
    762e:	47b0      	blx	r6
    7630:	fa5f fe80 	uxtb.w	lr, r0
    7634:	f00e 033f 	and.w	r3, lr, #63	; 0x3f
    7638:	722b      	strb	r3, [r5, #8]
	tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    763a:	f01e 0303 	ands.w	r3, lr, #3
    763e:	bf18      	it	ne
    7640:	2301      	movne	r3, #1
    7642:	8921      	ldrh	r1, [r4, #8]
    7644:	440b      	add	r3, r1
    7646:	b299      	uxth	r1, r3
    7648:	8229      	strh	r1, [r5, #16]
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    764a:	4b71      	ldr	r3, [pc, #452]	; (7810 <tcp_input+0x29c>)
    764c:	6818      	ldr	r0, [r3, #0]
    764e:	2800      	cmp	r0, #0
    7650:	f000 8084 	beq.w	775c <tcp_input+0x1e8>
		if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    7654:	682f      	ldr	r7, [r5, #0]
    7656:	883e      	ldrh	r6, [r7, #0]
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    7658:	4b6a      	ldr	r3, [pc, #424]	; (7804 <tcp_input+0x290>)
    765a:	f8d3 c000 	ldr.w	ip, [r3]
		    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    765e:	4b67      	ldr	r3, [pc, #412]	; (77fc <tcp_input+0x288>)
    7660:	f8d3 8000 	ldr.w	r8, [r3]
    7664:	4605      	mov	r5, r0
    7666:	2200      	movs	r2, #0
    7668:	e004      	b.n	7674 <tcp_input+0x100>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    766a:	68eb      	ldr	r3, [r5, #12]
    766c:	462a      	mov	r2, r5
    766e:	2b00      	cmp	r3, #0
    7670:	d074      	beq.n	775c <tcp_input+0x1e8>
    7672:	461d      	mov	r5, r3
		if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    7674:	8bab      	ldrh	r3, [r5, #28]
    7676:	42b3      	cmp	r3, r6
    7678:	d1f7      	bne.n	766a <tcp_input+0xf6>
    767a:	f8b5 901a 	ldrh.w	r9, [r5, #26]
    767e:	887b      	ldrh	r3, [r7, #2]
    7680:	4599      	cmp	r9, r3
    7682:	d1f2      	bne.n	766a <tcp_input+0xf6>
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    7684:	686b      	ldr	r3, [r5, #4]
    7686:	4563      	cmp	r3, ip
    7688:	d1ef      	bne.n	766a <tcp_input+0xf6>
		    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    768a:	682b      	ldr	r3, [r5, #0]
    768c:	4543      	cmp	r3, r8
    768e:	d1ec      	bne.n	766a <tcp_input+0xf6>
			if (prev != NULL) {
    7690:	b122      	cbz	r2, 769c <tcp_input+0x128>
				prev->next      = pcb->next;
    7692:	68eb      	ldr	r3, [r5, #12]
    7694:	60d3      	str	r3, [r2, #12]
				pcb->next       = tcp_active_pcbs;
    7696:	60e8      	str	r0, [r5, #12]
				tcp_active_pcbs = pcb;
    7698:	4b5d      	ldr	r3, [pc, #372]	; (7810 <tcp_input+0x29c>)
    769a:	601d      	str	r5, [r3, #0]
	if (pcb == NULL) {
    769c:	2d00      	cmp	r5, #0
    769e:	d05d      	beq.n	775c <tcp_input+0x1e8>
		inseg.next   = NULL;
    76a0:	4b53      	ldr	r3, [pc, #332]	; (77f0 <tcp_input+0x27c>)
    76a2:	2200      	movs	r2, #0
    76a4:	615a      	str	r2, [r3, #20]
		inseg.len    = p->tot_len;
    76a6:	8921      	ldrh	r1, [r4, #8]
    76a8:	8399      	strh	r1, [r3, #28]
		inseg.p      = p;
    76aa:	619c      	str	r4, [r3, #24]
		inseg.tcphdr = tcphdr;
    76ac:	625f      	str	r7, [r3, #36]	; 0x24
		recv_data  = NULL;
    76ae:	629a      	str	r2, [r3, #40]	; 0x28
		recv_flags = 0;
    76b0:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
		if (flags & TCP_PSH) {
    76b4:	f01e 0f08 	tst.w	lr, #8
    76b8:	d003      	beq.n	76c2 <tcp_input+0x14e>
			p->flags |= PBUF_FLAG_PUSH;
    76ba:	7b63      	ldrb	r3, [r4, #13]
    76bc:	f043 0301 	orr.w	r3, r3, #1
    76c0:	7363      	strb	r3, [r4, #13]
		if (pcb->refused_data != NULL) {
    76c2:	6fab      	ldr	r3, [r5, #120]	; 0x78
    76c4:	b15b      	cbz	r3, 76de <tcp_input+0x16a>
			if ((tcp_process_refused_data(pcb) == ERR_ABRT) || ((pcb->refused_data != NULL) && (tcplen > 0))) {
    76c6:	4628      	mov	r0, r5
    76c8:	4b52      	ldr	r3, [pc, #328]	; (7814 <tcp_input+0x2a0>)
    76ca:	4798      	blx	r3
    76cc:	f110 0f0a 	cmn.w	r0, #10
    76d0:	d035      	beq.n	773e <tcp_input+0x1ca>
    76d2:	6fab      	ldr	r3, [r5, #120]	; 0x78
    76d4:	b11b      	cbz	r3, 76de <tcp_input+0x16a>
    76d6:	4b46      	ldr	r3, [pc, #280]	; (77f0 <tcp_input+0x27c>)
    76d8:	8a1b      	ldrh	r3, [r3, #16]
    76da:	2b00      	cmp	r3, #0
    76dc:	d12f      	bne.n	773e <tcp_input+0x1ca>
		tcp_input_pcb = pcb;
    76de:	4b4e      	ldr	r3, [pc, #312]	; (7818 <tcp_input+0x2a4>)
    76e0:	601d      	str	r5, [r3, #0]
	if (flags & TCP_RST) {
    76e2:	4b43      	ldr	r3, [pc, #268]	; (77f0 <tcp_input+0x27c>)
    76e4:	7a1b      	ldrb	r3, [r3, #8]
    76e6:	f013 0f04 	tst.w	r3, #4
    76ea:	f000 8144 	beq.w	7976 <tcp_input+0x402>
		if (pcb->state == SYN_SENT) {
    76ee:	7e2b      	ldrb	r3, [r5, #24]
    76f0:	2b02      	cmp	r3, #2
    76f2:	f000 812c 	beq.w	794e <tcp_input+0x3da>
			if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
    76f6:	4b3e      	ldr	r3, [pc, #248]	; (77f0 <tcp_input+0x27c>)
    76f8:	685b      	ldr	r3, [r3, #4]
    76fa:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    76fc:	1a9b      	subs	r3, r3, r2
    76fe:	d408      	bmi.n	7712 <tcp_input+0x19e>
    7700:	8daa      	ldrh	r2, [r5, #44]	; 0x2c
    7702:	1a9b      	subs	r3, r3, r2
	u8_t            acceptable = 0;
    7704:	2b00      	cmp	r3, #0
    7706:	bfcc      	ite	gt
    7708:	2300      	movgt	r3, #0
    770a:	2301      	movle	r3, #1
		if (acceptable) {
    770c:	2b00      	cmp	r3, #0
    770e:	f040 8126 	bne.w	795e <tcp_input+0x3ea>
			if (recv_flags & TF_RESET) {
    7712:	4b37      	ldr	r3, [pc, #220]	; (77f0 <tcp_input+0x27c>)
    7714:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    7718:	f013 0f08 	tst.w	r3, #8
    771c:	f000 835d 	beq.w	7dda <tcp_input+0x866>
				TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
    7720:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    7724:	b11b      	cbz	r3, 772e <tcp_input+0x1ba>
    7726:	f06f 010a 	mvn.w	r1, #10
    772a:	6928      	ldr	r0, [r5, #16]
    772c:	4798      	blx	r3
				tcp_pcb_remove(&tcp_active_pcbs, pcb);
    772e:	4629      	mov	r1, r5
    7730:	4837      	ldr	r0, [pc, #220]	; (7810 <tcp_input+0x29c>)
    7732:	4b3a      	ldr	r3, [pc, #232]	; (781c <tcp_input+0x2a8>)
    7734:	4798      	blx	r3
				memp_free(MEMP_TCP_PCB, pcb);
    7736:	4629      	mov	r1, r5
    7738:	2002      	movs	r0, #2
    773a:	4b39      	ldr	r3, [pc, #228]	; (7820 <tcp_input+0x2ac>)
    773c:	4798      	blx	r3
		tcp_input_pcb = NULL;
    773e:	2200      	movs	r2, #0
    7740:	4b35      	ldr	r3, [pc, #212]	; (7818 <tcp_input+0x2a4>)
    7742:	601a      	str	r2, [r3, #0]
		recv_data     = NULL;
    7744:	4b2a      	ldr	r3, [pc, #168]	; (77f0 <tcp_input+0x27c>)
    7746:	629a      	str	r2, [r3, #40]	; 0x28
		if (inseg.p != NULL) {
    7748:	6998      	ldr	r0, [r3, #24]
    774a:	2800      	cmp	r0, #0
    774c:	f43f af2a 	beq.w	75a4 <tcp_input+0x30>
			pbuf_free(inseg.p);
    7750:	4b29      	ldr	r3, [pc, #164]	; (77f8 <tcp_input+0x284>)
    7752:	4798      	blx	r3
			inseg.p = NULL;
    7754:	2200      	movs	r2, #0
    7756:	4b26      	ldr	r3, [pc, #152]	; (77f0 <tcp_input+0x27c>)
    7758:	619a      	str	r2, [r3, #24]
    775a:	e723      	b.n	75a4 <tcp_input+0x30>
		for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    775c:	4b31      	ldr	r3, [pc, #196]	; (7824 <tcp_input+0x2b0>)
    775e:	6818      	ldr	r0, [r3, #0]
    7760:	2800      	cmp	r0, #0
    7762:	d069      	beq.n	7838 <tcp_input+0x2c4>
			if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    7764:	4b22      	ldr	r3, [pc, #136]	; (77f0 <tcp_input+0x27c>)
    7766:	681f      	ldr	r7, [r3, #0]
    7768:	883a      	ldrh	r2, [r7, #0]
			    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    776a:	4b26      	ldr	r3, [pc, #152]	; (7804 <tcp_input+0x290>)
    776c:	f8d3 8000 	ldr.w	r8, [r3]
			    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    7770:	4b22      	ldr	r3, [pc, #136]	; (77fc <tcp_input+0x288>)
    7772:	f8d3 c000 	ldr.w	ip, [r3]
    7776:	e011      	b.n	779c <tcp_input+0x228>
	} else if (flags & TCP_FIN) {
    7778:	f01e 0f01 	tst.w	lr, #1
    777c:	d002      	beq.n	7784 <tcp_input+0x210>
		pcb->tmr = tcp_ticks;
    777e:	4b2a      	ldr	r3, [pc, #168]	; (7828 <tcp_input+0x2b4>)
    7780:	681b      	ldr	r3, [r3, #0]
    7782:	6243      	str	r3, [r0, #36]	; 0x24
	if ((tcplen > 0)) {
    7784:	2900      	cmp	r1, #0
    7786:	d02e      	beq.n	77e6 <tcp_input+0x272>
		pcb->flags |= TF_ACK_NOW;
    7788:	7f83      	ldrb	r3, [r0, #30]
    778a:	f043 0302 	orr.w	r3, r3, #2
    778e:	7783      	strb	r3, [r0, #30]
		return tcp_output(pcb);
    7790:	4b26      	ldr	r3, [pc, #152]	; (782c <tcp_input+0x2b8>)
    7792:	4798      	blx	r3
    7794:	e027      	b.n	77e6 <tcp_input+0x272>
		for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    7796:	68c0      	ldr	r0, [r0, #12]
    7798:	2800      	cmp	r0, #0
    779a:	d04d      	beq.n	7838 <tcp_input+0x2c4>
			if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    779c:	8b83      	ldrh	r3, [r0, #28]
    779e:	4293      	cmp	r3, r2
    77a0:	d1f9      	bne.n	7796 <tcp_input+0x222>
    77a2:	8b45      	ldrh	r5, [r0, #26]
    77a4:	887e      	ldrh	r6, [r7, #2]
    77a6:	42ae      	cmp	r6, r5
    77a8:	d1f5      	bne.n	7796 <tcp_input+0x222>
			    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    77aa:	6846      	ldr	r6, [r0, #4]
    77ac:	4546      	cmp	r6, r8
    77ae:	d1f2      	bne.n	7796 <tcp_input+0x222>
			    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    77b0:	6806      	ldr	r6, [r0, #0]
    77b2:	4566      	cmp	r6, ip
    77b4:	d1ef      	bne.n	7796 <tcp_input+0x222>
	if (flags & TCP_RST) {
    77b6:	f01e 0f04 	tst.w	lr, #4
    77ba:	d114      	bne.n	77e6 <tcp_input+0x272>
	if (flags & TCP_SYN) {
    77bc:	f01e 0f02 	tst.w	lr, #2
    77c0:	d0da      	beq.n	7778 <tcp_input+0x204>
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
    77c2:	4a0b      	ldr	r2, [pc, #44]	; (77f0 <tcp_input+0x27c>)
    77c4:	6856      	ldr	r6, [r2, #4]
    77c6:	6a82      	ldr	r2, [r0, #40]	; 0x28
    77c8:	1ab2      	subs	r2, r6, r2
    77ca:	d4db      	bmi.n	7784 <tcp_input+0x210>
    77cc:	8d87      	ldrh	r7, [r0, #44]	; 0x2c
    77ce:	1bd2      	subs	r2, r2, r7
    77d0:	2a00      	cmp	r2, #0
    77d2:	dcd7      	bgt.n	7784 <tcp_input+0x210>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    77d4:	9301      	str	r3, [sp, #4]
    77d6:	9500      	str	r5, [sp, #0]
    77d8:	4b0a      	ldr	r3, [pc, #40]	; (7804 <tcp_input+0x290>)
    77da:	4a08      	ldr	r2, [pc, #32]	; (77fc <tcp_input+0x288>)
    77dc:	4431      	add	r1, r6
    77de:	4804      	ldr	r0, [pc, #16]	; (77f0 <tcp_input+0x27c>)
    77e0:	68c0      	ldr	r0, [r0, #12]
    77e2:	4d13      	ldr	r5, [pc, #76]	; (7830 <tcp_input+0x2bc>)
    77e4:	47a8      	blx	r5
				pbuf_free(p);
    77e6:	4620      	mov	r0, r4
    77e8:	4b03      	ldr	r3, [pc, #12]	; (77f8 <tcp_input+0x284>)
    77ea:	4798      	blx	r3
				return;
    77ec:	e6da      	b.n	75a4 <tcp_input+0x30>
    77ee:	bf00      	nop
    77f0:	20007f9c 	.word	0x20007f9c
    77f4:	00005bf5 	.word	0x00005bf5
    77f8:	00005c89 	.word	0x00005c89
    77fc:	20008334 	.word	0x20008334
    7800:	00004ef9 	.word	0x00004ef9
    7804:	2000832c 	.word	0x2000832c
    7808:	00004a91 	.word	0x00004a91
    780c:	00002eaf 	.word	0x00002eaf
    7810:	20009300 	.word	0x20009300
    7814:	00006861 	.word	0x00006861
    7818:	20009318 	.word	0x20009318
    781c:	000065e9 	.word	0x000065e9
    7820:	000059c1 	.word	0x000059c1
    7824:	20009314 	.word	0x20009314
    7828:	20009304 	.word	0x20009304
    782c:	00008209 	.word	0x00008209
    7830:	000084dd 	.word	0x000084dd
    7834:	00002ed1 	.word	0x00002ed1
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    7838:	4b9c      	ldr	r3, [pc, #624]	; (7aac <tcp_input+0x538>)
    783a:	f8d3 c000 	ldr.w	ip, [r3]
    783e:	f1bc 0f00 	cmp.w	ip, #0
    7842:	f000 8337 	beq.w	7eb4 <tcp_input+0x940>
			if (lpcb->local_port == tcphdr->dest) {
    7846:	4b9a      	ldr	r3, [pc, #616]	; (7ab0 <tcp_input+0x53c>)
    7848:	681f      	ldr	r7, [r3, #0]
    784a:	8878      	ldrh	r0, [r7, #2]
				if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) || ip_addr_isany(&(lpcb->local_ip))) {
    784c:	4b99      	ldr	r3, [pc, #612]	; (7ab4 <tcp_input+0x540>)
    784e:	681e      	ldr	r6, [r3, #0]
    7850:	4665      	mov	r5, ip
    7852:	2200      	movs	r2, #0
    7854:	e005      	b.n	7862 <tcp_input+0x2ee>
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    7856:	68eb      	ldr	r3, [r5, #12]
    7858:	462a      	mov	r2, r5
    785a:	2b00      	cmp	r3, #0
    785c:	f000 832a 	beq.w	7eb4 <tcp_input+0x940>
    7860:	461d      	mov	r5, r3
			if (lpcb->local_port == tcphdr->dest) {
    7862:	8b6b      	ldrh	r3, [r5, #26]
    7864:	4283      	cmp	r3, r0
    7866:	d1f6      	bne.n	7856 <tcp_input+0x2e2>
				if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) || ip_addr_isany(&(lpcb->local_ip))) {
    7868:	682b      	ldr	r3, [r5, #0]
    786a:	42b3      	cmp	r3, r6
    786c:	d002      	beq.n	7874 <tcp_input+0x300>
    786e:	b10d      	cbz	r5, 7874 <tcp_input+0x300>
    7870:	2b00      	cmp	r3, #0
    7872:	d1f0      	bne.n	7856 <tcp_input+0x2e2>
		if (lpcb != NULL) {
    7874:	2d00      	cmp	r5, #0
    7876:	f000 831d 	beq.w	7eb4 <tcp_input+0x940>
			if (prev != NULL) {
    787a:	b12a      	cbz	r2, 7888 <tcp_input+0x314>
				((struct tcp_pcb_listen *)prev)->next = lpcb->next;
    787c:	68eb      	ldr	r3, [r5, #12]
    787e:	60d3      	str	r3, [r2, #12]
				lpcb->next = tcp_listen_pcbs.listen_pcbs;
    7880:	f8c5 c00c 	str.w	ip, [r5, #12]
				tcp_listen_pcbs.listen_pcbs = lpcb;
    7884:	4b89      	ldr	r3, [pc, #548]	; (7aac <tcp_input+0x538>)
    7886:	601d      	str	r5, [r3, #0]
	if (flags & TCP_RST) {
    7888:	f01e 0f04 	tst.w	lr, #4
    788c:	d105      	bne.n	789a <tcp_input+0x326>
	if (flags & TCP_ACK) {
    788e:	f01e 0f10 	tst.w	lr, #16
    7892:	d106      	bne.n	78a2 <tcp_input+0x32e>
	} else if (flags & TCP_SYN) {
    7894:	f01e 0f02 	tst.w	lr, #2
    7898:	d110      	bne.n	78bc <tcp_input+0x348>
			pbuf_free(p);
    789a:	4620      	mov	r0, r4
    789c:	4b86      	ldr	r3, [pc, #536]	; (7ab8 <tcp_input+0x544>)
    789e:	4798      	blx	r3
			return;
    78a0:	e680      	b.n	75a4 <tcp_input+0x30>
		tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    78a2:	4883      	ldr	r0, [pc, #524]	; (7ab0 <tcp_input+0x53c>)
    78a4:	6845      	ldr	r5, [r0, #4]
    78a6:	883b      	ldrh	r3, [r7, #0]
    78a8:	9301      	str	r3, [sp, #4]
    78aa:	887b      	ldrh	r3, [r7, #2]
    78ac:	9300      	str	r3, [sp, #0]
    78ae:	4b83      	ldr	r3, [pc, #524]	; (7abc <tcp_input+0x548>)
    78b0:	4a80      	ldr	r2, [pc, #512]	; (7ab4 <tcp_input+0x540>)
    78b2:	4429      	add	r1, r5
    78b4:	68c0      	ldr	r0, [r0, #12]
    78b6:	4d82      	ldr	r5, [pc, #520]	; (7ac0 <tcp_input+0x54c>)
    78b8:	47a8      	blx	r5
    78ba:	e7ee      	b.n	789a <tcp_input+0x326>
		npcb = tcp_alloc(pcb->prio);
    78bc:	7e68      	ldrb	r0, [r5, #25]
    78be:	4b81      	ldr	r3, [pc, #516]	; (7ac4 <tcp_input+0x550>)
    78c0:	4798      	blx	r3
		if (npcb == NULL) {
    78c2:	4606      	mov	r6, r0
    78c4:	2800      	cmp	r0, #0
    78c6:	d0e8      	beq.n	789a <tcp_input+0x326>
		ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    78c8:	4b7a      	ldr	r3, [pc, #488]	; (7ab4 <tcp_input+0x540>)
    78ca:	681b      	ldr	r3, [r3, #0]
    78cc:	6003      	str	r3, [r0, #0]
		npcb->local_port = pcb->local_port;
    78ce:	8b6b      	ldrh	r3, [r5, #26]
    78d0:	8343      	strh	r3, [r0, #26]
		ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    78d2:	4b7a      	ldr	r3, [pc, #488]	; (7abc <tcp_input+0x548>)
    78d4:	681b      	ldr	r3, [r3, #0]
    78d6:	6043      	str	r3, [r0, #4]
		npcb->remote_port        = tcphdr->src;
    78d8:	4b75      	ldr	r3, [pc, #468]	; (7ab0 <tcp_input+0x53c>)
    78da:	681a      	ldr	r2, [r3, #0]
    78dc:	8811      	ldrh	r1, [r2, #0]
    78de:	8381      	strh	r1, [r0, #28]
		npcb->state              = SYN_RCVD;
    78e0:	2103      	movs	r1, #3
    78e2:	7601      	strb	r1, [r0, #24]
		npcb->rcv_nxt            = seqno + 1;
    78e4:	685b      	ldr	r3, [r3, #4]
    78e6:	1c59      	adds	r1, r3, #1
    78e8:	6281      	str	r1, [r0, #40]	; 0x28
		npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    78ea:	6301      	str	r1, [r0, #48]	; 0x30
		npcb->snd_wnd            = tcphdr->wnd;
    78ec:	89d1      	ldrh	r1, [r2, #14]
    78ee:	f8a0 1060 	strh.w	r1, [r0, #96]	; 0x60
		npcb->snd_wnd_max        = tcphdr->wnd;
    78f2:	89d2      	ldrh	r2, [r2, #14]
    78f4:	f8a0 2062 	strh.w	r2, [r0, #98]	; 0x62
		npcb->ssthresh           = npcb->snd_wnd;
    78f8:	f8a0 104e 	strh.w	r1, [r0, #78]	; 0x4e
		npcb->snd_wl1            = seqno - 1; /* initialise to seqno-1 to force window update */
    78fc:	3b01      	subs	r3, #1
    78fe:	6543      	str	r3, [r0, #84]	; 0x54
		npcb->callback_arg       = pcb->callback_arg;
    7900:	692b      	ldr	r3, [r5, #16]
    7902:	6103      	str	r3, [r0, #16]
		npcb->accept = pcb->accept;
    7904:	696b      	ldr	r3, [r5, #20]
    7906:	6143      	str	r3, [r0, #20]
		npcb->so_options = pcb->so_options & SOF_INHERITED;
    7908:	7a2b      	ldrb	r3, [r5, #8]
    790a:	f023 0373 	bic.w	r3, r3, #115	; 0x73
    790e:	7203      	strb	r3, [r0, #8]
		TCP_REG_ACTIVE(npcb);
    7910:	4b6d      	ldr	r3, [pc, #436]	; (7ac8 <tcp_input+0x554>)
    7912:	681a      	ldr	r2, [r3, #0]
    7914:	60c2      	str	r2, [r0, #12]
    7916:	6018      	str	r0, [r3, #0]
    7918:	4b6c      	ldr	r3, [pc, #432]	; (7acc <tcp_input+0x558>)
    791a:	4798      	blx	r3
    791c:	2201      	movs	r2, #1
    791e:	4b6c      	ldr	r3, [pc, #432]	; (7ad0 <tcp_input+0x55c>)
    7920:	701a      	strb	r2, [r3, #0]
		tcp_parseopt(npcb);
    7922:	4630      	mov	r0, r6
    7924:	4b6b      	ldr	r3, [pc, #428]	; (7ad4 <tcp_input+0x560>)
    7926:	4798      	blx	r3
		npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    7928:	1d31      	adds	r1, r6, #4
    792a:	8ef0      	ldrh	r0, [r6, #54]	; 0x36
    792c:	4b6a      	ldr	r3, [pc, #424]	; (7ad8 <tcp_input+0x564>)
    792e:	4798      	blx	r3
    7930:	86f0      	strh	r0, [r6, #54]	; 0x36
		rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    7932:	2112      	movs	r1, #18
    7934:	4630      	mov	r0, r6
    7936:	4b69      	ldr	r3, [pc, #420]	; (7adc <tcp_input+0x568>)
    7938:	4798      	blx	r3
		if (rc != ERR_OK) {
    793a:	b918      	cbnz	r0, 7944 <tcp_input+0x3d0>
		return tcp_output(npcb);
    793c:	4630      	mov	r0, r6
    793e:	4b68      	ldr	r3, [pc, #416]	; (7ae0 <tcp_input+0x56c>)
    7940:	4798      	blx	r3
    7942:	e7aa      	b.n	789a <tcp_input+0x326>
			tcp_abandon(npcb, 0);
    7944:	2100      	movs	r1, #0
    7946:	4630      	mov	r0, r6
    7948:	4b66      	ldr	r3, [pc, #408]	; (7ae4 <tcp_input+0x570>)
    794a:	4798      	blx	r3
    794c:	e7a5      	b.n	789a <tcp_input+0x326>
			if (ackno == pcb->snd_nxt) {
    794e:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    7950:	4a57      	ldr	r2, [pc, #348]	; (7ab0 <tcp_input+0x53c>)
    7952:	68d2      	ldr	r2, [r2, #12]
	u8_t            acceptable = 0;
    7954:	4293      	cmp	r3, r2
    7956:	bf14      	ite	ne
    7958:	2300      	movne	r3, #0
    795a:	2301      	moveq	r3, #1
    795c:	e6d6      	b.n	770c <tcp_input+0x198>
			recv_flags |= TF_RESET;
    795e:	4a54      	ldr	r2, [pc, #336]	; (7ab0 <tcp_input+0x53c>)
    7960:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
    7964:	f043 0308 	orr.w	r3, r3, #8
    7968:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
			pcb->flags &= ~TF_ACK_DELAY;
    796c:	7fab      	ldrb	r3, [r5, #30]
    796e:	f023 0301 	bic.w	r3, r3, #1
    7972:	77ab      	strb	r3, [r5, #30]
    7974:	e6cd      	b.n	7712 <tcp_input+0x19e>
	if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
    7976:	f013 0f02 	tst.w	r3, #2
    797a:	d009      	beq.n	7990 <tcp_input+0x41c>
    797c:	7e2b      	ldrb	r3, [r5, #24]
    797e:	3b02      	subs	r3, #2
    7980:	b2db      	uxtb	r3, r3
    7982:	2b01      	cmp	r3, #1
    7984:	d904      	bls.n	7990 <tcp_input+0x41c>
		tcp_ack_now(pcb);
    7986:	7fab      	ldrb	r3, [r5, #30]
    7988:	f043 0302 	orr.w	r3, r3, #2
    798c:	77ab      	strb	r3, [r5, #30]
    798e:	e6c0      	b.n	7712 <tcp_input+0x19e>
	if ((pcb->flags & TF_RXCLOSED) == 0) {
    7990:	7fab      	ldrb	r3, [r5, #30]
    7992:	f013 0f10 	tst.w	r3, #16
    7996:	d102      	bne.n	799e <tcp_input+0x42a>
		pcb->tmr = tcp_ticks;
    7998:	4b53      	ldr	r3, [pc, #332]	; (7ae8 <tcp_input+0x574>)
    799a:	681b      	ldr	r3, [r3, #0]
    799c:	626b      	str	r3, [r5, #36]	; 0x24
	pcb->keep_cnt_sent = 0;
    799e:	2300      	movs	r3, #0
    79a0:	f885 3096 	strb.w	r3, [r5, #150]	; 0x96
	tcp_parseopt(pcb);
    79a4:	4628      	mov	r0, r5
    79a6:	4b4b      	ldr	r3, [pc, #300]	; (7ad4 <tcp_input+0x560>)
    79a8:	4798      	blx	r3
	switch (pcb->state) {
    79aa:	7e2b      	ldrb	r3, [r5, #24]
    79ac:	3b02      	subs	r3, #2
    79ae:	2b07      	cmp	r3, #7
    79b0:	f63f aeaf 	bhi.w	7712 <tcp_input+0x19e>
    79b4:	e8df f013 	tbh	[pc, r3, lsl #1]
    79b8:	009e0008 	.word	0x009e0008
    79bc:	010c00fb 	.word	0x010c00fb
    79c0:	00fb0166 	.word	0x00fb0166
    79c4:	01fa01a2 	.word	0x01fa01a2
		if ((flags & TCP_ACK) && (flags & TCP_SYN) && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    79c8:	4b39      	ldr	r3, [pc, #228]	; (7ab0 <tcp_input+0x53c>)
    79ca:	7a1b      	ldrb	r3, [r3, #8]
    79cc:	f003 0312 	and.w	r3, r3, #18
    79d0:	2b12      	cmp	r3, #18
    79d2:	d014      	beq.n	79fe <tcp_input+0x48a>
		else if (flags & TCP_ACK) {
    79d4:	4b36      	ldr	r3, [pc, #216]	; (7ab0 <tcp_input+0x53c>)
    79d6:	7a1b      	ldrb	r3, [r3, #8]
    79d8:	f013 0f10 	tst.w	r3, #16
    79dc:	f43f ae99 	beq.w	7712 <tcp_input+0x19e>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    79e0:	4833      	ldr	r0, [pc, #204]	; (7ab0 <tcp_input+0x53c>)
    79e2:	6803      	ldr	r3, [r0, #0]
    79e4:	8a04      	ldrh	r4, [r0, #16]
    79e6:	6841      	ldr	r1, [r0, #4]
    79e8:	881a      	ldrh	r2, [r3, #0]
    79ea:	9201      	str	r2, [sp, #4]
    79ec:	885b      	ldrh	r3, [r3, #2]
    79ee:	9300      	str	r3, [sp, #0]
    79f0:	4b32      	ldr	r3, [pc, #200]	; (7abc <tcp_input+0x548>)
    79f2:	4a30      	ldr	r2, [pc, #192]	; (7ab4 <tcp_input+0x540>)
    79f4:	4421      	add	r1, r4
    79f6:	68c0      	ldr	r0, [r0, #12]
    79f8:	4c31      	ldr	r4, [pc, #196]	; (7ac0 <tcp_input+0x54c>)
    79fa:	47a0      	blx	r4
    79fc:	e689      	b.n	7712 <tcp_input+0x19e>
		if ((flags & TCP_ACK) && (flags & TCP_SYN) && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    79fe:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    7a00:	691b      	ldr	r3, [r3, #16]
    7a02:	6858      	ldr	r0, [r3, #4]
    7a04:	4b39      	ldr	r3, [pc, #228]	; (7aec <tcp_input+0x578>)
    7a06:	4798      	blx	r3
    7a08:	3001      	adds	r0, #1
    7a0a:	4b29      	ldr	r3, [pc, #164]	; (7ab0 <tcp_input+0x53c>)
    7a0c:	68db      	ldr	r3, [r3, #12]
    7a0e:	4298      	cmp	r0, r3
    7a10:	d1e0      	bne.n	79d4 <tcp_input+0x460>
			pcb->snd_buf++;
    7a12:	f8b5 3066 	ldrh.w	r3, [r5, #102]	; 0x66
    7a16:	3301      	adds	r3, #1
    7a18:	f8a5 3066 	strh.w	r3, [r5, #102]	; 0x66
			pcb->rcv_nxt            = seqno + 1;
    7a1c:	4a24      	ldr	r2, [pc, #144]	; (7ab0 <tcp_input+0x53c>)
    7a1e:	6853      	ldr	r3, [r2, #4]
    7a20:	1c59      	adds	r1, r3, #1
    7a22:	62a9      	str	r1, [r5, #40]	; 0x28
			pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    7a24:	6329      	str	r1, [r5, #48]	; 0x30
			pcb->lastack            = ackno;
    7a26:	64a8      	str	r0, [r5, #72]	; 0x48
			pcb->snd_wnd            = tcphdr->wnd;
    7a28:	6812      	ldr	r2, [r2, #0]
    7a2a:	89d1      	ldrh	r1, [r2, #14]
    7a2c:	f8a5 1060 	strh.w	r1, [r5, #96]	; 0x60
			pcb->snd_wnd_max        = tcphdr->wnd;
    7a30:	89d2      	ldrh	r2, [r2, #14]
    7a32:	f8a5 2062 	strh.w	r2, [r5, #98]	; 0x62
			pcb->snd_wl1            = seqno - 1; /* initialise to seqno - 1 to force window update */
    7a36:	3b01      	subs	r3, #1
    7a38:	656b      	str	r3, [r5, #84]	; 0x54
			pcb->state              = ESTABLISHED;
    7a3a:	2304      	movs	r3, #4
    7a3c:	762b      	strb	r3, [r5, #24]
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    7a3e:	18e9      	adds	r1, r5, r3
    7a40:	8ee8      	ldrh	r0, [r5, #54]	; 0x36
    7a42:	4b25      	ldr	r3, [pc, #148]	; (7ad8 <tcp_input+0x564>)
    7a44:	4798      	blx	r3
    7a46:	86e8      	strh	r0, [r5, #54]	; 0x36
			pcb->ssthresh = pcb->mss * 10;
    7a48:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    7a4c:	005b      	lsls	r3, r3, #1
    7a4e:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
			pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    7a52:	f8b5 304c 	ldrh.w	r3, [r5, #76]	; 0x4c
    7a56:	2b01      	cmp	r3, #1
    7a58:	bf04      	itt	eq
    7a5a:	0040      	lsleq	r0, r0, #1
    7a5c:	b280      	uxtheq	r0, r0
    7a5e:	f8a5 004c 	strh.w	r0, [r5, #76]	; 0x4c
			--pcb->snd_queuelen;
    7a62:	f8b5 3068 	ldrh.w	r3, [r5, #104]	; 0x68
    7a66:	3b01      	subs	r3, #1
    7a68:	f8a5 3068 	strh.w	r3, [r5, #104]	; 0x68
			rseg         = pcb->unacked;
    7a6c:	6f28      	ldr	r0, [r5, #112]	; 0x70
			pcb->unacked = rseg->next;
    7a6e:	6803      	ldr	r3, [r0, #0]
    7a70:	672b      	str	r3, [r5, #112]	; 0x70
			tcp_seg_free(rseg);
    7a72:	4b1f      	ldr	r3, [pc, #124]	; (7af0 <tcp_input+0x57c>)
    7a74:	4798      	blx	r3
			if (pcb->unacked == NULL)
    7a76:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    7a78:	b993      	cbnz	r3, 7aa0 <tcp_input+0x52c>
				pcb->rtime = -1;
    7a7a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    7a7e:	86ab      	strh	r3, [r5, #52]	; 0x34
			TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    7a80:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
    7a84:	b13b      	cbz	r3, 7a96 <tcp_input+0x522>
    7a86:	2200      	movs	r2, #0
    7a88:	4629      	mov	r1, r5
    7a8a:	6928      	ldr	r0, [r5, #16]
    7a8c:	4798      	blx	r3
			if (err == ERR_ABRT) {
    7a8e:	f110 0f0a 	cmn.w	r0, #10
    7a92:	f43f ae54 	beq.w	773e <tcp_input+0x1ca>
			tcp_ack_now(pcb);
    7a96:	7fab      	ldrb	r3, [r5, #30]
    7a98:	f043 0302 	orr.w	r3, r3, #2
    7a9c:	77ab      	strb	r3, [r5, #30]
    7a9e:	e638      	b.n	7712 <tcp_input+0x19e>
				pcb->rtime = 0;
    7aa0:	2300      	movs	r3, #0
    7aa2:	86ab      	strh	r3, [r5, #52]	; 0x34
				pcb->nrtx  = 0;
    7aa4:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
    7aa8:	e7ea      	b.n	7a80 <tcp_input+0x50c>
    7aaa:	bf00      	nop
    7aac:	20009308 	.word	0x20009308
    7ab0:	20007f9c 	.word	0x20007f9c
    7ab4:	20008334 	.word	0x20008334
    7ab8:	00005c89 	.word	0x00005c89
    7abc:	2000832c 	.word	0x2000832c
    7ac0:	000084dd 	.word	0x000084dd
    7ac4:	00006a45 	.word	0x00006a45
    7ac8:	20009300 	.word	0x20009300
    7acc:	00008821 	.word	0x00008821
    7ad0:	200092fc 	.word	0x200092fc
    7ad4:	00006b95 	.word	0x00006b95
    7ad8:	00006b6d 	.word	0x00006b6d
    7adc:	0000806d 	.word	0x0000806d
    7ae0:	00008209 	.word	0x00008209
    7ae4:	00006979 	.word	0x00006979
    7ae8:	20009304 	.word	0x20009304
    7aec:	00002ed1 	.word	0x00002ed1
    7af0:	000061a9 	.word	0x000061a9
		if (flags & TCP_ACK) {
    7af4:	4b9d      	ldr	r3, [pc, #628]	; (7d6c <tcp_input+0x7f8>)
    7af6:	7a1b      	ldrb	r3, [r3, #8]
    7af8:	f013 0f10 	tst.w	r3, #16
    7afc:	d048      	beq.n	7b90 <tcp_input+0x61c>
			if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
    7afe:	4b9b      	ldr	r3, [pc, #620]	; (7d6c <tcp_input+0x7f8>)
    7b00:	68d8      	ldr	r0, [r3, #12]
    7b02:	6cab      	ldr	r3, [r5, #72]	; 0x48
    7b04:	43db      	mvns	r3, r3
    7b06:	42c3      	cmn	r3, r0
    7b08:	d434      	bmi.n	7b74 <tcp_input+0x600>
    7b0a:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    7b0c:	1ac3      	subs	r3, r0, r3
    7b0e:	2b00      	cmp	r3, #0
    7b10:	dc30      	bgt.n	7b74 <tcp_input+0x600>
				pcb->state = ESTABLISHED;
    7b12:	2304      	movs	r3, #4
    7b14:	762b      	strb	r3, [r5, #24]
				TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    7b16:	696b      	ldr	r3, [r5, #20]
    7b18:	b143      	cbz	r3, 7b2c <tcp_input+0x5b8>
    7b1a:	2200      	movs	r2, #0
    7b1c:	4629      	mov	r1, r5
    7b1e:	6928      	ldr	r0, [r5, #16]
    7b20:	4798      	blx	r3
				if (err != ERR_OK) {
    7b22:	b138      	cbz	r0, 7b34 <tcp_input+0x5c0>
					if (err != ERR_ABRT) {
    7b24:	f110 0f0a 	cmn.w	r0, #10
    7b28:	f43f ae09 	beq.w	773e <tcp_input+0x1ca>
						tcp_abort(pcb);
    7b2c:	4628      	mov	r0, r5
    7b2e:	4b90      	ldr	r3, [pc, #576]	; (7d70 <tcp_input+0x7fc>)
    7b30:	4798      	blx	r3
    7b32:	e604      	b.n	773e <tcp_input+0x1ca>
				old_cwnd = pcb->cwnd;
    7b34:	f8b5 404c 	ldrh.w	r4, [r5, #76]	; 0x4c
				tcp_receive(pcb);
    7b38:	4628      	mov	r0, r5
    7b3a:	4b8e      	ldr	r3, [pc, #568]	; (7d74 <tcp_input+0x800>)
    7b3c:	4798      	blx	r3
				if (pcb->acked != 0) {
    7b3e:	f8b5 3064 	ldrh.w	r3, [r5, #100]	; 0x64
    7b42:	b113      	cbz	r3, 7b4a <tcp_input+0x5d6>
					pcb->acked--;
    7b44:	3b01      	subs	r3, #1
    7b46:	f8a5 3064 	strh.w	r3, [r5, #100]	; 0x64
				pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    7b4a:	2c01      	cmp	r4, #1
    7b4c:	8eeb      	ldrh	r3, [r5, #54]	; 0x36
    7b4e:	bf04      	itt	eq
    7b50:	005b      	lsleq	r3, r3, #1
    7b52:	b29b      	uxtheq	r3, r3
    7b54:	f8a5 304c 	strh.w	r3, [r5, #76]	; 0x4c
				if (recv_flags & TF_GOT_FIN) {
    7b58:	4b84      	ldr	r3, [pc, #528]	; (7d6c <tcp_input+0x7f8>)
    7b5a:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    7b5e:	f013 0f20 	tst.w	r3, #32
    7b62:	f43f add6 	beq.w	7712 <tcp_input+0x19e>
					tcp_ack_now(pcb);
    7b66:	7fab      	ldrb	r3, [r5, #30]
    7b68:	f043 0302 	orr.w	r3, r3, #2
    7b6c:	77ab      	strb	r3, [r5, #30]
					pcb->state = CLOSE_WAIT;
    7b6e:	2307      	movs	r3, #7
    7b70:	762b      	strb	r3, [r5, #24]
    7b72:	e5ce      	b.n	7712 <tcp_input+0x19e>
				    ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    7b74:	4b7d      	ldr	r3, [pc, #500]	; (7d6c <tcp_input+0x7f8>)
    7b76:	681a      	ldr	r2, [r3, #0]
				tcp_rst(
    7b78:	8a1c      	ldrh	r4, [r3, #16]
    7b7a:	6859      	ldr	r1, [r3, #4]
    7b7c:	8813      	ldrh	r3, [r2, #0]
    7b7e:	9301      	str	r3, [sp, #4]
    7b80:	8853      	ldrh	r3, [r2, #2]
    7b82:	9300      	str	r3, [sp, #0]
    7b84:	4b7c      	ldr	r3, [pc, #496]	; (7d78 <tcp_input+0x804>)
    7b86:	4a7d      	ldr	r2, [pc, #500]	; (7d7c <tcp_input+0x808>)
    7b88:	4421      	add	r1, r4
    7b8a:	4c7d      	ldr	r4, [pc, #500]	; (7d80 <tcp_input+0x80c>)
    7b8c:	47a0      	blx	r4
    7b8e:	e5c0      	b.n	7712 <tcp_input+0x19e>
		} else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
    7b90:	f013 0f02 	tst.w	r3, #2
    7b94:	f43f adbd 	beq.w	7712 <tcp_input+0x19e>
    7b98:	6aab      	ldr	r3, [r5, #40]	; 0x28
    7b9a:	3b01      	subs	r3, #1
    7b9c:	4a73      	ldr	r2, [pc, #460]	; (7d6c <tcp_input+0x7f8>)
    7b9e:	6852      	ldr	r2, [r2, #4]
    7ba0:	4293      	cmp	r3, r2
    7ba2:	f47f adb6 	bne.w	7712 <tcp_input+0x19e>
			tcp_rexmit(pcb);
    7ba6:	4628      	mov	r0, r5
    7ba8:	4b76      	ldr	r3, [pc, #472]	; (7d84 <tcp_input+0x810>)
    7baa:	4798      	blx	r3
    7bac:	e5b1      	b.n	7712 <tcp_input+0x19e>
		tcp_receive(pcb);
    7bae:	4628      	mov	r0, r5
    7bb0:	4b70      	ldr	r3, [pc, #448]	; (7d74 <tcp_input+0x800>)
    7bb2:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) { /* passive close */
    7bb4:	4b6d      	ldr	r3, [pc, #436]	; (7d6c <tcp_input+0x7f8>)
    7bb6:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    7bba:	f013 0f20 	tst.w	r3, #32
    7bbe:	f43f ada8 	beq.w	7712 <tcp_input+0x19e>
			tcp_ack_now(pcb);
    7bc2:	7fab      	ldrb	r3, [r5, #30]
    7bc4:	f043 0302 	orr.w	r3, r3, #2
    7bc8:	77ab      	strb	r3, [r5, #30]
			pcb->state = CLOSE_WAIT;
    7bca:	2307      	movs	r3, #7
    7bcc:	762b      	strb	r3, [r5, #24]
    7bce:	e5a0      	b.n	7712 <tcp_input+0x19e>
		tcp_receive(pcb);
    7bd0:	4628      	mov	r0, r5
    7bd2:	4b68      	ldr	r3, [pc, #416]	; (7d74 <tcp_input+0x800>)
    7bd4:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) {
    7bd6:	4b65      	ldr	r3, [pc, #404]	; (7d6c <tcp_input+0x7f8>)
    7bd8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    7bdc:	f013 0f20 	tst.w	r3, #32
    7be0:	d041      	beq.n	7c66 <tcp_input+0x6f2>
			if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    7be2:	4b62      	ldr	r3, [pc, #392]	; (7d6c <tcp_input+0x7f8>)
    7be4:	7a1b      	ldrb	r3, [r3, #8]
    7be6:	f013 0f10 	tst.w	r3, #16
    7bea:	d035      	beq.n	7c58 <tcp_input+0x6e4>
    7bec:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    7bee:	4b5f      	ldr	r3, [pc, #380]	; (7d6c <tcp_input+0x7f8>)
    7bf0:	68db      	ldr	r3, [r3, #12]
    7bf2:	429a      	cmp	r2, r3
    7bf4:	d130      	bne.n	7c58 <tcp_input+0x6e4>
				tcp_ack_now(pcb);
    7bf6:	7fab      	ldrb	r3, [r5, #30]
    7bf8:	f043 0302 	orr.w	r3, r3, #2
    7bfc:	77ab      	strb	r3, [r5, #30]
				tcp_pcb_purge(pcb);
    7bfe:	4628      	mov	r0, r5
    7c00:	4b61      	ldr	r3, [pc, #388]	; (7d88 <tcp_input+0x814>)
    7c02:	4798      	blx	r3
				TCP_RMV_ACTIVE(pcb);
    7c04:	4b61      	ldr	r3, [pc, #388]	; (7d8c <tcp_input+0x818>)
    7c06:	681b      	ldr	r3, [r3, #0]
    7c08:	429d      	cmp	r5, r3
    7c0a:	d10e      	bne.n	7c2a <tcp_input+0x6b6>
    7c0c:	68ea      	ldr	r2, [r5, #12]
    7c0e:	4b5f      	ldr	r3, [pc, #380]	; (7d8c <tcp_input+0x818>)
    7c10:	601a      	str	r2, [r3, #0]
    7c12:	2201      	movs	r2, #1
    7c14:	4b5e      	ldr	r3, [pc, #376]	; (7d90 <tcp_input+0x81c>)
    7c16:	701a      	strb	r2, [r3, #0]
				pcb->state = TIME_WAIT;
    7c18:	230a      	movs	r3, #10
    7c1a:	762b      	strb	r3, [r5, #24]
				TCP_REG(&tcp_tw_pcbs, pcb);
    7c1c:	4b5d      	ldr	r3, [pc, #372]	; (7d94 <tcp_input+0x820>)
    7c1e:	681a      	ldr	r2, [r3, #0]
    7c20:	60ea      	str	r2, [r5, #12]
    7c22:	601d      	str	r5, [r3, #0]
    7c24:	4b5c      	ldr	r3, [pc, #368]	; (7d98 <tcp_input+0x824>)
    7c26:	4798      	blx	r3
    7c28:	e573      	b.n	7712 <tcp_input+0x19e>
				TCP_RMV_ACTIVE(pcb);
    7c2a:	4a5c      	ldr	r2, [pc, #368]	; (7d9c <tcp_input+0x828>)
    7c2c:	6013      	str	r3, [r2, #0]
    7c2e:	2200      	movs	r2, #0
    7c30:	2001      	movs	r0, #1
    7c32:	b92b      	cbnz	r3, 7c40 <tcp_input+0x6cc>
    7c34:	2a00      	cmp	r2, #0
    7c36:	d0ec      	beq.n	7c12 <tcp_input+0x69e>
    7c38:	2200      	movs	r2, #0
    7c3a:	4b58      	ldr	r3, [pc, #352]	; (7d9c <tcp_input+0x828>)
    7c3c:	601a      	str	r2, [r3, #0]
    7c3e:	e7e8      	b.n	7c12 <tcp_input+0x69e>
    7c40:	68d9      	ldr	r1, [r3, #12]
    7c42:	428d      	cmp	r5, r1
    7c44:	d105      	bne.n	7c52 <tcp_input+0x6de>
    7c46:	b10a      	cbz	r2, 7c4c <tcp_input+0x6d8>
    7c48:	4a54      	ldr	r2, [pc, #336]	; (7d9c <tcp_input+0x828>)
    7c4a:	6013      	str	r3, [r2, #0]
    7c4c:	68ea      	ldr	r2, [r5, #12]
    7c4e:	60da      	str	r2, [r3, #12]
    7c50:	e7df      	b.n	7c12 <tcp_input+0x69e>
    7c52:	4602      	mov	r2, r0
    7c54:	460b      	mov	r3, r1
    7c56:	e7ec      	b.n	7c32 <tcp_input+0x6be>
				tcp_ack_now(pcb);
    7c58:	7fab      	ldrb	r3, [r5, #30]
    7c5a:	f043 0302 	orr.w	r3, r3, #2
    7c5e:	77ab      	strb	r3, [r5, #30]
				pcb->state = CLOSING;
    7c60:	2308      	movs	r3, #8
    7c62:	762b      	strb	r3, [r5, #24]
    7c64:	e555      	b.n	7712 <tcp_input+0x19e>
		} else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    7c66:	4b41      	ldr	r3, [pc, #260]	; (7d6c <tcp_input+0x7f8>)
    7c68:	7a1b      	ldrb	r3, [r3, #8]
    7c6a:	f013 0f10 	tst.w	r3, #16
    7c6e:	f43f ad50 	beq.w	7712 <tcp_input+0x19e>
    7c72:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    7c74:	4b3d      	ldr	r3, [pc, #244]	; (7d6c <tcp_input+0x7f8>)
    7c76:	68db      	ldr	r3, [r3, #12]
    7c78:	429a      	cmp	r2, r3
    7c7a:	f47f ad4a 	bne.w	7712 <tcp_input+0x19e>
			pcb->state = FIN_WAIT_2;
    7c7e:	2306      	movs	r3, #6
    7c80:	762b      	strb	r3, [r5, #24]
    7c82:	e546      	b.n	7712 <tcp_input+0x19e>
		tcp_receive(pcb);
    7c84:	4628      	mov	r0, r5
    7c86:	4b3b      	ldr	r3, [pc, #236]	; (7d74 <tcp_input+0x800>)
    7c88:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) {
    7c8a:	4b38      	ldr	r3, [pc, #224]	; (7d6c <tcp_input+0x7f8>)
    7c8c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    7c90:	f013 0f20 	tst.w	r3, #32
    7c94:	f43f ad3d 	beq.w	7712 <tcp_input+0x19e>
			tcp_ack_now(pcb);
    7c98:	7fab      	ldrb	r3, [r5, #30]
    7c9a:	f043 0302 	orr.w	r3, r3, #2
    7c9e:	77ab      	strb	r3, [r5, #30]
			tcp_pcb_purge(pcb);
    7ca0:	4628      	mov	r0, r5
    7ca2:	4b39      	ldr	r3, [pc, #228]	; (7d88 <tcp_input+0x814>)
    7ca4:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    7ca6:	4b39      	ldr	r3, [pc, #228]	; (7d8c <tcp_input+0x818>)
    7ca8:	681b      	ldr	r3, [r3, #0]
    7caa:	429d      	cmp	r5, r3
    7cac:	d10e      	bne.n	7ccc <tcp_input+0x758>
    7cae:	68ea      	ldr	r2, [r5, #12]
    7cb0:	4b36      	ldr	r3, [pc, #216]	; (7d8c <tcp_input+0x818>)
    7cb2:	601a      	str	r2, [r3, #0]
    7cb4:	2201      	movs	r2, #1
    7cb6:	4b36      	ldr	r3, [pc, #216]	; (7d90 <tcp_input+0x81c>)
    7cb8:	701a      	strb	r2, [r3, #0]
			pcb->state = TIME_WAIT;
    7cba:	230a      	movs	r3, #10
    7cbc:	762b      	strb	r3, [r5, #24]
			TCP_REG(&tcp_tw_pcbs, pcb);
    7cbe:	4b35      	ldr	r3, [pc, #212]	; (7d94 <tcp_input+0x820>)
    7cc0:	681a      	ldr	r2, [r3, #0]
    7cc2:	60ea      	str	r2, [r5, #12]
    7cc4:	601d      	str	r5, [r3, #0]
    7cc6:	4b34      	ldr	r3, [pc, #208]	; (7d98 <tcp_input+0x824>)
    7cc8:	4798      	blx	r3
    7cca:	e522      	b.n	7712 <tcp_input+0x19e>
			TCP_RMV_ACTIVE(pcb);
    7ccc:	4a33      	ldr	r2, [pc, #204]	; (7d9c <tcp_input+0x828>)
    7cce:	6013      	str	r3, [r2, #0]
    7cd0:	2200      	movs	r2, #0
    7cd2:	2001      	movs	r0, #1
    7cd4:	e004      	b.n	7ce0 <tcp_input+0x76c>
    7cd6:	68d9      	ldr	r1, [r3, #12]
    7cd8:	428d      	cmp	r5, r1
    7cda:	d009      	beq.n	7cf0 <tcp_input+0x77c>
    7cdc:	4602      	mov	r2, r0
    7cde:	460b      	mov	r3, r1
    7ce0:	2b00      	cmp	r3, #0
    7ce2:	d1f8      	bne.n	7cd6 <tcp_input+0x762>
    7ce4:	2a00      	cmp	r2, #0
    7ce6:	d0e5      	beq.n	7cb4 <tcp_input+0x740>
    7ce8:	2200      	movs	r2, #0
    7cea:	4b2c      	ldr	r3, [pc, #176]	; (7d9c <tcp_input+0x828>)
    7cec:	601a      	str	r2, [r3, #0]
    7cee:	e7e1      	b.n	7cb4 <tcp_input+0x740>
    7cf0:	b10a      	cbz	r2, 7cf6 <tcp_input+0x782>
    7cf2:	4a2a      	ldr	r2, [pc, #168]	; (7d9c <tcp_input+0x828>)
    7cf4:	6013      	str	r3, [r2, #0]
    7cf6:	68ea      	ldr	r2, [r5, #12]
    7cf8:	60da      	str	r2, [r3, #12]
    7cfa:	e7db      	b.n	7cb4 <tcp_input+0x740>
		tcp_receive(pcb);
    7cfc:	4628      	mov	r0, r5
    7cfe:	4b1d      	ldr	r3, [pc, #116]	; (7d74 <tcp_input+0x800>)
    7d00:	4798      	blx	r3
		if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    7d02:	4b1a      	ldr	r3, [pc, #104]	; (7d6c <tcp_input+0x7f8>)
    7d04:	7a1b      	ldrb	r3, [r3, #8]
    7d06:	f013 0f10 	tst.w	r3, #16
    7d0a:	f43f ad02 	beq.w	7712 <tcp_input+0x19e>
    7d0e:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    7d10:	4b16      	ldr	r3, [pc, #88]	; (7d6c <tcp_input+0x7f8>)
    7d12:	68db      	ldr	r3, [r3, #12]
    7d14:	429a      	cmp	r2, r3
    7d16:	f47f acfc 	bne.w	7712 <tcp_input+0x19e>
			tcp_pcb_purge(pcb);
    7d1a:	4628      	mov	r0, r5
    7d1c:	4b1a      	ldr	r3, [pc, #104]	; (7d88 <tcp_input+0x814>)
    7d1e:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    7d20:	4b1a      	ldr	r3, [pc, #104]	; (7d8c <tcp_input+0x818>)
    7d22:	681b      	ldr	r3, [r3, #0]
    7d24:	429d      	cmp	r5, r3
    7d26:	d10e      	bne.n	7d46 <tcp_input+0x7d2>
    7d28:	68ea      	ldr	r2, [r5, #12]
    7d2a:	4b18      	ldr	r3, [pc, #96]	; (7d8c <tcp_input+0x818>)
    7d2c:	601a      	str	r2, [r3, #0]
    7d2e:	2201      	movs	r2, #1
    7d30:	4b17      	ldr	r3, [pc, #92]	; (7d90 <tcp_input+0x81c>)
    7d32:	701a      	strb	r2, [r3, #0]
			pcb->state = TIME_WAIT;
    7d34:	230a      	movs	r3, #10
    7d36:	762b      	strb	r3, [r5, #24]
			TCP_REG(&tcp_tw_pcbs, pcb);
    7d38:	4b16      	ldr	r3, [pc, #88]	; (7d94 <tcp_input+0x820>)
    7d3a:	681a      	ldr	r2, [r3, #0]
    7d3c:	60ea      	str	r2, [r5, #12]
    7d3e:	601d      	str	r5, [r3, #0]
    7d40:	4b15      	ldr	r3, [pc, #84]	; (7d98 <tcp_input+0x824>)
    7d42:	4798      	blx	r3
    7d44:	e4e5      	b.n	7712 <tcp_input+0x19e>
			TCP_RMV_ACTIVE(pcb);
    7d46:	4a15      	ldr	r2, [pc, #84]	; (7d9c <tcp_input+0x828>)
    7d48:	6013      	str	r3, [r2, #0]
    7d4a:	2200      	movs	r2, #0
    7d4c:	2001      	movs	r0, #1
    7d4e:	e004      	b.n	7d5a <tcp_input+0x7e6>
    7d50:	68d9      	ldr	r1, [r3, #12]
    7d52:	428d      	cmp	r5, r1
    7d54:	d024      	beq.n	7da0 <tcp_input+0x82c>
    7d56:	4602      	mov	r2, r0
    7d58:	460b      	mov	r3, r1
    7d5a:	2b00      	cmp	r3, #0
    7d5c:	d1f8      	bne.n	7d50 <tcp_input+0x7dc>
    7d5e:	2a00      	cmp	r2, #0
    7d60:	d0e5      	beq.n	7d2e <tcp_input+0x7ba>
    7d62:	2200      	movs	r2, #0
    7d64:	4b0d      	ldr	r3, [pc, #52]	; (7d9c <tcp_input+0x828>)
    7d66:	601a      	str	r2, [r3, #0]
    7d68:	e7e1      	b.n	7d2e <tcp_input+0x7ba>
    7d6a:	bf00      	nop
    7d6c:	20007f9c 	.word	0x20007f9c
    7d70:	00006a1d 	.word	0x00006a1d
    7d74:	00006cfd 	.word	0x00006cfd
    7d78:	2000832c 	.word	0x2000832c
    7d7c:	20008334 	.word	0x20008334
    7d80:	000084dd 	.word	0x000084dd
    7d84:	000085b5 	.word	0x000085b5
    7d88:	0000621d 	.word	0x0000621d
    7d8c:	20009300 	.word	0x20009300
    7d90:	200092fc 	.word	0x200092fc
    7d94:	20009314 	.word	0x20009314
    7d98:	00008821 	.word	0x00008821
    7d9c:	2000930c 	.word	0x2000930c
    7da0:	b10a      	cbz	r2, 7da6 <tcp_input+0x832>
    7da2:	4a52      	ldr	r2, [pc, #328]	; (7eec <tcp_input+0x978>)
    7da4:	6013      	str	r3, [r2, #0]
    7da6:	68ea      	ldr	r2, [r5, #12]
    7da8:	60da      	str	r2, [r3, #12]
    7daa:	e7c0      	b.n	7d2e <tcp_input+0x7ba>
		tcp_receive(pcb);
    7dac:	4628      	mov	r0, r5
    7dae:	4b50      	ldr	r3, [pc, #320]	; (7ef0 <tcp_input+0x97c>)
    7db0:	4798      	blx	r3
		if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    7db2:	4b50      	ldr	r3, [pc, #320]	; (7ef4 <tcp_input+0x980>)
    7db4:	7a1b      	ldrb	r3, [r3, #8]
    7db6:	f013 0f10 	tst.w	r3, #16
    7dba:	f43f acaa 	beq.w	7712 <tcp_input+0x19e>
    7dbe:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    7dc0:	4b4c      	ldr	r3, [pc, #304]	; (7ef4 <tcp_input+0x980>)
    7dc2:	68db      	ldr	r3, [r3, #12]
    7dc4:	429a      	cmp	r2, r3
    7dc6:	f47f aca4 	bne.w	7712 <tcp_input+0x19e>
			recv_flags |= TF_CLOSED;
    7dca:	4a4a      	ldr	r2, [pc, #296]	; (7ef4 <tcp_input+0x980>)
    7dcc:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
    7dd0:	f043 0310 	orr.w	r3, r3, #16
    7dd4:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
    7dd8:	e49b      	b.n	7712 <tcp_input+0x19e>
			} else if (recv_flags & TF_CLOSED) {
    7dda:	f013 0f10 	tst.w	r3, #16
    7dde:	d013      	beq.n	7e08 <tcp_input+0x894>
				if (!(pcb->flags & TF_RXCLOSED)) {
    7de0:	7fab      	ldrb	r3, [r5, #30]
    7de2:	f013 0f10 	tst.w	r3, #16
    7de6:	d106      	bne.n	7df6 <tcp_input+0x882>
					TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
    7de8:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    7dec:	b11b      	cbz	r3, 7df6 <tcp_input+0x882>
    7dee:	f06f 010b 	mvn.w	r1, #11
    7df2:	6928      	ldr	r0, [r5, #16]
    7df4:	4798      	blx	r3
				tcp_pcb_remove(&tcp_active_pcbs, pcb);
    7df6:	4629      	mov	r1, r5
    7df8:	483f      	ldr	r0, [pc, #252]	; (7ef8 <tcp_input+0x984>)
    7dfa:	4b40      	ldr	r3, [pc, #256]	; (7efc <tcp_input+0x988>)
    7dfc:	4798      	blx	r3
				memp_free(MEMP_TCP_PCB, pcb);
    7dfe:	4629      	mov	r1, r5
    7e00:	2002      	movs	r0, #2
    7e02:	4b3f      	ldr	r3, [pc, #252]	; (7f00 <tcp_input+0x98c>)
    7e04:	4798      	blx	r3
    7e06:	e49a      	b.n	773e <tcp_input+0x1ca>
				if (pcb->acked > 0) {
    7e08:	f8b5 2064 	ldrh.w	r2, [r5, #100]	; 0x64
    7e0c:	b142      	cbz	r2, 7e20 <tcp_input+0x8ac>
					TCP_EVENT_SENT(pcb, pcb->acked, err);
    7e0e:	6feb      	ldr	r3, [r5, #124]	; 0x7c
    7e10:	b133      	cbz	r3, 7e20 <tcp_input+0x8ac>
    7e12:	4629      	mov	r1, r5
    7e14:	6928      	ldr	r0, [r5, #16]
    7e16:	4798      	blx	r3
					if (err == ERR_ABRT) {
    7e18:	f110 0f0a 	cmn.w	r0, #10
    7e1c:	f43f ac8f 	beq.w	773e <tcp_input+0x1ca>
				if (recv_data != NULL) {
    7e20:	4b34      	ldr	r3, [pc, #208]	; (7ef4 <tcp_input+0x980>)
    7e22:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    7e24:	b1ca      	cbz	r2, 7e5a <tcp_input+0x8e6>
					if (pcb->flags & TF_RXCLOSED) {
    7e26:	7fab      	ldrb	r3, [r5, #30]
    7e28:	f013 0f10 	tst.w	r3, #16
    7e2c:	d006      	beq.n	7e3c <tcp_input+0x8c8>
						pbuf_free(recv_data);
    7e2e:	4610      	mov	r0, r2
    7e30:	4b34      	ldr	r3, [pc, #208]	; (7f04 <tcp_input+0x990>)
    7e32:	4798      	blx	r3
						tcp_abort(pcb);
    7e34:	4628      	mov	r0, r5
    7e36:	4b34      	ldr	r3, [pc, #208]	; (7f08 <tcp_input+0x994>)
    7e38:	4798      	blx	r3
						goto aborted;
    7e3a:	e480      	b.n	773e <tcp_input+0x1ca>
					TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    7e3c:	f8d5 4080 	ldr.w	r4, [r5, #128]	; 0x80
    7e40:	b1f4      	cbz	r4, 7e80 <tcp_input+0x90c>
    7e42:	2300      	movs	r3, #0
    7e44:	4629      	mov	r1, r5
    7e46:	6928      	ldr	r0, [r5, #16]
    7e48:	47a0      	blx	r4
					if (err == ERR_ABRT) {
    7e4a:	f110 0f0a 	cmn.w	r0, #10
    7e4e:	f43f ac76 	beq.w	773e <tcp_input+0x1ca>
					if (err != ERR_OK) {
    7e52:	b110      	cbz	r0, 7e5a <tcp_input+0x8e6>
						pcb->refused_data = recv_data;
    7e54:	4b27      	ldr	r3, [pc, #156]	; (7ef4 <tcp_input+0x980>)
    7e56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    7e58:	67ab      	str	r3, [r5, #120]	; 0x78
				if (recv_flags & TF_GOT_FIN) {
    7e5a:	4b26      	ldr	r3, [pc, #152]	; (7ef4 <tcp_input+0x980>)
    7e5c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    7e60:	f013 0f20 	tst.w	r3, #32
    7e64:	d005      	beq.n	7e72 <tcp_input+0x8fe>
					if (pcb->refused_data != NULL) {
    7e66:	6fab      	ldr	r3, [r5, #120]	; 0x78
    7e68:	b183      	cbz	r3, 7e8c <tcp_input+0x918>
						pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
    7e6a:	7b5a      	ldrb	r2, [r3, #13]
    7e6c:	f042 0220 	orr.w	r2, r2, #32
    7e70:	735a      	strb	r2, [r3, #13]
				tcp_input_pcb = NULL;
    7e72:	2200      	movs	r2, #0
    7e74:	4b25      	ldr	r3, [pc, #148]	; (7f0c <tcp_input+0x998>)
    7e76:	601a      	str	r2, [r3, #0]
				tcp_output(pcb);
    7e78:	4628      	mov	r0, r5
    7e7a:	4b25      	ldr	r3, [pc, #148]	; (7f10 <tcp_input+0x99c>)
    7e7c:	4798      	blx	r3
    7e7e:	e45e      	b.n	773e <tcp_input+0x1ca>
					TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    7e80:	2300      	movs	r3, #0
    7e82:	4629      	mov	r1, r5
    7e84:	4618      	mov	r0, r3
    7e86:	4c23      	ldr	r4, [pc, #140]	; (7f14 <tcp_input+0x9a0>)
    7e88:	47a0      	blx	r4
    7e8a:	e7de      	b.n	7e4a <tcp_input+0x8d6>
						if (pcb->rcv_wnd != TCP_WND) {
    7e8c:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    7e8e:	f241 62d0 	movw	r2, #5840	; 0x16d0
    7e92:	4293      	cmp	r3, r2
							pcb->rcv_wnd++;
    7e94:	bf1c      	itt	ne
    7e96:	3301      	addne	r3, #1
    7e98:	85ab      	strhne	r3, [r5, #44]	; 0x2c
						TCP_EVENT_CLOSED(pcb, err);
    7e9a:	f8d5 4080 	ldr.w	r4, [r5, #128]	; 0x80
    7e9e:	2c00      	cmp	r4, #0
    7ea0:	d0e7      	beq.n	7e72 <tcp_input+0x8fe>
    7ea2:	2300      	movs	r3, #0
    7ea4:	461a      	mov	r2, r3
    7ea6:	4629      	mov	r1, r5
    7ea8:	6928      	ldr	r0, [r5, #16]
    7eaa:	47a0      	blx	r4
						if (err == ERR_ABRT) {
    7eac:	f110 0f0a 	cmn.w	r0, #10
    7eb0:	d1df      	bne.n	7e72 <tcp_input+0x8fe>
    7eb2:	e444      	b.n	773e <tcp_input+0x1ca>
		if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
    7eb4:	4b0f      	ldr	r3, [pc, #60]	; (7ef4 <tcp_input+0x980>)
    7eb6:	681b      	ldr	r3, [r3, #0]
    7eb8:	8998      	ldrh	r0, [r3, #12]
    7eba:	4b17      	ldr	r3, [pc, #92]	; (7f18 <tcp_input+0x9a4>)
    7ebc:	4798      	blx	r3
    7ebe:	f010 0f04 	tst.w	r0, #4
    7ec2:	d004      	beq.n	7ece <tcp_input+0x95a>
		pbuf_free(p);
    7ec4:	4620      	mov	r0, r4
    7ec6:	4b0f      	ldr	r3, [pc, #60]	; (7f04 <tcp_input+0x990>)
    7ec8:	4798      	blx	r3
    7eca:	f7ff bb6b 	b.w	75a4 <tcp_input+0x30>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    7ece:	4809      	ldr	r0, [pc, #36]	; (7ef4 <tcp_input+0x980>)
    7ed0:	6803      	ldr	r3, [r0, #0]
    7ed2:	8a05      	ldrh	r5, [r0, #16]
    7ed4:	6841      	ldr	r1, [r0, #4]
    7ed6:	881a      	ldrh	r2, [r3, #0]
    7ed8:	9201      	str	r2, [sp, #4]
    7eda:	885b      	ldrh	r3, [r3, #2]
    7edc:	9300      	str	r3, [sp, #0]
    7ede:	4b0f      	ldr	r3, [pc, #60]	; (7f1c <tcp_input+0x9a8>)
    7ee0:	4a0f      	ldr	r2, [pc, #60]	; (7f20 <tcp_input+0x9ac>)
    7ee2:	4429      	add	r1, r5
    7ee4:	68c0      	ldr	r0, [r0, #12]
    7ee6:	4d0f      	ldr	r5, [pc, #60]	; (7f24 <tcp_input+0x9b0>)
    7ee8:	47a8      	blx	r5
    7eea:	e7eb      	b.n	7ec4 <tcp_input+0x950>
    7eec:	2000930c 	.word	0x2000930c
    7ef0:	00006cfd 	.word	0x00006cfd
    7ef4:	20007f9c 	.word	0x20007f9c
    7ef8:	20009300 	.word	0x20009300
    7efc:	000065e9 	.word	0x000065e9
    7f00:	000059c1 	.word	0x000059c1
    7f04:	00005c89 	.word	0x00005c89
    7f08:	00006a1d 	.word	0x00006a1d
    7f0c:	20009318 	.word	0x20009318
    7f10:	00008209 	.word	0x00008209
    7f14:	00006831 	.word	0x00006831
    7f18:	00002eaf 	.word	0x00002eaf
    7f1c:	2000832c 	.word	0x2000832c
    7f20:	20008334 	.word	0x20008334
    7f24:	000084dd 	.word	0x000084dd

00007f28 <tcp_create_segment>:
 * @return a new tcp_seg pointing to p, or NULL.
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
    7f28:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7f2c:	4681      	mov	r9, r0
    7f2e:	4688      	mov	r8, r1
    7f30:	4616      	mov	r6, r2
    7f32:	469a      	mov	sl, r3
    7f34:	f89d 7020 	ldrb.w	r7, [sp, #32]
	struct tcp_seg *seg;
	u8_t            optlen = LWIP_TCP_OPT_LENGTH(optflags);
    7f38:	f007 0301 	and.w	r3, r7, #1
    7f3c:	f007 0202 	and.w	r2, r7, #2
    7f40:	2a00      	cmp	r2, #0
    7f42:	bf14      	ite	ne
    7f44:	250c      	movne	r5, #12
    7f46:	2500      	moveq	r5, #0
    7f48:	eb05 0583 	add.w	r5, r5, r3, lsl #2

	if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    7f4c:	2004      	movs	r0, #4
    7f4e:	4b24      	ldr	r3, [pc, #144]	; (7fe0 <tcp_create_segment+0xb8>)
    7f50:	4798      	blx	r3
    7f52:	4604      	mov	r4, r0
    7f54:	2800      	cmp	r0, #0
    7f56:	d039      	beq.n	7fcc <tcp_create_segment+0xa4>
		LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
		pbuf_free(p);
		return NULL;
	}
	seg->flags = optflags;
    7f58:	7307      	strb	r7, [r0, #12]
	seg->next  = NULL;
    7f5a:	2200      	movs	r2, #0
    7f5c:	6002      	str	r2, [r0, #0]
	seg->p     = p;
    7f5e:	f8c0 8004 	str.w	r8, [r0, #4]
	seg->len   = p->tot_len - optlen;
    7f62:	f8b8 3008 	ldrh.w	r3, [r8, #8]
    7f66:	1b5b      	subs	r3, r3, r5
    7f68:	8103      	strh	r3, [r0, #8]
#if TCP_OVERSIZE_DBGCHECK
	seg->oversize_left = 0;
    7f6a:	8142      	strh	r2, [r0, #10]
	/* check optflags */
	LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED", (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

	/* build TCP header */
	if (pbuf_header(p, TCP_HLEN)) {
    7f6c:	2114      	movs	r1, #20
    7f6e:	4640      	mov	r0, r8
    7f70:	4b1c      	ldr	r3, [pc, #112]	; (7fe4 <tcp_create_segment+0xbc>)
    7f72:	4798      	blx	r3
    7f74:	bb70      	cbnz	r0, 7fd4 <tcp_create_segment+0xac>
		LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
		TCP_STATS_INC(tcp.err);
		tcp_seg_free(seg);
		return NULL;
	}
	seg->tcphdr        = (struct tcp_hdr *)seg->p->payload;
    7f76:	6863      	ldr	r3, [r4, #4]
    7f78:	f8d3 8004 	ldr.w	r8, [r3, #4]
    7f7c:	f8c4 8010 	str.w	r8, [r4, #16]
	seg->tcphdr->src   = htons(pcb->local_port);
    7f80:	f8b9 001a 	ldrh.w	r0, [r9, #26]
    7f84:	4f18      	ldr	r7, [pc, #96]	; (7fe8 <tcp_create_segment+0xc0>)
    7f86:	47b8      	blx	r7
    7f88:	f8a8 0000 	strh.w	r0, [r8]
	seg->tcphdr->dest  = htons(pcb->remote_port);
    7f8c:	f8d4 8010 	ldr.w	r8, [r4, #16]
    7f90:	f8b9 001c 	ldrh.w	r0, [r9, #28]
    7f94:	47b8      	blx	r7
    7f96:	f8a8 0002 	strh.w	r0, [r8, #2]
	seg->tcphdr->seqno = htonl(seqno);
    7f9a:	f8d4 8010 	ldr.w	r8, [r4, #16]
    7f9e:	4650      	mov	r0, sl
    7fa0:	4b12      	ldr	r3, [pc, #72]	; (7fec <tcp_create_segment+0xc4>)
    7fa2:	4798      	blx	r3
    7fa4:	f8c8 0004 	str.w	r0, [r8, #4]
	/* ackno is set in tcp_output */
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    7fa8:	f8d4 8010 	ldr.w	r8, [r4, #16]
    7fac:	f3c5 0587 	ubfx	r5, r5, #2, #8
    7fb0:	3505      	adds	r5, #5
    7fb2:	ea46 3505 	orr.w	r5, r6, r5, lsl #12
    7fb6:	b2a8      	uxth	r0, r5
    7fb8:	47b8      	blx	r7
    7fba:	f8a8 000c 	strh.w	r0, [r8, #12]
	/* wnd and chksum are set in tcp_output */
	seg->tcphdr->urgp = 0;
    7fbe:	6923      	ldr	r3, [r4, #16]
    7fc0:	2200      	movs	r2, #0
    7fc2:	749a      	strb	r2, [r3, #18]
    7fc4:	74da      	strb	r2, [r3, #19]
	return seg;
}
    7fc6:	4620      	mov	r0, r4
    7fc8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		pbuf_free(p);
    7fcc:	4640      	mov	r0, r8
    7fce:	4b08      	ldr	r3, [pc, #32]	; (7ff0 <tcp_create_segment+0xc8>)
    7fd0:	4798      	blx	r3
		return NULL;
    7fd2:	e7f8      	b.n	7fc6 <tcp_create_segment+0x9e>
		tcp_seg_free(seg);
    7fd4:	4620      	mov	r0, r4
    7fd6:	4b07      	ldr	r3, [pc, #28]	; (7ff4 <tcp_create_segment+0xcc>)
    7fd8:	4798      	blx	r3
		return NULL;
    7fda:	2400      	movs	r4, #0
    7fdc:	e7f3      	b.n	7fc6 <tcp_create_segment+0x9e>
    7fde:	bf00      	nop
    7fe0:	00005979 	.word	0x00005979
    7fe4:	00005bf5 	.word	0x00005bf5
    7fe8:	00002ea5 	.word	0x00002ea5
    7fec:	00002eb9 	.word	0x00002eb9
    7ff0:	00005c89 	.word	0x00005c89
    7ff4:	000061a9 	.word	0x000061a9

00007ff8 <tcp_output_alloc_header>:
{
    7ff8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    7ffc:	4606      	mov	r6, r0
    7ffe:	460c      	mov	r4, r1
    8000:	4699      	mov	r9, r3
	struct pbuf *   p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    8002:	3214      	adds	r2, #20
    8004:	4411      	add	r1, r2
    8006:	2200      	movs	r2, #0
    8008:	b289      	uxth	r1, r1
    800a:	2001      	movs	r0, #1
    800c:	4b14      	ldr	r3, [pc, #80]	; (8060 <tcp_output_alloc_header+0x68>)
    800e:	4798      	blx	r3
	if (p != NULL) {
    8010:	4680      	mov	r8, r0
    8012:	b310      	cbz	r0, 805a <tcp_output_alloc_header+0x62>
		tcphdr        = (struct tcp_hdr *)p->payload;
    8014:	6845      	ldr	r5, [r0, #4]
		tcphdr->src   = htons(pcb->local_port);
    8016:	8b70      	ldrh	r0, [r6, #26]
    8018:	4f12      	ldr	r7, [pc, #72]	; (8064 <tcp_output_alloc_header+0x6c>)
    801a:	47b8      	blx	r7
    801c:	8028      	strh	r0, [r5, #0]
		tcphdr->dest  = htons(pcb->remote_port);
    801e:	8bb0      	ldrh	r0, [r6, #28]
    8020:	47b8      	blx	r7
    8022:	8068      	strh	r0, [r5, #2]
		tcphdr->seqno = seqno_be;
    8024:	f8c5 9004 	str.w	r9, [r5, #4]
		tcphdr->ackno = htonl(pcb->rcv_nxt);
    8028:	6ab0      	ldr	r0, [r6, #40]	; 0x28
    802a:	4b0f      	ldr	r3, [pc, #60]	; (8068 <tcp_output_alloc_header+0x70>)
    802c:	4798      	blx	r3
    802e:	60a8      	str	r0, [r5, #8]
		TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    8030:	08a0      	lsrs	r0, r4, #2
    8032:	3005      	adds	r0, #5
    8034:	0300      	lsls	r0, r0, #12
    8036:	f400 4070 	and.w	r0, r0, #61440	; 0xf000
    803a:	f040 0010 	orr.w	r0, r0, #16
    803e:	47b8      	blx	r7
    8040:	81a8      	strh	r0, [r5, #12]
		tcphdr->wnd    = htons(pcb->rcv_ann_wnd);
    8042:	8df0      	ldrh	r0, [r6, #46]	; 0x2e
    8044:	47b8      	blx	r7
    8046:	81e8      	strh	r0, [r5, #14]
		tcphdr->chksum = 0;
    8048:	2300      	movs	r3, #0
    804a:	742b      	strb	r3, [r5, #16]
    804c:	746b      	strb	r3, [r5, #17]
		tcphdr->urgp   = 0;
    804e:	74ab      	strb	r3, [r5, #18]
    8050:	74eb      	strb	r3, [r5, #19]
		pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    8052:	8df2      	ldrh	r2, [r6, #46]	; 0x2e
    8054:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    8056:	4413      	add	r3, r2
    8058:	6333      	str	r3, [r6, #48]	; 0x30
}
    805a:	4640      	mov	r0, r8
    805c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    8060:	00005cf1 	.word	0x00005cf1
    8064:	00002ea5 	.word	0x00002ea5
    8068:	00002eb9 	.word	0x00002eb9

0000806c <tcp_enqueue_flags>:

	LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
	            (flags & (TCP_SYN | TCP_FIN)) != 0);

	/* check for configured max queuelen and possible overflow */
	if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    806c:	f8b0 3068 	ldrh.w	r3, [r0, #104]	; 0x68
    8070:	2b07      	cmp	r3, #7
    8072:	d822      	bhi.n	80ba <tcp_enqueue_flags+0x4e>
{
    8074:	b5f0      	push	{r4, r5, r6, r7, lr}
    8076:	b083      	sub	sp, #12
		TCP_STATS_INC(tcp.memerr);
		pcb->flags |= TF_NAGLEMEMERR;
		return ERR_MEM;
	}

	if (flags & TCP_SYN) {
    8078:	f001 0302 	and.w	r3, r1, #2
	u8_t            optflags = 0;
    807c:	f3c1 0640 	ubfx	r6, r1, #1, #1
#if LWIP_TCP_TIMESTAMPS
	if ((pcb->flags & TF_TIMESTAMP)) {
		optflags |= TF_SEG_OPTS_TS;
	}
#endif /* LWIP_TCP_TIMESTAMPS */
	optlen = LWIP_TCP_OPT_LENGTH(optflags);
    8080:	2b00      	cmp	r3, #0
    8082:	bf14      	ite	ne
    8084:	2704      	movne	r7, #4
    8086:	2700      	moveq	r7, #0

	/* tcp_enqueue_flags is always called with either SYN or FIN in flags.
	 * We need one available snd_buf byte to do that.
	 * This means we can't send FIN while snd_buf==0. A better fix would be to
	 * not include SYN and FIN sequence numbers in the snd_buf count. */
	if (pcb->snd_buf == 0) {
    8088:	f8b0 3066 	ldrh.w	r3, [r0, #102]	; 0x66
    808c:	2b00      	cmp	r3, #0
    808e:	d04e      	beq.n	812e <tcp_enqueue_flags+0xc2>
    8090:	460d      	mov	r5, r1
    8092:	4604      	mov	r4, r0
		TCP_STATS_INC(tcp.memerr);
		return ERR_MEM;
	}

	/* Allocate pbuf with room for TCP header + options */
	if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    8094:	2200      	movs	r2, #0
    8096:	4639      	mov	r1, r7
    8098:	4610      	mov	r0, r2
    809a:	4b26      	ldr	r3, [pc, #152]	; (8134 <tcp_enqueue_flags+0xc8>)
    809c:	4798      	blx	r3
    809e:	4601      	mov	r1, r0
    80a0:	b190      	cbz	r0, 80c8 <tcp_enqueue_flags+0x5c>
		return ERR_MEM;
	}
	LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen", (p->len >= optlen));

	/* Allocate memory for tcp_seg, and fill in fields. */
	if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    80a2:	9600      	str	r6, [sp, #0]
    80a4:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    80a6:	462a      	mov	r2, r5
    80a8:	4620      	mov	r0, r4
    80aa:	4e23      	ldr	r6, [pc, #140]	; (8138 <tcp_enqueue_flags+0xcc>)
    80ac:	47b0      	blx	r6
    80ae:	4601      	mov	r1, r0
    80b0:	b188      	cbz	r0, 80d6 <tcp_enqueue_flags+0x6a>
	             ntohl(seg->tcphdr->seqno),
	             ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
	             (u16_t)flags));

	/* Now append seg to pcb->unsent queue */
	if (pcb->unsent == NULL) {
    80b2:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
    80b4:	b9ba      	cbnz	r2, 80e6 <tcp_enqueue_flags+0x7a>
		pcb->unsent = seg;
    80b6:	66e0      	str	r0, [r4, #108]	; 0x6c
    80b8:	e019      	b.n	80ee <tcp_enqueue_flags+0x82>
		pcb->flags |= TF_NAGLEMEMERR;
    80ba:	7f83      	ldrb	r3, [r0, #30]
    80bc:	f063 037f 	orn	r3, r3, #127	; 0x7f
    80c0:	7783      	strb	r3, [r0, #30]
		return ERR_MEM;
    80c2:	f04f 30ff 	mov.w	r0, #4294967295
    80c6:	4770      	bx	lr
		pcb->flags |= TF_NAGLEMEMERR;
    80c8:	7fa3      	ldrb	r3, [r4, #30]
    80ca:	f063 037f 	orn	r3, r3, #127	; 0x7f
    80ce:	77a3      	strb	r3, [r4, #30]
		return ERR_MEM;
    80d0:	f04f 30ff 	mov.w	r0, #4294967295
    80d4:	e029      	b.n	812a <tcp_enqueue_flags+0xbe>
		pcb->flags |= TF_NAGLEMEMERR;
    80d6:	7fa3      	ldrb	r3, [r4, #30]
    80d8:	f063 037f 	orn	r3, r3, #127	; 0x7f
    80dc:	77a3      	strb	r3, [r4, #30]
		return ERR_MEM;
    80de:	f04f 30ff 	mov.w	r0, #4294967295
    80e2:	e022      	b.n	812a <tcp_enqueue_flags+0xbe>
	} else {
		struct tcp_seg *useg;
		for (useg = pcb->unsent; useg->next != NULL; useg = useg->next)
    80e4:	461a      	mov	r2, r3
    80e6:	6813      	ldr	r3, [r2, #0]
    80e8:	2b00      	cmp	r3, #0
    80ea:	d1fb      	bne.n	80e4 <tcp_enqueue_flags+0x78>
			;
		useg->next = seg;
    80ec:	6011      	str	r1, [r2, #0]
	}
#if TCP_OVERSIZE
	/* The new unsent tail has no space */
	pcb->unsent_oversize = 0;
    80ee:	2300      	movs	r3, #0
    80f0:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

	/* SYN and FIN bump the sequence number */
	if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    80f4:	f015 0f03 	tst.w	r5, #3
    80f8:	d007      	beq.n	810a <tcp_enqueue_flags+0x9e>
		pcb->snd_lbb++;
    80fa:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    80fc:	3301      	adds	r3, #1
    80fe:	65e3      	str	r3, [r4, #92]	; 0x5c
		/* optlen does not influence snd_buf */
		pcb->snd_buf--;
    8100:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
    8104:	3b01      	subs	r3, #1
    8106:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
	}
	if (flags & TCP_FIN) {
    810a:	f015 0f01 	tst.w	r5, #1
    810e:	d003      	beq.n	8118 <tcp_enqueue_flags+0xac>
		pcb->flags |= TF_FIN;
    8110:	7fa3      	ldrb	r3, [r4, #30]
    8112:	f043 0320 	orr.w	r3, r3, #32
    8116:	77a3      	strb	r3, [r4, #30]
	}

	/* update number of segments on the queues */
	pcb->snd_queuelen += pbuf_clen(seg->p);
    8118:	6848      	ldr	r0, [r1, #4]
    811a:	4b08      	ldr	r3, [pc, #32]	; (813c <tcp_enqueue_flags+0xd0>)
    811c:	4798      	blx	r3
    811e:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    8122:	4418      	add	r0, r3
    8124:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
	LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %" S16_F " (after enqueued)\n", pcb->snd_queuelen));
	if (pcb->snd_queuelen != 0) {
		LWIP_ASSERT("tcp_enqueue_flags: invalid queue length", pcb->unacked != NULL || pcb->unsent != NULL);
	}

	return ERR_OK;
    8128:	2000      	movs	r0, #0
}
    812a:	b003      	add	sp, #12
    812c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_MEM;
    812e:	f04f 30ff 	mov.w	r0, #4294967295
    8132:	e7fa      	b.n	812a <tcp_enqueue_flags+0xbe>
    8134:	00005cf1 	.word	0x00005cf1
    8138:	00007f29 	.word	0x00007f29
    813c:	00005e8d 	.word	0x00005e8d

00008140 <tcp_send_fin>:
{
    8140:	b570      	push	{r4, r5, r6, lr}
    8142:	4605      	mov	r5, r0
	if (pcb->unsent != NULL) {
    8144:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
    8146:	b90c      	cbnz	r4, 814c <tcp_send_fin+0xc>
    8148:	e00a      	b.n	8160 <tcp_send_fin+0x20>
		for (last_unsent = pcb->unsent; last_unsent->next != NULL; last_unsent = last_unsent->next)
    814a:	461c      	mov	r4, r3
    814c:	6823      	ldr	r3, [r4, #0]
    814e:	2b00      	cmp	r3, #0
    8150:	d1fb      	bne.n	814a <tcp_send_fin+0xa>
		if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
    8152:	6923      	ldr	r3, [r4, #16]
    8154:	8998      	ldrh	r0, [r3, #12]
    8156:	4b0b      	ldr	r3, [pc, #44]	; (8184 <tcp_send_fin+0x44>)
    8158:	4798      	blx	r3
    815a:	f010 0f07 	tst.w	r0, #7
    815e:	d004      	beq.n	816a <tcp_send_fin+0x2a>
	return tcp_enqueue_flags(pcb, TCP_FIN);
    8160:	2101      	movs	r1, #1
    8162:	4628      	mov	r0, r5
    8164:	4b08      	ldr	r3, [pc, #32]	; (8188 <tcp_send_fin+0x48>)
    8166:	4798      	blx	r3
}
    8168:	bd70      	pop	{r4, r5, r6, pc}
			TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
    816a:	6926      	ldr	r6, [r4, #16]
    816c:	89b4      	ldrh	r4, [r6, #12]
    816e:	2001      	movs	r0, #1
    8170:	4b06      	ldr	r3, [pc, #24]	; (818c <tcp_send_fin+0x4c>)
    8172:	4798      	blx	r3
    8174:	4320      	orrs	r0, r4
    8176:	81b0      	strh	r0, [r6, #12]
			pcb->flags |= TF_FIN;
    8178:	7fab      	ldrb	r3, [r5, #30]
    817a:	f043 0320 	orr.w	r3, r3, #32
    817e:	77ab      	strb	r3, [r5, #30]
			return ERR_OK;
    8180:	2000      	movs	r0, #0
    8182:	bd70      	pop	{r4, r5, r6, pc}
    8184:	00002eaf 	.word	0x00002eaf
    8188:	0000806d 	.word	0x0000806d
    818c:	00002ea5 	.word	0x00002ea5

00008190 <tcp_send_empty_ack>:
/** Send an ACK without data.
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t tcp_send_empty_ack(struct tcp_pcb *pcb)
{
    8190:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8194:	b082      	sub	sp, #8
    8196:	4604      	mov	r4, r0
	if (pcb->flags & TF_TIMESTAMP) {
		optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
	}
#endif

	p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    8198:	6d00      	ldr	r0, [r0, #80]	; 0x50
    819a:	4b16      	ldr	r3, [pc, #88]	; (81f4 <tcp_send_empty_ack+0x64>)
    819c:	4798      	blx	r3
    819e:	4603      	mov	r3, r0
    81a0:	2200      	movs	r2, #0
    81a2:	4611      	mov	r1, r2
    81a4:	4620      	mov	r0, r4
    81a6:	4d14      	ldr	r5, [pc, #80]	; (81f8 <tcp_send_empty_ack+0x68>)
    81a8:	47a8      	blx	r5
	if (p == NULL) {
    81aa:	b300      	cbz	r0, 81ee <tcp_send_empty_ack+0x5e>
    81ac:	4605      	mov	r5, r0
		LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
		return ERR_BUF;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
    81ae:	6847      	ldr	r7, [r0, #4]
	LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %" U32_F "\n", pcb->rcv_nxt));
	/* remove ACK flags from the PCB, as we send an empty ACK now */
	pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    81b0:	7fa3      	ldrb	r3, [r4, #30]
    81b2:	f023 0303 	bic.w	r3, r3, #3
    81b6:	77a3      	strb	r3, [r4, #30]
		tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
	}
#endif

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, p->tot_len);
    81b8:	1d26      	adds	r6, r4, #4
    81ba:	8903      	ldrh	r3, [r0, #8]
    81bc:	9300      	str	r3, [sp, #0]
    81be:	2306      	movs	r3, #6
    81c0:	4632      	mov	r2, r6
    81c2:	4621      	mov	r1, r4
    81c4:	f8df 803c 	ldr.w	r8, [pc, #60]	; 8204 <tcp_send_empty_ack+0x74>
    81c8:	47c0      	blx	r8
    81ca:	8238      	strh	r0, [r7, #16]
#endif
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    81cc:	7aa3      	ldrb	r3, [r4, #10]
    81ce:	2206      	movs	r2, #6
    81d0:	9201      	str	r2, [sp, #4]
    81d2:	7a62      	ldrb	r2, [r4, #9]
    81d4:	9200      	str	r2, [sp, #0]
    81d6:	4632      	mov	r2, r6
    81d8:	4621      	mov	r1, r4
    81da:	4628      	mov	r0, r5
    81dc:	4c07      	ldr	r4, [pc, #28]	; (81fc <tcp_send_empty_ack+0x6c>)
    81de:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/
	pbuf_free(p);
    81e0:	4628      	mov	r0, r5
    81e2:	4b07      	ldr	r3, [pc, #28]	; (8200 <tcp_send_empty_ack+0x70>)
    81e4:	4798      	blx	r3

	return ERR_OK;
    81e6:	2000      	movs	r0, #0
}
    81e8:	b002      	add	sp, #8
    81ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_BUF;
    81ee:	f06f 0001 	mvn.w	r0, #1
    81f2:	e7f9      	b.n	81e8 <tcp_send_empty_ack+0x58>
    81f4:	00002eb9 	.word	0x00002eb9
    81f8:	00007ff9 	.word	0x00007ff9
    81fc:	00004eb9 	.word	0x00004eb9
    8200:	00005c89 	.word	0x00005c89
    8204:	00004a91 	.word	0x00004a91

00008208 <tcp_output>:

	/* First, check if we are invoked by the TCP input processing
	   code. If so, we do not output anything. Instead, we rely on the
	   input processing code to call us when input processing is done
	   with. */
	if (tcp_input_pcb == pcb) {
    8208:	4ba7      	ldr	r3, [pc, #668]	; (84a8 <tcp_output+0x2a0>)
    820a:	681b      	ldr	r3, [r3, #0]
    820c:	4283      	cmp	r3, r0
    820e:	f000 8163 	beq.w	84d8 <tcp_output+0x2d0>
{
    8212:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8216:	b085      	sub	sp, #20
    8218:	4605      	mov	r5, r0
		return ERR_OK;
	}

	wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
    821a:	f8b0 2060 	ldrh.w	r2, [r0, #96]	; 0x60
    821e:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
    8222:	429a      	cmp	r2, r3
    8224:	bf28      	it	cs
    8226:	461a      	movcs	r2, r3
    8228:	4692      	mov	sl, r2

	seg = pcb->unsent;
    822a:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
	 * because the ->unsent queue is empty or because the window does
	 * not allow it), construct an empty ACK segment and send it.
	 *
	 * If data is to be sent, we will just piggyback the ACK (see below).
	 */
	if (pcb->flags & TF_ACK_NOW && (seg == NULL || ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    822c:	7f83      	ldrb	r3, [r0, #30]
    822e:	f013 0f02 	tst.w	r3, #2
    8232:	d014      	beq.n	825e <tcp_output+0x56>
    8234:	b17c      	cbz	r4, 8256 <tcp_output+0x4e>
    8236:	6923      	ldr	r3, [r4, #16]
    8238:	6858      	ldr	r0, [r3, #4]
    823a:	4b9c      	ldr	r3, [pc, #624]	; (84ac <tcp_output+0x2a4>)
    823c:	4798      	blx	r3
    823e:	8923      	ldrh	r3, [r4, #8]
    8240:	6caa      	ldr	r2, [r5, #72]	; 0x48
    8242:	1a9b      	subs	r3, r3, r2
    8244:	4418      	add	r0, r3
    8246:	4582      	cmp	sl, r0
    8248:	d305      	bcc.n	8256 <tcp_output+0x4e>
		return tcp_send_empty_ack(pcb);
	}

	/* useg should point to last segment on unacked queue */
	useg = pcb->unacked;
    824a:	f8d5 8070 	ldr.w	r8, [r5, #112]	; 0x70
	if (useg != NULL) {
    824e:	f1b8 0f00 	cmp.w	r8, #0
    8252:	d10f      	bne.n	8274 <tcp_output+0x6c>
    8254:	e015      	b.n	8282 <tcp_output+0x7a>
		return tcp_send_empty_ack(pcb);
    8256:	4628      	mov	r0, r5
    8258:	4b95      	ldr	r3, [pc, #596]	; (84b0 <tcp_output+0x2a8>)
    825a:	4798      	blx	r3
    825c:	e120      	b.n	84a0 <tcp_output+0x298>
	useg = pcb->unacked;
    825e:	f8d0 8070 	ldr.w	r8, [r0, #112]	; 0x70
	if (useg != NULL) {
    8262:	f1b8 0f00 	cmp.w	r8, #0
    8266:	d105      	bne.n	8274 <tcp_output+0x6c>
		             ntohl(seg->tcphdr->seqno),
		             pcb->lastack));
	}
#endif /* TCP_CWND_DEBUG */
	/* data available and window allows it to be sent? */
	while (seg != NULL && ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    8268:	b95c      	cbnz	r4, 8282 <tcp_output+0x7a>
		seg = pcb->unsent;
	}
#if TCP_OVERSIZE
	if (pcb->unsent == NULL) {
		/* last unsent has been removed, reset unsent_oversize */
		pcb->unsent_oversize = 0;
    826a:	2300      	movs	r3, #0
    826c:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
    8270:	e111      	b.n	8496 <tcp_output+0x28e>
		for (; useg->next != NULL; useg = useg->next)
    8272:	4698      	mov	r8, r3
    8274:	f8d8 3000 	ldr.w	r3, [r8]
    8278:	2b00      	cmp	r3, #0
    827a:	d1fa      	bne.n	8272 <tcp_output+0x6a>
	while (seg != NULL && ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    827c:	2c00      	cmp	r4, #0
    827e:	f000 8106 	beq.w	848e <tcp_output+0x286>
    8282:	4e8a      	ldr	r6, [pc, #552]	; (84ac <tcp_output+0x2a4>)
			TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
    8284:	f8df b248 	ldr.w	fp, [pc, #584]	; 84d0 <tcp_output+0x2c8>
    8288:	e0a3      	b.n	83d2 <tcp_output+0x1ca>
		if ((tcp_do_output_nagle(pcb) == 0) && ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
    828a:	f8b5 2066 	ldrh.w	r2, [r5, #102]	; 0x66
    828e:	b13a      	cbz	r2, 82a0 <tcp_output+0x98>
    8290:	f8b5 2068 	ldrh.w	r2, [r5, #104]	; 0x68
    8294:	2a07      	cmp	r2, #7
    8296:	d803      	bhi.n	82a0 <tcp_output+0x98>
    8298:	f013 0fa0 	tst.w	r3, #160	; 0xa0
    829c:	f000 80f7 	beq.w	848e <tcp_output+0x286>
		pcb->unsent = seg->next;
    82a0:	6823      	ldr	r3, [r4, #0]
    82a2:	66eb      	str	r3, [r5, #108]	; 0x6c
		if (pcb->state != SYN_SENT) {
    82a4:	7e2b      	ldrb	r3, [r5, #24]
    82a6:	2b02      	cmp	r3, #2
    82a8:	d00c      	beq.n	82c4 <tcp_output+0xbc>
			TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
    82aa:	f8d4 9010 	ldr.w	r9, [r4, #16]
    82ae:	f8b9 700c 	ldrh.w	r7, [r9, #12]
    82b2:	2010      	movs	r0, #16
    82b4:	47d8      	blx	fp
    82b6:	4338      	orrs	r0, r7
    82b8:	f8a9 000c 	strh.w	r0, [r9, #12]
			pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    82bc:	7fab      	ldrb	r3, [r5, #30]
    82be:	f023 0303 	bic.w	r3, r3, #3
    82c2:	77ab      	strb	r3, [r5, #30]
	/** @bug Exclude retransmitted segments from this count. */
	snmp_inc_tcpoutsegs();

	/* The TCP header has already been constructed, but the ackno and
	 wnd fields remain. */
	seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
    82c4:	6927      	ldr	r7, [r4, #16]
    82c6:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    82c8:	4b7a      	ldr	r3, [pc, #488]	; (84b4 <tcp_output+0x2ac>)
    82ca:	4798      	blx	r3
    82cc:	60b8      	str	r0, [r7, #8]

	/* advertise our receive window size in this TCP segment */
	seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    82ce:	6927      	ldr	r7, [r4, #16]
    82d0:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
    82d2:	47d8      	blx	fp
    82d4:	81f8      	strh	r0, [r7, #14]

	pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    82d6:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
    82d8:	6aab      	ldr	r3, [r5, #40]	; 0x28
    82da:	4413      	add	r3, r2
    82dc:	632b      	str	r3, [r5, #48]	; 0x30

	/* Add any requested options.  NB MSS option is only set on SYN
	   packets, so ignore it here */
	opts = (u32_t *)(void *)(seg->tcphdr + 1);
	if (seg->flags & TF_SEG_OPTS_MSS) {
    82de:	7b23      	ldrb	r3, [r4, #12]
    82e0:	f013 0f01 	tst.w	r3, #1
    82e4:	f040 8095 	bne.w	8412 <tcp_output+0x20a>
	}
#endif

	/* Set retransmission timer running if it is not currently enabled
	   This must be set before checking the route. */
	if (pcb->rtime == -1) {
    82e8:	f9b5 3034 	ldrsh.w	r3, [r5, #52]	; 0x34
    82ec:	f1b3 3fff 	cmp.w	r3, #4294967295
		pcb->rtime = 0;
    82f0:	bf04      	itt	eq
    82f2:	2300      	moveq	r3, #0
    82f4:	86ab      	strheq	r3, [r5, #52]	; 0x34
	}

	/* If we don't have a local IP address, we get one by
	   calling ip_route(). */
	if (ip_addr_isany(&(pcb->local_ip))) {
    82f6:	b10d      	cbz	r5, 82fc <tcp_output+0xf4>
    82f8:	682b      	ldr	r3, [r5, #0]
    82fa:	b933      	cbnz	r3, 830a <tcp_output+0x102>
		netif = ip_route(&(pcb->remote_ip));
    82fc:	1d28      	adds	r0, r5, #4
    82fe:	4b6e      	ldr	r3, [pc, #440]	; (84b8 <tcp_output+0x2b0>)
    8300:	4798      	blx	r3
		if (netif == NULL) {
    8302:	2800      	cmp	r0, #0
    8304:	d02e      	beq.n	8364 <tcp_output+0x15c>
			return;
		}
		ip_addr_copy(pcb->local_ip, netif->ip_addr);
    8306:	6843      	ldr	r3, [r0, #4]
    8308:	602b      	str	r3, [r5, #0]
	}

	if (pcb->rttest == 0) {
    830a:	6bab      	ldr	r3, [r5, #56]	; 0x38
    830c:	2b00      	cmp	r3, #0
    830e:	f000 808c 	beq.w	842a <tcp_output+0x222>
	LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
	            ("tcp_output_segment: %" U32_F ":%" U32_F "\n",
	             htonl(seg->tcphdr->seqno),
	             htonl(seg->tcphdr->seqno) + seg->len));

	len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
    8312:	6862      	ldr	r2, [r4, #4]
    8314:	6923      	ldr	r3, [r4, #16]
    8316:	6851      	ldr	r1, [r2, #4]
    8318:	1a5b      	subs	r3, r3, r1
    831a:	b29b      	uxth	r3, r3

	seg->p->len -= len;
    831c:	8951      	ldrh	r1, [r2, #10]
    831e:	1ac9      	subs	r1, r1, r3
    8320:	8151      	strh	r1, [r2, #10]
	seg->p->tot_len -= len;
    8322:	6861      	ldr	r1, [r4, #4]
    8324:	890a      	ldrh	r2, [r1, #8]
    8326:	1ad3      	subs	r3, r2, r3
    8328:	810b      	strh	r3, [r1, #8]

	seg->p->payload = seg->tcphdr;
    832a:	6863      	ldr	r3, [r4, #4]
    832c:	6922      	ldr	r2, [r4, #16]
    832e:	605a      	str	r2, [r3, #4]

	seg->tcphdr->chksum = 0;
    8330:	6923      	ldr	r3, [r4, #16]
    8332:	2200      	movs	r2, #0
    8334:	741a      	strb	r2, [r3, #16]
    8336:	745a      	strb	r2, [r3, #17]
			seg->tcphdr->chksum = chksum_slow;
		}
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
	}
#else  /* TCP_CHECKSUM_ON_COPY */
	seg->tcphdr->chksum
    8338:	6927      	ldr	r7, [r4, #16]
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    833a:	6860      	ldr	r0, [r4, #4]
    833c:	1d2a      	adds	r2, r5, #4
    833e:	8903      	ldrh	r3, [r0, #8]
    8340:	9300      	str	r3, [sp, #0]
    8342:	2306      	movs	r3, #6
    8344:	9203      	str	r2, [sp, #12]
    8346:	4629      	mov	r1, r5
    8348:	f8df 9188 	ldr.w	r9, [pc, #392]	; 84d4 <tcp_output+0x2cc>
    834c:	47c8      	blx	r9
    834e:	8238      	strh	r0, [r7, #16]
	TCP_STATS_INC(tcp.xmit);

#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    8350:	7aab      	ldrb	r3, [r5, #10]
    8352:	6860      	ldr	r0, [r4, #4]
    8354:	2206      	movs	r2, #6
    8356:	9201      	str	r2, [sp, #4]
    8358:	7a6a      	ldrb	r2, [r5, #9]
    835a:	9200      	str	r2, [sp, #0]
    835c:	9a03      	ldr	r2, [sp, #12]
    835e:	4629      	mov	r1, r5
    8360:	4f56      	ldr	r7, [pc, #344]	; (84bc <tcp_output+0x2b4>)
    8362:	47b8      	blx	r7
		snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    8364:	6923      	ldr	r3, [r4, #16]
    8366:	6858      	ldr	r0, [r3, #4]
    8368:	47b0      	blx	r6
    836a:	4607      	mov	r7, r0
    836c:	f8b4 9008 	ldrh.w	r9, [r4, #8]
    8370:	6923      	ldr	r3, [r4, #16]
    8372:	8998      	ldrh	r0, [r3, #12]
    8374:	4b52      	ldr	r3, [pc, #328]	; (84c0 <tcp_output+0x2b8>)
    8376:	4798      	blx	r3
    8378:	f010 0003 	ands.w	r0, r0, #3
    837c:	bf18      	it	ne
    837e:	2001      	movne	r0, #1
    8380:	4448      	add	r0, r9
    8382:	4407      	add	r7, r0
		if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
    8384:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    8386:	1bdb      	subs	r3, r3, r7
    8388:	2b00      	cmp	r3, #0
			pcb->snd_nxt = snd_nxt;
    838a:	bfb8      	it	lt
    838c:	652f      	strlt	r7, [r5, #80]	; 0x50
		if (TCP_TCPLEN(seg) > 0) {
    838e:	8927      	ldrh	r7, [r4, #8]
    8390:	6923      	ldr	r3, [r4, #16]
    8392:	8998      	ldrh	r0, [r3, #12]
    8394:	4b4a      	ldr	r3, [pc, #296]	; (84c0 <tcp_output+0x2b8>)
    8396:	4798      	blx	r3
    8398:	f010 0003 	ands.w	r0, r0, #3
    839c:	bf18      	it	ne
    839e:	2001      	movne	r0, #1
    83a0:	42f8      	cmn	r0, r7
    83a2:	d070      	beq.n	8486 <tcp_output+0x27e>
			seg->next = NULL;
    83a4:	2300      	movs	r3, #0
    83a6:	6023      	str	r3, [r4, #0]
			if (pcb->unacked == NULL) {
    83a8:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    83aa:	2b00      	cmp	r3, #0
    83ac:	d045      	beq.n	843a <tcp_output+0x232>
				if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
    83ae:	6923      	ldr	r3, [r4, #16]
    83b0:	6858      	ldr	r0, [r3, #4]
    83b2:	47b0      	blx	r6
    83b4:	4607      	mov	r7, r0
    83b6:	f8d8 3010 	ldr.w	r3, [r8, #16]
    83ba:	6858      	ldr	r0, [r3, #4]
    83bc:	47b0      	blx	r6
    83be:	1a38      	subs	r0, r7, r0
    83c0:	2800      	cmp	r0, #0
    83c2:	db3d      	blt.n	8440 <tcp_output+0x238>
					useg->next = seg;
    83c4:	f8c8 4000 	str.w	r4, [r8]
    83c8:	46a0      	mov	r8, r4
		seg = pcb->unsent;
    83ca:	6eec      	ldr	r4, [r5, #108]	; 0x6c
	while (seg != NULL && ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    83cc:	2c00      	cmp	r4, #0
    83ce:	f43f af4c 	beq.w	826a <tcp_output+0x62>
    83d2:	6923      	ldr	r3, [r4, #16]
    83d4:	6858      	ldr	r0, [r3, #4]
    83d6:	47b0      	blx	r6
    83d8:	6cab      	ldr	r3, [r5, #72]	; 0x48
    83da:	1ac0      	subs	r0, r0, r3
    83dc:	8923      	ldrh	r3, [r4, #8]
    83de:	4418      	add	r0, r3
    83e0:	4582      	cmp	sl, r0
    83e2:	d354      	bcc.n	848e <tcp_output+0x286>
		if ((tcp_do_output_nagle(pcb) == 0) && ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
    83e4:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    83e6:	2b00      	cmp	r3, #0
    83e8:	f43f af5a 	beq.w	82a0 <tcp_output+0x98>
    83ec:	7fab      	ldrb	r3, [r5, #30]
    83ee:	f013 0f44 	tst.w	r3, #68	; 0x44
    83f2:	f47f af55 	bne.w	82a0 <tcp_output+0x98>
    83f6:	6eea      	ldr	r2, [r5, #108]	; 0x6c
    83f8:	2a00      	cmp	r2, #0
    83fa:	f43f af46 	beq.w	828a <tcp_output+0x82>
    83fe:	6811      	ldr	r1, [r2, #0]
    8400:	2900      	cmp	r1, #0
    8402:	f47f af4d 	bne.w	82a0 <tcp_output+0x98>
    8406:	8911      	ldrh	r1, [r2, #8]
    8408:	8eea      	ldrh	r2, [r5, #54]	; 0x36
    840a:	4291      	cmp	r1, r2
    840c:	f4bf af48 	bcs.w	82a0 <tcp_output+0x98>
    8410:	e73b      	b.n	828a <tcp_output+0x82>
	opts = (u32_t *)(void *)(seg->tcphdr + 1);
    8412:	6927      	ldr	r7, [r4, #16]
		mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    8414:	1d29      	adds	r1, r5, #4
    8416:	f240 50b4 	movw	r0, #1460	; 0x5b4
    841a:	4b2a      	ldr	r3, [pc, #168]	; (84c4 <tcp_output+0x2bc>)
    841c:	4798      	blx	r3
		*opts = TCP_BUILD_MSS_OPTION(mss);
    841e:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
    8422:	4b24      	ldr	r3, [pc, #144]	; (84b4 <tcp_output+0x2ac>)
    8424:	4798      	blx	r3
    8426:	6178      	str	r0, [r7, #20]
    8428:	e75e      	b.n	82e8 <tcp_output+0xe0>
		pcb->rttest = tcp_ticks;
    842a:	4b27      	ldr	r3, [pc, #156]	; (84c8 <tcp_output+0x2c0>)
    842c:	681b      	ldr	r3, [r3, #0]
    842e:	63ab      	str	r3, [r5, #56]	; 0x38
		pcb->rtseq  = ntohl(seg->tcphdr->seqno);
    8430:	6923      	ldr	r3, [r4, #16]
    8432:	6858      	ldr	r0, [r3, #4]
    8434:	47b0      	blx	r6
    8436:	63e8      	str	r0, [r5, #60]	; 0x3c
    8438:	e76b      	b.n	8312 <tcp_output+0x10a>
				pcb->unacked = seg;
    843a:	672c      	str	r4, [r5, #112]	; 0x70
    843c:	46a0      	mov	r8, r4
    843e:	e7c4      	b.n	83ca <tcp_output+0x1c2>
					struct tcp_seg **cur_seg = &(pcb->unacked);
    8440:	f105 0970 	add.w	r9, r5, #112	; 0x70
					while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    8444:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    8446:	b1c3      	cbz	r3, 847a <tcp_output+0x272>
    8448:	4622      	mov	r2, r4
    844a:	464c      	mov	r4, r9
    844c:	4691      	mov	r9, r2
    844e:	691b      	ldr	r3, [r3, #16]
    8450:	6858      	ldr	r0, [r3, #4]
    8452:	47b0      	blx	r6
    8454:	4607      	mov	r7, r0
    8456:	f8d9 3010 	ldr.w	r3, [r9, #16]
    845a:	6858      	ldr	r0, [r3, #4]
    845c:	47b0      	blx	r6
    845e:	1a38      	subs	r0, r7, r0
    8460:	2800      	cmp	r0, #0
    8462:	da07      	bge.n	8474 <tcp_output+0x26c>
						cur_seg = &((*cur_seg)->next);
    8464:	6824      	ldr	r4, [r4, #0]
					while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    8466:	6823      	ldr	r3, [r4, #0]
    8468:	2b00      	cmp	r3, #0
    846a:	d1f0      	bne.n	844e <tcp_output+0x246>
    846c:	464b      	mov	r3, r9
    846e:	46a1      	mov	r9, r4
    8470:	461c      	mov	r4, r3
    8472:	e002      	b.n	847a <tcp_output+0x272>
    8474:	464b      	mov	r3, r9
    8476:	46a1      	mov	r9, r4
    8478:	461c      	mov	r4, r3
					seg->next  = (*cur_seg);
    847a:	f8d9 3000 	ldr.w	r3, [r9]
    847e:	6023      	str	r3, [r4, #0]
					(*cur_seg) = seg;
    8480:	f8c9 4000 	str.w	r4, [r9]
    8484:	e7a1      	b.n	83ca <tcp_output+0x1c2>
			tcp_seg_free(seg);
    8486:	4620      	mov	r0, r4
    8488:	4b10      	ldr	r3, [pc, #64]	; (84cc <tcp_output+0x2c4>)
    848a:	4798      	blx	r3
    848c:	e79d      	b.n	83ca <tcp_output+0x1c2>
	if (pcb->unsent == NULL) {
    848e:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
    8490:	2b00      	cmp	r3, #0
    8492:	f43f aeea 	beq.w	826a <tcp_output+0x62>
	pcb->flags &= ~TF_NAGLEMEMERR;
    8496:	7fab      	ldrb	r3, [r5, #30]
    8498:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    849c:	77ab      	strb	r3, [r5, #30]
	return ERR_OK;
    849e:	2000      	movs	r0, #0
}
    84a0:	b005      	add	sp, #20
    84a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    84a6:	bf00      	nop
    84a8:	20009318 	.word	0x20009318
    84ac:	00002ed1 	.word	0x00002ed1
    84b0:	00008191 	.word	0x00008191
    84b4:	00002eb9 	.word	0x00002eb9
    84b8:	00004b8d 	.word	0x00004b8d
    84bc:	00004eb9 	.word	0x00004eb9
    84c0:	00002eaf 	.word	0x00002eaf
    84c4:	00006b6d 	.word	0x00006b6d
    84c8:	20009304 	.word	0x20009304
    84cc:	000061a9 	.word	0x000061a9
    84d0:	00002ea5 	.word	0x00002ea5
    84d4:	00004a91 	.word	0x00004a91
		return ERR_OK;
    84d8:	2000      	movs	r0, #0
    84da:	4770      	bx	lr

000084dc <tcp_rst>:
 * @param remote_ip the remote IP address to send the segment to
 * @param local_port the local TCP port to send the segment from
 * @param remote_port the remote TCP port to send the segment to
 */
void tcp_rst(u32_t seqno, u32_t ackno, ip_addr_t *local_ip, ip_addr_t *remote_ip, u16_t local_port, u16_t remote_port)
{
    84dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    84e0:	b083      	sub	sp, #12
    84e2:	4681      	mov	r9, r0
    84e4:	468a      	mov	sl, r1
    84e6:	4693      	mov	fp, r2
    84e8:	4698      	mov	r8, r3
	struct pbuf *   p;
	struct tcp_hdr *tcphdr;
	p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    84ea:	2200      	movs	r2, #0
    84ec:	2114      	movs	r1, #20
    84ee:	2001      	movs	r0, #1
    84f0:	4b1d      	ldr	r3, [pc, #116]	; (8568 <tcp_rst+0x8c>)
    84f2:	4798      	blx	r3
	if (p == NULL) {
    84f4:	2800      	cmp	r0, #0
    84f6:	d034      	beq.n	8562 <tcp_rst+0x86>
    84f8:	4605      	mov	r5, r0
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
		return;
	}
	LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr", (p->len >= sizeof(struct tcp_hdr)));

	tcphdr        = (struct tcp_hdr *)p->payload;
    84fa:	6844      	ldr	r4, [r0, #4]
	tcphdr->src   = htons(local_port);
    84fc:	f8bd 0030 	ldrh.w	r0, [sp, #48]	; 0x30
    8500:	4e1a      	ldr	r6, [pc, #104]	; (856c <tcp_rst+0x90>)
    8502:	47b0      	blx	r6
    8504:	8020      	strh	r0, [r4, #0]
	tcphdr->dest  = htons(remote_port);
    8506:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
    850a:	47b0      	blx	r6
    850c:	8060      	strh	r0, [r4, #2]
	tcphdr->seqno = htonl(seqno);
    850e:	4648      	mov	r0, r9
    8510:	4f17      	ldr	r7, [pc, #92]	; (8570 <tcp_rst+0x94>)
    8512:	47b8      	blx	r7
    8514:	6060      	str	r0, [r4, #4]
	tcphdr->ackno = htonl(ackno);
    8516:	4650      	mov	r0, sl
    8518:	47b8      	blx	r7
    851a:	60a0      	str	r0, [r4, #8]
	TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN / 4, TCP_RST | TCP_ACK);
    851c:	f245 0014 	movw	r0, #20500	; 0x5014
    8520:	47b0      	blx	r6
    8522:	81a0      	strh	r0, [r4, #12]
	tcphdr->wnd    = PP_HTONS(TCP_WND);
    8524:	2600      	movs	r6, #0
    8526:	2316      	movs	r3, #22
    8528:	73a3      	strb	r3, [r4, #14]
    852a:	f06f 032f 	mvn.w	r3, #47	; 0x2f
    852e:	73e3      	strb	r3, [r4, #15]
	tcphdr->chksum = 0;
    8530:	7426      	strb	r6, [r4, #16]
    8532:	7466      	strb	r6, [r4, #17]
	tcphdr->urgp   = 0;
    8534:	74a6      	strb	r6, [r4, #18]
    8536:	74e6      	strb	r6, [r4, #19]

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip, IP_PROTO_TCP, p->tot_len);
    8538:	892b      	ldrh	r3, [r5, #8]
    853a:	9300      	str	r3, [sp, #0]
    853c:	2306      	movs	r3, #6
    853e:	4642      	mov	r2, r8
    8540:	4659      	mov	r1, fp
    8542:	4628      	mov	r0, r5
    8544:	4f0b      	ldr	r7, [pc, #44]	; (8574 <tcp_rst+0x98>)
    8546:	47b8      	blx	r7
    8548:	8220      	strh	r0, [r4, #16]
#endif
	TCP_STATS_INC(tcp.xmit);
	snmp_inc_tcpoutrsts();
	/* Send output with hardcoded TTL since we have no access to the pcb */
	ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
    854a:	2306      	movs	r3, #6
    854c:	9301      	str	r3, [sp, #4]
    854e:	9600      	str	r6, [sp, #0]
    8550:	23ff      	movs	r3, #255	; 0xff
    8552:	4642      	mov	r2, r8
    8554:	4659      	mov	r1, fp
    8556:	4628      	mov	r0, r5
    8558:	4c07      	ldr	r4, [pc, #28]	; (8578 <tcp_rst+0x9c>)
    855a:	47a0      	blx	r4
	pbuf_free(p);
    855c:	4628      	mov	r0, r5
    855e:	4b07      	ldr	r3, [pc, #28]	; (857c <tcp_rst+0xa0>)
    8560:	4798      	blx	r3
	LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %" U32_F " ackno %" U32_F ".\n", seqno, ackno));
}
    8562:	b003      	add	sp, #12
    8564:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8568:	00005cf1 	.word	0x00005cf1
    856c:	00002ea5 	.word	0x00002ea5
    8570:	00002eb9 	.word	0x00002eb9
    8574:	00004a91 	.word	0x00004a91
    8578:	00004eb9 	.word	0x00004eb9
    857c:	00005c89 	.word	0x00005c89

00008580 <tcp_rexmit_rto>:
 */
void tcp_rexmit_rto(struct tcp_pcb *pcb)
{
	struct tcp_seg *seg;

	if (pcb->unacked == NULL) {
    8580:	6f02      	ldr	r2, [r0, #112]	; 0x70
    8582:	b10a      	cbz	r2, 8588 <tcp_rexmit_rto+0x8>
{
    8584:	b508      	push	{r3, lr}
    8586:	e001      	b.n	858c <tcp_rexmit_rto+0xc>
    8588:	4770      	bx	lr
		return;
	}

	/* Move all unacked segments to the head of the unsent queue */
	for (seg = pcb->unacked; seg->next != NULL; seg = seg->next)
    858a:	461a      	mov	r2, r3
    858c:	6813      	ldr	r3, [r2, #0]
    858e:	2b00      	cmp	r3, #0
    8590:	d1fb      	bne.n	858a <tcp_rexmit_rto+0xa>
		;
	/* concatenate unsent queue after unacked queue */
	seg->next = pcb->unsent;
    8592:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    8594:	6013      	str	r3, [r2, #0]
	/* unsent queue is the concatenated queue (of unacked, unsent) */
	pcb->unsent = pcb->unacked;
    8596:	6f03      	ldr	r3, [r0, #112]	; 0x70
    8598:	66c3      	str	r3, [r0, #108]	; 0x6c
	/* unacked queue is now empty */
	pcb->unacked = NULL;
    859a:	2200      	movs	r2, #0
    859c:	6702      	str	r2, [r0, #112]	; 0x70
	/* last unsent hasn't changed, no need to reset unsent_oversize */

	/* increment number of retransmissions */
	++pcb->nrtx;
    859e:	f890 3046 	ldrb.w	r3, [r0, #70]	; 0x46
    85a2:	3301      	adds	r3, #1
    85a4:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46

	/* Don't take any RTT measurements after retransmitting. */
	pcb->rttest = 0;
    85a8:	6382      	str	r2, [r0, #56]	; 0x38

	/* Do the actual retransmission */
	tcp_output(pcb);
    85aa:	4b01      	ldr	r3, [pc, #4]	; (85b0 <tcp_rexmit_rto+0x30>)
    85ac:	4798      	blx	r3
    85ae:	bd08      	pop	{r3, pc}
    85b0:	00008209 	.word	0x00008209

000085b4 <tcp_rexmit>:
 * Called by tcp_receive() for fast retramsmit.
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void tcp_rexmit(struct tcp_pcb *pcb)
{
    85b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct tcp_seg * seg;
	struct tcp_seg **cur_seg;

	if (pcb->unacked == NULL) {
    85b8:	6f07      	ldr	r7, [r0, #112]	; 0x70
    85ba:	b317      	cbz	r7, 8602 <tcp_rexmit+0x4e>
    85bc:	4680      	mov	r8, r0
	}

	/* Move the first unacked segment to the unsent queue */
	/* Keep the unsent queue sorted. */
	seg          = pcb->unacked;
	pcb->unacked = seg->next;
    85be:	683b      	ldr	r3, [r7, #0]
    85c0:	6703      	str	r3, [r0, #112]	; 0x70

	cur_seg = &(pcb->unsent);
    85c2:	f100 056c 	add.w	r5, r0, #108	; 0x6c
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    85c6:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    85c8:	b173      	cbz	r3, 85e8 <tcp_rexmit+0x34>
    85ca:	4e10      	ldr	r6, [pc, #64]	; (860c <tcp_rexmit+0x58>)
    85cc:	691b      	ldr	r3, [r3, #16]
    85ce:	6858      	ldr	r0, [r3, #4]
    85d0:	47b0      	blx	r6
    85d2:	4604      	mov	r4, r0
    85d4:	693b      	ldr	r3, [r7, #16]
    85d6:	6858      	ldr	r0, [r3, #4]
    85d8:	47b0      	blx	r6
    85da:	1a20      	subs	r0, r4, r0
    85dc:	2800      	cmp	r0, #0
    85de:	da03      	bge.n	85e8 <tcp_rexmit+0x34>
		cur_seg = &((*cur_seg)->next);
    85e0:	682d      	ldr	r5, [r5, #0]
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    85e2:	682b      	ldr	r3, [r5, #0]
    85e4:	2b00      	cmp	r3, #0
    85e6:	d1f1      	bne.n	85cc <tcp_rexmit+0x18>
	}
	seg->next = *cur_seg;
    85e8:	682b      	ldr	r3, [r5, #0]
    85ea:	603b      	str	r3, [r7, #0]
	*cur_seg  = seg;
    85ec:	602f      	str	r7, [r5, #0]
#if TCP_OVERSIZE
	if (seg->next == NULL) {
    85ee:	683b      	ldr	r3, [r7, #0]
    85f0:	b14b      	cbz	r3, 8606 <tcp_rexmit+0x52>
		/* the retransmitted segment is last in unsent, so reset unsent_oversize */
		pcb->unsent_oversize = 0;
	}
#endif /* TCP_OVERSIZE */

	++pcb->nrtx;
    85f2:	f898 3046 	ldrb.w	r3, [r8, #70]	; 0x46
    85f6:	3301      	adds	r3, #1
    85f8:	f888 3046 	strb.w	r3, [r8, #70]	; 0x46

	/* Don't take any rtt measurements after retransmitting. */
	pcb->rttest = 0;
    85fc:	2300      	movs	r3, #0
    85fe:	f8c8 3038 	str.w	r3, [r8, #56]	; 0x38
    8602:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		pcb->unsent_oversize = 0;
    8606:	f8a8 306a 	strh.w	r3, [r8, #106]	; 0x6a
    860a:	e7f2      	b.n	85f2 <tcp_rexmit+0x3e>
    860c:	00002ed1 	.word	0x00002ed1

00008610 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void tcp_rexmit_fast(struct tcp_pcb *pcb)
{
	if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    8610:	6f03      	ldr	r3, [r0, #112]	; 0x70
    8612:	b11b      	cbz	r3, 861c <tcp_rexmit_fast+0xc>
    8614:	7f83      	ldrb	r3, [r0, #30]
    8616:	f013 0f04 	tst.w	r3, #4
    861a:	d000      	beq.n	861e <tcp_rexmit_fast+0xe>
    861c:	4770      	bx	lr
{
    861e:	b510      	push	{r4, lr}
    8620:	4604      	mov	r4, r0
		LWIP_DEBUGF(TCP_FR_DEBUG,
		            ("tcp_receive: dupacks %" U16_F " (%" U32_F "), fast retransmit %" U32_F "\n",
		             (u16_t)pcb->dupacks,
		             pcb->lastack,
		             ntohl(pcb->unacked->tcphdr->seqno)));
		tcp_rexmit(pcb);
    8622:	4b11      	ldr	r3, [pc, #68]	; (8668 <tcp_rexmit_fast+0x58>)
    8624:	4798      	blx	r3

		/* Set ssthresh to half of the minimum of the current
		 * cwnd and the advertised window */
		if (pcb->cwnd > pcb->snd_wnd) {
    8626:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
    862a:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
    862e:	4293      	cmp	r3, r2
			pcb->ssthresh = pcb->snd_wnd / 2;
    8630:	bf87      	ittee	hi
    8632:	0852      	lsrhi	r2, r2, #1
    8634:	f8a4 204e 	strhhi.w	r2, [r4, #78]	; 0x4e
		} else {
			pcb->ssthresh = pcb->cwnd / 2;
    8638:	085b      	lsrls	r3, r3, #1
    863a:	f8a4 304e 	strhls.w	r3, [r4, #78]	; 0x4e
		}

		/* The minimum value for ssthresh should be 2 MSS */
		if (pcb->ssthresh < 2 * pcb->mss) {
    863e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    8640:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
    8644:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
			LWIP_DEBUGF(TCP_FR_DEBUG,
			            ("tcp_receive: The minimum value for ssthresh %" U16_F " should be min 2 mss %" U16_F "...\n",
			             pcb->ssthresh,
			             2 * pcb->mss));
			pcb->ssthresh = 2 * pcb->mss;
    8648:	bfbc      	itt	lt
    864a:	005a      	lsllt	r2, r3, #1
    864c:	f8a4 204e 	strhlt.w	r2, [r4, #78]	; 0x4e
		}

		pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    8650:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    8654:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
    8658:	4413      	add	r3, r2
    865a:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		pcb->flags |= TF_INFR;
    865e:	7fa3      	ldrb	r3, [r4, #30]
    8660:	f043 0304 	orr.w	r3, r3, #4
    8664:	77a3      	strb	r3, [r4, #30]
    8666:	bd10      	pop	{r4, pc}
    8668:	000085b5 	.word	0x000085b5

0000866c <tcp_keepalive>:
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void tcp_keepalive(struct tcp_pcb *pcb)
{
    866c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8670:	b082      	sub	sp, #8
    8672:	4604      	mov	r4, r0
	            ("tcp_keepalive: tcp_ticks %" U32_F "   pcb->tmr %" U32_F " pcb->keep_cnt_sent %" U16_F "\n",
	             tcp_ticks,
	             pcb->tmr,
	             pcb->keep_cnt_sent));

	p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    8674:	6d00      	ldr	r0, [r0, #80]	; 0x50
    8676:	3801      	subs	r0, #1
    8678:	4b12      	ldr	r3, [pc, #72]	; (86c4 <tcp_keepalive+0x58>)
    867a:	4798      	blx	r3
    867c:	4603      	mov	r3, r0
    867e:	2200      	movs	r2, #0
    8680:	4611      	mov	r1, r2
    8682:	4620      	mov	r0, r4
    8684:	4d10      	ldr	r5, [pc, #64]	; (86c8 <tcp_keepalive+0x5c>)
    8686:	47a8      	blx	r5
	if (p == NULL) {
    8688:	b1c0      	cbz	r0, 86bc <tcp_keepalive+0x50>
    868a:	4605      	mov	r5, r0
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: could not allocate memory for pbuf\n"));
		return;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
    868c:	6847      	ldr	r7, [r0, #4]

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    868e:	1d26      	adds	r6, r4, #4
    8690:	8903      	ldrh	r3, [r0, #8]
    8692:	9300      	str	r3, [sp, #0]
    8694:	2306      	movs	r3, #6
    8696:	4632      	mov	r2, r6
    8698:	4621      	mov	r1, r4
    869a:	f8df 8038 	ldr.w	r8, [pc, #56]	; 86d4 <tcp_keepalive+0x68>
    869e:	47c0      	blx	r8
    86a0:	8238      	strh	r0, [r7, #16]

	/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    86a2:	7aa3      	ldrb	r3, [r4, #10]
    86a4:	2206      	movs	r2, #6
    86a6:	9201      	str	r2, [sp, #4]
    86a8:	2200      	movs	r2, #0
    86aa:	9200      	str	r2, [sp, #0]
    86ac:	4632      	mov	r2, r6
    86ae:	4621      	mov	r1, r4
    86b0:	4628      	mov	r0, r5
    86b2:	4c06      	ldr	r4, [pc, #24]	; (86cc <tcp_keepalive+0x60>)
    86b4:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

	pbuf_free(p);
    86b6:	4628      	mov	r0, r5
    86b8:	4b05      	ldr	r3, [pc, #20]	; (86d0 <tcp_keepalive+0x64>)
    86ba:	4798      	blx	r3

	LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %" U32_F " ackno %" U32_F ".\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    86bc:	b002      	add	sp, #8
    86be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    86c2:	bf00      	nop
    86c4:	00002eb9 	.word	0x00002eb9
    86c8:	00007ff9 	.word	0x00007ff9
    86cc:	00004eb9 	.word	0x00004eb9
    86d0:	00005c89 	.word	0x00005c89
    86d4:	00004a91 	.word	0x00004a91

000086d8 <tcp_zero_window_probe>:
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void tcp_zero_window_probe(struct tcp_pcb *pcb)
{
    86d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    86dc:	b082      	sub	sp, #8
	            ("tcp_zero_window_probe: tcp_ticks %" U32_F "   pcb->tmr %" U32_F " pcb->keep_cnt_sent %" U16_F "\n",
	             tcp_ticks,
	             pcb->tmr,
	             pcb->keep_cnt_sent));

	seg = pcb->unacked;
    86de:	6f05      	ldr	r5, [r0, #112]	; 0x70

	if (seg == NULL) {
    86e0:	b1fd      	cbz	r5, 8722 <tcp_zero_window_probe+0x4a>
    86e2:	4604      	mov	r4, r0
	}
	if (seg == NULL) {
		return;
	}

	is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    86e4:	692b      	ldr	r3, [r5, #16]
    86e6:	8998      	ldrh	r0, [r3, #12]
    86e8:	4b26      	ldr	r3, [pc, #152]	; (8784 <tcp_zero_window_probe+0xac>)
    86ea:	4798      	blx	r3
    86ec:	f010 0f01 	tst.w	r0, #1
    86f0:	d001      	beq.n	86f6 <tcp_zero_window_probe+0x1e>
    86f2:	892b      	ldrh	r3, [r5, #8]
    86f4:	b1c3      	cbz	r3, 8728 <tcp_zero_window_probe+0x50>
	/* we want to send one seqno: either FIN or data (no options) */
	len = is_fin ? 0 : 1;

	p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    86f6:	692b      	ldr	r3, [r5, #16]
    86f8:	685b      	ldr	r3, [r3, #4]
    86fa:	2201      	movs	r2, #1
    86fc:	2100      	movs	r1, #0
    86fe:	4620      	mov	r0, r4
    8700:	4e21      	ldr	r6, [pc, #132]	; (8788 <tcp_zero_window_probe+0xb0>)
    8702:	47b0      	blx	r6
	if (p == NULL) {
    8704:	4606      	mov	r6, r0
    8706:	2800      	cmp	r0, #0
    8708:	d039      	beq.n	877e <tcp_zero_window_probe+0xa6>
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
		return;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
    870a:	6877      	ldr	r7, [r6, #4]
		/* Data segment, copy in one byte from the head of the unacked queue */
		char *d = ((char *)p->payload + TCP_HLEN);
		/* Depending on whether the segment has already been sent (unacked) or not
		   (unsent), seg->p->payload points to the IP header or TCP header.
		   Ensure we copy the first TCP data byte: */
		pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
    870c:	6868      	ldr	r0, [r5, #4]
    870e:	8903      	ldrh	r3, [r0, #8]
    8710:	892a      	ldrh	r2, [r5, #8]
    8712:	1a9b      	subs	r3, r3, r2
    8714:	b29b      	uxth	r3, r3
    8716:	2201      	movs	r2, #1
    8718:	f107 0114 	add.w	r1, r7, #20
    871c:	4d1b      	ldr	r5, [pc, #108]	; (878c <tcp_zero_window_probe+0xb4>)
    871e:	47a8      	blx	r5
    8720:	e015      	b.n	874e <tcp_zero_window_probe+0x76>
		seg = pcb->unsent;
    8722:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
	if (seg == NULL) {
    8724:	b35d      	cbz	r5, 877e <tcp_zero_window_probe+0xa6>
    8726:	e7dc      	b.n	86e2 <tcp_zero_window_probe+0xa>
	p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    8728:	692b      	ldr	r3, [r5, #16]
    872a:	685b      	ldr	r3, [r3, #4]
    872c:	2200      	movs	r2, #0
    872e:	4611      	mov	r1, r2
    8730:	4620      	mov	r0, r4
    8732:	4d15      	ldr	r5, [pc, #84]	; (8788 <tcp_zero_window_probe+0xb0>)
    8734:	47a8      	blx	r5
	if (p == NULL) {
    8736:	4606      	mov	r6, r0
    8738:	b308      	cbz	r0, 877e <tcp_zero_window_probe+0xa6>
	tcphdr = (struct tcp_hdr *)p->payload;
    873a:	6877      	ldr	r7, [r6, #4]
		TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
    873c:	f9b7 500c 	ldrsh.w	r5, [r7, #12]
    8740:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
    8744:	2011      	movs	r0, #17
    8746:	4b12      	ldr	r3, [pc, #72]	; (8790 <tcp_zero_window_probe+0xb8>)
    8748:	4798      	blx	r3
    874a:	4328      	orrs	r0, r5
    874c:	81b8      	strh	r0, [r7, #12]
	}

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    874e:	1d25      	adds	r5, r4, #4
    8750:	8933      	ldrh	r3, [r6, #8]
    8752:	9300      	str	r3, [sp, #0]
    8754:	2306      	movs	r3, #6
    8756:	462a      	mov	r2, r5
    8758:	4621      	mov	r1, r4
    875a:	4630      	mov	r0, r6
    875c:	f8df 803c 	ldr.w	r8, [pc, #60]	; 879c <tcp_zero_window_probe+0xc4>
    8760:	47c0      	blx	r8
    8762:	8238      	strh	r0, [r7, #16]

	/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    8764:	7aa3      	ldrb	r3, [r4, #10]
    8766:	2206      	movs	r2, #6
    8768:	9201      	str	r2, [sp, #4]
    876a:	2200      	movs	r2, #0
    876c:	9200      	str	r2, [sp, #0]
    876e:	462a      	mov	r2, r5
    8770:	4621      	mov	r1, r4
    8772:	4630      	mov	r0, r6
    8774:	4c07      	ldr	r4, [pc, #28]	; (8794 <tcp_zero_window_probe+0xbc>)
    8776:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

	pbuf_free(p);
    8778:	4630      	mov	r0, r6
    877a:	4b07      	ldr	r3, [pc, #28]	; (8798 <tcp_zero_window_probe+0xc0>)
    877c:	4798      	blx	r3

	LWIP_DEBUGF(TCP_DEBUG,
	            ("tcp_zero_window_probe: seqno %" U32_F " ackno %" U32_F ".\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    877e:	b002      	add	sp, #8
    8780:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8784:	00002eaf 	.word	0x00002eaf
    8788:	00007ff9 	.word	0x00007ff9
    878c:	00006015 	.word	0x00006015
    8790:	00002ea5 	.word	0x00002ea5
    8794:	00004eb9 	.word	0x00004eb9
    8798:	00005c89 	.word	0x00005c89
    879c:	00004a91 	.word	0x00004a91

000087a0 <sys_timeout>:
#if LWIP_DEBUG_TIMERNAMES
void sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else  /* LWIP_DEBUG_TIMERNAMES */
void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
    87a0:	b570      	push	{r4, r5, r6, lr}
    87a2:	4604      	mov	r4, r0
    87a4:	460e      	mov	r6, r1
    87a6:	4615      	mov	r5, r2
	struct sys_timeo *timeout, *t;

	timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    87a8:	2007      	movs	r0, #7
    87aa:	4b1b      	ldr	r3, [pc, #108]	; (8818 <sys_timeout+0x78>)
    87ac:	4798      	blx	r3
	if (timeout == NULL) {
    87ae:	2800      	cmp	r0, #0
    87b0:	d030      	beq.n	8814 <sys_timeout+0x74>
    87b2:	4601      	mov	r1, r0
		LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
		return;
	}
	timeout->next = NULL;
    87b4:	2300      	movs	r3, #0
    87b6:	6003      	str	r3, [r0, #0]
	timeout->h    = handler;
    87b8:	6086      	str	r6, [r0, #8]
	timeout->arg  = arg;
    87ba:	60c5      	str	r5, [r0, #12]
	timeout->time = msecs;
    87bc:	6044      	str	r4, [r0, #4]
	LWIP_DEBUGF(
	    TIMERS_DEBUG,
	    ("sys_timeout: %p msecs=%" U32_F " handler=%s arg=%p\n", (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

	if (next_timeout == NULL) {
    87be:	4b17      	ldr	r3, [pc, #92]	; (881c <sys_timeout+0x7c>)
    87c0:	681d      	ldr	r5, [r3, #0]
    87c2:	b1a5      	cbz	r5, 87ee <sys_timeout+0x4e>
		next_timeout = timeout;
		return;
	}

	if (next_timeout->time > msecs) {
    87c4:	6868      	ldr	r0, [r5, #4]
    87c6:	4284      	cmp	r4, r0
    87c8:	d313      	bcc.n	87f2 <sys_timeout+0x52>
		next_timeout->time -= msecs;
		timeout->next = next_timeout;
		next_timeout  = timeout;
	} else {
		for (t = next_timeout; t != NULL; t = t->next) {
			timeout->time -= t->time;
    87ca:	1a20      	subs	r0, r4, r0
    87cc:	6048      	str	r0, [r1, #4]
			if (t->next == NULL || t->next->time > timeout->time) {
    87ce:	682a      	ldr	r2, [r5, #0]
    87d0:	b1f2      	cbz	r2, 8810 <sys_timeout+0x70>
    87d2:	6853      	ldr	r3, [r2, #4]
    87d4:	4298      	cmp	r0, r3
    87d6:	d312      	bcc.n	87fe <sys_timeout+0x5e>
			timeout->time -= t->time;
    87d8:	6848      	ldr	r0, [r1, #4]
    87da:	6853      	ldr	r3, [r2, #4]
    87dc:	1ac0      	subs	r0, r0, r3
    87de:	6048      	str	r0, [r1, #4]
			if (t->next == NULL || t->next->time > timeout->time) {
    87e0:	6813      	ldr	r3, [r2, #0]
    87e2:	b18b      	cbz	r3, 8808 <sys_timeout+0x68>
    87e4:	685c      	ldr	r4, [r3, #4]
    87e6:	42a0      	cmp	r0, r4
    87e8:	d30b      	bcc.n	8802 <sys_timeout+0x62>
    87ea:	461a      	mov	r2, r3
    87ec:	e7f4      	b.n	87d8 <sys_timeout+0x38>
		next_timeout = timeout;
    87ee:	6018      	str	r0, [r3, #0]
		return;
    87f0:	bd70      	pop	{r4, r5, r6, pc}
		next_timeout->time -= msecs;
    87f2:	1b00      	subs	r0, r0, r4
    87f4:	6068      	str	r0, [r5, #4]
		timeout->next = next_timeout;
    87f6:	600d      	str	r5, [r1, #0]
		next_timeout  = timeout;
    87f8:	4b08      	ldr	r3, [pc, #32]	; (881c <sys_timeout+0x7c>)
    87fa:	6019      	str	r1, [r3, #0]
    87fc:	bd70      	pop	{r4, r5, r6, pc}
			if (t->next == NULL || t->next->time > timeout->time) {
    87fe:	4613      	mov	r3, r2
    8800:	462a      	mov	r2, r5
				if (t->next != NULL) {
					t->next->time -= timeout->time;
    8802:	685c      	ldr	r4, [r3, #4]
    8804:	1a20      	subs	r0, r4, r0
    8806:	6058      	str	r0, [r3, #4]
				}
				timeout->next = t->next;
    8808:	6813      	ldr	r3, [r2, #0]
    880a:	600b      	str	r3, [r1, #0]
				t->next       = timeout;
    880c:	6011      	str	r1, [r2, #0]
				break;
    880e:	bd70      	pop	{r4, r5, r6, pc}
			if (t->next == NULL || t->next->time > timeout->time) {
    8810:	462a      	mov	r2, r5
    8812:	e7f9      	b.n	8808 <sys_timeout+0x68>
    8814:	bd70      	pop	{r4, r5, r6, pc}
    8816:	bf00      	nop
    8818:	00005979 	.word	0x00005979
    881c:	20007fcc 	.word	0x20007fcc

00008820 <tcp_timer_needed>:
{
    8820:	b508      	push	{r3, lr}
	if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
    8822:	4b0a      	ldr	r3, [pc, #40]	; (884c <tcp_timer_needed+0x2c>)
    8824:	685b      	ldr	r3, [r3, #4]
    8826:	b953      	cbnz	r3, 883e <tcp_timer_needed+0x1e>
    8828:	4b09      	ldr	r3, [pc, #36]	; (8850 <tcp_timer_needed+0x30>)
    882a:	681b      	ldr	r3, [r3, #0]
    882c:	b143      	cbz	r3, 8840 <tcp_timer_needed+0x20>
		tcpip_tcp_timer_active = 1;
    882e:	2201      	movs	r2, #1
    8830:	4b06      	ldr	r3, [pc, #24]	; (884c <tcp_timer_needed+0x2c>)
    8832:	605a      	str	r2, [r3, #4]
		sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    8834:	2200      	movs	r2, #0
    8836:	4907      	ldr	r1, [pc, #28]	; (8854 <tcp_timer_needed+0x34>)
    8838:	20fa      	movs	r0, #250	; 0xfa
    883a:	4b07      	ldr	r3, [pc, #28]	; (8858 <tcp_timer_needed+0x38>)
    883c:	4798      	blx	r3
    883e:	bd08      	pop	{r3, pc}
	if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
    8840:	4b06      	ldr	r3, [pc, #24]	; (885c <tcp_timer_needed+0x3c>)
    8842:	681b      	ldr	r3, [r3, #0]
    8844:	2b00      	cmp	r3, #0
    8846:	d1f2      	bne.n	882e <tcp_timer_needed+0xe>
    8848:	e7f9      	b.n	883e <tcp_timer_needed+0x1e>
    884a:	bf00      	nop
    884c:	20007fcc 	.word	0x20007fcc
    8850:	20009300 	.word	0x20009300
    8854:	00008861 	.word	0x00008861
    8858:	000087a1 	.word	0x000087a1
    885c:	20009314 	.word	0x20009314

00008860 <tcpip_tcp_timer>:
{
    8860:	b508      	push	{r3, lr}
	tcp_tmr();
    8862:	4b09      	ldr	r3, [pc, #36]	; (8888 <tcpip_tcp_timer+0x28>)
    8864:	4798      	blx	r3
	if (tcp_active_pcbs || tcp_tw_pcbs) {
    8866:	4b09      	ldr	r3, [pc, #36]	; (888c <tcpip_tcp_timer+0x2c>)
    8868:	681b      	ldr	r3, [r3, #0]
    886a:	b12b      	cbz	r3, 8878 <tcpip_tcp_timer+0x18>
		sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    886c:	2200      	movs	r2, #0
    886e:	4908      	ldr	r1, [pc, #32]	; (8890 <tcpip_tcp_timer+0x30>)
    8870:	20fa      	movs	r0, #250	; 0xfa
    8872:	4b08      	ldr	r3, [pc, #32]	; (8894 <tcpip_tcp_timer+0x34>)
    8874:	4798      	blx	r3
    8876:	bd08      	pop	{r3, pc}
	if (tcp_active_pcbs || tcp_tw_pcbs) {
    8878:	4b07      	ldr	r3, [pc, #28]	; (8898 <tcpip_tcp_timer+0x38>)
    887a:	681b      	ldr	r3, [r3, #0]
    887c:	2b00      	cmp	r3, #0
    887e:	d1f5      	bne.n	886c <tcpip_tcp_timer+0xc>
		tcpip_tcp_timer_active = 0;
    8880:	2200      	movs	r2, #0
    8882:	4b06      	ldr	r3, [pc, #24]	; (889c <tcpip_tcp_timer+0x3c>)
    8884:	605a      	str	r2, [r3, #4]
    8886:	bd08      	pop	{r3, pc}
    8888:	0000694d 	.word	0x0000694d
    888c:	20009300 	.word	0x20009300
    8890:	00008861 	.word	0x00008861
    8894:	000087a1 	.word	0x000087a1
    8898:	20009314 	.word	0x20009314
    889c:	20007fcc 	.word	0x20007fcc

000088a0 <sys_timeouts_init>:
{
    88a0:	b510      	push	{r4, lr}
	sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    88a2:	2200      	movs	r2, #0
    88a4:	490c      	ldr	r1, [pc, #48]	; (88d8 <sys_timeouts_init+0x38>)
    88a6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    88aa:	4c0c      	ldr	r4, [pc, #48]	; (88dc <sys_timeouts_init+0x3c>)
    88ac:	47a0      	blx	r4
	sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    88ae:	2200      	movs	r2, #0
    88b0:	490b      	ldr	r1, [pc, #44]	; (88e0 <sys_timeouts_init+0x40>)
    88b2:	f241 3088 	movw	r0, #5000	; 0x1388
    88b6:	47a0      	blx	r4
	sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
    88b8:	2200      	movs	r2, #0
    88ba:	490a      	ldr	r1, [pc, #40]	; (88e4 <sys_timeouts_init+0x44>)
    88bc:	f64e 2060 	movw	r0, #60000	; 0xea60
    88c0:	47a0      	blx	r4
	sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    88c2:	2200      	movs	r2, #0
    88c4:	4908      	ldr	r1, [pc, #32]	; (88e8 <sys_timeouts_init+0x48>)
    88c6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    88ca:	47a0      	blx	r4
	timeouts_last_time = sys_now();
    88cc:	4b07      	ldr	r3, [pc, #28]	; (88ec <sys_timeouts_init+0x4c>)
    88ce:	4798      	blx	r3
    88d0:	4b07      	ldr	r3, [pc, #28]	; (88f0 <sys_timeouts_init+0x50>)
    88d2:	6098      	str	r0, [r3, #8]
    88d4:	bd10      	pop	{r4, pc}
    88d6:	bf00      	nop
    88d8:	00008955 	.word	0x00008955
    88dc:	000087a1 	.word	0x000087a1
    88e0:	00008935 	.word	0x00008935
    88e4:	00008915 	.word	0x00008915
    88e8:	000088f5 	.word	0x000088f5
    88ec:	00009811 	.word	0x00009811
    88f0:	20007fcc 	.word	0x20007fcc

000088f4 <dhcp_timer_fine>:
{
    88f4:	b508      	push	{r3, lr}
	dhcp_fine_tmr();
    88f6:	4b04      	ldr	r3, [pc, #16]	; (8908 <dhcp_timer_fine+0x14>)
    88f8:	4798      	blx	r3
	sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    88fa:	2200      	movs	r2, #0
    88fc:	4903      	ldr	r1, [pc, #12]	; (890c <dhcp_timer_fine+0x18>)
    88fe:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    8902:	4b03      	ldr	r3, [pc, #12]	; (8910 <dhcp_timer_fine+0x1c>)
    8904:	4798      	blx	r3
    8906:	bd08      	pop	{r3, pc}
    8908:	000044ad 	.word	0x000044ad
    890c:	000088f5 	.word	0x000088f5
    8910:	000087a1 	.word	0x000087a1

00008914 <dhcp_timer_coarse>:
{
    8914:	b508      	push	{r3, lr}
	dhcp_coarse_tmr();
    8916:	4b04      	ldr	r3, [pc, #16]	; (8928 <dhcp_timer_coarse+0x14>)
    8918:	4798      	blx	r3
	sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
    891a:	2200      	movs	r2, #0
    891c:	4903      	ldr	r1, [pc, #12]	; (892c <dhcp_timer_coarse+0x18>)
    891e:	f64e 2060 	movw	r0, #60000	; 0xea60
    8922:	4b03      	ldr	r3, [pc, #12]	; (8930 <dhcp_timer_coarse+0x1c>)
    8924:	4798      	blx	r3
    8926:	bd08      	pop	{r3, pc}
    8928:	000042e1 	.word	0x000042e1
    892c:	00008915 	.word	0x00008915
    8930:	000087a1 	.word	0x000087a1

00008934 <arp_timer>:
{
    8934:	b508      	push	{r3, lr}
	etharp_tmr();
    8936:	4b04      	ldr	r3, [pc, #16]	; (8948 <arp_timer+0x14>)
    8938:	4798      	blx	r3
	sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    893a:	2200      	movs	r2, #0
    893c:	4903      	ldr	r1, [pc, #12]	; (894c <arp_timer+0x18>)
    893e:	f241 3088 	movw	r0, #5000	; 0x1388
    8942:	4b03      	ldr	r3, [pc, #12]	; (8950 <arp_timer+0x1c>)
    8944:	4798      	blx	r3
    8946:	bd08      	pop	{r3, pc}
    8948:	00009025 	.word	0x00009025
    894c:	00008935 	.word	0x00008935
    8950:	000087a1 	.word	0x000087a1

00008954 <ip_reass_timer>:
{
    8954:	b508      	push	{r3, lr}
	ip_reass_tmr();
    8956:	4b04      	ldr	r3, [pc, #16]	; (8968 <ip_reass_timer+0x14>)
    8958:	4798      	blx	r3
	sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    895a:	2200      	movs	r2, #0
    895c:	4903      	ldr	r1, [pc, #12]	; (896c <ip_reass_timer+0x18>)
    895e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    8962:	4b03      	ldr	r3, [pc, #12]	; (8970 <ip_reass_timer+0x1c>)
    8964:	4798      	blx	r3
    8966:	bd08      	pop	{r3, pc}
    8968:	0000513d 	.word	0x0000513d
    896c:	00008955 	.word	0x00008955
    8970:	000087a1 	.word	0x000087a1

00008974 <sys_check_timeouts>:
 *
 * Must be called periodically from your main loop.
 */
void sys_check_timeouts(void)
{
	if (next_timeout) {
    8974:	4b15      	ldr	r3, [pc, #84]	; (89cc <sys_check_timeouts+0x58>)
    8976:	681b      	ldr	r3, [r3, #0]
    8978:	b333      	cbz	r3, 89c8 <sys_check_timeouts+0x54>
{
    897a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		sys_timeout_handler handler;
		void *              arg;
		u8_t                had_one;
		u32_t               now;

		now = sys_now();
    897e:	4b14      	ldr	r3, [pc, #80]	; (89d0 <sys_check_timeouts+0x5c>)
    8980:	4798      	blx	r3
    8982:	4680      	mov	r8, r0
		/* this cares for wraparounds */
		diff = now - timeouts_last_time;
    8984:	4b11      	ldr	r3, [pc, #68]	; (89cc <sys_check_timeouts+0x58>)
    8986:	689c      	ldr	r4, [r3, #8]
    8988:	1b04      	subs	r4, r0, r4
		do {
#if PBUF_POOL_FREE_OOSEQ
			PBUF_CHECK_FREE_OOSEQ();
    898a:	4f12      	ldr	r7, [pc, #72]	; (89d4 <sys_check_timeouts+0x60>)
    898c:	f8df 904c 	ldr.w	r9, [pc, #76]	; 89dc <sys_check_timeouts+0x68>
#endif /* PBUF_POOL_FREE_OOSEQ */
			had_one    = 0;
			tmptimeout = next_timeout;
    8990:	461d      	mov	r5, r3
			PBUF_CHECK_FREE_OOSEQ();
    8992:	783b      	ldrb	r3, [r7, #0]
    8994:	b9a3      	cbnz	r3, 89c0 <sys_check_timeouts+0x4c>
			tmptimeout = next_timeout;
    8996:	6829      	ldr	r1, [r5, #0]
			if (tmptimeout && (tmptimeout->time <= diff)) {
    8998:	b1a1      	cbz	r1, 89c4 <sys_check_timeouts+0x50>
    899a:	684b      	ldr	r3, [r1, #4]
    899c:	429c      	cmp	r4, r3
    899e:	d311      	bcc.n	89c4 <sys_check_timeouts+0x50>
				/* timeout has expired */
				had_one            = 1;
				timeouts_last_time = now;
    89a0:	f8c5 8008 	str.w	r8, [r5, #8]
				diff -= tmptimeout->time;
    89a4:	1ae4      	subs	r4, r4, r3
				next_timeout = tmptimeout->next;
    89a6:	680b      	ldr	r3, [r1, #0]
    89a8:	602b      	str	r3, [r5, #0]
				handler      = tmptimeout->h;
    89aa:	688e      	ldr	r6, [r1, #8]
				arg          = tmptimeout->arg;
    89ac:	f8d1 a00c 	ldr.w	sl, [r1, #12]
#if LWIP_DEBUG_TIMERNAMES
				if (handler != NULL) {
					LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s arg=%p\n", tmptimeout->handler_name, arg));
				}
#endif /* LWIP_DEBUG_TIMERNAMES */
				memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
    89b0:	2007      	movs	r0, #7
    89b2:	4b09      	ldr	r3, [pc, #36]	; (89d8 <sys_check_timeouts+0x64>)
    89b4:	4798      	blx	r3
				if (handler != NULL) {
    89b6:	2e00      	cmp	r6, #0
    89b8:	d0eb      	beq.n	8992 <sys_check_timeouts+0x1e>
					handler(arg);
    89ba:	4650      	mov	r0, sl
    89bc:	47b0      	blx	r6
    89be:	e7e8      	b.n	8992 <sys_check_timeouts+0x1e>
			PBUF_CHECK_FREE_OOSEQ();
    89c0:	47c8      	blx	r9
    89c2:	e7e8      	b.n	8996 <sys_check_timeouts+0x22>
    89c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    89c8:	4770      	bx	lr
    89ca:	bf00      	nop
    89cc:	20007fcc 	.word	0x20007fcc
    89d0:	00009811 	.word	0x00009811
    89d4:	200092f8 	.word	0x200092f8
    89d8:	000059c1 	.word	0x000059c1
    89dc:	00005b61 	.word	0x00005b61

000089e0 <udp_init>:

/**
 * Initialize this module.
 */
void udp_init(void)
{
    89e0:	4770      	bx	lr
	...

000089e4 <udp_input>:
 * @param p pbuf to be demultiplexed to a UDP PCB.
 * @param inp network interface on which the datagram was received.
 *
 */
void udp_input(struct pbuf *p, struct netif *inp)
{
    89e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    89e8:	b085      	sub	sp, #20
    89ea:	4604      	mov	r4, r0
    89ec:	4689      	mov	r9, r1

	PERF_START;

	UDP_STATS_INC(udp.recv);

	iphdr = (struct ip_hdr *)p->payload;
    89ee:	6847      	ldr	r7, [r0, #4]
    89f0:	7839      	ldrb	r1, [r7, #0]
    89f2:	f001 010f 	and.w	r1, r1, #15

	/* Check minimum length (IP header + UDP header)
	 * and move payload pointer to UDP header */
	if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    89f6:	8903      	ldrh	r3, [r0, #8]
    89f8:	1c8a      	adds	r2, r1, #2
    89fa:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
    89fe:	db04      	blt.n	8a0a <udp_input+0x26>
    8a00:	0089      	lsls	r1, r1, #2
    8a02:	4249      	negs	r1, r1
    8a04:	4b6a      	ldr	r3, [pc, #424]	; (8bb0 <udp_input+0x1cc>)
    8a06:	4798      	blx	r3
    8a08:	b128      	cbz	r0, 8a16 <udp_input+0x32>
		/* drop short packets */
		LWIP_DEBUGF(UDP_DEBUG, ("udp_input: short UDP datagram (%" U16_F " bytes) discarded\n", p->tot_len));
		UDP_STATS_INC(udp.lenerr);
		UDP_STATS_INC(udp.drop);
		snmp_inc_udpinerrors();
		pbuf_free(p);
    8a0a:	4620      	mov	r0, r4
    8a0c:	4b69      	ldr	r3, [pc, #420]	; (8bb4 <udp_input+0x1d0>)
    8a0e:	4798      	blx	r3
	} else {
		pbuf_free(p);
	}
end:
	PERF_STOP("udp_input");
}
    8a10:	b005      	add	sp, #20
    8a12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	udphdr = (struct udp_hdr *)p->payload;
    8a16:	f8d4 a004 	ldr.w	sl, [r4, #4]
	broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    8a1a:	4649      	mov	r1, r9
    8a1c:	4b66      	ldr	r3, [pc, #408]	; (8bb8 <udp_input+0x1d4>)
    8a1e:	6818      	ldr	r0, [r3, #0]
    8a20:	4b66      	ldr	r3, [pc, #408]	; (8bbc <udp_input+0x1d8>)
    8a22:	4798      	blx	r3
    8a24:	4680      	mov	r8, r0
	src  = ntohs(udphdr->src);
    8a26:	f8ba 0000 	ldrh.w	r0, [sl]
    8a2a:	4e65      	ldr	r6, [pc, #404]	; (8bc0 <udp_input+0x1dc>)
    8a2c:	47b0      	blx	r6
    8a2e:	4605      	mov	r5, r0
	dest = ntohs(udphdr->dest);
    8a30:	f8ba 0002 	ldrh.w	r0, [sl, #2]
    8a34:	47b0      	blx	r6
	if (dest == DHCP_CLIENT_PORT) {
    8a36:	2844      	cmp	r0, #68	; 0x44
    8a38:	d014      	beq.n	8a64 <udp_input+0x80>
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    8a3a:	4b62      	ldr	r3, [pc, #392]	; (8bc4 <udp_input+0x1e0>)
    8a3c:	f8d3 e000 	ldr.w	lr, [r3]
    8a40:	f1be 0f00 	cmp.w	lr, #0
    8a44:	d010      	beq.n	8a68 <udp_input+0x84>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    8a46:	4b5c      	ldr	r3, [pc, #368]	; (8bb8 <udp_input+0x1d4>)
    8a48:	f8d3 c000 	ldr.w	ip, [r3]
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    8a4c:	4b5e      	ldr	r3, [pc, #376]	; (8bc8 <udp_input+0x1e4>)
    8a4e:	f8d3 b000 	ldr.w	fp, [r3]
    8a52:	4673      	mov	r3, lr
    8a54:	2600      	movs	r6, #0
    8a56:	4632      	mov	r2, r6
    8a58:	9703      	str	r7, [sp, #12]
    8a5a:	4621      	mov	r1, r4
    8a5c:	4644      	mov	r4, r8
    8a5e:	46f0      	mov	r8, lr
    8a60:	468e      	mov	lr, r1
    8a62:	e097      	b.n	8b94 <udp_input+0x1b0>
		if (src == DHCP_SERVER_PORT) {
    8a64:	2d43      	cmp	r5, #67	; 0x43
    8a66:	d009      	beq.n	8a7c <udp_input+0x98>
	if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    8a68:	f8d9 2004 	ldr.w	r2, [r9, #4]
    8a6c:	4b52      	ldr	r3, [pc, #328]	; (8bb8 <udp_input+0x1d4>)
    8a6e:	681b      	ldr	r3, [r3, #0]
    8a70:	429a      	cmp	r2, r3
    8a72:	d053      	beq.n	8b1c <udp_input+0x138>
		pbuf_free(p);
    8a74:	4620      	mov	r0, r4
    8a76:	4b4f      	ldr	r3, [pc, #316]	; (8bb4 <udp_input+0x1d0>)
    8a78:	4798      	blx	r3
}
    8a7a:	e7c9      	b.n	8a10 <udp_input+0x2c>
			if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
    8a7c:	f8d9 3028 	ldr.w	r3, [r9, #40]	; 0x28
    8a80:	2b00      	cmp	r3, #0
    8a82:	d0f1      	beq.n	8a68 <udp_input+0x84>
    8a84:	685b      	ldr	r3, [r3, #4]
    8a86:	2b00      	cmp	r3, #0
    8a88:	d0ee      	beq.n	8a68 <udp_input+0x84>
				if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip)
    8a8a:	f113 0f04 	cmn.w	r3, #4
    8a8e:	d021      	beq.n	8ad4 <udp_input+0xf0>
    8a90:	685a      	ldr	r2, [r3, #4]
    8a92:	b1fa      	cbz	r2, 8ad4 <udp_input+0xf0>
				     || ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
    8a94:	494c      	ldr	r1, [pc, #304]	; (8bc8 <udp_input+0x1e4>)
    8a96:	6809      	ldr	r1, [r1, #0]
    8a98:	428a      	cmp	r2, r1
    8a9a:	d1e5      	bne.n	8a68 <udp_input+0x84>
    8a9c:	e01a      	b.n	8ad4 <udp_input+0xf0>
					if ((uncon_pcb == NULL) && ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    8a9e:	7c19      	ldrb	r1, [r3, #16]
    8aa0:	f001 0104 	and.w	r1, r1, #4
    8aa4:	2900      	cmp	r1, #0
    8aa6:	bf08      	it	eq
    8aa8:	461e      	moveq	r6, r3
    8aaa:	e06b      	b.n	8b84 <udp_input+0x1a0>
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    8aac:	f113 0f04 	cmn.w	r3, #4
    8ab0:	d003      	beq.n	8aba <udp_input+0xd6>
    8ab2:	6859      	ldr	r1, [r3, #4]
    8ab4:	b109      	cbz	r1, 8aba <udp_input+0xd6>
    8ab6:	4559      	cmp	r1, fp
    8ab8:	d167      	bne.n	8b8a <udp_input+0x1a6>
    8aba:	9f03      	ldr	r7, [sp, #12]
    8abc:	4671      	mov	r1, lr
    8abe:	46c6      	mov	lr, r8
    8ac0:	46a0      	mov	r8, r4
    8ac2:	460c      	mov	r4, r1
				if (prev != NULL) {
    8ac4:	b12a      	cbz	r2, 8ad2 <udp_input+0xee>
					prev->next = pcb->next;
    8ac6:	68d9      	ldr	r1, [r3, #12]
    8ac8:	60d1      	str	r1, [r2, #12]
					pcb->next  = udp_pcbs;
    8aca:	f8c3 e00c 	str.w	lr, [r3, #12]
					udp_pcbs   = pcb;
    8ace:	4a3d      	ldr	r2, [pc, #244]	; (8bc4 <udp_input+0x1e0>)
    8ad0:	6013      	str	r3, [r2, #0]
		if (pcb == NULL) {
    8ad2:	b123      	cbz	r3, 8ade <udp_input+0xfa>
    8ad4:	461e      	mov	r6, r3
    8ad6:	e004      	b.n	8ae2 <udp_input+0xfe>
    8ad8:	9f03      	ldr	r7, [sp, #12]
    8ada:	46a0      	mov	r8, r4
    8adc:	4674      	mov	r4, lr
	if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    8ade:	2e00      	cmp	r6, #0
    8ae0:	d0c2      	beq.n	8a68 <udp_input+0x84>
			if (udphdr->chksum != 0) {
    8ae2:	f8ba 3006 	ldrh.w	r3, [sl, #6]
    8ae6:	b14b      	cbz	r3, 8afc <udp_input+0x118>
				if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(), IP_PROTO_UDP, p->tot_len)
    8ae8:	8923      	ldrh	r3, [r4, #8]
    8aea:	9300      	str	r3, [sp, #0]
    8aec:	2311      	movs	r3, #17
    8aee:	4a32      	ldr	r2, [pc, #200]	; (8bb8 <udp_input+0x1d4>)
    8af0:	4935      	ldr	r1, [pc, #212]	; (8bc8 <udp_input+0x1e4>)
    8af2:	4620      	mov	r0, r4
    8af4:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 8bd0 <udp_input+0x1ec>
    8af8:	47c8      	blx	r9
    8afa:	b988      	cbnz	r0, 8b20 <udp_input+0x13c>
		if (pbuf_header(p, -UDP_HLEN)) {
    8afc:	f06f 0107 	mvn.w	r1, #7
    8b00:	4620      	mov	r0, r4
    8b02:	4b2b      	ldr	r3, [pc, #172]	; (8bb0 <udp_input+0x1cc>)
    8b04:	4798      	blx	r3
    8b06:	b978      	cbnz	r0, 8b28 <udp_input+0x144>
		if (pcb != NULL) {
    8b08:	b1b6      	cbz	r6, 8b38 <udp_input+0x154>
			if (pcb->recv != NULL) {
    8b0a:	69b7      	ldr	r7, [r6, #24]
    8b0c:	b187      	cbz	r7, 8b30 <udp_input+0x14c>
				pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
    8b0e:	69f0      	ldr	r0, [r6, #28]
    8b10:	9500      	str	r5, [sp, #0]
    8b12:	4b2d      	ldr	r3, [pc, #180]	; (8bc8 <udp_input+0x1e4>)
    8b14:	4622      	mov	r2, r4
    8b16:	4631      	mov	r1, r6
    8b18:	47b8      	blx	r7
    8b1a:	e779      	b.n	8a10 <udp_input+0x2c>
    8b1c:	2600      	movs	r6, #0
    8b1e:	e7e0      	b.n	8ae2 <udp_input+0xfe>
					pbuf_free(p);
    8b20:	4620      	mov	r0, r4
    8b22:	4b24      	ldr	r3, [pc, #144]	; (8bb4 <udp_input+0x1d0>)
    8b24:	4798      	blx	r3
					goto end;
    8b26:	e773      	b.n	8a10 <udp_input+0x2c>
			pbuf_free(p);
    8b28:	4620      	mov	r0, r4
    8b2a:	4b22      	ldr	r3, [pc, #136]	; (8bb4 <udp_input+0x1d0>)
    8b2c:	4798      	blx	r3
			goto end;
    8b2e:	e76f      	b.n	8a10 <udp_input+0x2c>
				pbuf_free(p);
    8b30:	4620      	mov	r0, r4
    8b32:	4b20      	ldr	r3, [pc, #128]	; (8bb4 <udp_input+0x1d0>)
    8b34:	4798      	blx	r3
				goto end;
    8b36:	e76b      	b.n	8a10 <udp_input+0x2c>
			if (!broadcast && !ip_addr_ismulticast(&current_iphdr_dest)) {
    8b38:	f1b8 0f00 	cmp.w	r8, #0
    8b3c:	d111      	bne.n	8b62 <udp_input+0x17e>
    8b3e:	4b1e      	ldr	r3, [pc, #120]	; (8bb8 <udp_input+0x1d4>)
    8b40:	681b      	ldr	r3, [r3, #0]
    8b42:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    8b46:	2be0      	cmp	r3, #224	; 0xe0
    8b48:	d00b      	beq.n	8b62 <udp_input+0x17e>
				pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
    8b4a:	7839      	ldrb	r1, [r7, #0]
    8b4c:	f001 010f 	and.w	r1, r1, #15
    8b50:	3102      	adds	r1, #2
    8b52:	0089      	lsls	r1, r1, #2
    8b54:	4620      	mov	r0, r4
    8b56:	4b16      	ldr	r3, [pc, #88]	; (8bb0 <udp_input+0x1cc>)
    8b58:	4798      	blx	r3
				icmp_dest_unreach(p, ICMP_DUR_PORT);
    8b5a:	2103      	movs	r1, #3
    8b5c:	4620      	mov	r0, r4
    8b5e:	4b1b      	ldr	r3, [pc, #108]	; (8bcc <udp_input+0x1e8>)
    8b60:	4798      	blx	r3
			pbuf_free(p);
    8b62:	4620      	mov	r0, r4
    8b64:	4b13      	ldr	r3, [pc, #76]	; (8bb4 <udp_input+0x1d0>)
    8b66:	4798      	blx	r3
    8b68:	e752      	b.n	8a10 <udp_input+0x2c>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    8b6a:	6819      	ldr	r1, [r3, #0]
    8b6c:	458c      	cmp	ip, r1
    8b6e:	d007      	beq.n	8b80 <udp_input+0x19c>
				     && (ip_addr_isany(&pcb->local_ip)
    8b70:	b133      	cbz	r3, 8b80 <udp_input+0x19c>
    8b72:	b129      	cbz	r1, 8b80 <udp_input+0x19c>
				         || ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
    8b74:	ea8c 0701 	eor.w	r7, ip, r1
    8b78:	f8d9 1008 	ldr.w	r1, [r9, #8]
    8b7c:	420f      	tst	r7, r1
    8b7e:	d104      	bne.n	8b8a <udp_input+0x1a6>
					if ((uncon_pcb == NULL) && ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    8b80:	2e00      	cmp	r6, #0
    8b82:	d08c      	beq.n	8a9e <udp_input+0xba>
			if ((local_match != 0) && (pcb->remote_port == src)
    8b84:	8a99      	ldrh	r1, [r3, #20]
    8b86:	42a9      	cmp	r1, r5
    8b88:	d090      	beq.n	8aac <udp_input+0xc8>
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    8b8a:	68d9      	ldr	r1, [r3, #12]
    8b8c:	461a      	mov	r2, r3
    8b8e:	2900      	cmp	r1, #0
    8b90:	d0a2      	beq.n	8ad8 <udp_input+0xf4>
    8b92:	460b      	mov	r3, r1
			if (pcb->local_port == dest) {
    8b94:	8a59      	ldrh	r1, [r3, #18]
    8b96:	4281      	cmp	r1, r0
    8b98:	d1f7      	bne.n	8b8a <udp_input+0x1a6>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    8b9a:	2c00      	cmp	r4, #0
    8b9c:	d1e5      	bne.n	8b6a <udp_input+0x186>
    8b9e:	2b00      	cmp	r3, #0
    8ba0:	d0ee      	beq.n	8b80 <udp_input+0x19c>
    8ba2:	6819      	ldr	r1, [r3, #0]
    8ba4:	2900      	cmp	r1, #0
    8ba6:	d0eb      	beq.n	8b80 <udp_input+0x19c>
    8ba8:	4561      	cmp	r1, ip
    8baa:	d1ee      	bne.n	8b8a <udp_input+0x1a6>
    8bac:	e7e8      	b.n	8b80 <udp_input+0x19c>
    8bae:	bf00      	nop
    8bb0:	00005bf5 	.word	0x00005bf5
    8bb4:	00005c89 	.word	0x00005c89
    8bb8:	20008334 	.word	0x20008334
    8bbc:	00004ef9 	.word	0x00004ef9
    8bc0:	00002eaf 	.word	0x00002eaf
    8bc4:	2000931c 	.word	0x2000931c
    8bc8:	2000832c 	.word	0x2000832c
    8bcc:	000049f9 	.word	0x000049f9
    8bd0:	00004a91 	.word	0x00004a91

00008bd4 <udp_bind>:
 * another UDP PCB.
 *
 * @see udp_disconnect()
 */
err_t udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    8bd4:	b5f0      	push	{r4, r5, r6, r7, lr}
	ip_addr_debug_print(UDP_DEBUG, ipaddr);
	LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %" U16_F ")\n", port));

	rebind = 0;
	/* Check for double bind and rebind of the same pcb */
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    8bd6:	4b34      	ldr	r3, [pc, #208]	; (8ca8 <udp_bind+0xd4>)
    8bd8:	681b      	ldr	r3, [r3, #0]
    8bda:	b1cb      	cbz	r3, 8c10 <udp_bind+0x3c>
    8bdc:	2600      	movs	r6, #0
		/* is this UDP PCB already on active list? */
		if (pcb == ipcb) {
			/* pcb may occur at most once in active list */
			LWIP_ASSERT("rebind == 0", rebind == 0);
			/* pcb already in list, just rebind */
			rebind = 1;
    8bde:	2701      	movs	r7, #1
    8be0:	e002      	b.n	8be8 <udp_bind+0x14>
    8be2:	463e      	mov	r6, r7
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    8be4:	68db      	ldr	r3, [r3, #12]
    8be6:	b1a3      	cbz	r3, 8c12 <udp_bind+0x3e>
		if (pcb == ipcb) {
    8be8:	4298      	cmp	r0, r3
    8bea:	d0fa      	beq.n	8be2 <udp_bind+0xe>
		else if (!ip_get_option(pcb, SOF_REUSEADDR) && !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else  /* SO_REUSE */
		/* port matches that of PCB in list and REUSEADDR not set -> reject */
		else {
#endif /* SO_REUSE */
			if ((ipcb->local_port == port) &&
    8bec:	8a5c      	ldrh	r4, [r3, #18]
    8bee:	4294      	cmp	r4, r2
    8bf0:	d1f8      	bne.n	8be4 <udp_bind+0x10>
    8bf2:	2b00      	cmp	r3, #0
    8bf4:	d04a      	beq.n	8c8c <udp_bind+0xb8>
			    /* IP address matches, or one is IP_ADDR_ANY? */
			    (ip_addr_isany(&(ipcb->local_ip)) || ip_addr_isany(ipaddr) || ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
    8bf6:	681c      	ldr	r4, [r3, #0]
    8bf8:	2c00      	cmp	r4, #0
    8bfa:	d04a      	beq.n	8c92 <udp_bind+0xbe>
    8bfc:	2900      	cmp	r1, #0
    8bfe:	d04b      	beq.n	8c98 <udp_bind+0xc4>
    8c00:	680d      	ldr	r5, [r1, #0]
    8c02:	2d00      	cmp	r5, #0
    8c04:	d04b      	beq.n	8c9e <udp_bind+0xca>
    8c06:	42ac      	cmp	r4, r5
    8c08:	d1ec      	bne.n	8be4 <udp_bind+0x10>
				/* other PCB already binds to this local IP and port */
				LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: local port %" U16_F " already bound by another pcb\n", port));
				return ERR_USE;
    8c0a:	f06f 0007 	mvn.w	r0, #7
    8c0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	rebind = 0;
    8c10:	2600      	movs	r6, #0
			}
		}
	}

	ip_addr_set(&pcb->local_ip, ipaddr);
    8c12:	b159      	cbz	r1, 8c2c <udp_bind+0x58>
    8c14:	680b      	ldr	r3, [r1, #0]
    8c16:	6003      	str	r3, [r0, #0]

	/* no port specified? */
	if (port == 0) {
    8c18:	b152      	cbz	r2, 8c30 <udp_bind+0x5c>
			/* no more ports available in local range */
			LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
			return ERR_USE;
		}
	}
	pcb->local_port = port;
    8c1a:	8242      	strh	r2, [r0, #18]
	snmp_insert_udpidx_tree(pcb);
	/* pcb not active yet? */
	if (rebind == 0) {
    8c1c:	2e00      	cmp	r6, #0
    8c1e:	d141      	bne.n	8ca4 <udp_bind+0xd0>
		/* place the PCB on the active list if not already there */
		pcb->next = udp_pcbs;
    8c20:	4b21      	ldr	r3, [pc, #132]	; (8ca8 <udp_bind+0xd4>)
    8c22:	681a      	ldr	r2, [r3, #0]
    8c24:	60c2      	str	r2, [r0, #12]
		udp_pcbs  = pcb;
    8c26:	6018      	str	r0, [r3, #0]
	             ip4_addr1_16(&pcb->local_ip),
	             ip4_addr2_16(&pcb->local_ip),
	             ip4_addr3_16(&pcb->local_ip),
	             ip4_addr4_16(&pcb->local_ip),
	             pcb->local_port));
	return ERR_OK;
    8c28:	2000      	movs	r0, #0
    8c2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ip_addr_set(&pcb->local_ip, ipaddr);
    8c2c:	2300      	movs	r3, #0
    8c2e:	e7f2      	b.n	8c16 <udp_bind+0x42>
    8c30:	4b1e      	ldr	r3, [pc, #120]	; (8cac <udp_bind+0xd8>)
    8c32:	8819      	ldrh	r1, [r3, #0]
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    8c34:	4b1c      	ldr	r3, [pc, #112]	; (8ca8 <udp_bind+0xd4>)
    8c36:	681c      	ldr	r4, [r3, #0]
    8c38:	f44f 4580 	mov.w	r5, #16384	; 0x4000
	if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    8c3c:	f64f 77ff 	movw	r7, #65535	; 0xffff
		udp_port = UDP_LOCAL_PORT_RANGE_START;
    8c40:	f44f 4e40 	mov.w	lr, #49152	; 0xc000
	if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    8c44:	42b9      	cmp	r1, r7
    8c46:	bf1a      	itte	ne
    8c48:	3101      	addne	r1, #1
    8c4a:	b289      	uxthne	r1, r1
		udp_port = UDP_LOCAL_PORT_RANGE_START;
    8c4c:	4671      	moveq	r1, lr
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    8c4e:	b18c      	cbz	r4, 8c74 <udp_bind+0xa0>
		if (pcb->local_port == udp_port) {
    8c50:	8a63      	ldrh	r3, [r4, #18]
    8c52:	428b      	cmp	r3, r1
    8c54:	d005      	beq.n	8c62 <udp_bind+0x8e>
    8c56:	4623      	mov	r3, r4
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    8c58:	68db      	ldr	r3, [r3, #12]
    8c5a:	b173      	cbz	r3, 8c7a <udp_bind+0xa6>
		if (pcb->local_port == udp_port) {
    8c5c:	8a5a      	ldrh	r2, [r3, #18]
    8c5e:	428a      	cmp	r2, r1
    8c60:	d1fa      	bne.n	8c58 <udp_bind+0x84>
    8c62:	3d01      	subs	r5, #1
    8c64:	b2ad      	uxth	r5, r5
			if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
    8c66:	2d00      	cmp	r5, #0
    8c68:	d1ec      	bne.n	8c44 <udp_bind+0x70>
    8c6a:	4b10      	ldr	r3, [pc, #64]	; (8cac <udp_bind+0xd8>)
    8c6c:	8019      	strh	r1, [r3, #0]
			return ERR_USE;
    8c6e:	f06f 0007 	mvn.w	r0, #7
    8c72:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8c74:	4b0d      	ldr	r3, [pc, #52]	; (8cac <udp_bind+0xd8>)
    8c76:	8019      	strh	r1, [r3, #0]
    8c78:	e001      	b.n	8c7e <udp_bind+0xaa>
    8c7a:	4b0c      	ldr	r3, [pc, #48]	; (8cac <udp_bind+0xd8>)
    8c7c:	8019      	strh	r1, [r3, #0]
	return udp_port;
    8c7e:	4b0b      	ldr	r3, [pc, #44]	; (8cac <udp_bind+0xd8>)
    8c80:	881a      	ldrh	r2, [r3, #0]
		if (port == 0) {
    8c82:	2a00      	cmp	r2, #0
    8c84:	d1c9      	bne.n	8c1a <udp_bind+0x46>
			return ERR_USE;
    8c86:	f06f 0007 	mvn.w	r0, #7
    8c8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
				return ERR_USE;
    8c8c:	f06f 0007 	mvn.w	r0, #7
    8c90:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8c92:	f06f 0007 	mvn.w	r0, #7
    8c96:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8c98:	f06f 0007 	mvn.w	r0, #7
    8c9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8c9e:	f06f 0007 	mvn.w	r0, #7
    8ca2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return ERR_OK;
    8ca4:	2000      	movs	r0, #0
}
    8ca6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8ca8:	2000931c 	.word	0x2000931c
    8cac:	2000000c 	.word	0x2000000c

00008cb0 <udp_sendto_if>:
{
    8cb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8cb4:	b085      	sub	sp, #20
    8cb6:	4604      	mov	r4, r0
    8cb8:	460f      	mov	r7, r1
    8cba:	4692      	mov	sl, r2
    8cbc:	469b      	mov	fp, r3
    8cbe:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
	if (pcb->local_port == 0) {
    8cc2:	8a43      	ldrh	r3, [r0, #18]
    8cc4:	b933      	cbnz	r3, 8cd4 <udp_sendto_if+0x24>
		err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    8cc6:	2200      	movs	r2, #0
    8cc8:	4601      	mov	r1, r0
    8cca:	4b35      	ldr	r3, [pc, #212]	; (8da0 <udp_sendto_if+0xf0>)
    8ccc:	4798      	blx	r3
		if (err != ERR_OK) {
    8cce:	4605      	mov	r5, r0
    8cd0:	2800      	cmp	r0, #0
    8cd2:	d13f      	bne.n	8d54 <udp_sendto_if+0xa4>
	if (pbuf_header(p, UDP_HLEN)) {
    8cd4:	2108      	movs	r1, #8
    8cd6:	4638      	mov	r0, r7
    8cd8:	4b32      	ldr	r3, [pc, #200]	; (8da4 <udp_sendto_if+0xf4>)
    8cda:	4798      	blx	r3
    8cdc:	b168      	cbz	r0, 8cfa <udp_sendto_if+0x4a>
		q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    8cde:	2200      	movs	r2, #0
    8ce0:	2108      	movs	r1, #8
    8ce2:	2001      	movs	r0, #1
    8ce4:	4b30      	ldr	r3, [pc, #192]	; (8da8 <udp_sendto_if+0xf8>)
    8ce6:	4798      	blx	r3
		if (q == NULL) {
    8ce8:	4606      	mov	r6, r0
    8cea:	2800      	cmp	r0, #0
    8cec:	d052      	beq.n	8d94 <udp_sendto_if+0xe4>
		if (p->tot_len != 0) {
    8cee:	893b      	ldrh	r3, [r7, #8]
    8cf0:	b123      	cbz	r3, 8cfc <udp_sendto_if+0x4c>
			pbuf_chain(q, p);
    8cf2:	4639      	mov	r1, r7
    8cf4:	4b2d      	ldr	r3, [pc, #180]	; (8dac <udp_sendto_if+0xfc>)
    8cf6:	4798      	blx	r3
    8cf8:	e000      	b.n	8cfc <udp_sendto_if+0x4c>
		q = p;
    8cfa:	463e      	mov	r6, r7
	udphdr       = (struct udp_hdr *)q->payload;
    8cfc:	6875      	ldr	r5, [r6, #4]
	udphdr->src  = htons(pcb->local_port);
    8cfe:	8a60      	ldrh	r0, [r4, #18]
    8d00:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 8db0 <udp_sendto_if+0x100>
    8d04:	47c0      	blx	r8
    8d06:	8028      	strh	r0, [r5, #0]
	udphdr->dest = htons(dst_port);
    8d08:	4658      	mov	r0, fp
    8d0a:	47c0      	blx	r8
    8d0c:	8068      	strh	r0, [r5, #2]
	udphdr->chksum = 0x0000;
    8d0e:	2300      	movs	r3, #0
    8d10:	71ab      	strb	r3, [r5, #6]
    8d12:	71eb      	strb	r3, [r5, #7]
	if (ip_addr_isany(&pcb->local_ip)) {
    8d14:	46a0      	mov	r8, r4
    8d16:	b10c      	cbz	r4, 8d1c <udp_sendto_if+0x6c>
    8d18:	6823      	ldr	r3, [r4, #0]
    8d1a:	b9fb      	cbnz	r3, 8d5c <udp_sendto_if+0xac>
		src_ip = &(netif->ip_addr);
    8d1c:	f109 0804 	add.w	r8, r9, #4
		udphdr->len = htons(q->tot_len);
    8d20:	8930      	ldrh	r0, [r6, #8]
    8d22:	4b23      	ldr	r3, [pc, #140]	; (8db0 <udp_sendto_if+0x100>)
    8d24:	4798      	blx	r3
    8d26:	80a8      	strh	r0, [r5, #4]
		if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
    8d28:	7c23      	ldrb	r3, [r4, #16]
    8d2a:	f013 0f01 	tst.w	r3, #1
    8d2e:	d021      	beq.n	8d74 <udp_sendto_if+0xc4>
		err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
    8d30:	7aa3      	ldrb	r3, [r4, #10]
    8d32:	f8cd 9008 	str.w	r9, [sp, #8]
    8d36:	2211      	movs	r2, #17
    8d38:	9201      	str	r2, [sp, #4]
    8d3a:	7a62      	ldrb	r2, [r4, #9]
    8d3c:	9200      	str	r2, [sp, #0]
    8d3e:	4652      	mov	r2, sl
    8d40:	4641      	mov	r1, r8
    8d42:	4630      	mov	r0, r6
    8d44:	4c1b      	ldr	r4, [pc, #108]	; (8db4 <udp_sendto_if+0x104>)
    8d46:	47a0      	blx	r4
    8d48:	4605      	mov	r5, r0
	if (q != p) {
    8d4a:	42be      	cmp	r6, r7
    8d4c:	d002      	beq.n	8d54 <udp_sendto_if+0xa4>
		pbuf_free(q);
    8d4e:	4630      	mov	r0, r6
    8d50:	4b19      	ldr	r3, [pc, #100]	; (8db8 <udp_sendto_if+0x108>)
    8d52:	4798      	blx	r3
}
    8d54:	4628      	mov	r0, r5
    8d56:	b005      	add	sp, #20
    8d58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
    8d5c:	f8d9 2004 	ldr.w	r2, [r9, #4]
    8d60:	4293      	cmp	r3, r2
    8d62:	d0dd      	beq.n	8d20 <udp_sendto_if+0x70>
			if (q != p) {
    8d64:	42be      	cmp	r6, r7
    8d66:	d018      	beq.n	8d9a <udp_sendto_if+0xea>
				pbuf_free(q);
    8d68:	4630      	mov	r0, r6
    8d6a:	4b13      	ldr	r3, [pc, #76]	; (8db8 <udp_sendto_if+0x108>)
    8d6c:	4798      	blx	r3
			return ERR_VAL;
    8d6e:	f06f 0505 	mvn.w	r5, #5
    8d72:	e7ef      	b.n	8d54 <udp_sendto_if+0xa4>
				udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
    8d74:	8933      	ldrh	r3, [r6, #8]
    8d76:	9300      	str	r3, [sp, #0]
    8d78:	2311      	movs	r3, #17
    8d7a:	4652      	mov	r2, sl
    8d7c:	4641      	mov	r1, r8
    8d7e:	4630      	mov	r0, r6
    8d80:	f8df b038 	ldr.w	fp, [pc, #56]	; 8dbc <udp_sendto_if+0x10c>
    8d84:	47d8      	blx	fp
			udphdr->chksum = udpchksum;
    8d86:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8d8a:	2800      	cmp	r0, #0
    8d8c:	bf08      	it	eq
    8d8e:	4618      	moveq	r0, r3
    8d90:	80e8      	strh	r0, [r5, #6]
    8d92:	e7cd      	b.n	8d30 <udp_sendto_if+0x80>
			return ERR_MEM;
    8d94:	f04f 35ff 	mov.w	r5, #4294967295
    8d98:	e7dc      	b.n	8d54 <udp_sendto_if+0xa4>
			return ERR_VAL;
    8d9a:	f06f 0505 	mvn.w	r5, #5
    8d9e:	e7d9      	b.n	8d54 <udp_sendto_if+0xa4>
    8da0:	00008bd5 	.word	0x00008bd5
    8da4:	00005bf5 	.word	0x00005bf5
    8da8:	00005cf1 	.word	0x00005cf1
    8dac:	00005efd 	.word	0x00005efd
    8db0:	00002ea5 	.word	0x00002ea5
    8db4:	00004dbd 	.word	0x00004dbd
    8db8:	00005c89 	.word	0x00005c89
    8dbc:	00004a91 	.word	0x00004a91

00008dc0 <udp_sendto>:
{
    8dc0:	b5f0      	push	{r4, r5, r6, r7, lr}
    8dc2:	b083      	sub	sp, #12
    8dc4:	4605      	mov	r5, r0
    8dc6:	460e      	mov	r6, r1
    8dc8:	4614      	mov	r4, r2
    8dca:	461f      	mov	r7, r3
	netif = ip_route(dst_ip);
    8dcc:	4610      	mov	r0, r2
    8dce:	4b07      	ldr	r3, [pc, #28]	; (8dec <udp_sendto+0x2c>)
    8dd0:	4798      	blx	r3
	if (netif == NULL) {
    8dd2:	b140      	cbz	r0, 8de6 <udp_sendto+0x26>
	return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
    8dd4:	9000      	str	r0, [sp, #0]
    8dd6:	463b      	mov	r3, r7
    8dd8:	4622      	mov	r2, r4
    8dda:	4631      	mov	r1, r6
    8ddc:	4628      	mov	r0, r5
    8dde:	4c04      	ldr	r4, [pc, #16]	; (8df0 <udp_sendto+0x30>)
    8de0:	47a0      	blx	r4
}
    8de2:	b003      	add	sp, #12
    8de4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_RTE;
    8de6:	f06f 0003 	mvn.w	r0, #3
    8dea:	e7fa      	b.n	8de2 <udp_sendto+0x22>
    8dec:	00004b8d 	.word	0x00004b8d
    8df0:	00008cb1 	.word	0x00008cb1

00008df4 <udp_connect>:
 * The udp pcb is bound to a random local port if not already bound.
 *
 * @see udp_disconnect()
 */
err_t udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    8df4:	b570      	push	{r4, r5, r6, lr}
    8df6:	4604      	mov	r4, r0
    8df8:	460d      	mov	r5, r1
    8dfa:	4616      	mov	r6, r2
	struct udp_pcb *ipcb;

	if (pcb->local_port == 0) {
    8dfc:	8a43      	ldrh	r3, [r0, #18]
    8dfe:	b19b      	cbz	r3, 8e28 <udp_connect+0x34>
		if (err != ERR_OK) {
			return err;
		}
	}

	ip_addr_set(&pcb->remote_ip, ipaddr);
    8e00:	b1d5      	cbz	r5, 8e38 <udp_connect+0x44>
    8e02:	682b      	ldr	r3, [r5, #0]
    8e04:	6063      	str	r3, [r4, #4]
	pcb->remote_port = port;
    8e06:	82a6      	strh	r6, [r4, #20]
	pcb->flags |= UDP_FLAGS_CONNECTED;
    8e08:	7c23      	ldrb	r3, [r4, #16]
    8e0a:	f043 0304 	orr.w	r3, r3, #4
    8e0e:	7423      	strb	r3, [r4, #16]
	             ip4_addr3_16(&pcb->local_ip),
	             ip4_addr4_16(&pcb->local_ip),
	             pcb->local_port));

	/* Insert UDP PCB into the list of active UDP PCBs. */
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    8e10:	4b0e      	ldr	r3, [pc, #56]	; (8e4c <udp_connect+0x58>)
    8e12:	681a      	ldr	r2, [r3, #0]
    8e14:	b192      	cbz	r2, 8e3c <udp_connect+0x48>
		if (pcb == ipcb) {
    8e16:	4294      	cmp	r4, r2
    8e18:	d016      	beq.n	8e48 <udp_connect+0x54>
    8e1a:	4613      	mov	r3, r2
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    8e1c:	68db      	ldr	r3, [r3, #12]
    8e1e:	b16b      	cbz	r3, 8e3c <udp_connect+0x48>
		if (pcb == ipcb) {
    8e20:	429c      	cmp	r4, r3
    8e22:	d1fb      	bne.n	8e1c <udp_connect+0x28>
			/* already on the list, just return */
			return ERR_OK;
    8e24:	2300      	movs	r3, #0
    8e26:	e00d      	b.n	8e44 <udp_connect+0x50>
		err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    8e28:	2200      	movs	r2, #0
    8e2a:	4601      	mov	r1, r0
    8e2c:	4b08      	ldr	r3, [pc, #32]	; (8e50 <udp_connect+0x5c>)
    8e2e:	4798      	blx	r3
		if (err != ERR_OK) {
    8e30:	4603      	mov	r3, r0
    8e32:	2800      	cmp	r0, #0
    8e34:	d0e4      	beq.n	8e00 <udp_connect+0xc>
    8e36:	e005      	b.n	8e44 <udp_connect+0x50>
	ip_addr_set(&pcb->remote_ip, ipaddr);
    8e38:	2300      	movs	r3, #0
    8e3a:	e7e3      	b.n	8e04 <udp_connect+0x10>
		}
	}
	/* PCB not yet on the list, add PCB now */
	pcb->next = udp_pcbs;
    8e3c:	60e2      	str	r2, [r4, #12]
	udp_pcbs  = pcb;
    8e3e:	4b03      	ldr	r3, [pc, #12]	; (8e4c <udp_connect+0x58>)
    8e40:	601c      	str	r4, [r3, #0]
	return ERR_OK;
    8e42:	2300      	movs	r3, #0
}
    8e44:	4618      	mov	r0, r3
    8e46:	bd70      	pop	{r4, r5, r6, pc}
			return ERR_OK;
    8e48:	2300      	movs	r3, #0
    8e4a:	e7fb      	b.n	8e44 <udp_connect+0x50>
    8e4c:	2000931c 	.word	0x2000931c
    8e50:	00008bd5 	.word	0x00008bd5

00008e54 <udp_recv>:
 * @param recv_arg additional argument to pass to the callback function
 */
void udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
	/* remember recv() callback and user data */
	pcb->recv     = recv;
    8e54:	6181      	str	r1, [r0, #24]
	pcb->recv_arg = recv_arg;
    8e56:	61c2      	str	r2, [r0, #28]
    8e58:	4770      	bx	lr
	...

00008e5c <udp_remove>:
 * UDP PCB's and the data structure is freed from memory.
 *
 * @see udp_new()
 */
void udp_remove(struct udp_pcb *pcb)
{
    8e5c:	b508      	push	{r3, lr}
    8e5e:	4601      	mov	r1, r0
	struct udp_pcb *pcb2;

	snmp_delete_udpidx_tree(pcb);
	/* pcb to be removed is first in list? */
	if (udp_pcbs == pcb) {
    8e60:	4b0b      	ldr	r3, [pc, #44]	; (8e90 <udp_remove+0x34>)
    8e62:	681a      	ldr	r2, [r3, #0]
    8e64:	4282      	cmp	r2, r0
    8e66:	d001      	beq.n	8e6c <udp_remove+0x10>
		/* make list start at 2nd pcb */
		udp_pcbs = udp_pcbs->next;
		/* pcb not 1st in list */
	} else {
		for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    8e68:	b942      	cbnz	r2, 8e7c <udp_remove+0x20>
    8e6a:	e002      	b.n	8e72 <udp_remove+0x16>
		udp_pcbs = udp_pcbs->next;
    8e6c:	68d2      	ldr	r2, [r2, #12]
    8e6e:	4b08      	ldr	r3, [pc, #32]	; (8e90 <udp_remove+0x34>)
    8e70:	601a      	str	r2, [r3, #0]
				/* remove pcb from list */
				pcb2->next = pcb->next;
			}
		}
	}
	memp_free(MEMP_UDP_PCB, pcb);
    8e72:	2001      	movs	r0, #1
    8e74:	4b07      	ldr	r3, [pc, #28]	; (8e94 <udp_remove+0x38>)
    8e76:	4798      	blx	r3
    8e78:	bd08      	pop	{r3, pc}
{
    8e7a:	461a      	mov	r2, r3
			if (pcb2->next != NULL && pcb2->next == pcb) {
    8e7c:	68d3      	ldr	r3, [r2, #12]
    8e7e:	2b00      	cmp	r3, #0
    8e80:	d0f7      	beq.n	8e72 <udp_remove+0x16>
    8e82:	4299      	cmp	r1, r3
    8e84:	d1f9      	bne.n	8e7a <udp_remove+0x1e>
				pcb2->next = pcb->next;
    8e86:	68cb      	ldr	r3, [r1, #12]
    8e88:	60d3      	str	r3, [r2, #12]
		for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    8e8a:	2b00      	cmp	r3, #0
    8e8c:	d1f5      	bne.n	8e7a <udp_remove+0x1e>
    8e8e:	e7f0      	b.n	8e72 <udp_remove+0x16>
    8e90:	2000931c 	.word	0x2000931c
    8e94:	000059c1 	.word	0x000059c1

00008e98 <udp_new>:
 * could not be allocated.
 *
 * @see udp_remove()
 */
struct udp_pcb *udp_new(void)
{
    8e98:	b510      	push	{r4, lr}
	struct udp_pcb *pcb;
	pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
    8e9a:	2001      	movs	r0, #1
    8e9c:	4b05      	ldr	r3, [pc, #20]	; (8eb4 <udp_new+0x1c>)
    8e9e:	4798      	blx	r3
	/* could allocate UDP PCB? */
	if (pcb != NULL) {
    8ea0:	4604      	mov	r4, r0
    8ea2:	b128      	cbz	r0, 8eb0 <udp_new+0x18>
		/* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
		 * which means checksum is generated over the whole datagram per default
		 * (recommended as default by RFC 3828). */
		/* initialize PCB to all zeroes */
		memset(pcb, 0, sizeof(struct udp_pcb));
    8ea4:	2220      	movs	r2, #32
    8ea6:	2100      	movs	r1, #0
    8ea8:	4b03      	ldr	r3, [pc, #12]	; (8eb8 <udp_new+0x20>)
    8eaa:	4798      	blx	r3
		pcb->ttl = UDP_TTL;
    8eac:	23ff      	movs	r3, #255	; 0xff
    8eae:	72a3      	strb	r3, [r4, #10]
	}
	return pcb;
}
    8eb0:	4620      	mov	r0, r4
    8eb2:	bd10      	pop	{r4, pc}
    8eb4:	00005979 	.word	0x00005979
    8eb8:	00009fc5 	.word	0x00009fc5

00008ebc <etharp_free_entry>:

#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void etharp_free_entry(int i)
{
    8ebc:	b510      	push	{r4, lr}
    8ebe:	4604      	mov	r4, r0
	/* remove from SNMP ARP index tree */
	snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
	/* and empty packet queue */
	if (arp_table[i].q != NULL) {
    8ec0:	eb00 0280 	add.w	r2, r0, r0, lsl #2
    8ec4:	4b0c      	ldr	r3, [pc, #48]	; (8ef8 <etharp_free_entry+0x3c>)
    8ec6:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    8eca:	b138      	cbz	r0, 8edc <etharp_free_entry+0x20>
		/* remove all queued packets */
		LWIP_DEBUGF(
		    ETHARP_DEBUG,
		    ("etharp_free_entry: freeing entry %" U16_F ", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
		free_etharp_q(arp_table[i].q);
    8ecc:	4b0b      	ldr	r3, [pc, #44]	; (8efc <etharp_free_entry+0x40>)
    8ece:	4798      	blx	r3
		arp_table[i].q = NULL;
    8ed0:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    8ed4:	009b      	lsls	r3, r3, #2
    8ed6:	2100      	movs	r1, #0
    8ed8:	4a07      	ldr	r2, [pc, #28]	; (8ef8 <etharp_free_entry+0x3c>)
    8eda:	50d1      	str	r1, [r2, r3]
	}
	/* recycle entry for re-use */
	arp_table[i].state = ETHARP_STATE_EMPTY;
    8edc:	4906      	ldr	r1, [pc, #24]	; (8ef8 <etharp_free_entry+0x3c>)
    8ede:	00a0      	lsls	r0, r4, #2
    8ee0:	1902      	adds	r2, r0, r4
    8ee2:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    8ee6:	2300      	movs	r3, #0
    8ee8:	7493      	strb	r3, [r2, #18]
#ifdef LWIP_DEBUG
	/* for debugging, clean out the complete entry */
	arp_table[i].ctime = 0;
    8eea:	74d3      	strb	r3, [r2, #19]
	arp_table[i].netif = NULL;
    8eec:	6093      	str	r3, [r2, #8]
	ip_addr_set_zero(&arp_table[i].ipaddr);
    8eee:	6053      	str	r3, [r2, #4]
	arp_table[i].ethaddr = ethzero;
    8ef0:	4614      	mov	r4, r2
    8ef2:	60e3      	str	r3, [r4, #12]
    8ef4:	8223      	strh	r3, [r4, #16]
    8ef6:	bd10      	pop	{r4, pc}
    8ef8:	20007fd8 	.word	0x20007fd8
    8efc:	00005c89 	.word	0x00005c89

00008f00 <etharp_find_entry>:
 *
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
    8f00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8f04:	b083      	sub	sp, #12
    8f06:	4a3c      	ldr	r2, [pc, #240]	; (8ff8 <etharp_find_entry+0xf8>)
    8f08:	2300      	movs	r3, #0
	s8_t empty = ARP_TABLE_SIZE;
	u8_t i = 0, age_pending = 0, age_stable = 0;
	/* oldest entry with packets on queue */
	s8_t old_queue = ARP_TABLE_SIZE;
	/* its age */
	u8_t age_queue = 0;
    8f0a:	4699      	mov	r9, r3
	s8_t old_queue = ARP_TABLE_SIZE;
    8f0c:	f04f 0e0a 	mov.w	lr, #10
	u8_t i = 0, age_pending = 0, age_stable = 0;
    8f10:	469c      	mov	ip, r3
	s8_t empty = ARP_TABLE_SIZE;
    8f12:	4675      	mov	r5, lr
	s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
    8f14:	46f0      	mov	r8, lr
    8f16:	46f2      	mov	sl, lr
    8f18:	9301      	str	r3, [sp, #4]
    8f1a:	e005      	b.n	8f28 <etharp_find_entry+0x28>
	 */

	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
		u8_t state = arp_table[i].state;
		/* no empty entry found yet and now we do find one? */
		if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    8f1c:	b957      	cbnz	r7, 8f34 <etharp_find_entry+0x34>
			LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %" U16_F "\n", (u16_t)i));
			/* remember first empty entry */
			empty = i;
    8f1e:	b25d      	sxtb	r5, r3
    8f20:	3301      	adds	r3, #1
    8f22:	3214      	adds	r2, #20
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    8f24:	2b0a      	cmp	r3, #10
    8f26:	d029      	beq.n	8f7c <etharp_find_entry+0x7c>
    8f28:	4614      	mov	r4, r2
		u8_t state = arp_table[i].state;
    8f2a:	7c97      	ldrb	r7, [r2, #18]
		if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    8f2c:	2d0a      	cmp	r5, #10
    8f2e:	d0f5      	beq.n	8f1c <etharp_find_entry+0x1c>
		} else if (state != ETHARP_STATE_EMPTY) {
    8f30:	2f00      	cmp	r7, #0
    8f32:	d0f5      	beq.n	8f20 <etharp_find_entry+0x20>
			LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
			            state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
			/* if given, does IP address match IP address in ARP entry? */
			if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
    8f34:	b120      	cbz	r0, 8f40 <etharp_find_entry+0x40>
    8f36:	6806      	ldr	r6, [r0, #0]
    8f38:	46b3      	mov	fp, r6
    8f3a:	6866      	ldr	r6, [r4, #4]
    8f3c:	45b3      	cmp	fp, r6
    8f3e:	d00a      	beq.n	8f56 <etharp_find_entry+0x56>
				            ("etharp_find_entry: found matching entry %" U16_F "\n", (u16_t)i));
				/* found exact IP address match, simply bail out */
				return i;
			}
			/* pending entry? */
			if (state == ETHARP_STATE_PENDING) {
    8f40:	2f01      	cmp	r7, #1
    8f42:	d00a      	beq.n	8f5a <etharp_find_entry+0x5a>
						old_pending = i;
						age_pending = arp_table[i].ctime;
					}
				}
				/* stable entry? */
			} else if (state >= ETHARP_STATE_STABLE) {
    8f44:	2f01      	cmp	r7, #1
    8f46:	d9eb      	bls.n	8f20 <etharp_find_entry+0x20>
				/* don't record old_stable for static entries since they never expire */
				if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
				{
					/* remember entry with oldest stable entry in oldest, its age in maxtime */
					if (arp_table[i].ctime >= age_stable) {
    8f48:	7ce4      	ldrb	r4, [r4, #19]
    8f4a:	4564      	cmp	r4, ip
						old_stable = i;
    8f4c:	bf24      	itt	cs
    8f4e:	fa4f f883 	sxtbcs.w	r8, r3
						age_stable = arp_table[i].ctime;
    8f52:	46a4      	movcs	ip, r4
    8f54:	e7e4      	b.n	8f20 <etharp_find_entry+0x20>
				return i;
    8f56:	b258      	sxtb	r0, r3
    8f58:	e029      	b.n	8fae <etharp_find_entry+0xae>
				if (arp_table[i].q != NULL) {
    8f5a:	6827      	ldr	r7, [r4, #0]
    8f5c:	b137      	cbz	r7, 8f6c <etharp_find_entry+0x6c>
					if (arp_table[i].ctime >= age_queue) {
    8f5e:	7ce4      	ldrb	r4, [r4, #19]
    8f60:	454c      	cmp	r4, r9
    8f62:	d3dd      	bcc.n	8f20 <etharp_find_entry+0x20>
						old_queue = i;
    8f64:	fa4f fe83 	sxtb.w	lr, r3
						age_queue = arp_table[i].ctime;
    8f68:	46a1      	mov	r9, r4
    8f6a:	e7d9      	b.n	8f20 <etharp_find_entry+0x20>
					if (arp_table[i].ctime >= age_pending) {
    8f6c:	7ce4      	ldrb	r4, [r4, #19]
    8f6e:	9e01      	ldr	r6, [sp, #4]
    8f70:	42b4      	cmp	r4, r6
    8f72:	d3d5      	bcc.n	8f20 <etharp_find_entry+0x20>
						old_pending = i;
    8f74:	fa4f fa83 	sxtb.w	sl, r3
						age_pending = arp_table[i].ctime;
    8f78:	9401      	str	r4, [sp, #4]
    8f7a:	e7d1      	b.n	8f20 <etharp_find_entry+0x20>
		}
	}
	/* { we have no match } => try to create a new entry */

	/* don't create new entry, only search? */
	if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
    8f7c:	f011 0f02 	tst.w	r1, #2
    8f80:	d130      	bne.n	8fe4 <etharp_find_entry+0xe4>
    8f82:	4604      	mov	r4, r0
    8f84:	2d0a      	cmp	r5, #10
    8f86:	d015      	beq.n	8fb4 <etharp_find_entry+0xb4>
	 *
	 * { ETHARP_FLAG_TRY_HARD is set at this point }
	 */

	/* 1) empty entry available? */
	if (empty < ARP_TABLE_SIZE) {
    8f88:	2d09      	cmp	r5, #9
    8f8a:	dc16      	bgt.n	8fba <etharp_find_entry+0xba>
		i = empty;
    8f8c:	b2ed      	uxtb	r5, r5

	LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
	LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY", arp_table[i].state == ETHARP_STATE_EMPTY);

	/* IP address given? */
	if (ipaddr != NULL) {
    8f8e:	b134      	cbz	r4, 8f9e <etharp_find_entry+0x9e>
		/* set IP address */
		ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
    8f90:	6821      	ldr	r1, [r4, #0]
    8f92:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    8f96:	4a18      	ldr	r2, [pc, #96]	; (8ff8 <etharp_find_entry+0xf8>)
    8f98:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    8f9c:	6059      	str	r1, [r3, #4]
	}
	arp_table[i].ctime = 0;
    8f9e:	eb05 0285 	add.w	r2, r5, r5, lsl #2
    8fa2:	4b15      	ldr	r3, [pc, #84]	; (8ff8 <etharp_find_entry+0xf8>)
    8fa4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    8fa8:	2200      	movs	r2, #0
    8faa:	74da      	strb	r2, [r3, #19]
	return (err_t)i;
    8fac:	b268      	sxtb	r0, r5
}
    8fae:	b003      	add	sp, #12
    8fb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
    8fb4:	f011 0f01 	tst.w	r1, #1
    8fb8:	d017      	beq.n	8fea <etharp_find_entry+0xea>
		if (old_stable < ARP_TABLE_SIZE) {
    8fba:	f1b8 0f09 	cmp.w	r8, #9
    8fbe:	dc05      	bgt.n	8fcc <etharp_find_entry+0xcc>
			i = old_stable;
    8fc0:	fa5f f588 	uxtb.w	r5, r8
		etharp_free_entry(i);
    8fc4:	4628      	mov	r0, r5
    8fc6:	4b0d      	ldr	r3, [pc, #52]	; (8ffc <etharp_find_entry+0xfc>)
    8fc8:	4798      	blx	r3
    8fca:	e7e0      	b.n	8f8e <etharp_find_entry+0x8e>
		} else if (old_pending < ARP_TABLE_SIZE) {
    8fcc:	f1ba 0f09 	cmp.w	sl, #9
    8fd0:	dc02      	bgt.n	8fd8 <etharp_find_entry+0xd8>
			i = old_pending;
    8fd2:	fa5f f58a 	uxtb.w	r5, sl
    8fd6:	e7f5      	b.n	8fc4 <etharp_find_entry+0xc4>
		} else if (old_queue < ARP_TABLE_SIZE) {
    8fd8:	f1be 0f09 	cmp.w	lr, #9
    8fdc:	dc08      	bgt.n	8ff0 <etharp_find_entry+0xf0>
			i = old_queue;
    8fde:	fa5f f58e 	uxtb.w	r5, lr
    8fe2:	e7ef      	b.n	8fc4 <etharp_find_entry+0xc4>
		return (s8_t)ERR_MEM;
    8fe4:	f04f 30ff 	mov.w	r0, #4294967295
    8fe8:	e7e1      	b.n	8fae <etharp_find_entry+0xae>
    8fea:	f04f 30ff 	mov.w	r0, #4294967295
    8fee:	e7de      	b.n	8fae <etharp_find_entry+0xae>
			return (s8_t)ERR_MEM;
    8ff0:	f04f 30ff 	mov.w	r0, #4294967295
    8ff4:	e7db      	b.n	8fae <etharp_find_entry+0xae>
    8ff6:	bf00      	nop
    8ff8:	20007fd8 	.word	0x20007fd8
    8ffc:	00008ebd 	.word	0x00008ebd

00009000 <etharp_send_ip>:
 * @params src the source MAC address to be copied into the ethernet header
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
    9000:	b538      	push	{r3, r4, r5, lr}
	struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    9002:	684c      	ldr	r4, [r1, #4]

	LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
	            (netif->hwaddr_len == ETHARP_HWADDR_LEN));
	ETHADDR32_COPY(&ethhdr->dest, dst);
    9004:	681d      	ldr	r5, [r3, #0]
    9006:	6025      	str	r5, [r4, #0]
    9008:	889b      	ldrh	r3, [r3, #4]
    900a:	80a3      	strh	r3, [r4, #4]
	ETHADDR16_COPY(&ethhdr->src, src);
    900c:	6813      	ldr	r3, [r2, #0]
    900e:	f8c4 3006 	str.w	r3, [r4, #6]
    9012:	8893      	ldrh	r3, [r2, #4]
    9014:	8163      	strh	r3, [r4, #10]
	ethhdr->type = PP_HTONS(ETHTYPE_IP);
    9016:	2308      	movs	r3, #8
    9018:	7323      	strb	r3, [r4, #12]
    901a:	2300      	movs	r3, #0
    901c:	7363      	strb	r3, [r4, #13]
	LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
	/* send the packet */
	return netif->linkoutput(netif, p);
    901e:	6983      	ldr	r3, [r0, #24]
    9020:	4798      	blx	r3
}
    9022:	bd38      	pop	{r3, r4, r5, pc}

00009024 <etharp_tmr>:
{
    9024:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9026:	4c0e      	ldr	r4, [pc, #56]	; (9060 <etharp_tmr+0x3c>)
    9028:	2500      	movs	r5, #0
				etharp_free_entry(i);
    902a:	4e0e      	ldr	r6, [pc, #56]	; (9064 <etharp_tmr+0x40>)
				arp_table[i].state = ETHARP_STATE_STABLE;
    902c:	2702      	movs	r7, #2
    902e:	e006      	b.n	903e <etharp_tmr+0x1a>
			} else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
    9030:	2a03      	cmp	r2, #3
				arp_table[i].state = ETHARP_STATE_STABLE;
    9032:	bf08      	it	eq
    9034:	74a7      	strbeq	r7, [r4, #18]
    9036:	3501      	adds	r5, #1
    9038:	3414      	adds	r4, #20
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    903a:	2d0a      	cmp	r5, #10
    903c:	d00f      	beq.n	905e <etharp_tmr+0x3a>
		u8_t state = arp_table[i].state;
    903e:	4628      	mov	r0, r5
    9040:	7ca2      	ldrb	r2, [r4, #18]
		if (state != ETHARP_STATE_EMPTY
    9042:	2a00      	cmp	r2, #0
    9044:	d0f7      	beq.n	9036 <etharp_tmr+0x12>
			arp_table[i].ctime++;
    9046:	7ce3      	ldrb	r3, [r4, #19]
    9048:	3301      	adds	r3, #1
    904a:	b2db      	uxtb	r3, r3
    904c:	74e3      	strb	r3, [r4, #19]
			if ((arp_table[i].ctime >= ARP_MAXAGE)
    904e:	2bef      	cmp	r3, #239	; 0xef
    9050:	d803      	bhi.n	905a <etharp_tmr+0x36>
			    || ((arp_table[i].state == ETHARP_STATE_PENDING) && (arp_table[i].ctime >= ARP_MAXPENDING))) {
    9052:	2a01      	cmp	r2, #1
    9054:	d1ec      	bne.n	9030 <etharp_tmr+0xc>
    9056:	2b01      	cmp	r3, #1
    9058:	d9ed      	bls.n	9036 <etharp_tmr+0x12>
				etharp_free_entry(i);
    905a:	47b0      	blx	r6
    905c:	e7eb      	b.n	9036 <etharp_tmr+0x12>
}
    905e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9060:	20007fd8 	.word	0x20007fd8
    9064:	00008ebd 	.word	0x00008ebd

00009068 <etharp_cleanup_netif>:
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
    9068:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    906a:	4606      	mov	r6, r0
    906c:	4d08      	ldr	r5, [pc, #32]	; (9090 <etharp_cleanup_netif+0x28>)
    906e:	2400      	movs	r4, #0
	u8_t i;

	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
		u8_t state = arp_table[i].state;
		if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
			etharp_free_entry(i);
    9070:	4f08      	ldr	r7, [pc, #32]	; (9094 <etharp_cleanup_netif+0x2c>)
    9072:	e003      	b.n	907c <etharp_cleanup_netif+0x14>
    9074:	3401      	adds	r4, #1
    9076:	3514      	adds	r5, #20
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    9078:	2c0a      	cmp	r4, #10
    907a:	d008      	beq.n	908e <etharp_cleanup_netif+0x26>
		u8_t state = arp_table[i].state;
    907c:	4620      	mov	r0, r4
		if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
    907e:	7cab      	ldrb	r3, [r5, #18]
    9080:	2b00      	cmp	r3, #0
    9082:	d0f7      	beq.n	9074 <etharp_cleanup_netif+0xc>
    9084:	68ab      	ldr	r3, [r5, #8]
    9086:	42b3      	cmp	r3, r6
    9088:	d1f4      	bne.n	9074 <etharp_cleanup_netif+0xc>
			etharp_free_entry(i);
    908a:	47b8      	blx	r7
    908c:	e7f2      	b.n	9074 <etharp_cleanup_netif+0xc>
		}
	}
}
    908e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9090:	20007fd8 	.word	0x20007fd8
    9094:	00008ebd 	.word	0x00008ebd

00009098 <etharp_request>:
 * @return ERR_OK if the request has been sent
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
    9098:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    909c:	4605      	mov	r5, r0
    909e:	4688      	mov	r8, r1
	p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
    90a0:	2200      	movs	r2, #0
    90a2:	212a      	movs	r1, #42	; 0x2a
    90a4:	2003      	movs	r0, #3
    90a6:	4b21      	ldr	r3, [pc, #132]	; (912c <etharp_request+0x94>)
    90a8:	4798      	blx	r3
	if (p == NULL) {
    90aa:	2800      	cmp	r0, #0
    90ac:	d03b      	beq.n	9126 <etharp_request+0x8e>
    90ae:	4607      	mov	r7, r0
	ethhdr = (struct eth_hdr *)p->payload;
    90b0:	6844      	ldr	r4, [r0, #4]
	hdr->opcode = htons(opcode);
    90b2:	2001      	movs	r0, #1
    90b4:	4b1e      	ldr	r3, [pc, #120]	; (9130 <etharp_request+0x98>)
    90b6:	4798      	blx	r3
    90b8:	82a0      	strh	r0, [r4, #20]
	ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    90ba:	f8d5 302f 	ldr.w	r3, [r5, #47]	; 0x2f
    90be:	f8c4 3016 	str.w	r3, [r4, #22]
    90c2:	f8b5 3033 	ldrh.w	r3, [r5, #51]	; 0x33
    90c6:	8363      	strh	r3, [r4, #26]
	ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    90c8:	4b1a      	ldr	r3, [pc, #104]	; (9134 <etharp_request+0x9c>)
    90ca:	6818      	ldr	r0, [r3, #0]
    90cc:	6220      	str	r0, [r4, #32]
    90ce:	889a      	ldrh	r2, [r3, #4]
    90d0:	84a2      	strh	r2, [r4, #36]	; 0x24
	ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    90d2:	6898      	ldr	r0, [r3, #8]
    90d4:	6020      	str	r0, [r4, #0]
    90d6:	899b      	ldrh	r3, [r3, #12]
    90d8:	80a3      	strh	r3, [r4, #4]
	ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
    90da:	f8d5 302f 	ldr.w	r3, [r5, #47]	; 0x2f
    90de:	f8c4 3006 	str.w	r3, [r4, #6]
    90e2:	f8b5 3033 	ldrh.w	r3, [r5, #51]	; 0x33
    90e6:	8163      	strh	r3, [r4, #10]
	IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
    90e8:	686b      	ldr	r3, [r5, #4]
    90ea:	61e3      	str	r3, [r4, #28]
	IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
    90ec:	f8d8 3000 	ldr.w	r3, [r8]
    90f0:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
	hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    90f4:	2200      	movs	r2, #0
    90f6:	73a2      	strb	r2, [r4, #14]
    90f8:	2301      	movs	r3, #1
    90fa:	73e3      	strb	r3, [r4, #15]
	hdr->proto  = PP_HTONS(ETHTYPE_IP);
    90fc:	2308      	movs	r3, #8
    90fe:	7423      	strb	r3, [r4, #16]
    9100:	7462      	strb	r2, [r4, #17]
	hdr->hwlen    = ETHARP_HWADDR_LEN;
    9102:	2206      	movs	r2, #6
    9104:	74a2      	strb	r2, [r4, #18]
	hdr->protolen = sizeof(ip_addr_t);
    9106:	2204      	movs	r2, #4
    9108:	74e2      	strb	r2, [r4, #19]
	ethhdr->type = PP_HTONS(ETHTYPE_ARP);
    910a:	7323      	strb	r3, [r4, #12]
    910c:	2306      	movs	r3, #6
    910e:	7363      	strb	r3, [r4, #13]
	result = netif->linkoutput(netif, p);
    9110:	69ab      	ldr	r3, [r5, #24]
    9112:	4639      	mov	r1, r7
    9114:	4628      	mov	r0, r5
    9116:	4798      	blx	r3
    9118:	4604      	mov	r4, r0
	pbuf_free(p);
    911a:	4638      	mov	r0, r7
    911c:	4b06      	ldr	r3, [pc, #24]	; (9138 <etharp_request+0xa0>)
    911e:	4798      	blx	r3
	                  (struct eth_addr *)netif->hwaddr,
	                  &netif->ip_addr,
	                  &ethzero,
	                  ipaddr,
	                  ARP_REQUEST);
}
    9120:	4620      	mov	r0, r4
    9122:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_MEM;
    9126:	f04f 34ff 	mov.w	r4, #4294967295
    912a:	e7f9      	b.n	9120 <etharp_request+0x88>
    912c:	00005cf1 	.word	0x00005cf1
    9130:	00002ea5 	.word	0x00002ea5
    9134:	0000c5d8 	.word	0x0000c5d8
    9138:	00005c89 	.word	0x00005c89

0000913c <etharp_output_to_arp_index>:
{
    913c:	b570      	push	{r4, r5, r6, lr}
    913e:	4605      	mov	r5, r0
    9140:	460e      	mov	r6, r1
    9142:	4614      	mov	r4, r2
	if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    9144:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    9148:	4b15      	ldr	r3, [pc, #84]	; (91a0 <etharp_output_to_arp_index+0x64>)
    914a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    914e:	7c9b      	ldrb	r3, [r3, #18]
    9150:	2b02      	cmp	r3, #2
    9152:	d00c      	beq.n	916e <etharp_output_to_arp_index+0x32>
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr);
    9154:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    9158:	4b11      	ldr	r3, [pc, #68]	; (91a0 <etharp_output_to_arp_index+0x64>)
    915a:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    915e:	330c      	adds	r3, #12
    9160:	f105 022f 	add.w	r2, r5, #47	; 0x2f
    9164:	4631      	mov	r1, r6
    9166:	4628      	mov	r0, r5
    9168:	4c0e      	ldr	r4, [pc, #56]	; (91a4 <etharp_output_to_arp_index+0x68>)
    916a:	47a0      	blx	r4
}
    916c:	bd70      	pop	{r4, r5, r6, pc}
	if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    916e:	4613      	mov	r3, r2
    9170:	4a0b      	ldr	r2, [pc, #44]	; (91a0 <etharp_output_to_arp_index+0x64>)
    9172:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    9176:	7cdb      	ldrb	r3, [r3, #19]
    9178:	2be3      	cmp	r3, #227	; 0xe3
    917a:	d9eb      	bls.n	9154 <etharp_output_to_arp_index+0x18>
		if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
    917c:	eb04 0184 	add.w	r1, r4, r4, lsl #2
    9180:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    9184:	3104      	adds	r1, #4
    9186:	4b08      	ldr	r3, [pc, #32]	; (91a8 <etharp_output_to_arp_index+0x6c>)
    9188:	4798      	blx	r3
    918a:	2800      	cmp	r0, #0
    918c:	d1e2      	bne.n	9154 <etharp_output_to_arp_index+0x18>
			arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    918e:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    9192:	4a03      	ldr	r2, [pc, #12]	; (91a0 <etharp_output_to_arp_index+0x64>)
    9194:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    9198:	2203      	movs	r2, #3
    919a:	749a      	strb	r2, [r3, #18]
    919c:	e7da      	b.n	9154 <etharp_output_to_arp_index+0x18>
    919e:	bf00      	nop
    91a0:	20007fd8 	.word	0x20007fd8
    91a4:	00009001 	.word	0x00009001
    91a8:	00009099 	.word	0x00009099

000091ac <etharp_query>:
{
    91ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    91b0:	4680      	mov	r8, r0
    91b2:	460d      	mov	r5, r1
    91b4:	4616      	mov	r6, r2
	if (ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr) || ip_addr_isany(ipaddr)) {
    91b6:	4601      	mov	r1, r0
    91b8:	6828      	ldr	r0, [r5, #0]
    91ba:	4b49      	ldr	r3, [pc, #292]	; (92e0 <etharp_query+0x134>)
    91bc:	4798      	blx	r3
    91be:	2800      	cmp	r0, #0
    91c0:	d161      	bne.n	9286 <etharp_query+0xda>
    91c2:	682b      	ldr	r3, [r5, #0]
    91c4:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    91c8:	2ae0      	cmp	r2, #224	; 0xe0
    91ca:	d05f      	beq.n	928c <etharp_query+0xe0>
    91cc:	2d00      	cmp	r5, #0
    91ce:	d060      	beq.n	9292 <etharp_query+0xe6>
    91d0:	2b00      	cmp	r3, #0
    91d2:	d061      	beq.n	9298 <etharp_query+0xec>
	i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
    91d4:	2101      	movs	r1, #1
    91d6:	4628      	mov	r0, r5
    91d8:	4b42      	ldr	r3, [pc, #264]	; (92e4 <etharp_query+0x138>)
    91da:	4798      	blx	r3
	if (i < 0) {
    91dc:	1e04      	subs	r4, r0, #0
    91de:	db49      	blt.n	9274 <etharp_query+0xc8>
	if (arp_table[i].state == ETHARP_STATE_EMPTY) {
    91e0:	4627      	mov	r7, r4
    91e2:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    91e6:	4a40      	ldr	r2, [pc, #256]	; (92e8 <etharp_query+0x13c>)
    91e8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    91ec:	7c9b      	ldrb	r3, [r3, #18]
    91ee:	bb6b      	cbnz	r3, 924c <etharp_query+0xa0>
		arp_table[i].state = ETHARP_STATE_PENDING;
    91f0:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    91f4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    91f8:	2201      	movs	r2, #1
    91fa:	749a      	strb	r2, [r3, #18]
		result = etharp_request(netif, ipaddr);
    91fc:	4629      	mov	r1, r5
    91fe:	4640      	mov	r0, r8
    9200:	4b3a      	ldr	r3, [pc, #232]	; (92ec <etharp_query+0x140>)
    9202:	4798      	blx	r3
		if (q == NULL) {
    9204:	2e00      	cmp	r6, #0
    9206:	d04a      	beq.n	929e <etharp_query+0xf2>
	if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    9208:	eb07 0387 	add.w	r3, r7, r7, lsl #2
    920c:	4a36      	ldr	r2, [pc, #216]	; (92e8 <etharp_query+0x13c>)
    920e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    9212:	7c9b      	ldrb	r3, [r3, #18]
    9214:	2b01      	cmp	r3, #1
    9216:	d81e      	bhi.n	9256 <etharp_query+0xaa>
	} else if (arp_table[i].state == ETHARP_STATE_PENDING) {
    9218:	2b01      	cmp	r3, #1
    921a:	d142      	bne.n	92a2 <etharp_query+0xf6>
			if (p->type != PBUF_ROM) {
    921c:	7b33      	ldrb	r3, [r6, #12]
    921e:	2b01      	cmp	r3, #1
    9220:	d15c      	bne.n	92dc <etharp_query+0x130>
    9222:	4633      	mov	r3, r6
			p = p->next;
    9224:	681b      	ldr	r3, [r3, #0]
		while (p) {
    9226:	2b00      	cmp	r3, #0
    9228:	d046      	beq.n	92b8 <etharp_query+0x10c>
			if (p->type != PBUF_ROM) {
    922a:	7b1a      	ldrb	r2, [r3, #12]
    922c:	2a01      	cmp	r2, #1
    922e:	d0f9      	beq.n	9224 <etharp_query+0x78>
			p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    9230:	2200      	movs	r2, #0
    9232:	8919      	ldrh	r1, [r3, #8]
    9234:	2003      	movs	r0, #3
    9236:	4b2e      	ldr	r3, [pc, #184]	; (92f0 <etharp_query+0x144>)
    9238:	4798      	blx	r3
			if (p != NULL) {
    923a:	4604      	mov	r4, r0
    923c:	b300      	cbz	r0, 9280 <etharp_query+0xd4>
				if (pbuf_copy(p, q) != ERR_OK) {
    923e:	4631      	mov	r1, r6
    9240:	4620      	mov	r0, r4
    9242:	4b2c      	ldr	r3, [pc, #176]	; (92f4 <etharp_query+0x148>)
    9244:	4798      	blx	r3
    9246:	b9c0      	cbnz	r0, 927a <etharp_query+0xce>
			p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    9248:	4626      	mov	r6, r4
    924a:	e038      	b.n	92be <etharp_query+0x112>
	if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    924c:	2b01      	cmp	r3, #1
    924e:	d0d5      	beq.n	91fc <etharp_query+0x50>
    9250:	b34e      	cbz	r6, 92a6 <etharp_query+0xfa>
	if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    9252:	2b01      	cmp	r3, #1
    9254:	d92d      	bls.n	92b2 <etharp_query+0x106>
		ETHARP_SET_HINT(netif, i);
    9256:	4b24      	ldr	r3, [pc, #144]	; (92e8 <etharp_query+0x13c>)
    9258:	f883 40c8 	strb.w	r4, [r3, #200]	; 0xc8
		result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    925c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    9260:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    9264:	330c      	adds	r3, #12
    9266:	f108 022f 	add.w	r2, r8, #47	; 0x2f
    926a:	4631      	mov	r1, r6
    926c:	4640      	mov	r0, r8
    926e:	4c22      	ldr	r4, [pc, #136]	; (92f8 <etharp_query+0x14c>)
    9270:	47a0      	blx	r4
    9272:	4604      	mov	r4, r0
}
    9274:	4620      	mov	r0, r4
    9276:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					pbuf_free(p);
    927a:	4620      	mov	r0, r4
    927c:	4b1f      	ldr	r3, [pc, #124]	; (92fc <etharp_query+0x150>)
    927e:	4798      	blx	r3
			result = ERR_MEM;
    9280:	f04f 34ff 	mov.w	r4, #4294967295
    9284:	e7f6      	b.n	9274 <etharp_query+0xc8>
		return ERR_ARG;
    9286:	f06f 040d 	mvn.w	r4, #13
    928a:	e7f3      	b.n	9274 <etharp_query+0xc8>
    928c:	f06f 040d 	mvn.w	r4, #13
    9290:	e7f0      	b.n	9274 <etharp_query+0xc8>
    9292:	f06f 040d 	mvn.w	r4, #13
    9296:	e7ed      	b.n	9274 <etharp_query+0xc8>
    9298:	f06f 040d 	mvn.w	r4, #13
    929c:	e7ea      	b.n	9274 <etharp_query+0xc8>
		result = etharp_request(netif, ipaddr);
    929e:	4604      	mov	r4, r0
    92a0:	e7e8      	b.n	9274 <etharp_query+0xc8>
    92a2:	4604      	mov	r4, r0
    92a4:	e7e6      	b.n	9274 <etharp_query+0xc8>
    92a6:	4629      	mov	r1, r5
    92a8:	4640      	mov	r0, r8
    92aa:	4b10      	ldr	r3, [pc, #64]	; (92ec <etharp_query+0x140>)
    92ac:	4798      	blx	r3
    92ae:	4604      	mov	r4, r0
    92b0:	e7e0      	b.n	9274 <etharp_query+0xc8>
	err_t            result  = ERR_MEM;
    92b2:	f04f 34ff 	mov.w	r4, #4294967295
    92b6:	e7dd      	b.n	9274 <etharp_query+0xc8>
			pbuf_ref(p);
    92b8:	4630      	mov	r0, r6
    92ba:	4b11      	ldr	r3, [pc, #68]	; (9300 <etharp_query+0x154>)
    92bc:	4798      	blx	r3
			if (arp_table[i].q != NULL) {
    92be:	eb07 0387 	add.w	r3, r7, r7, lsl #2
    92c2:	4a09      	ldr	r2, [pc, #36]	; (92e8 <etharp_query+0x13c>)
    92c4:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    92c8:	b108      	cbz	r0, 92ce <etharp_query+0x122>
				pbuf_free(arp_table[i].q);
    92ca:	4b0c      	ldr	r3, [pc, #48]	; (92fc <etharp_query+0x150>)
    92cc:	4798      	blx	r3
			arp_table[i].q = p;
    92ce:	eb07 0787 	add.w	r7, r7, r7, lsl #2
    92d2:	4b05      	ldr	r3, [pc, #20]	; (92e8 <etharp_query+0x13c>)
    92d4:	f843 6027 	str.w	r6, [r3, r7, lsl #2]
			result = ERR_OK;
    92d8:	2400      	movs	r4, #0
    92da:	e7cb      	b.n	9274 <etharp_query+0xc8>
			if (p->type != PBUF_ROM) {
    92dc:	4633      	mov	r3, r6
    92de:	e7a7      	b.n	9230 <etharp_query+0x84>
    92e0:	00004ef9 	.word	0x00004ef9
    92e4:	00008f01 	.word	0x00008f01
    92e8:	20007fd8 	.word	0x20007fd8
    92ec:	00009099 	.word	0x00009099
    92f0:	00005cf1 	.word	0x00005cf1
    92f4:	00005f15 	.word	0x00005f15
    92f8:	00009001 	.word	0x00009001
    92fc:	00005c89 	.word	0x00005c89
    9300:	00005ea3 	.word	0x00005ea3

00009304 <etharp_output>:
{
    9304:	b570      	push	{r4, r5, r6, lr}
    9306:	b082      	sub	sp, #8
    9308:	4605      	mov	r5, r0
    930a:	460e      	mov	r6, r1
    930c:	4614      	mov	r4, r2
	if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    930e:	210e      	movs	r1, #14
    9310:	4630      	mov	r0, r6
    9312:	4b3d      	ldr	r3, [pc, #244]	; (9408 <etharp_output+0x104>)
    9314:	4798      	blx	r3
    9316:	2800      	cmp	r0, #0
    9318:	d16d      	bne.n	93f6 <etharp_output+0xf2>
	if (ip_addr_isbroadcast(ipaddr, netif)) {
    931a:	4629      	mov	r1, r5
    931c:	6820      	ldr	r0, [r4, #0]
    931e:	4b3b      	ldr	r3, [pc, #236]	; (940c <etharp_output+0x108>)
    9320:	4798      	blx	r3
    9322:	2800      	cmp	r0, #0
    9324:	d15e      	bne.n	93e4 <etharp_output+0xe0>
	} else if (ip_addr_ismulticast(ipaddr)) {
    9326:	6823      	ldr	r3, [r4, #0]
    9328:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    932c:	2ae0      	cmp	r2, #224	; 0xe0
    932e:	d024      	beq.n	937a <etharp_output+0x76>
		if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) && !ip_addr_islinklocal(ipaddr)) {
    9330:	686a      	ldr	r2, [r5, #4]
    9332:	405a      	eors	r2, r3
    9334:	68a9      	ldr	r1, [r5, #8]
    9336:	420a      	tst	r2, r1
    9338:	d00a      	beq.n	9350 <etharp_output+0x4c>
    933a:	b29b      	uxth	r3, r3
    933c:	f64f 62a9 	movw	r2, #65193	; 0xfea9
    9340:	4293      	cmp	r3, r2
    9342:	d005      	beq.n	9350 <etharp_output+0x4c>
				if (!ip_addr_isany(&netif->gw)) {
    9344:	f115 040c 	adds.w	r4, r5, #12
    9348:	d058      	beq.n	93fc <etharp_output+0xf8>
    934a:	68eb      	ldr	r3, [r5, #12]
    934c:	2b00      	cmp	r3, #0
    934e:	d058      	beq.n	9402 <etharp_output+0xfe>
				if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE)
    9350:	4b2f      	ldr	r3, [pc, #188]	; (9410 <etharp_output+0x10c>)
    9352:	f893 20c8 	ldrb.w	r2, [r3, #200]	; 0xc8
    9356:	eb02 0182 	add.w	r1, r2, r2, lsl #2
    935a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    935e:	7c9b      	ldrb	r3, [r3, #18]
    9360:	2b01      	cmp	r3, #1
    9362:	d907      	bls.n	9374 <etharp_output+0x70>
				    && (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
    9364:	460b      	mov	r3, r1
    9366:	492a      	ldr	r1, [pc, #168]	; (9410 <etharp_output+0x10c>)
    9368:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    936c:	6821      	ldr	r1, [r4, #0]
    936e:	685b      	ldr	r3, [r3, #4]
    9370:	4299      	cmp	r1, r3
    9372:	d018      	beq.n	93a6 <etharp_output+0xa2>
    9374:	4b26      	ldr	r3, [pc, #152]	; (9410 <etharp_output+0x10c>)
{
    9376:	2200      	movs	r2, #0
    9378:	e01e      	b.n	93b8 <etharp_output+0xb4>
		mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    937a:	2301      	movs	r3, #1
    937c:	f88d 3000 	strb.w	r3, [sp]
		mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    9380:	2300      	movs	r3, #0
    9382:	f88d 3001 	strb.w	r3, [sp, #1]
		mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    9386:	235e      	movs	r3, #94	; 0x5e
    9388:	f88d 3002 	strb.w	r3, [sp, #2]
		mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    938c:	7863      	ldrb	r3, [r4, #1]
    938e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    9392:	f88d 3003 	strb.w	r3, [sp, #3]
		mcastaddr.addr[4] = ip4_addr3(ipaddr);
    9396:	78a3      	ldrb	r3, [r4, #2]
    9398:	f88d 3004 	strb.w	r3, [sp, #4]
		mcastaddr.addr[5] = ip4_addr4(ipaddr);
    939c:	78e3      	ldrb	r3, [r4, #3]
    939e:	f88d 3005 	strb.w	r3, [sp, #5]
		dest = &mcastaddr;
    93a2:	466b      	mov	r3, sp
    93a4:	e01f      	b.n	93e6 <etharp_output+0xe2>
					return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
    93a6:	4631      	mov	r1, r6
    93a8:	4628      	mov	r0, r5
    93aa:	4b1a      	ldr	r3, [pc, #104]	; (9414 <etharp_output+0x110>)
    93ac:	4798      	blx	r3
    93ae:	e020      	b.n	93f2 <etharp_output+0xee>
    93b0:	3201      	adds	r2, #1
    93b2:	3314      	adds	r3, #20
		for (i = 0; i < ARP_TABLE_SIZE; i++) {
    93b4:	2a0a      	cmp	r2, #10
    93b6:	d00f      	beq.n	93d8 <etharp_output+0xd4>
			if ((arp_table[i].state >= ETHARP_STATE_STABLE) && (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
    93b8:	7c99      	ldrb	r1, [r3, #18]
    93ba:	2901      	cmp	r1, #1
    93bc:	d9f8      	bls.n	93b0 <etharp_output+0xac>
    93be:	6820      	ldr	r0, [r4, #0]
    93c0:	6859      	ldr	r1, [r3, #4]
    93c2:	4288      	cmp	r0, r1
    93c4:	d1f4      	bne.n	93b0 <etharp_output+0xac>
				ETHARP_SET_HINT(netif, i);
    93c6:	b2d2      	uxtb	r2, r2
    93c8:	4b11      	ldr	r3, [pc, #68]	; (9410 <etharp_output+0x10c>)
    93ca:	f883 20c8 	strb.w	r2, [r3, #200]	; 0xc8
				return etharp_output_to_arp_index(netif, q, i);
    93ce:	4631      	mov	r1, r6
    93d0:	4628      	mov	r0, r5
    93d2:	4b10      	ldr	r3, [pc, #64]	; (9414 <etharp_output+0x110>)
    93d4:	4798      	blx	r3
    93d6:	e00c      	b.n	93f2 <etharp_output+0xee>
		return etharp_query(netif, dst_addr, q);
    93d8:	4632      	mov	r2, r6
    93da:	4621      	mov	r1, r4
    93dc:	4628      	mov	r0, r5
    93de:	4b0e      	ldr	r3, [pc, #56]	; (9418 <etharp_output+0x114>)
    93e0:	4798      	blx	r3
    93e2:	e006      	b.n	93f2 <etharp_output+0xee>
		dest = (struct eth_addr *)&ethbroadcast;
    93e4:	4b0d      	ldr	r3, [pc, #52]	; (941c <etharp_output+0x118>)
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), dest);
    93e6:	f105 022f 	add.w	r2, r5, #47	; 0x2f
    93ea:	4631      	mov	r1, r6
    93ec:	4628      	mov	r0, r5
    93ee:	4c0c      	ldr	r4, [pc, #48]	; (9420 <etharp_output+0x11c>)
    93f0:	47a0      	blx	r4
}
    93f2:	b002      	add	sp, #8
    93f4:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_BUF;
    93f6:	f06f 0001 	mvn.w	r0, #1
    93fa:	e7fa      	b.n	93f2 <etharp_output+0xee>
					return ERR_RTE;
    93fc:	f06f 0003 	mvn.w	r0, #3
    9400:	e7f7      	b.n	93f2 <etharp_output+0xee>
    9402:	f06f 0003 	mvn.w	r0, #3
    9406:	e7f4      	b.n	93f2 <etharp_output+0xee>
    9408:	00005bf5 	.word	0x00005bf5
    940c:	00004ef9 	.word	0x00004ef9
    9410:	20007fd8 	.word	0x20007fd8
    9414:	0000913d 	.word	0x0000913d
    9418:	000091ad 	.word	0x000091ad
    941c:	0000c5e0 	.word	0x0000c5e0
    9420:	00009001 	.word	0x00009001

00009424 <ethernet_input>:
 *
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t ethernet_input(struct pbuf *p, struct netif *netif)
{
    9424:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9428:	b083      	sub	sp, #12
    942a:	4604      	mov	r4, r0
	u16_t           type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
	s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

	if (p->len <= SIZEOF_ETH_HDR) {
    942c:	8946      	ldrh	r6, [r0, #10]
    942e:	2e0e      	cmp	r6, #14
    9430:	d919      	bls.n	9466 <ethernet_input+0x42>
    9432:	460f      	mov	r7, r1
		ETHARP_STATS_INC(etharp.drop);
		goto free_and_return;
	}

	/* points to packet payload, which starts with an Ethernet header */
	ethhdr = (struct eth_hdr *)p->payload;
    9434:	6845      	ldr	r5, [r0, #4]
	             (unsigned)ethhdr->src.addr[3],
	             (unsigned)ethhdr->src.addr[4],
	             (unsigned)ethhdr->src.addr[5],
	             (unsigned)htons(ethhdr->type)));

	type = ethhdr->type;
    9436:	f8b5 800c 	ldrh.w	r8, [r5, #12]

#if LWIP_ARP_FILTER_NETIF
	netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

	if (ethhdr->dest.addr[0] & 1) {
    943a:	782b      	ldrb	r3, [r5, #0]
    943c:	f013 0f01 	tst.w	r3, #1
    9440:	d00b      	beq.n	945a <ethernet_input+0x36>
		/* this might be a multicast or broadcast packet */
		if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
    9442:	2b01      	cmp	r3, #1
    9444:	d016      	beq.n	9474 <ethernet_input+0x50>
			if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) && (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
				/* mark the pbuf as link-layer multicast */
				p->flags |= PBUF_FLAG_LLMCAST;
			}
		} else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
    9446:	2206      	movs	r2, #6
    9448:	4976      	ldr	r1, [pc, #472]	; (9624 <ethernet_input+0x200>)
    944a:	4628      	mov	r0, r5
    944c:	4b76      	ldr	r3, [pc, #472]	; (9628 <ethernet_input+0x204>)
    944e:	4798      	blx	r3
    9450:	b918      	cbnz	r0, 945a <ethernet_input+0x36>
			/* mark the pbuf as link-layer broadcast */
			p->flags |= PBUF_FLAG_LLBCAST;
    9452:	7b63      	ldrb	r3, [r4, #13]
    9454:	f043 0308 	orr.w	r3, r3, #8
    9458:	7363      	strb	r3, [r4, #13]
		}
	}

	switch (type) {
    945a:	f1b8 0f08 	cmp.w	r8, #8
    945e:	d014      	beq.n	948a <ethernet_input+0x66>
    9460:	f5b8 6fc1 	cmp.w	r8, #1544	; 0x608
    9464:	d022      	beq.n	94ac <ethernet_input+0x88>
	/* This means the pbuf is freed or consumed,
	   so the caller doesn't have to free it again */
	return ERR_OK;

free_and_return:
	pbuf_free(p);
    9466:	4620      	mov	r0, r4
    9468:	4b70      	ldr	r3, [pc, #448]	; (962c <ethernet_input+0x208>)
    946a:	4798      	blx	r3
	return ERR_OK;
}
    946c:	2000      	movs	r0, #0
    946e:	b003      	add	sp, #12
    9470:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) && (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
    9474:	786b      	ldrb	r3, [r5, #1]
    9476:	2b00      	cmp	r3, #0
    9478:	d1ef      	bne.n	945a <ethernet_input+0x36>
    947a:	78ab      	ldrb	r3, [r5, #2]
    947c:	2b5e      	cmp	r3, #94	; 0x5e
    947e:	d1ec      	bne.n	945a <ethernet_input+0x36>
				p->flags |= PBUF_FLAG_LLMCAST;
    9480:	7b43      	ldrb	r3, [r0, #13]
    9482:	f043 0310 	orr.w	r3, r3, #16
    9486:	7343      	strb	r3, [r0, #13]
    9488:	e7e7      	b.n	945a <ethernet_input+0x36>
		if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    948a:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
    948e:	f013 0f20 	tst.w	r3, #32
    9492:	d0e8      	beq.n	9466 <ethernet_input+0x42>
		if (pbuf_header(p, -ip_hdr_offset)) {
    9494:	f06f 010d 	mvn.w	r1, #13
    9498:	4620      	mov	r0, r4
    949a:	4b65      	ldr	r3, [pc, #404]	; (9630 <ethernet_input+0x20c>)
    949c:	4798      	blx	r3
    949e:	2800      	cmp	r0, #0
    94a0:	d1e1      	bne.n	9466 <ethernet_input+0x42>
			ip_input(p, netif);
    94a2:	4639      	mov	r1, r7
    94a4:	4620      	mov	r0, r4
    94a6:	4b63      	ldr	r3, [pc, #396]	; (9634 <ethernet_input+0x210>)
    94a8:	4798      	blx	r3
		break;
    94aa:	e7df      	b.n	946c <ethernet_input+0x48>
		if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    94ac:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
    94b0:	f013 0f20 	tst.w	r3, #32
    94b4:	d0d7      	beq.n	9466 <ethernet_input+0x42>
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    94b6:	b167      	cbz	r7, 94d2 <ethernet_input+0xae>
	if (p->len < SIZEOF_ETHARP_PACKET) {
    94b8:	2e29      	cmp	r6, #41	; 0x29
    94ba:	d912      	bls.n	94e2 <ethernet_input+0xbe>
	if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) || (hdr->hwlen != ETHARP_HWADDR_LEN)
    94bc:	89eb      	ldrh	r3, [r5, #14]
    94be:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    94c2:	d102      	bne.n	94ca <ethernet_input+0xa6>
    94c4:	7cab      	ldrb	r3, [r5, #18]
    94c6:	2b06      	cmp	r3, #6
    94c8:	d00f      	beq.n	94ea <ethernet_input+0xc6>
		pbuf_free(p);
    94ca:	4620      	mov	r0, r4
    94cc:	4b57      	ldr	r3, [pc, #348]	; (962c <ethernet_input+0x208>)
    94ce:	4798      	blx	r3
    94d0:	e7cc      	b.n	946c <ethernet_input+0x48>
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    94d2:	4b59      	ldr	r3, [pc, #356]	; (9638 <ethernet_input+0x214>)
    94d4:	f44f 7233 	mov.w	r2, #716	; 0x2cc
    94d8:	4958      	ldr	r1, [pc, #352]	; (963c <ethernet_input+0x218>)
    94da:	4859      	ldr	r0, [pc, #356]	; (9640 <ethernet_input+0x21c>)
    94dc:	4c59      	ldr	r4, [pc, #356]	; (9644 <ethernet_input+0x220>)
    94de:	47a0      	blx	r4
    94e0:	e7fe      	b.n	94e0 <ethernet_input+0xbc>
		pbuf_free(p);
    94e2:	4620      	mov	r0, r4
    94e4:	4b51      	ldr	r3, [pc, #324]	; (962c <ethernet_input+0x208>)
    94e6:	4798      	blx	r3
    94e8:	e7c0      	b.n	946c <ethernet_input+0x48>
	    || (hdr->protolen != sizeof(ip_addr_t)) || (hdr->proto != PP_HTONS(ETHTYPE_IP))) {
    94ea:	7ceb      	ldrb	r3, [r5, #19]
    94ec:	2b04      	cmp	r3, #4
    94ee:	d1ec      	bne.n	94ca <ethernet_input+0xa6>
    94f0:	8a2b      	ldrh	r3, [r5, #16]
    94f2:	2b08      	cmp	r3, #8
    94f4:	d1e9      	bne.n	94ca <ethernet_input+0xa6>
	IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
    94f6:	69e8      	ldr	r0, [r5, #28]
    94f8:	9001      	str	r0, [sp, #4]
	IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
    94fa:	f8d5 2026 	ldr.w	r2, [r5, #38]	; 0x26
	if (ip_addr_isany(&netif->ip_addr)) {
    94fe:	f117 0f04 	cmn.w	r7, #4
    9502:	f000 8087 	beq.w	9614 <ethernet_input+0x1f0>
    9506:	687b      	ldr	r3, [r7, #4]
    9508:	2b00      	cmp	r3, #0
    950a:	f000 8083 	beq.w	9614 <ethernet_input+0x1f0>
		for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
    950e:	429a      	cmp	r2, r3
    9510:	bf0c      	ite	eq
    9512:	f04f 0901 	moveq.w	r9, #1
    9516:	f04f 0900 	movne.w	r9, #0
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    951a:	f105 0616 	add.w	r6, r5, #22
    951e:	bf12      	itee	ne
    9520:	f04f 0a02 	movne.w	sl, #2
		for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
    9524:	f04f 0901 	moveq.w	r9, #1
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    9528:	46ca      	moveq	sl, r9
		etharp_arp_input(netif, (struct eth_addr *)(netif->hwaddr), p);
    952a:	f107 082f 	add.w	r8, r7, #47	; 0x2f
	if (ip_addr_isany(ipaddr) || ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr)) {
    952e:	2800      	cmp	r0, #0
    9530:	d03a      	beq.n	95a8 <ethernet_input+0x184>
    9532:	4639      	mov	r1, r7
    9534:	4b44      	ldr	r3, [pc, #272]	; (9648 <ethernet_input+0x224>)
    9536:	4798      	blx	r3
    9538:	bbb0      	cbnz	r0, 95a8 <ethernet_input+0x184>
    953a:	9b01      	ldr	r3, [sp, #4]
    953c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    9540:	2be0      	cmp	r3, #224	; 0xe0
    9542:	d031      	beq.n	95a8 <ethernet_input+0x184>
	i = etharp_find_entry(ipaddr, flags);
    9544:	4651      	mov	r1, sl
    9546:	a801      	add	r0, sp, #4
    9548:	4b40      	ldr	r3, [pc, #256]	; (964c <ethernet_input+0x228>)
    954a:	4798      	blx	r3
	if (i < 0) {
    954c:	1e03      	subs	r3, r0, #0
    954e:	db2b      	blt.n	95a8 <ethernet_input+0x184>
		arp_table[i].state = ETHARP_STATE_STABLE;
    9550:	f8df e104 	ldr.w	lr, [pc, #260]	; 9658 <ethernet_input+0x234>
    9554:	009a      	lsls	r2, r3, #2
    9556:	18d1      	adds	r1, r2, r3
    9558:	0089      	lsls	r1, r1, #2
    955a:	eb0e 0c01 	add.w	ip, lr, r1
    955e:	2002      	movs	r0, #2
    9560:	f88c 0012 	strb.w	r0, [ip, #18]
	arp_table[i].netif = netif;
    9564:	f8cc 7008 	str.w	r7, [ip, #8]
	ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    9568:	460a      	mov	r2, r1
    956a:	320c      	adds	r2, #12
    956c:	eb0e 0a02 	add.w	sl, lr, r2
    9570:	6830      	ldr	r0, [r6, #0]
    9572:	f84e 0002 	str.w	r0, [lr, r2]
    9576:	88b2      	ldrh	r2, [r6, #4]
    9578:	f8aa 2004 	strh.w	r2, [sl, #4]
	arp_table[i].ctime = 0;
    957c:	2200      	movs	r2, #0
    957e:	f88c 2013 	strb.w	r2, [ip, #19]
	if (arp_table[i].q != NULL) {
    9582:	f85e a001 	ldr.w	sl, [lr, r1]
    9586:	f1ba 0f00 	cmp.w	sl, #0
    958a:	d00d      	beq.n	95a8 <ethernet_input+0x184>
		arp_table[i].q = NULL;
    958c:	460b      	mov	r3, r1
    958e:	4611      	mov	r1, r2
    9590:	f84e 1003 	str.w	r1, [lr, r3]
		etharp_send_ip(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr);
    9594:	4633      	mov	r3, r6
    9596:	4642      	mov	r2, r8
    9598:	4651      	mov	r1, sl
    959a:	4638      	mov	r0, r7
    959c:	f8df b0bc 	ldr.w	fp, [pc, #188]	; 965c <ethernet_input+0x238>
    95a0:	47d8      	blx	fp
		pbuf_free(p);
    95a2:	4650      	mov	r0, sl
    95a4:	4b21      	ldr	r3, [pc, #132]	; (962c <ethernet_input+0x208>)
    95a6:	4798      	blx	r3
	switch (hdr->opcode) {
    95a8:	8aab      	ldrh	r3, [r5, #20]
    95aa:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    95ae:	d006      	beq.n	95be <ethernet_input+0x19a>
    95b0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    95b4:	d029      	beq.n	960a <ethernet_input+0x1e6>
	pbuf_free(p);
    95b6:	4620      	mov	r0, r4
    95b8:	4b1c      	ldr	r3, [pc, #112]	; (962c <ethernet_input+0x208>)
    95ba:	4798      	blx	r3
    95bc:	e756      	b.n	946c <ethernet_input+0x48>
		if (for_us) {
    95be:	f1b9 0f00 	cmp.w	r9, #0
    95c2:	d0f8      	beq.n	95b6 <ethernet_input+0x192>
			hdr->opcode = htons(ARP_REPLY);
    95c4:	2002      	movs	r0, #2
    95c6:	4b22      	ldr	r3, [pc, #136]	; (9650 <ethernet_input+0x22c>)
    95c8:	4798      	blx	r3
    95ca:	82a8      	strh	r0, [r5, #20]
			IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
    95cc:	69eb      	ldr	r3, [r5, #28]
    95ce:	f8c5 3026 	str.w	r3, [r5, #38]	; 0x26
			IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
    95d2:	687b      	ldr	r3, [r7, #4]
    95d4:	61eb      	str	r3, [r5, #28]
			ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
    95d6:	6833      	ldr	r3, [r6, #0]
    95d8:	622b      	str	r3, [r5, #32]
    95da:	88b3      	ldrh	r3, [r6, #4]
    95dc:	84ab      	strh	r3, [r5, #36]	; 0x24
			ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
    95de:	6833      	ldr	r3, [r6, #0]
    95e0:	602b      	str	r3, [r5, #0]
    95e2:	88b3      	ldrh	r3, [r6, #4]
    95e4:	80ab      	strh	r3, [r5, #4]
			ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
    95e6:	f8d8 3000 	ldr.w	r3, [r8]
    95ea:	6033      	str	r3, [r6, #0]
    95ec:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    95f0:	80b3      	strh	r3, [r6, #4]
			ETHADDR16_COPY(&ethhdr->src, ethaddr);
    95f2:	f8d8 3000 	ldr.w	r3, [r8]
    95f6:	f8c5 3006 	str.w	r3, [r5, #6]
    95fa:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    95fe:	816b      	strh	r3, [r5, #10]
			netif->linkoutput(netif, p);
    9600:	69bb      	ldr	r3, [r7, #24]
    9602:	4621      	mov	r1, r4
    9604:	4638      	mov	r0, r7
    9606:	4798      	blx	r3
    9608:	e7d5      	b.n	95b6 <ethernet_input+0x192>
		dhcp_arp_reply(netif, &sipaddr);
    960a:	a901      	add	r1, sp, #4
    960c:	4638      	mov	r0, r7
    960e:	4b11      	ldr	r3, [pc, #68]	; (9654 <ethernet_input+0x230>)
    9610:	4798      	blx	r3
    9612:	e7d0      	b.n	95b6 <ethernet_input+0x192>
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    9614:	f105 0616 	add.w	r6, r5, #22
    9618:	f04f 0900 	mov.w	r9, #0
    961c:	f04f 0a02 	mov.w	sl, #2
    9620:	e783      	b.n	952a <ethernet_input+0x106>
    9622:	bf00      	nop
    9624:	0000c5e0 	.word	0x0000c5e0
    9628:	00009f91 	.word	0x00009f91
    962c:	00005c89 	.word	0x00005c89
    9630:	00005bf5 	.word	0x00005bf5
    9634:	00004bd1 	.word	0x00004bd1
    9638:	0000c5e8 	.word	0x0000c5e8
    963c:	0000bbf4 	.word	0x0000bbf4
    9640:	0000b2e8 	.word	0x0000b2e8
    9644:	00009fd5 	.word	0x00009fd5
    9648:	00004ef9 	.word	0x00004ef9
    964c:	00008f01 	.word	0x00008f01
    9650:	00002ea5 	.word	0x00002ea5
    9654:	000040dd 	.word	0x000040dd
    9658:	20007fd8 	.word	0x20007fd8
    965c:	00009001 	.word	0x00009001

00009660 <mac_transmit_cb>:
	//gpio_set_pin_level(PHY_YELLOW_LED_PIN,false);
	gpio_set_pin_level(PHY_YELLOW_LED_PIN,true);
}

void mac_transmit_cb(struct mac_async_descriptor *desc)
{
    9660:	4770      	bx	lr
	...

00009664 <MotorTimerTask_cb>:
#endif		
		
static struct timer_task MotorTimerTask;

static void MotorTimerTask_cb(const struct timer_task *const timer_task)
{
    9664:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t temp;
	uint8_t i;


	//go through each motor status and set/reset the correct PORTB and PORTC pins
	for(i=0;i<NumMotors;i++) {//NUM_MOTORS;i++) {
    9666:	4b39      	ldr	r3, [pc, #228]	; (974c <MotorTimerTask_cb+0xe8>)
    9668:	781e      	ldrb	r6, [r3, #0]
    966a:	2e00      	cmp	r6, #0
    966c:	d06c      	beq.n	9748 <MotorTimerTask_cb+0xe4>
				//*Motor[i].PulsePort&=Motor[i].PulseBitMask;
				gpio_set_pin_level(Motor[i].PulsePin,false);
			} //if (Motor[i].StrengthCount<motor[i].Strength)

			Motor[i].StrengthCount++;  //increase duty cycle count
			if (Motor[i].StrengthCount>=NumClocksInMotorDutyCycle) {  //reached end of duty cycle, reset count
    966e:	4b38      	ldr	r3, [pc, #224]	; (9750 <MotorTimerTask_cb+0xec>)
    9670:	f8d3 e000 	ldr.w	lr, [r3]
    9674:	4b37      	ldr	r3, [pc, #220]	; (9754 <MotorTimerTask_cb+0xf0>)
    9676:	2000      	movs	r0, #0
				Motor[i].Duration--;  //currently units are timer interrupts
			}
			//which depend on MotorDutyCycleClock
		} else {  //no motor Duration - set motor pins to 0

			Motor[i].StrengthCount=0;
    9678:	4607      	mov	r7, r0
 * \param[in] level true  = Pin level set to "high" state
 *                  false = Pin level set to "low" state
 */
static inline void gpio_set_pin_level(const uint8_t pin, const bool level)
{
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    967a:	2501      	movs	r5, #1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    967c:	4c36      	ldr	r4, [pc, #216]	; (9758 <MotorTimerTask_cb+0xf4>)
    967e:	e03e      	b.n	96fe <MotorTimerTask_cb+0x9a>
					gpio_set_pin_level(Motor[i].DirPin,false);
    9680:	7919      	ldrb	r1, [r3, #4]
    9682:	f001 0c1f 	and.w	ip, r1, #31
    9686:	fa05 fc0c 	lsl.w	ip, r5, ip
    968a:	0949      	lsrs	r1, r1, #5
    968c:	eb04 11c1 	add.w	r1, r4, r1, lsl #7
    9690:	f8c1 c014 	str.w	ip, [r1, #20]
    9694:	e04d      	b.n	9732 <MotorTimerTask_cb+0xce>
				if (Motor[i].flags&MOTOR_INST_FIRST_RUN) {
    9696:	7819      	ldrb	r1, [r3, #0]
    9698:	f011 0f02 	tst.w	r1, #2
    969c:	d115      	bne.n	96ca <MotorTimerTask_cb+0x66>
				gpio_set_pin_level(Motor[i].PulsePin,false);
    969e:	7a11      	ldrb	r1, [r2, #8]
    96a0:	f001 0c1f 	and.w	ip, r1, #31
    96a4:	fa05 fc0c 	lsl.w	ip, r5, ip
    96a8:	0949      	lsrs	r1, r1, #5
    96aa:	eb04 11c1 	add.w	r1, r4, r1, lsl #7
    96ae:	f8c1 c014 	str.w	ip, [r1, #20]
			Motor[i].StrengthCount++;  //increase duty cycle count
    96b2:	8c51      	ldrh	r1, [r2, #34]	; 0x22
    96b4:	3101      	adds	r1, #1
    96b6:	b289      	uxth	r1, r1
    96b8:	8451      	strh	r1, [r2, #34]	; 0x22
			if (Motor[i].StrengthCount>=NumClocksInMotorDutyCycle) {  //reached end of duty cycle, reset count
    96ba:	4571      	cmp	r1, lr
				Motor[i].StrengthCount=0;
    96bc:	bfa8      	it	ge
    96be:	8457      	strhge	r7, [r2, #34]	; 0x22
			if (Motor[i].Duration!=0) { //new inst might set Duration=0
    96c0:	6a51      	ldr	r1, [r2, #36]	; 0x24
    96c2:	b1b9      	cbz	r1, 96f4 <MotorTimerTask_cb+0x90>
				Motor[i].Duration--;  //currently units are timer interrupts
    96c4:	3901      	subs	r1, #1
    96c6:	6251      	str	r1, [r2, #36]	; 0x24
    96c8:	e014      	b.n	96f4 <MotorTimerTask_cb+0x90>
					Motor[i].flags&=~MOTOR_INST_FIRST_RUN; //clear first run bit
    96ca:	f021 0102 	bic.w	r1, r1, #2
    96ce:	7011      	strb	r1, [r2, #0]
					if (Motor[i].StrengthCount>0) {
    96d0:	f1bc 0f00 	cmp.w	ip, #0
    96d4:	d0e3      	beq.n	969e <MotorTimerTask_cb+0x3a>
						Motor[i].StrengthCount--; //set back 1 so direction can get set above
    96d6:	f10c 3cff 	add.w	ip, ip, #4294967295
    96da:	f8a2 c022 	strh.w	ip, [r2, #34]	; 0x22
    96de:	e7de      	b.n	969e <MotorTimerTask_cb+0x3a>
			Motor[i].StrengthCount=0;
    96e0:	845f      	strh	r7, [r3, #34]	; 0x22
									    
			gpio_set_pin_level(Motor[i].PulsePin,false);
    96e2:	7a1a      	ldrb	r2, [r3, #8]
    96e4:	f002 011f 	and.w	r1, r2, #31
    96e8:	fa05 f101 	lsl.w	r1, r5, r1
    96ec:	0952      	lsrs	r2, r2, #5
    96ee:	eb04 12c2 	add.w	r2, r4, r2, lsl #7
    96f2:	6151      	str	r1, [r2, #20]
    96f4:	3001      	adds	r0, #1
    96f6:	332c      	adds	r3, #44	; 0x2c
	for(i=0;i<NumMotors;i++) {//NUM_MOTORS;i++) {
    96f8:	b2c2      	uxtb	r2, r0
    96fa:	4296      	cmp	r6, r2
    96fc:	d924      	bls.n	9748 <MotorTimerTask_cb+0xe4>
    96fe:	461a      	mov	r2, r3
		if (Motor[i].Duration>0) { //this motor is moving, or will start moving
    9700:	6a59      	ldr	r1, [r3, #36]	; 0x24
    9702:	2900      	cmp	r1, #0
    9704:	d0ec      	beq.n	96e0 <MotorTimerTask_cb+0x7c>
			if (Motor[i].StrengthCount<Motor[i].Strength && !(Motor[i].flags&MOTOR_INST_FIRST_RUN)) { //set motor pins
    9706:	f8b3 c022 	ldrh.w	ip, [r3, #34]	; 0x22
    970a:	8c19      	ldrh	r1, [r3, #32]
    970c:	4561      	cmp	r1, ip
    970e:	d9c2      	bls.n	9696 <MotorTimerTask_cb+0x32>
    9710:	7819      	ldrb	r1, [r3, #0]
    9712:	f011 0f02 	tst.w	r1, #2
    9716:	d1d8      	bne.n	96ca <MotorTimerTask_cb+0x66>
				if (Motor[i].Direction) {
    9718:	68d9      	ldr	r1, [r3, #12]
    971a:	2900      	cmp	r1, #0
    971c:	d0b0      	beq.n	9680 <MotorTimerTask_cb+0x1c>
					gpio_set_pin_level(Motor[i].DirPin,true);
    971e:	7919      	ldrb	r1, [r3, #4]
    9720:	f001 0c1f 	and.w	ip, r1, #31
    9724:	fa05 fc0c 	lsl.w	ip, r5, ip
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    9728:	0949      	lsrs	r1, r1, #5
    972a:	eb04 11c1 	add.w	r1, r4, r1, lsl #7
    972e:	f8c1 c018 	str.w	ip, [r1, #24]
				gpio_set_pin_level(Motor[i].PulsePin,true);
    9732:	7a11      	ldrb	r1, [r2, #8]
    9734:	f001 0c1f 	and.w	ip, r1, #31
    9738:	fa05 fc0c 	lsl.w	ip, r5, ip
    973c:	0949      	lsrs	r1, r1, #5
    973e:	eb04 11c1 	add.w	r1, r4, r1, lsl #7
    9742:	f8c1 c018 	str.w	ip, [r1, #24]
    9746:	e7b4      	b.n	96b2 <MotorTimerTask_cb+0x4e>
    9748:	bdf0      	pop	{r4, r5, r6, r7, pc}
    974a:	bf00      	nop
    974c:	20009320 	.word	0x20009320
    9750:	200095ec 	.word	0x200095ec
    9754:	2000932c 	.word	0x2000932c
    9758:	41008000 	.word	0x41008000

0000975c <mac_receive_cb>:
{
    975c:	b538      	push	{r3, r4, r5, lr}
	gmac_recv_flag = true;
    975e:	2001      	movs	r0, #1
    9760:	4b05      	ldr	r3, [pc, #20]	; (9778 <mac_receive_cb+0x1c>)
    9762:	7018      	strb	r0, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9764:	4c05      	ldr	r4, [pc, #20]	; (977c <mac_receive_cb+0x20>)
    9766:	f44f 4580 	mov.w	r5, #16384	; 0x4000
    976a:	f8c4 5114 	str.w	r5, [r4, #276]	; 0x114
	delay_ms(1);
    976e:	4b04      	ldr	r3, [pc, #16]	; (9780 <mac_receive_cb+0x24>)
    9770:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    9772:	f8c4 5118 	str.w	r5, [r4, #280]	; 0x118
    9776:	bd38      	pop	{r3, r4, r5, pc}
    9778:	200080a4 	.word	0x200080a4
    977c:	41008000 	.word	0x41008000
    9780:	00000ed1 	.word	0x00000ed1

00009784 <status_callback>:
{
    9784:	b508      	push	{r3, lr}
	if (n->flags & NETIF_FLAG_UP) {
    9786:	f890 1035 	ldrb.w	r1, [r0, #53]	; 0x35
    978a:	f011 0f01 	tst.w	r1, #1
    978e:	d00b      	beq.n	97a8 <status_callback+0x24>
		printf("Interface Up %s:\n",
    9790:	f001 0108 	and.w	r1, r1, #8
    9794:	4b06      	ldr	r3, [pc, #24]	; (97b0 <status_callback+0x2c>)
    9796:	4a07      	ldr	r2, [pc, #28]	; (97b4 <status_callback+0x30>)
    9798:	2900      	cmp	r1, #0
    979a:	bf14      	ite	ne
    979c:	4611      	movne	r1, r2
    979e:	4619      	moveq	r1, r3
    97a0:	4805      	ldr	r0, [pc, #20]	; (97b8 <status_callback+0x34>)
    97a2:	4b06      	ldr	r3, [pc, #24]	; (97bc <status_callback+0x38>)
    97a4:	4798      	blx	r3
    97a6:	bd08      	pop	{r3, pc}
		printf("Interface Down.\n");
    97a8:	4805      	ldr	r0, [pc, #20]	; (97c0 <status_callback+0x3c>)
    97aa:	4b06      	ldr	r3, [pc, #24]	; (97c4 <status_callback+0x40>)
    97ac:	4798      	blx	r3
    97ae:	bd08      	pop	{r3, pc}
    97b0:	0000c618 	.word	0x0000c618
    97b4:	0000c610 	.word	0x0000c610
    97b8:	0000c624 	.word	0x0000c624
    97bc:	00009fd5 	.word	0x00009fd5
    97c0:	0000c638 	.word	0x0000c638
    97c4:	0000a0bd 	.word	0x0000a0bd

000097c8 <link_callback>:
{
    97c8:	b510      	push	{r4, lr}
	if (n->flags & NETIF_FLAG_LINK_UP) {
    97ca:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
    97ce:	f013 0f10 	tst.w	r3, #16
    97d2:	d00f      	beq.n	97f4 <link_callback+0x2c>
    97d4:	4604      	mov	r4, r0
		printf("Link Up.\n");
    97d6:	4809      	ldr	r0, [pc, #36]	; (97fc <link_callback+0x34>)
    97d8:	4b09      	ldr	r3, [pc, #36]	; (9800 <link_callback+0x38>)
    97da:	4798      	blx	r3
		if (n->flags & NETIF_FLAG_DHCP) {
    97dc:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    97e0:	f013 0f08 	tst.w	r3, #8
    97e4:	d009      	beq.n	97fa <link_callback+0x32>
			printf("Restarting DHCP\n");
    97e6:	4807      	ldr	r0, [pc, #28]	; (9804 <link_callback+0x3c>)
    97e8:	4b05      	ldr	r3, [pc, #20]	; (9800 <link_callback+0x38>)
    97ea:	4798      	blx	r3
			dhcp_start(n);
    97ec:	4620      	mov	r0, r4
    97ee:	4b06      	ldr	r3, [pc, #24]	; (9808 <link_callback+0x40>)
    97f0:	4798      	blx	r3
    97f2:	bd10      	pop	{r4, pc}
		printf("Link Down.\n");
    97f4:	4805      	ldr	r0, [pc, #20]	; (980c <link_callback+0x44>)
    97f6:	4b02      	ldr	r3, [pc, #8]	; (9800 <link_callback+0x38>)
    97f8:	4798      	blx	r3
    97fa:	bd10      	pop	{r4, pc}
    97fc:	0000c648 	.word	0x0000c648
    9800:	0000a0bd 	.word	0x0000a0bd
    9804:	0000c654 	.word	0x0000c654
    9808:	00004649 	.word	0x00004649
    980c:	0000c664 	.word	0x0000c664

00009810 <sys_now>:
	return systick_timems;
    9810:	4b01      	ldr	r3, [pc, #4]	; (9818 <sys_now+0x8>)
    9812:	6858      	ldr	r0, [r3, #4]
}
    9814:	4770      	bx	lr
    9816:	bf00      	nop
    9818:	200080a4 	.word	0x200080a4

0000981c <SysTick_Handler>:
	systick_timems++;
    981c:	4a02      	ldr	r2, [pc, #8]	; (9828 <SysTick_Handler+0xc>)
    981e:	6853      	ldr	r3, [r2, #4]
    9820:	3301      	adds	r3, #1
    9822:	6053      	str	r3, [r2, #4]
    9824:	4770      	bx	lr
    9826:	bf00      	nop
    9828:	200080a4 	.word	0x200080a4

0000982c <systick_enable>:
	systick_timems = 0;
    982c:	2200      	movs	r2, #0
    982e:	4b06      	ldr	r3, [pc, #24]	; (9848 <systick_enable+0x1c>)
    9830:	605a      	str	r2, [r3, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    9832:	4b06      	ldr	r3, [pc, #24]	; (984c <systick_enable+0x20>)
    9834:	4906      	ldr	r1, [pc, #24]	; (9850 <systick_enable+0x24>)
    9836:	6059      	str	r1, [r3, #4]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9838:	20e0      	movs	r0, #224	; 0xe0
    983a:	4906      	ldr	r1, [pc, #24]	; (9854 <systick_enable+0x28>)
    983c:	f881 0023 	strb.w	r0, [r1, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    9840:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    9842:	2207      	movs	r2, #7
    9844:	601a      	str	r2, [r3, #0]
    9846:	4770      	bx	lr
    9848:	200080a4 	.word	0x200080a4
    984c:	e000e010 	.word	0xe000e010
    9850:	0001d4bf 	.word	0x0001d4bf
    9854:	e000ed00 	.word	0xe000ed00

00009858 <ringbuffer_last>:
{
    9858:	b510      	push	{r4, lr}
    ASSERT(rb);
    985a:	4604      	mov	r4, r0
    985c:	223f      	movs	r2, #63	; 0x3f
    985e:	4906      	ldr	r1, [pc, #24]	; (9878 <ringbuffer_last+0x20>)
    9860:	3000      	adds	r0, #0
    9862:	bf18      	it	ne
    9864:	2001      	movne	r0, #1
    9866:	4b05      	ldr	r3, [pc, #20]	; (987c <ringbuffer_last+0x24>)
    9868:	4798      	blx	r3
    uint8_t data = rb->buf[(rb->write_index-1) & rb->size];
    986a:	68e3      	ldr	r3, [r4, #12]
    986c:	3b01      	subs	r3, #1
    986e:	6862      	ldr	r2, [r4, #4]
    9870:	4013      	ands	r3, r2
    9872:	6822      	ldr	r2, [r4, #0]
}
    9874:	5cd0      	ldrb	r0, [r2, r3]
    9876:	bd10      	pop	{r4, pc}
    9878:	0000c670 	.word	0x0000c670
    987c:	00001861 	.word	0x00001861

00009880 <usart1_receive_cb>:
{
    9880:	b508      	push	{r3, lr}
    if( ringbuffer_last(&io_descr->rx) == 0x0a ) {
    9882:	3034      	adds	r0, #52	; 0x34
    9884:	4b04      	ldr	r3, [pc, #16]	; (9898 <usart1_receive_cb+0x18>)
    9886:	4798      	blx	r3
    9888:	280a      	cmp	r0, #10
    988a:	d000      	beq.n	988e <usart1_receive_cb+0xe>
    988c:	bd08      	pop	{r3, pc}
        line_available = true;
    988e:	2201      	movs	r2, #1
    9890:	4b02      	ldr	r3, [pc, #8]	; (989c <usart1_receive_cb+0x1c>)
    9892:	721a      	strb	r2, [r3, #8]
}
    9894:	e7fa      	b.n	988c <usart1_receive_cb+0xc>
    9896:	bf00      	nop
    9898:	00009859 	.word	0x00009859
    989c:	200080a4 	.word	0x200080a4

000098a0 <MotorTimer_Initialize>:



//tph - TIMER_0 uses the TC0 peripheral which takes as input the 12MHz general clock divided by 4 = 3Mhz to produce (/75) a 40khz (25us) signal for Motor pwm
void MotorTimer_Initialize(void)
{
    98a0:	b510      	push	{r4, lr}
	MotorTimerTask.interval = 1; //clock ticks
    98a2:	4907      	ldr	r1, [pc, #28]	; (98c0 <MotorTimer_Initialize+0x20>)
    98a4:	2301      	movs	r3, #1
    98a6:	614b      	str	r3, [r1, #20]
	MotorTimerTask.cb       = MotorTimerTask_cb;
    98a8:	4a06      	ldr	r2, [pc, #24]	; (98c4 <MotorTimer_Initialize+0x24>)
    98aa:	618a      	str	r2, [r1, #24]
	MotorTimerTask.mode     = TIMER_TASK_REPEAT;
    98ac:	770b      	strb	r3, [r1, #28]

	timer_add_task(&TIMER_0, &MotorTimerTask);
    98ae:	4c06      	ldr	r4, [pc, #24]	; (98c8 <MotorTimer_Initialize+0x28>)
    98b0:	310c      	adds	r1, #12
    98b2:	4620      	mov	r0, r4
    98b4:	4b05      	ldr	r3, [pc, #20]	; (98cc <MotorTimer_Initialize+0x2c>)
    98b6:	4798      	blx	r3
	timer_start(&TIMER_0);
    98b8:	4620      	mov	r0, r4
    98ba:	4b05      	ldr	r3, [pc, #20]	; (98d0 <MotorTimer_Initialize+0x30>)
    98bc:	4798      	blx	r3
    98be:	bd10      	pop	{r4, pc}
    98c0:	200080a4 	.word	0x200080a4
    98c4:	00009665 	.word	0x00009665
    98c8:	20008288 	.word	0x20008288
    98cc:	00001341 	.word	0x00001341
    98d0:	00001305 	.word	0x00001305

000098d4 <SendMotorInst>:
//and contains (in 4 bytes):
//Motor# (0:3),unused(4:7),direction(8),thrust(9:15),duration(16:31)
//was 3 bytes:
//motor# (address):4, direction:1, strength:3,duration:16
void SendMotorInst(uint8_t *MInst)
{
    98d4:	b430      	push	{r4, r5}
    uint32_t Duration;

    //set the motor status so the timer interrupt
    //will find that a motor has a duration and needs to be moved
    //determine which motor
    MotorNum=(MInst[0]&0xf0)>>4;
    98d6:	7803      	ldrb	r3, [r0, #0]

    Motor[MotorNum].Duration=0; //just in case motor is currently running (pulsing)
    98d8:	091b      	lsrs	r3, r3, #4
    98da:	4924      	ldr	r1, [pc, #144]	; (996c <SendMotorInst+0x98>)
    98dc:	222c      	movs	r2, #44	; 0x2c
    98de:	fb02 f203 	mul.w	r2, r2, r3
    98e2:	188c      	adds	r4, r1, r2
    98e4:	2500      	movs	r5, #0
    98e6:	6265      	str	r5, [r4, #36]	; 0x24
    //SYS_TMR_DelayMS(1);  //wait to make sure motor is stopped if running (pulsing)
    Motor[MotorNum].flags|=MOTOR_INST_FIRST_RUN; //first set motor pins to 00 to avoid short circuit
    98e8:	5c8c      	ldrb	r4, [r1, r2]
    98ea:	f044 0402 	orr.w	r4, r4, #2
    98ee:	548c      	strb	r4, [r1, r2]
    //for example, motor is turning with 10 then a 01 instruction is sent, and for a nanosecond when LATB is being set, possibly 2 pins might be 1 and cause a short at the h-bridge.

    //if ((MInst[0]&0x08)!=0) {
    if ((MInst[1]&0x80)!=0) {
    98f0:	f990 2001 	ldrsb.w	r2, [r0, #1]
    98f4:	42aa      	cmp	r2, r5
    98f6:	db2d      	blt.n	9954 <SendMotorInst+0x80>
         Motor[MotorNum].Direction=MOTOR_COUNTERCLOCKWISE;
    } else {
        //clock-wise
        //Motor[MotorNum].DirectionMask=0x80>>(MotorNum*2);  //clockwise
        //Motor[MotorNum].DirectionMask=0x2<<(MotorNum*2);  //clockwise
        Motor[MotorNum].Direction=MOTOR_CLOCKWISE;
    98f8:	222c      	movs	r2, #44	; 0x2c
    98fa:	491c      	ldr	r1, [pc, #112]	; (996c <SendMotorInst+0x98>)
    98fc:	fb02 1203 	mla	r2, r2, r3, r1
    9900:	2100      	movs	r1, #0
    9902:	60d1      	str	r1, [r2, #12]
    //0=stop 20=full speed (NumClkInDutyCycle)
    //this number is multiplied by the NumClocksInMotorDutyCycle/20
    //so for strength=1, Strength*NumClocksInMotorDutyCycle/20 (1 clks of 20 are on)
    //for strength=20 the motor is on for every clock (20 of 20)
    //Motor[MotorNum].Strength=((MInst[0]&0x07)*NumClocksInMotorDutyCycle)/ROBOT_MOTORS_DEFAULT_NUM_CLKS_IN_MOTOR_DUTY_CYCLE;
    Strength=(MInst[1]&0x7f);//max is currently 0 to 127
    9904:	7842      	ldrb	r2, [r0, #1]
    9906:	f002 027f 	and.w	r2, r2, #127	; 0x7f
        Strength=ROBOT_MOTORS_DEFAULT_NUM_CLKS_IN_MOTOR_DUTY_CYCLE;
    }

    //set motor turn duration (is 16-bit little endian int)
    //Motor[MotorNum].Duration=(uint16_t)((MInst[2]<<8)+MInst[1]);
    Duration=(uint32_t)((MInst[3]<<8)+MInst[2]);
    990a:	78c1      	ldrb	r1, [r0, #3]
    990c:	7880      	ldrb	r0, [r0, #2]
    990e:	eb00 2101 	add.w	r1, r0, r1, lsl #8
    //convert ms to 25us units
    //so Duration of 100ms in 25uS units=0.1/0.000025=4000 clocks * 2= 8000
    //in us: (100)*1000/25=4000, so generalizing in us:
    //Duration*1000/MotorDutyCycle = number of TimerInterrupts for 
    //user sent Duration in ms.
    Duration*=1000; //Duration is divided by MotorDutyCycleClock below
    9912:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    9916:	fb00 f001 	mul.w	r0, r0, r1
    //at 40khz (25us) a pulse:
	//duty cycle is 25us*20=500us
	//so 1/20 speed is 25us on 475us off (shortest pulse possible for drv8800- 40khz)
	//   19/20 speed is 475us on 25us off

    Motor[MotorNum].Strength=Strength;
    991a:	212c      	movs	r1, #44	; 0x2c
    991c:	4c13      	ldr	r4, [pc, #76]	; (996c <SendMotorInst+0x98>)
    991e:	fb01 4103 	mla	r1, r1, r3, r4
    9922:	2a14      	cmp	r2, #20
    9924:	bf28      	it	cs
    9926:	2214      	movcs	r2, #20
    9928:	840a      	strh	r2, [r1, #32]
    Motor[MotorNum].StrengthCount=0;
    992a:	2200      	movs	r2, #0
    992c:	844a      	strh	r2, [r1, #34]	; 0x22

    //Convert duration in us to duration in number of timer interrupts
    //since multiplying by 1000 above, I doubt Duration would ever be < MotorDutyCycleClock
    //but just as a failsafe in case Motor[].Duration somehow will get set to 0]
    //and somebody is trying to set strength=0 - probably not needed
    if ((Duration/MotorDutyCycleClock)==0 && Duration>0) {
    992e:	4a10      	ldr	r2, [pc, #64]	; (9970 <SendMotorInst+0x9c>)
    9930:	6812      	ldr	r2, [r2, #0]
    9932:	fbb0 f2f2 	udiv	r2, r0, r2
    9936:	b902      	cbnz	r2, 993a <SendMotorInst+0x66>
    9938:	b990      	cbnz	r0, 9960 <SendMotorInst+0x8c>
      Motor[MotorNum].Duration=1;
    } else {
      Motor[MotorNum].Duration=Duration/MotorDutyCycleClock;  //note: this is the equivalent of enabling the motor
    993a:	212c      	movs	r1, #44	; 0x2c
    993c:	480b      	ldr	r0, [pc, #44]	; (996c <SendMotorInst+0x98>)
    993e:	fb01 0103 	mla	r1, r1, r3, r0
    9942:	624a      	str	r2, [r1, #36]	; 0x24
    } 

    Motor[MotorNum].DurationCount=0;
    9944:	212c      	movs	r1, #44	; 0x2c
    9946:	4a09      	ldr	r2, [pc, #36]	; (996c <SendMotorInst+0x98>)
    9948:	fb01 2303 	mla	r3, r1, r3, r2
    994c:	2200      	movs	r2, #0
    994e:	629a      	str	r2, [r3, #40]	; 0x28

	//was: start timer3 if not already started
} //SendMotorInst
    9950:	bc30      	pop	{r4, r5}
    9952:	4770      	bx	lr
         Motor[MotorNum].Direction=MOTOR_COUNTERCLOCKWISE;
    9954:	222c      	movs	r2, #44	; 0x2c
    9956:	fb02 1203 	mla	r2, r2, r3, r1
    995a:	2101      	movs	r1, #1
    995c:	60d1      	str	r1, [r2, #12]
    995e:	e7d1      	b.n	9904 <SendMotorInst+0x30>
      Motor[MotorNum].Duration=1;
    9960:	222c      	movs	r2, #44	; 0x2c
    9962:	fb02 4203 	mla	r2, r2, r3, r4
    9966:	2101      	movs	r1, #1
    9968:	6251      	str	r1, [r2, #36]	; 0x24
    996a:	e7eb      	b.n	9944 <SendMotorInst+0x70>
    996c:	2000932c 	.word	0x2000932c
    9970:	20009328 	.word	0x20009328

00009974 <USART_1_input>:
{
    9974:	b530      	push	{r4, r5, lr}
    9976:	b085      	sub	sp, #20
    usart_async_get_io_descriptor(&USART_1, &io);	// Get the pointer to statically allocated io_descriptor structure.
    9978:	a903      	add	r1, sp, #12
    997a:	4823      	ldr	r0, [pc, #140]	; (9a08 <USART_1_input+0x94>)
    997c:	4b23      	ldr	r3, [pc, #140]	; (9a0c <USART_1_input+0x98>)
    997e:	4798      	blx	r3
    if( nread <= 0 ) {
    9980:	4b23      	ldr	r3, [pc, #140]	; (9a10 <USART_1_input+0x9c>)
    9982:	6a1b      	ldr	r3, [r3, #32]
    9984:	2b00      	cmp	r3, #0
    9986:	dd01      	ble.n	998c <USART_1_input+0x18>
}
    9988:	b005      	add	sp, #20
    998a:	bd30      	pop	{r4, r5, pc}
        CRITICAL_SECTION_ENTER()
    998c:	a801      	add	r0, sp, #4
    998e:	4b21      	ldr	r3, [pc, #132]	; (9a14 <USART_1_input+0xa0>)
    9990:	4798      	blx	r3
        if(line_available) {
    9992:	4b1f      	ldr	r3, [pc, #124]	; (9a10 <USART_1_input+0x9c>)
    9994:	7a1b      	ldrb	r3, [r3, #8]
    9996:	2b00      	cmp	r3, #0
    9998:	d031      	beq.n	99fe <USART_1_input+0x8a>
            line_available = false;		// Decrementing the semaphore count from 1 to 0.
    999a:	4c1d      	ldr	r4, [pc, #116]	; (9a10 <USART_1_input+0x9c>)
    999c:	2300      	movs	r3, #0
    999e:	7223      	strb	r3, [r4, #8]
        CRITICAL_SECTION_LEAVE()
    99a0:	a801      	add	r0, sp, #4
    99a2:	4b1d      	ldr	r3, [pc, #116]	; (9a18 <USART_1_input+0xa4>)
    99a4:	4798      	blx	r3
			nread = io_read(io, buffer, sizeof(buffer));	// Returns count of characters read (or negative error flag).
    99a6:	f44f 7280 	mov.w	r2, #256	; 0x100
    99aa:	f104 0124 	add.w	r1, r4, #36	; 0x24
    99ae:	9803      	ldr	r0, [sp, #12]
    99b0:	4b1a      	ldr	r3, [pc, #104]	; (9a1c <USART_1_input+0xa8>)
    99b2:	4798      	blx	r3
    99b4:	6220      	str	r0, [r4, #32]
			if (nread>0) {
    99b6:	2800      	cmp	r0, #0
    99b8:	dde6      	ble.n	9988 <USART_1_input+0x14>
				buffer[nread]=0; //terminate string
    99ba:	4420      	add	r0, r4
    99bc:	2500      	movs	r5, #0
    99be:	f880 5024 	strb.w	r5, [r0, #36]	; 0x24
				printf("W: %s:W\n",buffer); //each USART packet ends with 0x0a
    99c2:	f104 0124 	add.w	r1, r4, #36	; 0x24
    99c6:	4816      	ldr	r0, [pc, #88]	; (9a20 <USART_1_input+0xac>)
    99c8:	4b16      	ldr	r3, [pc, #88]	; (9a24 <USART_1_input+0xb0>)
    99ca:	4798      	blx	r3
				nread=0;
    99cc:	6225      	str	r5, [r4, #32]
				if (buffer[4]==ROBOT_MOTORS_SEND_4BYTE_INST) {
    99ce:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    99d2:	2b20      	cmp	r3, #32
    99d4:	d1d8      	bne.n	9988 <USART_1_input+0x14>
					MotorInst[0]=buffer[5];  //Motor Num<<4
    99d6:	f894 2029 	ldrb.w	r2, [r4, #41]	; 0x29
    99da:	f88d 2008 	strb.w	r2, [sp, #8]
					MotorInst[1]=buffer[6];  //Dir+Strength
    99de:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
    99e2:	f88d 2009 	strb.w	r2, [sp, #9]
					MotorInst[2]=buffer[7];  //duration low byte
    99e6:	f894 202b 	ldrb.w	r2, [r4, #43]	; 0x2b
    99ea:	f88d 200a 	strb.w	r2, [sp, #10]
					MotorInst[3]=buffer[8];  //duration high byte
    99ee:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    99f2:	f88d 300b 	strb.w	r3, [sp, #11]
					SendMotorInst(MotorInst);
    99f6:	a802      	add	r0, sp, #8
    99f8:	4b0b      	ldr	r3, [pc, #44]	; (9a28 <USART_1_input+0xb4>)
    99fa:	4798      	blx	r3
}
    99fc:	e7c4      	b.n	9988 <USART_1_input+0x14>
        CRITICAL_SECTION_LEAVE()
    99fe:	a801      	add	r0, sp, #4
    9a00:	4b05      	ldr	r3, [pc, #20]	; (9a18 <USART_1_input+0xa4>)
    9a02:	4798      	blx	r3
    9a04:	e7c0      	b.n	9988 <USART_1_input+0x14>
    9a06:	bf00      	nop
    9a08:	200081fc 	.word	0x200081fc
    9a0c:	00001655 	.word	0x00001655
    9a10:	200080a4 	.word	0x200080a4
    9a14:	00000eb5 	.word	0x00000eb5
    9a18:	00000ec3 	.word	0x00000ec3
    9a1c:	00000fc1 	.word	0x00000fc1
    9a20:	0000c67c 	.word	0x0000c67c
    9a24:	00009fd5 	.word	0x00009fd5
    9a28:	000098d5 	.word	0x000098d5

00009a2c <udpserver_recv>:
	struct io_descriptor *io; //for ESP-01 UART1
	uint8_t buffer[256]; //temporary buffer
	
	//printf("received at %d, echoing to the same port\n",pcb->local_port);
	//dst_ip = &(pcb->remote_ip); // this is zero always
	if (p != NULL) {
    9a2c:	2a00      	cmp	r2, #0
    9a2e:	f000 8088 	beq.w	9b42 <udpserver_recv+0x116>
{
    9a32:	b5f0      	push	{r4, r5, r6, r7, lr}
    9a34:	b0c3      	sub	sp, #268	; 0x10c
    9a36:	4614      	mov	r4, r2
    9a38:	461e      	mov	r6, r3
    9a3a:	460d      	mov	r5, r1
		//printf("UDP rcv %d bytes: ", (*p).len);
		printf("%d ", (*p).len);
    9a3c:	8951      	ldrh	r1, [r2, #10]
    9a3e:	4841      	ldr	r0, [pc, #260]	; (9b44 <udpserver_recv+0x118>)
    9a40:	4b41      	ldr	r3, [pc, #260]	; (9b48 <udpserver_recv+0x11c>)
    9a42:	4798      	blx	r3
		//    	printf("\n");
		//udp_sendto(pcb, p, IP_ADDR_BROADCAST, 1234); //dest port
				//		udp_sendto(pcb, p, &forward_ip, fwd_port); //dest port
				
		//Process any UDP instructions recognized
		if (pcb->local_port==UDP_PORT) {  //note that currently there could never be a different port because UDP server only listens to this port
    9a44:	8a6a      	ldrh	r2, [r5, #18]
    9a46:	f24d 1306 	movw	r3, #53510	; 0xd106
    9a4a:	429a      	cmp	r2, r3
    9a4c:	d004      	beq.n	9a58 <udpserver_recv+0x2c>
				io_write(io, (uint8_t *)&InstData[5], InstLen-5);
			break;
			} //switch

		} //if (pcb->local_port==UDP_PORT) {
		pbuf_free(p);
    9a4e:	4620      	mov	r0, r4
    9a50:	4b3e      	ldr	r3, [pc, #248]	; (9b4c <udpserver_recv+0x120>)
    9a52:	4798      	blx	r3
	} //if (p != NULL) {
} //void udpserver_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
    9a54:	b043      	add	sp, #268	; 0x10c
    9a56:	bdf0      	pop	{r4, r5, r6, r7, pc}
			InstData=(uint8_t *)(*p).payload;  //shorthand to data
    9a58:	6867      	ldr	r7, [r4, #4]
			switch(InstData[4]) //Robot Instruction
    9a5a:	793b      	ldrb	r3, [r7, #4]
    9a5c:	2b01      	cmp	r3, #1
    9a5e:	d03c      	beq.n	9ada <udpserver_recv+0xae>
    9a60:	b1e3      	cbz	r3, 9a9c <udpserver_recv+0x70>
    9a62:	2b20      	cmp	r3, #32
    9a64:	d05d      	beq.n	9b22 <udpserver_recv+0xf6>
    9a66:	2b40      	cmp	r3, #64	; 0x40
    9a68:	d1f1      	bne.n	9a4e <udpserver_recv+0x22>
			InstLen=(*p).len;
    9a6a:	8965      	ldrh	r5, [r4, #10]
				usart_async_get_io_descriptor(&USART_1, &io);
    9a6c:	a940      	add	r1, sp, #256	; 0x100
    9a6e:	4838      	ldr	r0, [pc, #224]	; (9b50 <udpserver_recv+0x124>)
    9a70:	4b38      	ldr	r3, [pc, #224]	; (9b54 <udpserver_recv+0x128>)
    9a72:	4798      	blx	r3
				memcpy(buffer,&InstData[5],InstLen-5);
    9a74:	3705      	adds	r7, #5
    9a76:	3d05      	subs	r5, #5
    9a78:	462a      	mov	r2, r5
    9a7a:	4639      	mov	r1, r7
    9a7c:	4668      	mov	r0, sp
    9a7e:	4b36      	ldr	r3, [pc, #216]	; (9b58 <udpserver_recv+0x12c>)
    9a80:	4798      	blx	r3
				buffer[InstLen-5]=0; //terminate string
    9a82:	2300      	movs	r3, #0
    9a84:	f80d 3005 	strb.w	r3, [sp, r5]
				printf("%s",buffer);
    9a88:	4669      	mov	r1, sp
    9a8a:	4834      	ldr	r0, [pc, #208]	; (9b5c <udpserver_recv+0x130>)
    9a8c:	4b2e      	ldr	r3, [pc, #184]	; (9b48 <udpserver_recv+0x11c>)
    9a8e:	4798      	blx	r3
				io_write(io, (uint8_t *)&InstData[5], InstLen-5);
    9a90:	b2aa      	uxth	r2, r5
    9a92:	4639      	mov	r1, r7
    9a94:	9840      	ldr	r0, [sp, #256]	; 0x100
    9a96:	4b32      	ldr	r3, [pc, #200]	; (9b60 <udpserver_recv+0x134>)
    9a98:	4798      	blx	r3
			break;
    9a9a:	e7d8      	b.n	9a4e <udpserver_recv+0x22>
				retbuf = pbuf_alloc(PBUF_TRANSPORT, 10, PBUF_RAM);
    9a9c:	2200      	movs	r2, #0
    9a9e:	210a      	movs	r1, #10
    9aa0:	4610      	mov	r0, r2
    9aa2:	4b30      	ldr	r3, [pc, #192]	; (9b64 <udpserver_recv+0x138>)
    9aa4:	4798      	blx	r3
    9aa6:	4607      	mov	r7, r0
				ReturnInst=retbuf->payload;
    9aa8:	6843      	ldr	r3, [r0, #4]
				memcpy(ReturnInst,p->payload,5); //copy IP + inst byte to return instruction
    9aaa:	6862      	ldr	r2, [r4, #4]
    9aac:	6811      	ldr	r1, [r2, #0]
    9aae:	6019      	str	r1, [r3, #0]
    9ab0:	7912      	ldrb	r2, [r2, #4]
    9ab2:	711a      	strb	r2, [r3, #4]
				ReturnInst[6]=0x12;
    9ab4:	2212      	movs	r2, #18
    9ab6:	719a      	strb	r2, [r3, #6]
				ReturnInst[7]=0x34;
    9ab8:	2234      	movs	r2, #52	; 0x34
    9aba:	71da      	strb	r2, [r3, #7]
				ReturnInst[8]=0x56;
    9abc:	2256      	movs	r2, #86	; 0x56
    9abe:	721a      	strb	r2, [r3, #8]
				ReturnInst[9]=0x78;
    9ac0:	2278      	movs	r2, #120	; 0x78
    9ac2:	725a      	strb	r2, [r3, #9]
				udp_sendto(pcb, retbuf, addr, UDP_PORT); //dest port
    9ac4:	f24d 1306 	movw	r3, #53510	; 0xd106
    9ac8:	4632      	mov	r2, r6
    9aca:	4601      	mov	r1, r0
    9acc:	4628      	mov	r0, r5
    9ace:	4d26      	ldr	r5, [pc, #152]	; (9b68 <udpserver_recv+0x13c>)
    9ad0:	47a8      	blx	r5
				pbuf_free(retbuf);
    9ad2:	4638      	mov	r0, r7
    9ad4:	4b1d      	ldr	r3, [pc, #116]	; (9b4c <udpserver_recv+0x120>)
    9ad6:	4798      	blx	r3
				break;
    9ad8:	e7b9      	b.n	9a4e <udpserver_recv+0x22>
				retbuf = pbuf_alloc(PBUF_TRANSPORT, 5+sizeof(LWIP_MACIF_hwaddr)+PCB_NAME_LENGTH, PBUF_RAM);
    9ada:	2200      	movs	r2, #0
    9adc:	2110      	movs	r1, #16
    9ade:	4610      	mov	r0, r2
    9ae0:	4b20      	ldr	r3, [pc, #128]	; (9b64 <udpserver_recv+0x138>)
    9ae2:	4798      	blx	r3
    9ae4:	4607      	mov	r7, r0
				ReturnInst=retbuf->payload;
    9ae6:	6843      	ldr	r3, [r0, #4]
				memcpy(ReturnInst,p->payload,5); //copy IP + inst byte to return instruction
    9ae8:	6862      	ldr	r2, [r4, #4]
    9aea:	6811      	ldr	r1, [r2, #0]
    9aec:	6019      	str	r1, [r3, #0]
    9aee:	7912      	ldrb	r2, [r2, #4]
    9af0:	711a      	strb	r2, [r3, #4]
				memcpy(ReturnInst+ReturnInstLen,LWIP_MACIF_hwaddr,sizeof(LWIP_MACIF_hwaddr));//copy mac
    9af2:	4a1e      	ldr	r2, [pc, #120]	; (9b6c <udpserver_recv+0x140>)
    9af4:	6811      	ldr	r1, [r2, #0]
    9af6:	f8c3 1005 	str.w	r1, [r3, #5]
    9afa:	8892      	ldrh	r2, [r2, #4]
    9afc:	f8a3 2009 	strh.w	r2, [r3, #9]
				memcpy(ReturnInst+ReturnInstLen,PCB_Name,PCB_NAME_LENGTH);//copy name
    9b00:	4a1b      	ldr	r2, [pc, #108]	; (9b70 <udpserver_recv+0x144>)
    9b02:	6810      	ldr	r0, [r2, #0]
    9b04:	f8c3 000b 	str.w	r0, [r3, #11]
    9b08:	7912      	ldrb	r2, [r2, #4]
    9b0a:	73da      	strb	r2, [r3, #15]
				udp_sendto(pcb, retbuf, addr, UDP_PORT); //dest port
    9b0c:	f24d 1306 	movw	r3, #53510	; 0xd106
    9b10:	4632      	mov	r2, r6
    9b12:	4639      	mov	r1, r7
    9b14:	4628      	mov	r0, r5
    9b16:	4d14      	ldr	r5, [pc, #80]	; (9b68 <udpserver_recv+0x13c>)
    9b18:	47a8      	blx	r5
				pbuf_free(retbuf);
    9b1a:	4638      	mov	r0, r7
    9b1c:	4b0b      	ldr	r3, [pc, #44]	; (9b4c <udpserver_recv+0x120>)
    9b1e:	4798      	blx	r3
			break;
    9b20:	e795      	b.n	9a4e <udpserver_recv+0x22>
				MotorInst[0]=InstData[5];  //Motor Num<<4
    9b22:	797b      	ldrb	r3, [r7, #5]
    9b24:	f88d 3104 	strb.w	r3, [sp, #260]	; 0x104
				MotorInst[1]=InstData[6];  //Dir+Strength
    9b28:	79bb      	ldrb	r3, [r7, #6]
    9b2a:	f88d 3105 	strb.w	r3, [sp, #261]	; 0x105
				MotorInst[2]=InstData[7];  //duration low byte
    9b2e:	79fb      	ldrb	r3, [r7, #7]
    9b30:	f88d 3106 	strb.w	r3, [sp, #262]	; 0x106
				MotorInst[3]=InstData[8];  //duration high byte
    9b34:	7a3b      	ldrb	r3, [r7, #8]
    9b36:	f88d 3107 	strb.w	r3, [sp, #263]	; 0x107
				SendMotorInst(MotorInst);
    9b3a:	a841      	add	r0, sp, #260	; 0x104
    9b3c:	4b0d      	ldr	r3, [pc, #52]	; (9b74 <udpserver_recv+0x148>)
    9b3e:	4798      	blx	r3
			break; 
    9b40:	e785      	b.n	9a4e <udpserver_recv+0x22>
    9b42:	4770      	bx	lr
    9b44:	0000c688 	.word	0x0000c688
    9b48:	00009fd5 	.word	0x00009fd5
    9b4c:	00005c89 	.word	0x00005c89
    9b50:	200081fc 	.word	0x200081fc
    9b54:	00001655 	.word	0x00001655
    9b58:	00009faf 	.word	0x00009faf
    9b5c:	0000c694 	.word	0x0000c694
    9b60:	00000f91 	.word	0x00000f91
    9b64:	00005cf1 	.word	0x00005cf1
    9b68:	00008dc1 	.word	0x00008dc1
    9b6c:	200082a4 	.word	0x200082a4
    9b70:	0000c68c 	.word	0x0000c68c
    9b74:	000098d5 	.word	0x000098d5

00009b78 <InitializeMotors>:

int InitializeMotors(void) 
{
    9b78:	b410      	push	{r4}
	
	
	//set number of clocks in motor duty cycle
	//is 7 (but was 14), 7 timer2 interrupts make 1 full motor duty cycle
	NumClocksInMotorDutyCycle=ROBOT_MOTORS_DEFAULT_NUM_CLKS_IN_MOTOR_DUTY_CYCLE;
    9b7a:	2214      	movs	r2, #20
    9b7c:	4b14      	ldr	r3, [pc, #80]	; (9bd0 <InitializeMotors+0x58>)
    9b7e:	601a      	str	r2, [r3, #0]
	MotorDutyCycleClock=ROBOT_MOTORS_DEFAULT_MOTOR_DUTY_CYCLE_CLK;
    9b80:	2219      	movs	r2, #25
    9b82:	4b14      	ldr	r3, [pc, #80]	; (9bd4 <InitializeMotors+0x5c>)
    9b84:	601a      	str	r2, [r3, #0]
	
	
	NumMotors=1;
    9b86:	2001      	movs	r0, #1
    9b88:	4b13      	ldr	r3, [pc, #76]	; (9bd8 <InitializeMotors+0x60>)
    9b8a:	7018      	strb	r0, [r3, #0]
	//Clear the robot status array
	memset(Motor,sizeof(MotorStatus)*NumMotors,0);

	//Motor[0].flags|=MOTOR_DRIVER_USES_PULSE_PIN;
	Motor[0].DirPin=GPIO(GPIO_PORTB, 13);
    9b8c:	4b13      	ldr	r3, [pc, #76]	; (9bdc <InitializeMotors+0x64>)
    9b8e:	222d      	movs	r2, #45	; 0x2d
    9b90:	605a      	str	r2, [r3, #4]
	Motor[0].PulsePin=GPIO(GPIO_PORTB, 12);
    9b92:	222c      	movs	r2, #44	; 0x2c
    9b94:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    9b96:	4b12      	ldr	r3, [pc, #72]	; (9be0 <InitializeMotors+0x68>)
    9b98:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    9b9c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    9ba0:	4910      	ldr	r1, [pc, #64]	; (9be4 <InitializeMotors+0x6c>)
    9ba2:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
    9ba6:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
    9baa:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9bae:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    9bb2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    9bb6:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    9bba:	4c0b      	ldr	r4, [pc, #44]	; (9be8 <InitializeMotors+0x70>)
    9bbc:	f8c3 40a8 	str.w	r4, [r3, #168]	; 0xa8
    9bc0:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9bc4:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
	
//	Motor[1].DirPin=GPIO(GPIO_PORTB, 11); //13);
//	Motor[1].PulsePin=GPIO(GPIO_PORTB, 10);//12);

	return(1);
} //int InitializeMotors(void)
    9bc8:	f85d 4b04 	ldr.w	r4, [sp], #4
    9bcc:	4770      	bx	lr
    9bce:	bf00      	nop
    9bd0:	200095ec 	.word	0x200095ec
    9bd4:	20009328 	.word	0x20009328
    9bd8:	20009320 	.word	0x20009320
    9bdc:	2000932c 	.word	0x2000932c
    9be0:	41008000 	.word	0x41008000
    9be4:	40002000 	.word	0x40002000
    9be8:	40001000 	.word	0x40001000

00009bec <main>:


int main(void)
{
    9bec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9bf0:	b0c5      	sub	sp, #276	; 0x114
	u8_t    mac[6];
	u8_t ReadBuffer[256];
	//struct usart_async_status iostat;  //currently needed for usart async

	/* Initializes MCU, drivers and middleware - tph - inits phy and uarts*/
	atmel_start_init();
    9bf2:	4b6d      	ldr	r3, [pc, #436]	; (9da8 <main+0x1bc>)
    9bf4:	4798      	blx	r3
	// Set pin direction to output
	//gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
	//gpio_set_pin_function(LED0, GPIO_PIN_FUNCTION_OFF);

//USART_ASYNC_TXC_CB
	usart_async_register_callback(&USART_1, USART_ASYNC_RXC_CB, usart1_receive_cb);
    9bf6:	4c6d      	ldr	r4, [pc, #436]	; (9dac <main+0x1c0>)
    9bf8:	4a6d      	ldr	r2, [pc, #436]	; (9db0 <main+0x1c4>)
    9bfa:	2100      	movs	r1, #0
    9bfc:	4620      	mov	r0, r4
    9bfe:	4b6d      	ldr	r3, [pc, #436]	; (9db4 <main+0x1c8>)
    9c00:	4798      	blx	r3
	usart_async_enable(&USART_1);
    9c02:	4620      	mov	r0, r4
    9c04:	4b6c      	ldr	r3, [pc, #432]	; (9db8 <main+0x1cc>)
    9c06:	4798      	blx	r3
	mac[0]=0x74;
    9c08:	2374      	movs	r3, #116	; 0x74
    9c0a:	f88d 3004 	strb.w	r3, [sp, #4]
	mac[1]=0x27;
    9c0e:	2327      	movs	r3, #39	; 0x27
    9c10:	f88d 3005 	strb.w	r3, [sp, #5]
	mac[2]=0xea;
    9c14:	23ea      	movs	r3, #234	; 0xea
    9c16:	f88d 3006 	strb.w	r3, [sp, #6]
	mac[3]=0xda;
    9c1a:	23da      	movs	r3, #218	; 0xda
    9c1c:	f88d 3007 	strb.w	r3, [sp, #7]
	mac[4]=0x89;
    9c20:	2389      	movs	r3, #137	; 0x89
    9c22:	f88d 3008 	strb.w	r3, [sp, #8]
	mac[5]=0x85;
    9c26:	2385      	movs	r3, #133	; 0x85
    9c28:	f88d 3009 	strb.w	r3, [sp, #9]


	/* Read MacAddress from EEPROM */  //tph: currently just adding a valid public MAC address
	read_macaddress(mac);

	systick_enable();
    9c2c:	4b63      	ldr	r3, [pc, #396]	; (9dbc <main+0x1d0>)
    9c2e:	4798      	blx	r3

	//MACIF_example();
	
	ETHERNET_PHY_0_example();  //restarts autonegotiation
    9c30:	4b63      	ldr	r3, [pc, #396]	; (9dc0 <main+0x1d4>)
    9c32:	4798      	blx	r3

	//init usart
	usart_sync_get_io_descriptor(&USART_0, &io);
    9c34:	4c63      	ldr	r4, [pc, #396]	; (9dc4 <main+0x1d8>)
    9c36:	a943      	add	r1, sp, #268	; 0x10c
    9c38:	4620      	mov	r0, r4
    9c3a:	4b63      	ldr	r3, [pc, #396]	; (9dc8 <main+0x1dc>)
    9c3c:	4798      	blx	r3
	usart_sync_enable(&USART_0);
    9c3e:	4620      	mov	r0, r4
    9c40:	4b62      	ldr	r3, [pc, #392]	; (9dcc <main+0x1e0>)
    9c42:	4798      	blx	r3
	//usart_async_get_io_descriptor(&USART_0, &io);
	//usart_async_enable(&USART_0);
	count=0;
	sprintf((char *)OutStr,"**************************\n");
    9c44:	4e62      	ldr	r6, [pc, #392]	; (9dd0 <main+0x1e4>)
    9c46:	ad03      	add	r5, sp, #12
    9c48:	4634      	mov	r4, r6
    9c4a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    9c4c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    9c4e:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
    9c52:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	io_write(io,OutStr,strlen(OutStr));
    9c56:	a803      	add	r0, sp, #12
    9c58:	f8df 9204 	ldr.w	r9, [pc, #516]	; 9e60 <main+0x274>
    9c5c:	47c8      	blx	r9
    9c5e:	b282      	uxth	r2, r0
    9c60:	a903      	add	r1, sp, #12
    9c62:	9843      	ldr	r0, [sp, #268]	; 0x10c
    9c64:	f8df 81fc 	ldr.w	r8, [pc, #508]	; 9e64 <main+0x278>
    9c68:	47c0      	blx	r8
	
	//while (usart_async_get_status(&USART_0, &iostat)==ERR_BUSY);
	//sprintf((char *)OutStr,"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\n");
	//io_write(io,OutStr,strlen(OutStr));
	sprintf((char *)OutStr,"EthMotorsArm_DRV8800_rev03\n");
    9c6a:	ad03      	add	r5, sp, #12
    9c6c:	4f59      	ldr	r7, [pc, #356]	; (9dd4 <main+0x1e8>)
    9c6e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    9c70:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    9c72:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    9c76:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	io_write(io,OutStr,strlen(OutStr));
    9c7a:	a803      	add	r0, sp, #12
    9c7c:	47c8      	blx	r9
    9c7e:	b282      	uxth	r2, r0
    9c80:	a903      	add	r1, sp, #12
    9c82:	9843      	ldr	r0, [sp, #268]	; 0x10c
    9c84:	47c0      	blx	r8
	//while (usart_async_get_status(&USART_0, &iostat)==ERR_BUSY);

	//sprintf((char *)OutStr,"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\n");
	//io_write(io,OutStr,strlen(OutStr));
	sprintf((char *)OutStr,"**************************\n");
    9c86:	ad03      	add	r5, sp, #12
    9c88:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    9c8a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    9c8c:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
    9c90:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	io_write(io,OutStr,strlen(OutStr));
    9c94:	a803      	add	r0, sp, #12
    9c96:	47c8      	blx	r9
    9c98:	b282      	uxth	r2, r0
    9c9a:	a903      	add	r1, sp, #12
    9c9c:	9843      	ldr	r0, [sp, #268]	; 0x10c
    9c9e:	47c0      	blx	r8
	//sprintf((char *)OutStr,"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\n");
	//io_write(io,OutStr,strlen(OutStr));



	printf("\r\nHello ATMEL World!\r\n");
    9ca0:	484d      	ldr	r0, [pc, #308]	; (9dd8 <main+0x1ec>)
    9ca2:	4b4e      	ldr	r3, [pc, #312]	; (9ddc <main+0x1f0>)
    9ca4:	4798      	blx	r3
	//fflush(stdio_io);

	//below does not work for printf because printf calls _puts_r which must send one char at a time 
	//while (usart_async_get_status(&USART_0, &iostat)==ERR_BUSY); 

	mac_async_register_callback(&ETHERNET_MAC_0, MAC_ASYNC_RECEIVE_CB, (FUNC_PTR)mac_receive_cb);
    9ca6:	4d4e      	ldr	r5, [pc, #312]	; (9de0 <main+0x1f4>)
    9ca8:	4a4e      	ldr	r2, [pc, #312]	; (9de4 <main+0x1f8>)
    9caa:	2100      	movs	r1, #0
    9cac:	4628      	mov	r0, r5
    9cae:	4c4e      	ldr	r4, [pc, #312]	; (9de8 <main+0x1fc>)
    9cb0:	47a0      	blx	r4
	mac_async_register_callback(&ETHERNET_MAC_0, MAC_ASYNC_TRANSMIT_CB, (FUNC_PTR)mac_transmit_cb);
    9cb2:	4a4e      	ldr	r2, [pc, #312]	; (9dec <main+0x200>)
    9cb4:	2101      	movs	r1, #1
    9cb6:	4628      	mov	r0, r5
    9cb8:	47a0      	blx	r4

	eth_ipstack_init();
    9cba:	4b4d      	ldr	r3, [pc, #308]	; (9df0 <main+0x204>)
    9cbc:	4798      	blx	r3
	do {
		ret = ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_up);
    9cbe:	4f4d      	ldr	r7, [pc, #308]	; (9df4 <main+0x208>)
    9cc0:	f507 7692 	add.w	r6, r7, #292	; 0x124
    9cc4:	4d4c      	ldr	r5, [pc, #304]	; (9df8 <main+0x20c>)
    9cc6:	4c4d      	ldr	r4, [pc, #308]	; (9dfc <main+0x210>)
    9cc8:	4631      	mov	r1, r6
    9cca:	4628      	mov	r0, r5
    9ccc:	47a0      	blx	r4
		if (ret == ERR_NONE && link_up) {
    9cce:	2800      	cmp	r0, #0
    9cd0:	d1fa      	bne.n	9cc8 <main+0xdc>
    9cd2:	f897 3124 	ldrb.w	r3, [r7, #292]	; 0x124
    9cd6:	2b00      	cmp	r3, #0
    9cd8:	d0f6      	beq.n	9cc8 <main+0xdc>
			break;
		}
	} while (true);
	printf("Ethernet Connection established\n");
    9cda:	4849      	ldr	r0, [pc, #292]	; (9e00 <main+0x214>)
    9cdc:	4d3f      	ldr	r5, [pc, #252]	; (9ddc <main+0x1f0>)
    9cde:	47a8      	blx	r5
	LWIP_MACIF_init(mac);  //tph: add LWIP callback for recvd input: ethernet_input()
    9ce0:	a801      	add	r0, sp, #4
    9ce2:	4b48      	ldr	r3, [pc, #288]	; (9e04 <main+0x218>)
    9ce4:	4798      	blx	r3

	//make this the default interface
	netif_set_default(&LWIP_MACIF_desc);
    9ce6:	4c48      	ldr	r4, [pc, #288]	; (9e08 <main+0x21c>)
    9ce8:	4620      	mov	r0, r4
    9cea:	4b48      	ldr	r3, [pc, #288]	; (9e0c <main+0x220>)
    9cec:	4798      	blx	r3
	
	// Set callback function for netif status change 
	netif_set_status_callback(&LWIP_MACIF_desc, status_callback);
    9cee:	4948      	ldr	r1, [pc, #288]	; (9e10 <main+0x224>)
    9cf0:	4620      	mov	r0, r4
    9cf2:	4b48      	ldr	r3, [pc, #288]	; (9e14 <main+0x228>)
    9cf4:	4798      	blx	r3

	//Set callback function for link status change
	netif_set_link_callback(&LWIP_MACIF_desc, link_callback);
    9cf6:	4948      	ldr	r1, [pc, #288]	; (9e18 <main+0x22c>)
    9cf8:	4620      	mov	r0, r4
    9cfa:	4b48      	ldr	r3, [pc, #288]	; (9e1c <main+0x230>)
    9cfc:	4798      	blx	r3

		
	mac_async_enable(&ETHERNET_MAC_0);
    9cfe:	4838      	ldr	r0, [pc, #224]	; (9de0 <main+0x1f4>)
    9d00:	4b47      	ldr	r3, [pc, #284]	; (9e20 <main+0x234>)
    9d02:	4798      	blx	r3


//#if 0 
	//udpecho_init(); //START UDP ECHO THREAD - requires netconn 
	//start_udp();
	udpserver_pcb = udp_new();  //create udp server
    9d04:	4b47      	ldr	r3, [pc, #284]	; (9e24 <main+0x238>)
    9d06:	4798      	blx	r3
    9d08:	4e47      	ldr	r6, [pc, #284]	; (9e28 <main+0x23c>)
    9d0a:	6030      	str	r0, [r6, #0]
	//IP4_ADDR(&forward_ip, 192, 168,   2, 254);
//	udp_bind(udpserver_pcb, IP_ADDR_ANY, UDP_PORT);   //port UDP_PORT 
	udp_bind(udpserver_pcb, &LWIP_MACIF_desc.ip_addr.addr, UDP_PORT);   //port UDP_PORT 
    9d0c:	f24d 1206 	movw	r2, #53510	; 0xd106
    9d10:	1d21      	adds	r1, r4, #4
    9d12:	4b46      	ldr	r3, [pc, #280]	; (9e2c <main+0x240>)
    9d14:	4798      	blx	r3
	udp_recv(udpserver_pcb, udpserver_recv, NULL);  //set udpserver callback function
    9d16:	2200      	movs	r2, #0
    9d18:	4945      	ldr	r1, [pc, #276]	; (9e30 <main+0x244>)
    9d1a:	6830      	ldr	r0, [r6, #0]
    9d1c:	4b45      	ldr	r3, [pc, #276]	; (9e34 <main+0x248>)
    9d1e:	4798      	blx	r3


	//bring up the network interface - ned to do here so above interrupts are enabled
	#ifdef LWIP_DHCP
	/* DHCP mode. */
	if (ERR_OK != dhcp_start(&LWIP_MACIF_desc)) {
    9d20:	4620      	mov	r0, r4
    9d22:	4b45      	ldr	r3, [pc, #276]	; (9e38 <main+0x24c>)
    9d24:	4798      	blx	r3
		LWIP_ASSERT("ERR_OK != dhcp_start", 0);
	}
	printf("DHCP Started\r\n");
    9d26:	4845      	ldr	r0, [pc, #276]	; (9e3c <main+0x250>)
    9d28:	47a8      	blx	r5
	/* Static mode. */
	netif_set_up(&LWIP_MACIF_desc);
	printf("Static IP Address Assigned\r\n");
	#endif

	InitializeMotors(); //set initial settings of all motors
    9d2a:	4b45      	ldr	r3, [pc, #276]	; (9e40 <main+0x254>)
    9d2c:	4798      	blx	r3
	//currently motor timer stop DHCP from working
	MotorTimer_Initialize();  //start timer for motor pwm
    9d2e:	4b45      	ldr	r3, [pc, #276]	; (9e44 <main+0x258>)
    9d30:	4798      	blx	r3
			StartDHCP=0;
			dhcp_start(&LWIP_MACIF_desc); //tph start dhcp
		}
*/

		if (gmac_recv_flag) {
    9d32:	4c30      	ldr	r4, [pc, #192]	; (9df4 <main+0x208>)
			//printf("gmac_recd");
			//sprintf((char *)OutStr,"recvd2\n");
			//io_write(io,OutStr,strlen(OutStr));
			
			gmac_recv_flag = false;
			ethernetif_mac_input(&LWIP_MACIF_desc);
    9d34:	4d34      	ldr	r5, [pc, #208]	; (9e08 <main+0x21c>)
    9d36:	4e44      	ldr	r6, [pc, #272]	; (9e48 <main+0x25c>)
	printf("IP_ADDR    : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.ip_addr), tmp_buff, 16));
    9d38:	f504 7894 	add.w	r8, r4, #296	; 0x128
    9d3c:	1d2f      	adds	r7, r5, #4
	printf("NET_MASK   : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.netmask), tmp_buff, 16));
    9d3e:	f107 0904 	add.w	r9, r7, #4
    9d42:	e006      	b.n	9d52 <main+0x166>
			gmac_recv_flag = false;
    9d44:	2300      	movs	r3, #0
    9d46:	7023      	strb	r3, [r4, #0]
			ethernetif_mac_input(&LWIP_MACIF_desc);
    9d48:	4628      	mov	r0, r5
    9d4a:	47b0      	blx	r6
    9d4c:	e004      	b.n	9d58 <main+0x16c>
	tsr=hri_gmac_read_TSR_reg(GMAC);  //bit 5 tx complete
#endif	
	//could test loop back send and receive: set LBL bit in NCR


	USART_1_input();  //check for usart1 input
    9d4e:	4b3f      	ldr	r3, [pc, #252]	; (9e4c <main+0x260>)
    9d50:	4798      	blx	r3
		if (gmac_recv_flag) {
    9d52:	7823      	ldrb	r3, [r4, #0]
    9d54:	2b00      	cmp	r3, #0
    9d56:	d1f5      	bne.n	9d44 <main+0x158>
		sys_check_timeouts();
    9d58:	4b3d      	ldr	r3, [pc, #244]	; (9e50 <main+0x264>)
    9d5a:	4798      	blx	r3
		if (link_up && LWIP_MACIF_desc.ip_addr.addr) {
    9d5c:	f894 3124 	ldrb.w	r3, [r4, #292]	; 0x124
    9d60:	2b00      	cmp	r3, #0
    9d62:	d0f4      	beq.n	9d4e <main+0x162>
    9d64:	686b      	ldr	r3, [r5, #4]
    9d66:	2b00      	cmp	r3, #0
    9d68:	d0f1      	beq.n	9d4e <main+0x162>
			link_up = false;
    9d6a:	2300      	movs	r3, #0
    9d6c:	f884 3124 	strb.w	r3, [r4, #292]	; 0x124
	printf("IP_ADDR    : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.ip_addr), tmp_buff, 16));
    9d70:	2210      	movs	r2, #16
    9d72:	4641      	mov	r1, r8
    9d74:	4638      	mov	r0, r7
    9d76:	f8df b0f0 	ldr.w	fp, [pc, #240]	; 9e68 <main+0x27c>
    9d7a:	47d8      	blx	fp
    9d7c:	4601      	mov	r1, r0
    9d7e:	4835      	ldr	r0, [pc, #212]	; (9e54 <main+0x268>)
    9d80:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 9e6c <main+0x280>
    9d84:	47d0      	blx	sl
	printf("NET_MASK   : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.netmask), tmp_buff, 16));
    9d86:	2210      	movs	r2, #16
    9d88:	4641      	mov	r1, r8
    9d8a:	4648      	mov	r0, r9
    9d8c:	47d8      	blx	fp
    9d8e:	4601      	mov	r1, r0
    9d90:	4831      	ldr	r0, [pc, #196]	; (9e58 <main+0x26c>)
    9d92:	47d0      	blx	sl
	printf("GATEWAY_IP : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.gw), tmp_buff, 16));
    9d94:	2210      	movs	r2, #16
    9d96:	4641      	mov	r1, r8
    9d98:	f107 0008 	add.w	r0, r7, #8
    9d9c:	47d8      	blx	fp
    9d9e:	4601      	mov	r1, r0
    9da0:	482e      	ldr	r0, [pc, #184]	; (9e5c <main+0x270>)
    9da2:	47d0      	blx	sl
    9da4:	e7d3      	b.n	9d4e <main+0x162>
    9da6:	bf00      	nop
    9da8:	000002d1 	.word	0x000002d1
    9dac:	200081fc 	.word	0x200081fc
    9db0:	00009881 	.word	0x00009881
    9db4:	0000167d 	.word	0x0000167d
    9db8:	00001629 	.word	0x00001629
    9dbc:	0000982d 	.word	0x0000982d
    9dc0:	00000d99 	.word	0x00000d99
    9dc4:	200081f0 	.word	0x200081f0
    9dc8:	00001839 	.word	0x00001839
    9dcc:	0000180d 	.word	0x0000180d
    9dd0:	0000c698 	.word	0x0000c698
    9dd4:	0000c6b4 	.word	0x0000c6b4
    9dd8:	0000c6d0 	.word	0x0000c6d0
    9ddc:	0000a0bd 	.word	0x0000a0bd
    9de0:	2000826c 	.word	0x2000826c
    9de4:	0000975d 	.word	0x0000975d
    9de8:	000010f1 	.word	0x000010f1
    9dec:	00009661 	.word	0x00009661
    9df0:	00000ea9 	.word	0x00000ea9
    9df4:	200080a4 	.word	0x200080a4
    9df8:	200081e8 	.word	0x200081e8
    9dfc:	00000d1d 	.word	0x00000d1d
    9e00:	0000c6e8 	.word	0x0000c6e8
    9e04:	00000e5d 	.word	0x00000e5d
    9e08:	200082ac 	.word	0x200082ac
    9e0c:	00005ad9 	.word	0x00005ad9
    9e10:	00009785 	.word	0x00009785
    9e14:	00005b55 	.word	0x00005b55
    9e18:	000097c9 	.word	0x000097c9
    9e1c:	00005b5b 	.word	0x00005b5b
    9e20:	00001035 	.word	0x00001035
    9e24:	00008e99 	.word	0x00008e99
    9e28:	20009324 	.word	0x20009324
    9e2c:	00008bd5 	.word	0x00008bd5
    9e30:	00009a2d 	.word	0x00009a2d
    9e34:	00008e55 	.word	0x00008e55
    9e38:	00004649 	.word	0x00004649
    9e3c:	0000c708 	.word	0x0000c708
    9e40:	00009b79 	.word	0x00009b79
    9e44:	000098a1 	.word	0x000098a1
    9e48:	00002e1d 	.word	0x00002e1d
    9e4c:	00009975 	.word	0x00009975
    9e50:	00008975 	.word	0x00008975
    9e54:	0000c718 	.word	0x0000c718
    9e58:	0000c72c 	.word	0x0000c72c
    9e5c:	0000c740 	.word	0x0000c740
    9e60:	0000a239 	.word	0x0000a239
    9e64:	00000f91 	.word	0x00000f91
    9e68:	00004f39 	.word	0x00004f39
    9e6c:	00009fd5 	.word	0x00009fd5

00009e70 <_read>:

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
	int n = 0;

	if (file != 0) {
    9e70:	b940      	cbnz	r0, 9e84 <_read+0x14>
{
    9e72:	b508      	push	{r3, lr}
    9e74:	460b      	mov	r3, r1
    9e76:	4611      	mov	r1, r2
    9e78:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
    9e7a:	4b04      	ldr	r3, [pc, #16]	; (9e8c <_read+0x1c>)
    9e7c:	4798      	blx	r3
    9e7e:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
    9e82:	bd08      	pop	{r3, pc}
		return -1;
    9e84:	f04f 30ff 	mov.w	r0, #4294967295
    9e88:	4770      	bx	lr
    9e8a:	bf00      	nop
    9e8c:	00009ee1 	.word	0x00009ee1

00009e90 <_write>:

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
    9e90:	3801      	subs	r0, #1
    9e92:	2802      	cmp	r0, #2
    9e94:	d808      	bhi.n	9ea8 <_write+0x18>
{
    9e96:	b508      	push	{r3, lr}
    9e98:	460b      	mov	r3, r1
    9e9a:	4611      	mov	r1, r2
    9e9c:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    9e9e:	4b04      	ldr	r3, [pc, #16]	; (9eb0 <_write+0x20>)
    9ea0:	4798      	blx	r3
    9ea2:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
    9ea6:	bd08      	pop	{r3, pc}
		return -1;
    9ea8:	f04f 30ff 	mov.w	r0, #4294967295
    9eac:	4770      	bx	lr
    9eae:	bf00      	nop
    9eb0:	00009f05 	.word	0x00009f05

00009eb4 <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
    9eb4:	b570      	push	{r4, r5, r6, lr}
    9eb6:	4606      	mov	r6, r0
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
    9eb8:	4d06      	ldr	r5, [pc, #24]	; (9ed4 <stdio_io_init+0x20>)
    9eba:	682b      	ldr	r3, [r5, #0]
    9ebc:	2100      	movs	r1, #0
    9ebe:	6898      	ldr	r0, [r3, #8]
    9ec0:	4c05      	ldr	r4, [pc, #20]	; (9ed8 <stdio_io_init+0x24>)
    9ec2:	47a0      	blx	r4
	setbuf(stdin, NULL);
    9ec4:	682b      	ldr	r3, [r5, #0]
    9ec6:	2100      	movs	r1, #0
    9ec8:	6858      	ldr	r0, [r3, #4]
    9eca:	47a0      	blx	r4
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
    9ecc:	4b03      	ldr	r3, [pc, #12]	; (9edc <stdio_io_init+0x28>)
    9ece:	601e      	str	r6, [r3, #0]
    9ed0:	bd70      	pop	{r4, r5, r6, pc}
    9ed2:	bf00      	nop
    9ed4:	20000010 	.word	0x20000010
    9ed8:	0000a0cd 	.word	0x0000a0cd
    9edc:	200081dc 	.word	0x200081dc

00009ee0 <stdio_io_read>:
{
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
    9ee0:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
    9ee2:	4b06      	ldr	r3, [pc, #24]	; (9efc <stdio_io_read+0x1c>)
    9ee4:	681b      	ldr	r3, [r3, #0]
    9ee6:	b133      	cbz	r3, 9ef6 <stdio_io_read+0x16>
    9ee8:	460a      	mov	r2, r1
    9eea:	4601      	mov	r1, r0
		return 0;
	}
	return io_read(stdio_io, buf, len);
    9eec:	b292      	uxth	r2, r2
    9eee:	4618      	mov	r0, r3
    9ef0:	4b03      	ldr	r3, [pc, #12]	; (9f00 <stdio_io_read+0x20>)
    9ef2:	4798      	blx	r3
    9ef4:	bd08      	pop	{r3, pc}
		return 0;
    9ef6:	2000      	movs	r0, #0
}
    9ef8:	bd08      	pop	{r3, pc}
    9efa:	bf00      	nop
    9efc:	200081dc 	.word	0x200081dc
    9f00:	00000fc1 	.word	0x00000fc1

00009f04 <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
    9f04:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
    9f06:	4b06      	ldr	r3, [pc, #24]	; (9f20 <stdio_io_write+0x1c>)
    9f08:	681b      	ldr	r3, [r3, #0]
    9f0a:	b133      	cbz	r3, 9f1a <stdio_io_write+0x16>
    9f0c:	460a      	mov	r2, r1
    9f0e:	4601      	mov	r1, r0
		return 0;
	}
	return io_write(stdio_io, buf, len);
    9f10:	b292      	uxth	r2, r2
    9f12:	4618      	mov	r0, r3
    9f14:	4b03      	ldr	r3, [pc, #12]	; (9f24 <stdio_io_write+0x20>)
    9f16:	4798      	blx	r3
    9f18:	bd08      	pop	{r3, pc}
		return 0;
    9f1a:	2000      	movs	r0, #0
}
    9f1c:	bd08      	pop	{r3, pc}
    9f1e:	bf00      	nop
    9f20:	200081dc 	.word	0x200081dc
    9f24:	00000f91 	.word	0x00000f91

00009f28 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
    9f28:	b510      	push	{r4, lr}

	usart_sync_enable(&USART_0);
    9f2a:	4c04      	ldr	r4, [pc, #16]	; (9f3c <stdio_redirect_init+0x14>)
    9f2c:	4620      	mov	r0, r4
    9f2e:	4b04      	ldr	r3, [pc, #16]	; (9f40 <stdio_redirect_init+0x18>)
    9f30:	4798      	blx	r3
	stdio_io_init(&USART_0.io);
    9f32:	4620      	mov	r0, r4
    9f34:	4b03      	ldr	r3, [pc, #12]	; (9f44 <stdio_redirect_init+0x1c>)
    9f36:	4798      	blx	r3
    9f38:	bd10      	pop	{r4, pc}
    9f3a:	bf00      	nop
    9f3c:	200081f0 	.word	0x200081f0
    9f40:	0000180d 	.word	0x0000180d
    9f44:	00009eb5 	.word	0x00009eb5

00009f48 <__libc_init_array>:
    9f48:	b570      	push	{r4, r5, r6, lr}
    9f4a:	4e0d      	ldr	r6, [pc, #52]	; (9f80 <__libc_init_array+0x38>)
    9f4c:	4c0d      	ldr	r4, [pc, #52]	; (9f84 <__libc_init_array+0x3c>)
    9f4e:	1ba4      	subs	r4, r4, r6
    9f50:	10a4      	asrs	r4, r4, #2
    9f52:	2500      	movs	r5, #0
    9f54:	42a5      	cmp	r5, r4
    9f56:	d109      	bne.n	9f6c <__libc_init_array+0x24>
    9f58:	4e0b      	ldr	r6, [pc, #44]	; (9f88 <__libc_init_array+0x40>)
    9f5a:	4c0c      	ldr	r4, [pc, #48]	; (9f8c <__libc_init_array+0x44>)
    9f5c:	f002 fc46 	bl	c7ec <_init>
    9f60:	1ba4      	subs	r4, r4, r6
    9f62:	10a4      	asrs	r4, r4, #2
    9f64:	2500      	movs	r5, #0
    9f66:	42a5      	cmp	r5, r4
    9f68:	d105      	bne.n	9f76 <__libc_init_array+0x2e>
    9f6a:	bd70      	pop	{r4, r5, r6, pc}
    9f6c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    9f70:	4798      	blx	r3
    9f72:	3501      	adds	r5, #1
    9f74:	e7ee      	b.n	9f54 <__libc_init_array+0xc>
    9f76:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    9f7a:	4798      	blx	r3
    9f7c:	3501      	adds	r5, #1
    9f7e:	e7f2      	b.n	9f66 <__libc_init_array+0x1e>
    9f80:	0000c7f8 	.word	0x0000c7f8
    9f84:	0000c7f8 	.word	0x0000c7f8
    9f88:	0000c7f8 	.word	0x0000c7f8
    9f8c:	0000c7fc 	.word	0x0000c7fc

00009f90 <memcmp>:
    9f90:	b510      	push	{r4, lr}
    9f92:	3901      	subs	r1, #1
    9f94:	4402      	add	r2, r0
    9f96:	4290      	cmp	r0, r2
    9f98:	d101      	bne.n	9f9e <memcmp+0xe>
    9f9a:	2000      	movs	r0, #0
    9f9c:	bd10      	pop	{r4, pc}
    9f9e:	f810 3b01 	ldrb.w	r3, [r0], #1
    9fa2:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    9fa6:	42a3      	cmp	r3, r4
    9fa8:	d0f5      	beq.n	9f96 <memcmp+0x6>
    9faa:	1b18      	subs	r0, r3, r4
    9fac:	bd10      	pop	{r4, pc}

00009fae <memcpy>:
    9fae:	b510      	push	{r4, lr}
    9fb0:	1e43      	subs	r3, r0, #1
    9fb2:	440a      	add	r2, r1
    9fb4:	4291      	cmp	r1, r2
    9fb6:	d100      	bne.n	9fba <memcpy+0xc>
    9fb8:	bd10      	pop	{r4, pc}
    9fba:	f811 4b01 	ldrb.w	r4, [r1], #1
    9fbe:	f803 4f01 	strb.w	r4, [r3, #1]!
    9fc2:	e7f7      	b.n	9fb4 <memcpy+0x6>

00009fc4 <memset>:
    9fc4:	4402      	add	r2, r0
    9fc6:	4603      	mov	r3, r0
    9fc8:	4293      	cmp	r3, r2
    9fca:	d100      	bne.n	9fce <memset+0xa>
    9fcc:	4770      	bx	lr
    9fce:	f803 1b01 	strb.w	r1, [r3], #1
    9fd2:	e7f9      	b.n	9fc8 <memset+0x4>

00009fd4 <iprintf>:
    9fd4:	b40f      	push	{r0, r1, r2, r3}
    9fd6:	4b0a      	ldr	r3, [pc, #40]	; (a000 <iprintf+0x2c>)
    9fd8:	b513      	push	{r0, r1, r4, lr}
    9fda:	681c      	ldr	r4, [r3, #0]
    9fdc:	b124      	cbz	r4, 9fe8 <iprintf+0x14>
    9fde:	69a3      	ldr	r3, [r4, #24]
    9fe0:	b913      	cbnz	r3, 9fe8 <iprintf+0x14>
    9fe2:	4620      	mov	r0, r4
    9fe4:	f000 fae2 	bl	a5ac <__sinit>
    9fe8:	ab05      	add	r3, sp, #20
    9fea:	9a04      	ldr	r2, [sp, #16]
    9fec:	68a1      	ldr	r1, [r4, #8]
    9fee:	9301      	str	r3, [sp, #4]
    9ff0:	4620      	mov	r0, r4
    9ff2:	f000 fca5 	bl	a940 <_vfiprintf_r>
    9ff6:	b002      	add	sp, #8
    9ff8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    9ffc:	b004      	add	sp, #16
    9ffe:	4770      	bx	lr
    a000:	20000010 	.word	0x20000010

0000a004 <_puts_r>:
    a004:	b570      	push	{r4, r5, r6, lr}
    a006:	460e      	mov	r6, r1
    a008:	4605      	mov	r5, r0
    a00a:	b118      	cbz	r0, a014 <_puts_r+0x10>
    a00c:	6983      	ldr	r3, [r0, #24]
    a00e:	b90b      	cbnz	r3, a014 <_puts_r+0x10>
    a010:	f000 facc 	bl	a5ac <__sinit>
    a014:	69ab      	ldr	r3, [r5, #24]
    a016:	68ac      	ldr	r4, [r5, #8]
    a018:	b913      	cbnz	r3, a020 <_puts_r+0x1c>
    a01a:	4628      	mov	r0, r5
    a01c:	f000 fac6 	bl	a5ac <__sinit>
    a020:	4b23      	ldr	r3, [pc, #140]	; (a0b0 <_puts_r+0xac>)
    a022:	429c      	cmp	r4, r3
    a024:	d117      	bne.n	a056 <_puts_r+0x52>
    a026:	686c      	ldr	r4, [r5, #4]
    a028:	89a3      	ldrh	r3, [r4, #12]
    a02a:	071b      	lsls	r3, r3, #28
    a02c:	d51d      	bpl.n	a06a <_puts_r+0x66>
    a02e:	6923      	ldr	r3, [r4, #16]
    a030:	b1db      	cbz	r3, a06a <_puts_r+0x66>
    a032:	3e01      	subs	r6, #1
    a034:	68a3      	ldr	r3, [r4, #8]
    a036:	f816 1f01 	ldrb.w	r1, [r6, #1]!
    a03a:	3b01      	subs	r3, #1
    a03c:	60a3      	str	r3, [r4, #8]
    a03e:	b9e9      	cbnz	r1, a07c <_puts_r+0x78>
    a040:	2b00      	cmp	r3, #0
    a042:	da2e      	bge.n	a0a2 <_puts_r+0x9e>
    a044:	4622      	mov	r2, r4
    a046:	210a      	movs	r1, #10
    a048:	4628      	mov	r0, r5
    a04a:	f000 f8fd 	bl	a248 <__swbuf_r>
    a04e:	3001      	adds	r0, #1
    a050:	d011      	beq.n	a076 <_puts_r+0x72>
    a052:	200a      	movs	r0, #10
    a054:	bd70      	pop	{r4, r5, r6, pc}
    a056:	4b17      	ldr	r3, [pc, #92]	; (a0b4 <_puts_r+0xb0>)
    a058:	429c      	cmp	r4, r3
    a05a:	d101      	bne.n	a060 <_puts_r+0x5c>
    a05c:	68ac      	ldr	r4, [r5, #8]
    a05e:	e7e3      	b.n	a028 <_puts_r+0x24>
    a060:	4b15      	ldr	r3, [pc, #84]	; (a0b8 <_puts_r+0xb4>)
    a062:	429c      	cmp	r4, r3
    a064:	bf08      	it	eq
    a066:	68ec      	ldreq	r4, [r5, #12]
    a068:	e7de      	b.n	a028 <_puts_r+0x24>
    a06a:	4621      	mov	r1, r4
    a06c:	4628      	mov	r0, r5
    a06e:	f000 f93d 	bl	a2ec <__swsetup_r>
    a072:	2800      	cmp	r0, #0
    a074:	d0dd      	beq.n	a032 <_puts_r+0x2e>
    a076:	f04f 30ff 	mov.w	r0, #4294967295
    a07a:	bd70      	pop	{r4, r5, r6, pc}
    a07c:	2b00      	cmp	r3, #0
    a07e:	da04      	bge.n	a08a <_puts_r+0x86>
    a080:	69a2      	ldr	r2, [r4, #24]
    a082:	4293      	cmp	r3, r2
    a084:	db06      	blt.n	a094 <_puts_r+0x90>
    a086:	290a      	cmp	r1, #10
    a088:	d004      	beq.n	a094 <_puts_r+0x90>
    a08a:	6823      	ldr	r3, [r4, #0]
    a08c:	1c5a      	adds	r2, r3, #1
    a08e:	6022      	str	r2, [r4, #0]
    a090:	7019      	strb	r1, [r3, #0]
    a092:	e7cf      	b.n	a034 <_puts_r+0x30>
    a094:	4622      	mov	r2, r4
    a096:	4628      	mov	r0, r5
    a098:	f000 f8d6 	bl	a248 <__swbuf_r>
    a09c:	3001      	adds	r0, #1
    a09e:	d1c9      	bne.n	a034 <_puts_r+0x30>
    a0a0:	e7e9      	b.n	a076 <_puts_r+0x72>
    a0a2:	6823      	ldr	r3, [r4, #0]
    a0a4:	200a      	movs	r0, #10
    a0a6:	1c5a      	adds	r2, r3, #1
    a0a8:	6022      	str	r2, [r4, #0]
    a0aa:	7018      	strb	r0, [r3, #0]
    a0ac:	bd70      	pop	{r4, r5, r6, pc}
    a0ae:	bf00      	nop
    a0b0:	0000c778 	.word	0x0000c778
    a0b4:	0000c798 	.word	0x0000c798
    a0b8:	0000c758 	.word	0x0000c758

0000a0bc <puts>:
    a0bc:	4b02      	ldr	r3, [pc, #8]	; (a0c8 <puts+0xc>)
    a0be:	4601      	mov	r1, r0
    a0c0:	6818      	ldr	r0, [r3, #0]
    a0c2:	f7ff bf9f 	b.w	a004 <_puts_r>
    a0c6:	bf00      	nop
    a0c8:	20000010 	.word	0x20000010

0000a0cc <setbuf>:
    a0cc:	2900      	cmp	r1, #0
    a0ce:	f44f 6380 	mov.w	r3, #1024	; 0x400
    a0d2:	bf0c      	ite	eq
    a0d4:	2202      	moveq	r2, #2
    a0d6:	2200      	movne	r2, #0
    a0d8:	f000 b800 	b.w	a0dc <setvbuf>

0000a0dc <setvbuf>:
    a0dc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    a0e0:	461d      	mov	r5, r3
    a0e2:	4b51      	ldr	r3, [pc, #324]	; (a228 <setvbuf+0x14c>)
    a0e4:	681e      	ldr	r6, [r3, #0]
    a0e6:	4604      	mov	r4, r0
    a0e8:	460f      	mov	r7, r1
    a0ea:	4690      	mov	r8, r2
    a0ec:	b126      	cbz	r6, a0f8 <setvbuf+0x1c>
    a0ee:	69b3      	ldr	r3, [r6, #24]
    a0f0:	b913      	cbnz	r3, a0f8 <setvbuf+0x1c>
    a0f2:	4630      	mov	r0, r6
    a0f4:	f000 fa5a 	bl	a5ac <__sinit>
    a0f8:	4b4c      	ldr	r3, [pc, #304]	; (a22c <setvbuf+0x150>)
    a0fa:	429c      	cmp	r4, r3
    a0fc:	d152      	bne.n	a1a4 <setvbuf+0xc8>
    a0fe:	6874      	ldr	r4, [r6, #4]
    a100:	f1b8 0f02 	cmp.w	r8, #2
    a104:	d006      	beq.n	a114 <setvbuf+0x38>
    a106:	f1b8 0f01 	cmp.w	r8, #1
    a10a:	f200 8089 	bhi.w	a220 <setvbuf+0x144>
    a10e:	2d00      	cmp	r5, #0
    a110:	f2c0 8086 	blt.w	a220 <setvbuf+0x144>
    a114:	4621      	mov	r1, r4
    a116:	4630      	mov	r0, r6
    a118:	f000 f9de 	bl	a4d8 <_fflush_r>
    a11c:	6b61      	ldr	r1, [r4, #52]	; 0x34
    a11e:	b141      	cbz	r1, a132 <setvbuf+0x56>
    a120:	f104 0344 	add.w	r3, r4, #68	; 0x44
    a124:	4299      	cmp	r1, r3
    a126:	d002      	beq.n	a12e <setvbuf+0x52>
    a128:	4630      	mov	r0, r6
    a12a:	f000 fb35 	bl	a798 <_free_r>
    a12e:	2300      	movs	r3, #0
    a130:	6363      	str	r3, [r4, #52]	; 0x34
    a132:	2300      	movs	r3, #0
    a134:	61a3      	str	r3, [r4, #24]
    a136:	6063      	str	r3, [r4, #4]
    a138:	89a3      	ldrh	r3, [r4, #12]
    a13a:	061b      	lsls	r3, r3, #24
    a13c:	d503      	bpl.n	a146 <setvbuf+0x6a>
    a13e:	6921      	ldr	r1, [r4, #16]
    a140:	4630      	mov	r0, r6
    a142:	f000 fb29 	bl	a798 <_free_r>
    a146:	89a3      	ldrh	r3, [r4, #12]
    a148:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
    a14c:	f023 0303 	bic.w	r3, r3, #3
    a150:	f1b8 0f02 	cmp.w	r8, #2
    a154:	81a3      	strh	r3, [r4, #12]
    a156:	d05d      	beq.n	a214 <setvbuf+0x138>
    a158:	ab01      	add	r3, sp, #4
    a15a:	466a      	mov	r2, sp
    a15c:	4621      	mov	r1, r4
    a15e:	4630      	mov	r0, r6
    a160:	f000 faae 	bl	a6c0 <__swhatbuf_r>
    a164:	89a3      	ldrh	r3, [r4, #12]
    a166:	4318      	orrs	r0, r3
    a168:	81a0      	strh	r0, [r4, #12]
    a16a:	bb2d      	cbnz	r5, a1b8 <setvbuf+0xdc>
    a16c:	9d00      	ldr	r5, [sp, #0]
    a16e:	4628      	mov	r0, r5
    a170:	f000 fb0a 	bl	a788 <malloc>
    a174:	4607      	mov	r7, r0
    a176:	2800      	cmp	r0, #0
    a178:	d14e      	bne.n	a218 <setvbuf+0x13c>
    a17a:	f8dd 9000 	ldr.w	r9, [sp]
    a17e:	45a9      	cmp	r9, r5
    a180:	d13c      	bne.n	a1fc <setvbuf+0x120>
    a182:	f04f 30ff 	mov.w	r0, #4294967295
    a186:	89a3      	ldrh	r3, [r4, #12]
    a188:	f043 0302 	orr.w	r3, r3, #2
    a18c:	81a3      	strh	r3, [r4, #12]
    a18e:	2300      	movs	r3, #0
    a190:	60a3      	str	r3, [r4, #8]
    a192:	f104 0347 	add.w	r3, r4, #71	; 0x47
    a196:	6023      	str	r3, [r4, #0]
    a198:	6123      	str	r3, [r4, #16]
    a19a:	2301      	movs	r3, #1
    a19c:	6163      	str	r3, [r4, #20]
    a19e:	b003      	add	sp, #12
    a1a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    a1a4:	4b22      	ldr	r3, [pc, #136]	; (a230 <setvbuf+0x154>)
    a1a6:	429c      	cmp	r4, r3
    a1a8:	d101      	bne.n	a1ae <setvbuf+0xd2>
    a1aa:	68b4      	ldr	r4, [r6, #8]
    a1ac:	e7a8      	b.n	a100 <setvbuf+0x24>
    a1ae:	4b21      	ldr	r3, [pc, #132]	; (a234 <setvbuf+0x158>)
    a1b0:	429c      	cmp	r4, r3
    a1b2:	bf08      	it	eq
    a1b4:	68f4      	ldreq	r4, [r6, #12]
    a1b6:	e7a3      	b.n	a100 <setvbuf+0x24>
    a1b8:	2f00      	cmp	r7, #0
    a1ba:	d0d8      	beq.n	a16e <setvbuf+0x92>
    a1bc:	69b3      	ldr	r3, [r6, #24]
    a1be:	b913      	cbnz	r3, a1c6 <setvbuf+0xea>
    a1c0:	4630      	mov	r0, r6
    a1c2:	f000 f9f3 	bl	a5ac <__sinit>
    a1c6:	f1b8 0f01 	cmp.w	r8, #1
    a1ca:	bf08      	it	eq
    a1cc:	89a3      	ldrheq	r3, [r4, #12]
    a1ce:	6027      	str	r7, [r4, #0]
    a1d0:	bf04      	itt	eq
    a1d2:	f043 0301 	orreq.w	r3, r3, #1
    a1d6:	81a3      	strheq	r3, [r4, #12]
    a1d8:	89a3      	ldrh	r3, [r4, #12]
    a1da:	6127      	str	r7, [r4, #16]
    a1dc:	f013 0008 	ands.w	r0, r3, #8
    a1e0:	6165      	str	r5, [r4, #20]
    a1e2:	d01b      	beq.n	a21c <setvbuf+0x140>
    a1e4:	f013 0001 	ands.w	r0, r3, #1
    a1e8:	bf18      	it	ne
    a1ea:	426d      	negne	r5, r5
    a1ec:	f04f 0300 	mov.w	r3, #0
    a1f0:	bf1d      	ittte	ne
    a1f2:	60a3      	strne	r3, [r4, #8]
    a1f4:	61a5      	strne	r5, [r4, #24]
    a1f6:	4618      	movne	r0, r3
    a1f8:	60a5      	streq	r5, [r4, #8]
    a1fa:	e7d0      	b.n	a19e <setvbuf+0xc2>
    a1fc:	4648      	mov	r0, r9
    a1fe:	f000 fac3 	bl	a788 <malloc>
    a202:	4607      	mov	r7, r0
    a204:	2800      	cmp	r0, #0
    a206:	d0bc      	beq.n	a182 <setvbuf+0xa6>
    a208:	89a3      	ldrh	r3, [r4, #12]
    a20a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    a20e:	81a3      	strh	r3, [r4, #12]
    a210:	464d      	mov	r5, r9
    a212:	e7d3      	b.n	a1bc <setvbuf+0xe0>
    a214:	2000      	movs	r0, #0
    a216:	e7b6      	b.n	a186 <setvbuf+0xaa>
    a218:	46a9      	mov	r9, r5
    a21a:	e7f5      	b.n	a208 <setvbuf+0x12c>
    a21c:	60a0      	str	r0, [r4, #8]
    a21e:	e7be      	b.n	a19e <setvbuf+0xc2>
    a220:	f04f 30ff 	mov.w	r0, #4294967295
    a224:	e7bb      	b.n	a19e <setvbuf+0xc2>
    a226:	bf00      	nop
    a228:	20000010 	.word	0x20000010
    a22c:	0000c778 	.word	0x0000c778
    a230:	0000c798 	.word	0x0000c798
    a234:	0000c758 	.word	0x0000c758

0000a238 <strlen>:
    a238:	4603      	mov	r3, r0
    a23a:	f813 2b01 	ldrb.w	r2, [r3], #1
    a23e:	2a00      	cmp	r2, #0
    a240:	d1fb      	bne.n	a23a <strlen+0x2>
    a242:	1a18      	subs	r0, r3, r0
    a244:	3801      	subs	r0, #1
    a246:	4770      	bx	lr

0000a248 <__swbuf_r>:
    a248:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a24a:	460e      	mov	r6, r1
    a24c:	4614      	mov	r4, r2
    a24e:	4605      	mov	r5, r0
    a250:	b118      	cbz	r0, a25a <__swbuf_r+0x12>
    a252:	6983      	ldr	r3, [r0, #24]
    a254:	b90b      	cbnz	r3, a25a <__swbuf_r+0x12>
    a256:	f000 f9a9 	bl	a5ac <__sinit>
    a25a:	4b21      	ldr	r3, [pc, #132]	; (a2e0 <__swbuf_r+0x98>)
    a25c:	429c      	cmp	r4, r3
    a25e:	d12a      	bne.n	a2b6 <__swbuf_r+0x6e>
    a260:	686c      	ldr	r4, [r5, #4]
    a262:	69a3      	ldr	r3, [r4, #24]
    a264:	60a3      	str	r3, [r4, #8]
    a266:	89a3      	ldrh	r3, [r4, #12]
    a268:	071a      	lsls	r2, r3, #28
    a26a:	d52e      	bpl.n	a2ca <__swbuf_r+0x82>
    a26c:	6923      	ldr	r3, [r4, #16]
    a26e:	b363      	cbz	r3, a2ca <__swbuf_r+0x82>
    a270:	6923      	ldr	r3, [r4, #16]
    a272:	6820      	ldr	r0, [r4, #0]
    a274:	1ac0      	subs	r0, r0, r3
    a276:	6963      	ldr	r3, [r4, #20]
    a278:	b2f6      	uxtb	r6, r6
    a27a:	4298      	cmp	r0, r3
    a27c:	4637      	mov	r7, r6
    a27e:	db04      	blt.n	a28a <__swbuf_r+0x42>
    a280:	4621      	mov	r1, r4
    a282:	4628      	mov	r0, r5
    a284:	f000 f928 	bl	a4d8 <_fflush_r>
    a288:	bb28      	cbnz	r0, a2d6 <__swbuf_r+0x8e>
    a28a:	68a3      	ldr	r3, [r4, #8]
    a28c:	3b01      	subs	r3, #1
    a28e:	60a3      	str	r3, [r4, #8]
    a290:	6823      	ldr	r3, [r4, #0]
    a292:	1c5a      	adds	r2, r3, #1
    a294:	6022      	str	r2, [r4, #0]
    a296:	701e      	strb	r6, [r3, #0]
    a298:	6963      	ldr	r3, [r4, #20]
    a29a:	3001      	adds	r0, #1
    a29c:	4298      	cmp	r0, r3
    a29e:	d004      	beq.n	a2aa <__swbuf_r+0x62>
    a2a0:	89a3      	ldrh	r3, [r4, #12]
    a2a2:	07db      	lsls	r3, r3, #31
    a2a4:	d519      	bpl.n	a2da <__swbuf_r+0x92>
    a2a6:	2e0a      	cmp	r6, #10
    a2a8:	d117      	bne.n	a2da <__swbuf_r+0x92>
    a2aa:	4621      	mov	r1, r4
    a2ac:	4628      	mov	r0, r5
    a2ae:	f000 f913 	bl	a4d8 <_fflush_r>
    a2b2:	b190      	cbz	r0, a2da <__swbuf_r+0x92>
    a2b4:	e00f      	b.n	a2d6 <__swbuf_r+0x8e>
    a2b6:	4b0b      	ldr	r3, [pc, #44]	; (a2e4 <__swbuf_r+0x9c>)
    a2b8:	429c      	cmp	r4, r3
    a2ba:	d101      	bne.n	a2c0 <__swbuf_r+0x78>
    a2bc:	68ac      	ldr	r4, [r5, #8]
    a2be:	e7d0      	b.n	a262 <__swbuf_r+0x1a>
    a2c0:	4b09      	ldr	r3, [pc, #36]	; (a2e8 <__swbuf_r+0xa0>)
    a2c2:	429c      	cmp	r4, r3
    a2c4:	bf08      	it	eq
    a2c6:	68ec      	ldreq	r4, [r5, #12]
    a2c8:	e7cb      	b.n	a262 <__swbuf_r+0x1a>
    a2ca:	4621      	mov	r1, r4
    a2cc:	4628      	mov	r0, r5
    a2ce:	f000 f80d 	bl	a2ec <__swsetup_r>
    a2d2:	2800      	cmp	r0, #0
    a2d4:	d0cc      	beq.n	a270 <__swbuf_r+0x28>
    a2d6:	f04f 37ff 	mov.w	r7, #4294967295
    a2da:	4638      	mov	r0, r7
    a2dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a2de:	bf00      	nop
    a2e0:	0000c778 	.word	0x0000c778
    a2e4:	0000c798 	.word	0x0000c798
    a2e8:	0000c758 	.word	0x0000c758

0000a2ec <__swsetup_r>:
    a2ec:	4b32      	ldr	r3, [pc, #200]	; (a3b8 <__swsetup_r+0xcc>)
    a2ee:	b570      	push	{r4, r5, r6, lr}
    a2f0:	681d      	ldr	r5, [r3, #0]
    a2f2:	4606      	mov	r6, r0
    a2f4:	460c      	mov	r4, r1
    a2f6:	b125      	cbz	r5, a302 <__swsetup_r+0x16>
    a2f8:	69ab      	ldr	r3, [r5, #24]
    a2fa:	b913      	cbnz	r3, a302 <__swsetup_r+0x16>
    a2fc:	4628      	mov	r0, r5
    a2fe:	f000 f955 	bl	a5ac <__sinit>
    a302:	4b2e      	ldr	r3, [pc, #184]	; (a3bc <__swsetup_r+0xd0>)
    a304:	429c      	cmp	r4, r3
    a306:	d10f      	bne.n	a328 <__swsetup_r+0x3c>
    a308:	686c      	ldr	r4, [r5, #4]
    a30a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a30e:	b29a      	uxth	r2, r3
    a310:	0715      	lsls	r5, r2, #28
    a312:	d42c      	bmi.n	a36e <__swsetup_r+0x82>
    a314:	06d0      	lsls	r0, r2, #27
    a316:	d411      	bmi.n	a33c <__swsetup_r+0x50>
    a318:	2209      	movs	r2, #9
    a31a:	6032      	str	r2, [r6, #0]
    a31c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a320:	81a3      	strh	r3, [r4, #12]
    a322:	f04f 30ff 	mov.w	r0, #4294967295
    a326:	bd70      	pop	{r4, r5, r6, pc}
    a328:	4b25      	ldr	r3, [pc, #148]	; (a3c0 <__swsetup_r+0xd4>)
    a32a:	429c      	cmp	r4, r3
    a32c:	d101      	bne.n	a332 <__swsetup_r+0x46>
    a32e:	68ac      	ldr	r4, [r5, #8]
    a330:	e7eb      	b.n	a30a <__swsetup_r+0x1e>
    a332:	4b24      	ldr	r3, [pc, #144]	; (a3c4 <__swsetup_r+0xd8>)
    a334:	429c      	cmp	r4, r3
    a336:	bf08      	it	eq
    a338:	68ec      	ldreq	r4, [r5, #12]
    a33a:	e7e6      	b.n	a30a <__swsetup_r+0x1e>
    a33c:	0751      	lsls	r1, r2, #29
    a33e:	d512      	bpl.n	a366 <__swsetup_r+0x7a>
    a340:	6b61      	ldr	r1, [r4, #52]	; 0x34
    a342:	b141      	cbz	r1, a356 <__swsetup_r+0x6a>
    a344:	f104 0344 	add.w	r3, r4, #68	; 0x44
    a348:	4299      	cmp	r1, r3
    a34a:	d002      	beq.n	a352 <__swsetup_r+0x66>
    a34c:	4630      	mov	r0, r6
    a34e:	f000 fa23 	bl	a798 <_free_r>
    a352:	2300      	movs	r3, #0
    a354:	6363      	str	r3, [r4, #52]	; 0x34
    a356:	89a3      	ldrh	r3, [r4, #12]
    a358:	f023 0324 	bic.w	r3, r3, #36	; 0x24
    a35c:	81a3      	strh	r3, [r4, #12]
    a35e:	2300      	movs	r3, #0
    a360:	6063      	str	r3, [r4, #4]
    a362:	6923      	ldr	r3, [r4, #16]
    a364:	6023      	str	r3, [r4, #0]
    a366:	89a3      	ldrh	r3, [r4, #12]
    a368:	f043 0308 	orr.w	r3, r3, #8
    a36c:	81a3      	strh	r3, [r4, #12]
    a36e:	6923      	ldr	r3, [r4, #16]
    a370:	b94b      	cbnz	r3, a386 <__swsetup_r+0x9a>
    a372:	89a3      	ldrh	r3, [r4, #12]
    a374:	f403 7320 	and.w	r3, r3, #640	; 0x280
    a378:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    a37c:	d003      	beq.n	a386 <__swsetup_r+0x9a>
    a37e:	4621      	mov	r1, r4
    a380:	4630      	mov	r0, r6
    a382:	f000 f9c1 	bl	a708 <__smakebuf_r>
    a386:	89a2      	ldrh	r2, [r4, #12]
    a388:	f012 0301 	ands.w	r3, r2, #1
    a38c:	d00c      	beq.n	a3a8 <__swsetup_r+0xbc>
    a38e:	2300      	movs	r3, #0
    a390:	60a3      	str	r3, [r4, #8]
    a392:	6963      	ldr	r3, [r4, #20]
    a394:	425b      	negs	r3, r3
    a396:	61a3      	str	r3, [r4, #24]
    a398:	6923      	ldr	r3, [r4, #16]
    a39a:	b953      	cbnz	r3, a3b2 <__swsetup_r+0xc6>
    a39c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a3a0:	f013 0080 	ands.w	r0, r3, #128	; 0x80
    a3a4:	d1ba      	bne.n	a31c <__swsetup_r+0x30>
    a3a6:	bd70      	pop	{r4, r5, r6, pc}
    a3a8:	0792      	lsls	r2, r2, #30
    a3aa:	bf58      	it	pl
    a3ac:	6963      	ldrpl	r3, [r4, #20]
    a3ae:	60a3      	str	r3, [r4, #8]
    a3b0:	e7f2      	b.n	a398 <__swsetup_r+0xac>
    a3b2:	2000      	movs	r0, #0
    a3b4:	e7f7      	b.n	a3a6 <__swsetup_r+0xba>
    a3b6:	bf00      	nop
    a3b8:	20000010 	.word	0x20000010
    a3bc:	0000c778 	.word	0x0000c778
    a3c0:	0000c798 	.word	0x0000c798
    a3c4:	0000c758 	.word	0x0000c758

0000a3c8 <__sflush_r>:
    a3c8:	898a      	ldrh	r2, [r1, #12]
    a3ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a3ce:	4605      	mov	r5, r0
    a3d0:	0710      	lsls	r0, r2, #28
    a3d2:	460c      	mov	r4, r1
    a3d4:	d45a      	bmi.n	a48c <__sflush_r+0xc4>
    a3d6:	684b      	ldr	r3, [r1, #4]
    a3d8:	2b00      	cmp	r3, #0
    a3da:	dc05      	bgt.n	a3e8 <__sflush_r+0x20>
    a3dc:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    a3de:	2b00      	cmp	r3, #0
    a3e0:	dc02      	bgt.n	a3e8 <__sflush_r+0x20>
    a3e2:	2000      	movs	r0, #0
    a3e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a3e8:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    a3ea:	2e00      	cmp	r6, #0
    a3ec:	d0f9      	beq.n	a3e2 <__sflush_r+0x1a>
    a3ee:	2300      	movs	r3, #0
    a3f0:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
    a3f4:	682f      	ldr	r7, [r5, #0]
    a3f6:	602b      	str	r3, [r5, #0]
    a3f8:	d033      	beq.n	a462 <__sflush_r+0x9a>
    a3fa:	6d60      	ldr	r0, [r4, #84]	; 0x54
    a3fc:	89a3      	ldrh	r3, [r4, #12]
    a3fe:	075a      	lsls	r2, r3, #29
    a400:	d505      	bpl.n	a40e <__sflush_r+0x46>
    a402:	6863      	ldr	r3, [r4, #4]
    a404:	1ac0      	subs	r0, r0, r3
    a406:	6b63      	ldr	r3, [r4, #52]	; 0x34
    a408:	b10b      	cbz	r3, a40e <__sflush_r+0x46>
    a40a:	6c23      	ldr	r3, [r4, #64]	; 0x40
    a40c:	1ac0      	subs	r0, r0, r3
    a40e:	2300      	movs	r3, #0
    a410:	4602      	mov	r2, r0
    a412:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    a414:	6a21      	ldr	r1, [r4, #32]
    a416:	4628      	mov	r0, r5
    a418:	47b0      	blx	r6
    a41a:	1c43      	adds	r3, r0, #1
    a41c:	89a3      	ldrh	r3, [r4, #12]
    a41e:	d106      	bne.n	a42e <__sflush_r+0x66>
    a420:	6829      	ldr	r1, [r5, #0]
    a422:	291d      	cmp	r1, #29
    a424:	d84b      	bhi.n	a4be <__sflush_r+0xf6>
    a426:	4a2b      	ldr	r2, [pc, #172]	; (a4d4 <__sflush_r+0x10c>)
    a428:	40ca      	lsrs	r2, r1
    a42a:	07d6      	lsls	r6, r2, #31
    a42c:	d547      	bpl.n	a4be <__sflush_r+0xf6>
    a42e:	2200      	movs	r2, #0
    a430:	6062      	str	r2, [r4, #4]
    a432:	04d9      	lsls	r1, r3, #19
    a434:	6922      	ldr	r2, [r4, #16]
    a436:	6022      	str	r2, [r4, #0]
    a438:	d504      	bpl.n	a444 <__sflush_r+0x7c>
    a43a:	1c42      	adds	r2, r0, #1
    a43c:	d101      	bne.n	a442 <__sflush_r+0x7a>
    a43e:	682b      	ldr	r3, [r5, #0]
    a440:	b903      	cbnz	r3, a444 <__sflush_r+0x7c>
    a442:	6560      	str	r0, [r4, #84]	; 0x54
    a444:	6b61      	ldr	r1, [r4, #52]	; 0x34
    a446:	602f      	str	r7, [r5, #0]
    a448:	2900      	cmp	r1, #0
    a44a:	d0ca      	beq.n	a3e2 <__sflush_r+0x1a>
    a44c:	f104 0344 	add.w	r3, r4, #68	; 0x44
    a450:	4299      	cmp	r1, r3
    a452:	d002      	beq.n	a45a <__sflush_r+0x92>
    a454:	4628      	mov	r0, r5
    a456:	f000 f99f 	bl	a798 <_free_r>
    a45a:	2000      	movs	r0, #0
    a45c:	6360      	str	r0, [r4, #52]	; 0x34
    a45e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a462:	6a21      	ldr	r1, [r4, #32]
    a464:	2301      	movs	r3, #1
    a466:	4628      	mov	r0, r5
    a468:	47b0      	blx	r6
    a46a:	1c41      	adds	r1, r0, #1
    a46c:	d1c6      	bne.n	a3fc <__sflush_r+0x34>
    a46e:	682b      	ldr	r3, [r5, #0]
    a470:	2b00      	cmp	r3, #0
    a472:	d0c3      	beq.n	a3fc <__sflush_r+0x34>
    a474:	2b1d      	cmp	r3, #29
    a476:	d001      	beq.n	a47c <__sflush_r+0xb4>
    a478:	2b16      	cmp	r3, #22
    a47a:	d101      	bne.n	a480 <__sflush_r+0xb8>
    a47c:	602f      	str	r7, [r5, #0]
    a47e:	e7b0      	b.n	a3e2 <__sflush_r+0x1a>
    a480:	89a3      	ldrh	r3, [r4, #12]
    a482:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a486:	81a3      	strh	r3, [r4, #12]
    a488:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a48c:	690f      	ldr	r7, [r1, #16]
    a48e:	2f00      	cmp	r7, #0
    a490:	d0a7      	beq.n	a3e2 <__sflush_r+0x1a>
    a492:	0793      	lsls	r3, r2, #30
    a494:	680e      	ldr	r6, [r1, #0]
    a496:	bf08      	it	eq
    a498:	694b      	ldreq	r3, [r1, #20]
    a49a:	600f      	str	r7, [r1, #0]
    a49c:	bf18      	it	ne
    a49e:	2300      	movne	r3, #0
    a4a0:	eba6 0807 	sub.w	r8, r6, r7
    a4a4:	608b      	str	r3, [r1, #8]
    a4a6:	f1b8 0f00 	cmp.w	r8, #0
    a4aa:	dd9a      	ble.n	a3e2 <__sflush_r+0x1a>
    a4ac:	4643      	mov	r3, r8
    a4ae:	463a      	mov	r2, r7
    a4b0:	6a21      	ldr	r1, [r4, #32]
    a4b2:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    a4b4:	4628      	mov	r0, r5
    a4b6:	47b0      	blx	r6
    a4b8:	2800      	cmp	r0, #0
    a4ba:	dc07      	bgt.n	a4cc <__sflush_r+0x104>
    a4bc:	89a3      	ldrh	r3, [r4, #12]
    a4be:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a4c2:	81a3      	strh	r3, [r4, #12]
    a4c4:	f04f 30ff 	mov.w	r0, #4294967295
    a4c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a4cc:	4407      	add	r7, r0
    a4ce:	eba8 0800 	sub.w	r8, r8, r0
    a4d2:	e7e8      	b.n	a4a6 <__sflush_r+0xde>
    a4d4:	20400001 	.word	0x20400001

0000a4d8 <_fflush_r>:
    a4d8:	b538      	push	{r3, r4, r5, lr}
    a4da:	690b      	ldr	r3, [r1, #16]
    a4dc:	4605      	mov	r5, r0
    a4de:	460c      	mov	r4, r1
    a4e0:	b1db      	cbz	r3, a51a <_fflush_r+0x42>
    a4e2:	b118      	cbz	r0, a4ec <_fflush_r+0x14>
    a4e4:	6983      	ldr	r3, [r0, #24]
    a4e6:	b90b      	cbnz	r3, a4ec <_fflush_r+0x14>
    a4e8:	f000 f860 	bl	a5ac <__sinit>
    a4ec:	4b0c      	ldr	r3, [pc, #48]	; (a520 <_fflush_r+0x48>)
    a4ee:	429c      	cmp	r4, r3
    a4f0:	d109      	bne.n	a506 <_fflush_r+0x2e>
    a4f2:	686c      	ldr	r4, [r5, #4]
    a4f4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a4f8:	b17b      	cbz	r3, a51a <_fflush_r+0x42>
    a4fa:	4621      	mov	r1, r4
    a4fc:	4628      	mov	r0, r5
    a4fe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    a502:	f7ff bf61 	b.w	a3c8 <__sflush_r>
    a506:	4b07      	ldr	r3, [pc, #28]	; (a524 <_fflush_r+0x4c>)
    a508:	429c      	cmp	r4, r3
    a50a:	d101      	bne.n	a510 <_fflush_r+0x38>
    a50c:	68ac      	ldr	r4, [r5, #8]
    a50e:	e7f1      	b.n	a4f4 <_fflush_r+0x1c>
    a510:	4b05      	ldr	r3, [pc, #20]	; (a528 <_fflush_r+0x50>)
    a512:	429c      	cmp	r4, r3
    a514:	bf08      	it	eq
    a516:	68ec      	ldreq	r4, [r5, #12]
    a518:	e7ec      	b.n	a4f4 <_fflush_r+0x1c>
    a51a:	2000      	movs	r0, #0
    a51c:	bd38      	pop	{r3, r4, r5, pc}
    a51e:	bf00      	nop
    a520:	0000c778 	.word	0x0000c778
    a524:	0000c798 	.word	0x0000c798
    a528:	0000c758 	.word	0x0000c758

0000a52c <_cleanup_r>:
    a52c:	4901      	ldr	r1, [pc, #4]	; (a534 <_cleanup_r+0x8>)
    a52e:	f000 b8a9 	b.w	a684 <_fwalk_reent>
    a532:	bf00      	nop
    a534:	0000a4d9 	.word	0x0000a4d9

0000a538 <std.isra.0>:
    a538:	2300      	movs	r3, #0
    a53a:	b510      	push	{r4, lr}
    a53c:	4604      	mov	r4, r0
    a53e:	6003      	str	r3, [r0, #0]
    a540:	6043      	str	r3, [r0, #4]
    a542:	6083      	str	r3, [r0, #8]
    a544:	8181      	strh	r1, [r0, #12]
    a546:	6643      	str	r3, [r0, #100]	; 0x64
    a548:	81c2      	strh	r2, [r0, #14]
    a54a:	6103      	str	r3, [r0, #16]
    a54c:	6143      	str	r3, [r0, #20]
    a54e:	6183      	str	r3, [r0, #24]
    a550:	4619      	mov	r1, r3
    a552:	2208      	movs	r2, #8
    a554:	305c      	adds	r0, #92	; 0x5c
    a556:	f7ff fd35 	bl	9fc4 <memset>
    a55a:	4b05      	ldr	r3, [pc, #20]	; (a570 <std.isra.0+0x38>)
    a55c:	6263      	str	r3, [r4, #36]	; 0x24
    a55e:	4b05      	ldr	r3, [pc, #20]	; (a574 <std.isra.0+0x3c>)
    a560:	62a3      	str	r3, [r4, #40]	; 0x28
    a562:	4b05      	ldr	r3, [pc, #20]	; (a578 <std.isra.0+0x40>)
    a564:	62e3      	str	r3, [r4, #44]	; 0x2c
    a566:	4b05      	ldr	r3, [pc, #20]	; (a57c <std.isra.0+0x44>)
    a568:	6224      	str	r4, [r4, #32]
    a56a:	6323      	str	r3, [r4, #48]	; 0x30
    a56c:	bd10      	pop	{r4, pc}
    a56e:	bf00      	nop
    a570:	0000aeb9 	.word	0x0000aeb9
    a574:	0000aedb 	.word	0x0000aedb
    a578:	0000af13 	.word	0x0000af13
    a57c:	0000af37 	.word	0x0000af37

0000a580 <__sfmoreglue>:
    a580:	b570      	push	{r4, r5, r6, lr}
    a582:	1e4a      	subs	r2, r1, #1
    a584:	2568      	movs	r5, #104	; 0x68
    a586:	4355      	muls	r5, r2
    a588:	460e      	mov	r6, r1
    a58a:	f105 0174 	add.w	r1, r5, #116	; 0x74
    a58e:	f000 f951 	bl	a834 <_malloc_r>
    a592:	4604      	mov	r4, r0
    a594:	b140      	cbz	r0, a5a8 <__sfmoreglue+0x28>
    a596:	2100      	movs	r1, #0
    a598:	e880 0042 	stmia.w	r0, {r1, r6}
    a59c:	300c      	adds	r0, #12
    a59e:	60a0      	str	r0, [r4, #8]
    a5a0:	f105 0268 	add.w	r2, r5, #104	; 0x68
    a5a4:	f7ff fd0e 	bl	9fc4 <memset>
    a5a8:	4620      	mov	r0, r4
    a5aa:	bd70      	pop	{r4, r5, r6, pc}

0000a5ac <__sinit>:
    a5ac:	6983      	ldr	r3, [r0, #24]
    a5ae:	b510      	push	{r4, lr}
    a5b0:	4604      	mov	r4, r0
    a5b2:	bb33      	cbnz	r3, a602 <__sinit+0x56>
    a5b4:	6483      	str	r3, [r0, #72]	; 0x48
    a5b6:	64c3      	str	r3, [r0, #76]	; 0x4c
    a5b8:	6503      	str	r3, [r0, #80]	; 0x50
    a5ba:	4b12      	ldr	r3, [pc, #72]	; (a604 <__sinit+0x58>)
    a5bc:	4a12      	ldr	r2, [pc, #72]	; (a608 <__sinit+0x5c>)
    a5be:	681b      	ldr	r3, [r3, #0]
    a5c0:	6282      	str	r2, [r0, #40]	; 0x28
    a5c2:	4298      	cmp	r0, r3
    a5c4:	bf04      	itt	eq
    a5c6:	2301      	moveq	r3, #1
    a5c8:	6183      	streq	r3, [r0, #24]
    a5ca:	f000 f81f 	bl	a60c <__sfp>
    a5ce:	6060      	str	r0, [r4, #4]
    a5d0:	4620      	mov	r0, r4
    a5d2:	f000 f81b 	bl	a60c <__sfp>
    a5d6:	60a0      	str	r0, [r4, #8]
    a5d8:	4620      	mov	r0, r4
    a5da:	f000 f817 	bl	a60c <__sfp>
    a5de:	2200      	movs	r2, #0
    a5e0:	60e0      	str	r0, [r4, #12]
    a5e2:	2104      	movs	r1, #4
    a5e4:	6860      	ldr	r0, [r4, #4]
    a5e6:	f7ff ffa7 	bl	a538 <std.isra.0>
    a5ea:	2201      	movs	r2, #1
    a5ec:	2109      	movs	r1, #9
    a5ee:	68a0      	ldr	r0, [r4, #8]
    a5f0:	f7ff ffa2 	bl	a538 <std.isra.0>
    a5f4:	2202      	movs	r2, #2
    a5f6:	2112      	movs	r1, #18
    a5f8:	68e0      	ldr	r0, [r4, #12]
    a5fa:	f7ff ff9d 	bl	a538 <std.isra.0>
    a5fe:	2301      	movs	r3, #1
    a600:	61a3      	str	r3, [r4, #24]
    a602:	bd10      	pop	{r4, pc}
    a604:	0000c754 	.word	0x0000c754
    a608:	0000a52d 	.word	0x0000a52d

0000a60c <__sfp>:
    a60c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a60e:	4b1c      	ldr	r3, [pc, #112]	; (a680 <__sfp+0x74>)
    a610:	681e      	ldr	r6, [r3, #0]
    a612:	69b3      	ldr	r3, [r6, #24]
    a614:	4607      	mov	r7, r0
    a616:	b913      	cbnz	r3, a61e <__sfp+0x12>
    a618:	4630      	mov	r0, r6
    a61a:	f7ff ffc7 	bl	a5ac <__sinit>
    a61e:	3648      	adds	r6, #72	; 0x48
    a620:	68b4      	ldr	r4, [r6, #8]
    a622:	6873      	ldr	r3, [r6, #4]
    a624:	3b01      	subs	r3, #1
    a626:	d503      	bpl.n	a630 <__sfp+0x24>
    a628:	6833      	ldr	r3, [r6, #0]
    a62a:	b133      	cbz	r3, a63a <__sfp+0x2e>
    a62c:	6836      	ldr	r6, [r6, #0]
    a62e:	e7f7      	b.n	a620 <__sfp+0x14>
    a630:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
    a634:	b16d      	cbz	r5, a652 <__sfp+0x46>
    a636:	3468      	adds	r4, #104	; 0x68
    a638:	e7f4      	b.n	a624 <__sfp+0x18>
    a63a:	2104      	movs	r1, #4
    a63c:	4638      	mov	r0, r7
    a63e:	f7ff ff9f 	bl	a580 <__sfmoreglue>
    a642:	6030      	str	r0, [r6, #0]
    a644:	2800      	cmp	r0, #0
    a646:	d1f1      	bne.n	a62c <__sfp+0x20>
    a648:	230c      	movs	r3, #12
    a64a:	603b      	str	r3, [r7, #0]
    a64c:	4604      	mov	r4, r0
    a64e:	4620      	mov	r0, r4
    a650:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a652:	f64f 73ff 	movw	r3, #65535	; 0xffff
    a656:	81e3      	strh	r3, [r4, #14]
    a658:	2301      	movs	r3, #1
    a65a:	81a3      	strh	r3, [r4, #12]
    a65c:	6665      	str	r5, [r4, #100]	; 0x64
    a65e:	6025      	str	r5, [r4, #0]
    a660:	60a5      	str	r5, [r4, #8]
    a662:	6065      	str	r5, [r4, #4]
    a664:	6125      	str	r5, [r4, #16]
    a666:	6165      	str	r5, [r4, #20]
    a668:	61a5      	str	r5, [r4, #24]
    a66a:	2208      	movs	r2, #8
    a66c:	4629      	mov	r1, r5
    a66e:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    a672:	f7ff fca7 	bl	9fc4 <memset>
    a676:	6365      	str	r5, [r4, #52]	; 0x34
    a678:	63a5      	str	r5, [r4, #56]	; 0x38
    a67a:	64a5      	str	r5, [r4, #72]	; 0x48
    a67c:	64e5      	str	r5, [r4, #76]	; 0x4c
    a67e:	e7e6      	b.n	a64e <__sfp+0x42>
    a680:	0000c754 	.word	0x0000c754

0000a684 <_fwalk_reent>:
    a684:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a688:	4680      	mov	r8, r0
    a68a:	4689      	mov	r9, r1
    a68c:	f100 0448 	add.w	r4, r0, #72	; 0x48
    a690:	2600      	movs	r6, #0
    a692:	b914      	cbnz	r4, a69a <_fwalk_reent+0x16>
    a694:	4630      	mov	r0, r6
    a696:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a69a:	68a5      	ldr	r5, [r4, #8]
    a69c:	6867      	ldr	r7, [r4, #4]
    a69e:	3f01      	subs	r7, #1
    a6a0:	d501      	bpl.n	a6a6 <_fwalk_reent+0x22>
    a6a2:	6824      	ldr	r4, [r4, #0]
    a6a4:	e7f5      	b.n	a692 <_fwalk_reent+0xe>
    a6a6:	89ab      	ldrh	r3, [r5, #12]
    a6a8:	2b01      	cmp	r3, #1
    a6aa:	d907      	bls.n	a6bc <_fwalk_reent+0x38>
    a6ac:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
    a6b0:	3301      	adds	r3, #1
    a6b2:	d003      	beq.n	a6bc <_fwalk_reent+0x38>
    a6b4:	4629      	mov	r1, r5
    a6b6:	4640      	mov	r0, r8
    a6b8:	47c8      	blx	r9
    a6ba:	4306      	orrs	r6, r0
    a6bc:	3568      	adds	r5, #104	; 0x68
    a6be:	e7ee      	b.n	a69e <_fwalk_reent+0x1a>

0000a6c0 <__swhatbuf_r>:
    a6c0:	b570      	push	{r4, r5, r6, lr}
    a6c2:	460e      	mov	r6, r1
    a6c4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    a6c8:	2900      	cmp	r1, #0
    a6ca:	b090      	sub	sp, #64	; 0x40
    a6cc:	4614      	mov	r4, r2
    a6ce:	461d      	mov	r5, r3
    a6d0:	da07      	bge.n	a6e2 <__swhatbuf_r+0x22>
    a6d2:	2300      	movs	r3, #0
    a6d4:	602b      	str	r3, [r5, #0]
    a6d6:	89b3      	ldrh	r3, [r6, #12]
    a6d8:	061a      	lsls	r2, r3, #24
    a6da:	d410      	bmi.n	a6fe <__swhatbuf_r+0x3e>
    a6dc:	f44f 6380 	mov.w	r3, #1024	; 0x400
    a6e0:	e00e      	b.n	a700 <__swhatbuf_r+0x40>
    a6e2:	aa01      	add	r2, sp, #4
    a6e4:	f000 fc4e 	bl	af84 <_fstat_r>
    a6e8:	2800      	cmp	r0, #0
    a6ea:	dbf2      	blt.n	a6d2 <__swhatbuf_r+0x12>
    a6ec:	9a02      	ldr	r2, [sp, #8]
    a6ee:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
    a6f2:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
    a6f6:	425a      	negs	r2, r3
    a6f8:	415a      	adcs	r2, r3
    a6fa:	602a      	str	r2, [r5, #0]
    a6fc:	e7ee      	b.n	a6dc <__swhatbuf_r+0x1c>
    a6fe:	2340      	movs	r3, #64	; 0x40
    a700:	2000      	movs	r0, #0
    a702:	6023      	str	r3, [r4, #0]
    a704:	b010      	add	sp, #64	; 0x40
    a706:	bd70      	pop	{r4, r5, r6, pc}

0000a708 <__smakebuf_r>:
    a708:	898b      	ldrh	r3, [r1, #12]
    a70a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    a70c:	079d      	lsls	r5, r3, #30
    a70e:	4606      	mov	r6, r0
    a710:	460c      	mov	r4, r1
    a712:	d507      	bpl.n	a724 <__smakebuf_r+0x1c>
    a714:	f104 0347 	add.w	r3, r4, #71	; 0x47
    a718:	6023      	str	r3, [r4, #0]
    a71a:	6123      	str	r3, [r4, #16]
    a71c:	2301      	movs	r3, #1
    a71e:	6163      	str	r3, [r4, #20]
    a720:	b002      	add	sp, #8
    a722:	bd70      	pop	{r4, r5, r6, pc}
    a724:	ab01      	add	r3, sp, #4
    a726:	466a      	mov	r2, sp
    a728:	f7ff ffca 	bl	a6c0 <__swhatbuf_r>
    a72c:	9900      	ldr	r1, [sp, #0]
    a72e:	4605      	mov	r5, r0
    a730:	4630      	mov	r0, r6
    a732:	f000 f87f 	bl	a834 <_malloc_r>
    a736:	b948      	cbnz	r0, a74c <__smakebuf_r+0x44>
    a738:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a73c:	059a      	lsls	r2, r3, #22
    a73e:	d4ef      	bmi.n	a720 <__smakebuf_r+0x18>
    a740:	f023 0303 	bic.w	r3, r3, #3
    a744:	f043 0302 	orr.w	r3, r3, #2
    a748:	81a3      	strh	r3, [r4, #12]
    a74a:	e7e3      	b.n	a714 <__smakebuf_r+0xc>
    a74c:	4b0d      	ldr	r3, [pc, #52]	; (a784 <__smakebuf_r+0x7c>)
    a74e:	62b3      	str	r3, [r6, #40]	; 0x28
    a750:	89a3      	ldrh	r3, [r4, #12]
    a752:	6020      	str	r0, [r4, #0]
    a754:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    a758:	81a3      	strh	r3, [r4, #12]
    a75a:	9b00      	ldr	r3, [sp, #0]
    a75c:	6163      	str	r3, [r4, #20]
    a75e:	9b01      	ldr	r3, [sp, #4]
    a760:	6120      	str	r0, [r4, #16]
    a762:	b15b      	cbz	r3, a77c <__smakebuf_r+0x74>
    a764:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    a768:	4630      	mov	r0, r6
    a76a:	f000 fc1d 	bl	afa8 <_isatty_r>
    a76e:	b128      	cbz	r0, a77c <__smakebuf_r+0x74>
    a770:	89a3      	ldrh	r3, [r4, #12]
    a772:	f023 0303 	bic.w	r3, r3, #3
    a776:	f043 0301 	orr.w	r3, r3, #1
    a77a:	81a3      	strh	r3, [r4, #12]
    a77c:	89a3      	ldrh	r3, [r4, #12]
    a77e:	431d      	orrs	r5, r3
    a780:	81a5      	strh	r5, [r4, #12]
    a782:	e7cd      	b.n	a720 <__smakebuf_r+0x18>
    a784:	0000a52d 	.word	0x0000a52d

0000a788 <malloc>:
    a788:	4b02      	ldr	r3, [pc, #8]	; (a794 <malloc+0xc>)
    a78a:	4601      	mov	r1, r0
    a78c:	6818      	ldr	r0, [r3, #0]
    a78e:	f000 b851 	b.w	a834 <_malloc_r>
    a792:	bf00      	nop
    a794:	20000010 	.word	0x20000010

0000a798 <_free_r>:
    a798:	b538      	push	{r3, r4, r5, lr}
    a79a:	4605      	mov	r5, r0
    a79c:	2900      	cmp	r1, #0
    a79e:	d045      	beq.n	a82c <_free_r+0x94>
    a7a0:	f851 3c04 	ldr.w	r3, [r1, #-4]
    a7a4:	1f0c      	subs	r4, r1, #4
    a7a6:	2b00      	cmp	r3, #0
    a7a8:	bfb8      	it	lt
    a7aa:	18e4      	addlt	r4, r4, r3
    a7ac:	f000 fc70 	bl	b090 <__malloc_lock>
    a7b0:	4a1f      	ldr	r2, [pc, #124]	; (a830 <_free_r+0x98>)
    a7b2:	6813      	ldr	r3, [r2, #0]
    a7b4:	4610      	mov	r0, r2
    a7b6:	b933      	cbnz	r3, a7c6 <_free_r+0x2e>
    a7b8:	6063      	str	r3, [r4, #4]
    a7ba:	6014      	str	r4, [r2, #0]
    a7bc:	4628      	mov	r0, r5
    a7be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    a7c2:	f000 bc66 	b.w	b092 <__malloc_unlock>
    a7c6:	42a3      	cmp	r3, r4
    a7c8:	d90c      	bls.n	a7e4 <_free_r+0x4c>
    a7ca:	6821      	ldr	r1, [r4, #0]
    a7cc:	1862      	adds	r2, r4, r1
    a7ce:	4293      	cmp	r3, r2
    a7d0:	bf04      	itt	eq
    a7d2:	681a      	ldreq	r2, [r3, #0]
    a7d4:	685b      	ldreq	r3, [r3, #4]
    a7d6:	6063      	str	r3, [r4, #4]
    a7d8:	bf04      	itt	eq
    a7da:	1852      	addeq	r2, r2, r1
    a7dc:	6022      	streq	r2, [r4, #0]
    a7de:	6004      	str	r4, [r0, #0]
    a7e0:	e7ec      	b.n	a7bc <_free_r+0x24>
    a7e2:	4613      	mov	r3, r2
    a7e4:	685a      	ldr	r2, [r3, #4]
    a7e6:	b10a      	cbz	r2, a7ec <_free_r+0x54>
    a7e8:	42a2      	cmp	r2, r4
    a7ea:	d9fa      	bls.n	a7e2 <_free_r+0x4a>
    a7ec:	6819      	ldr	r1, [r3, #0]
    a7ee:	1858      	adds	r0, r3, r1
    a7f0:	42a0      	cmp	r0, r4
    a7f2:	d10b      	bne.n	a80c <_free_r+0x74>
    a7f4:	6820      	ldr	r0, [r4, #0]
    a7f6:	4401      	add	r1, r0
    a7f8:	1858      	adds	r0, r3, r1
    a7fa:	4282      	cmp	r2, r0
    a7fc:	6019      	str	r1, [r3, #0]
    a7fe:	d1dd      	bne.n	a7bc <_free_r+0x24>
    a800:	6810      	ldr	r0, [r2, #0]
    a802:	6852      	ldr	r2, [r2, #4]
    a804:	605a      	str	r2, [r3, #4]
    a806:	4401      	add	r1, r0
    a808:	6019      	str	r1, [r3, #0]
    a80a:	e7d7      	b.n	a7bc <_free_r+0x24>
    a80c:	d902      	bls.n	a814 <_free_r+0x7c>
    a80e:	230c      	movs	r3, #12
    a810:	602b      	str	r3, [r5, #0]
    a812:	e7d3      	b.n	a7bc <_free_r+0x24>
    a814:	6820      	ldr	r0, [r4, #0]
    a816:	1821      	adds	r1, r4, r0
    a818:	428a      	cmp	r2, r1
    a81a:	bf04      	itt	eq
    a81c:	6811      	ldreq	r1, [r2, #0]
    a81e:	6852      	ldreq	r2, [r2, #4]
    a820:	6062      	str	r2, [r4, #4]
    a822:	bf04      	itt	eq
    a824:	1809      	addeq	r1, r1, r0
    a826:	6021      	streq	r1, [r4, #0]
    a828:	605c      	str	r4, [r3, #4]
    a82a:	e7c7      	b.n	a7bc <_free_r+0x24>
    a82c:	bd38      	pop	{r3, r4, r5, pc}
    a82e:	bf00      	nop
    a830:	200081e0 	.word	0x200081e0

0000a834 <_malloc_r>:
    a834:	b570      	push	{r4, r5, r6, lr}
    a836:	1ccd      	adds	r5, r1, #3
    a838:	f025 0503 	bic.w	r5, r5, #3
    a83c:	3508      	adds	r5, #8
    a83e:	2d0c      	cmp	r5, #12
    a840:	bf38      	it	cc
    a842:	250c      	movcc	r5, #12
    a844:	2d00      	cmp	r5, #0
    a846:	4606      	mov	r6, r0
    a848:	db01      	blt.n	a84e <_malloc_r+0x1a>
    a84a:	42a9      	cmp	r1, r5
    a84c:	d903      	bls.n	a856 <_malloc_r+0x22>
    a84e:	230c      	movs	r3, #12
    a850:	6033      	str	r3, [r6, #0]
    a852:	2000      	movs	r0, #0
    a854:	bd70      	pop	{r4, r5, r6, pc}
    a856:	f000 fc1b 	bl	b090 <__malloc_lock>
    a85a:	4a23      	ldr	r2, [pc, #140]	; (a8e8 <_malloc_r+0xb4>)
    a85c:	6814      	ldr	r4, [r2, #0]
    a85e:	4621      	mov	r1, r4
    a860:	b991      	cbnz	r1, a888 <_malloc_r+0x54>
    a862:	4c22      	ldr	r4, [pc, #136]	; (a8ec <_malloc_r+0xb8>)
    a864:	6823      	ldr	r3, [r4, #0]
    a866:	b91b      	cbnz	r3, a870 <_malloc_r+0x3c>
    a868:	4630      	mov	r0, r6
    a86a:	f000 fb15 	bl	ae98 <_sbrk_r>
    a86e:	6020      	str	r0, [r4, #0]
    a870:	4629      	mov	r1, r5
    a872:	4630      	mov	r0, r6
    a874:	f000 fb10 	bl	ae98 <_sbrk_r>
    a878:	1c43      	adds	r3, r0, #1
    a87a:	d126      	bne.n	a8ca <_malloc_r+0x96>
    a87c:	230c      	movs	r3, #12
    a87e:	6033      	str	r3, [r6, #0]
    a880:	4630      	mov	r0, r6
    a882:	f000 fc06 	bl	b092 <__malloc_unlock>
    a886:	e7e4      	b.n	a852 <_malloc_r+0x1e>
    a888:	680b      	ldr	r3, [r1, #0]
    a88a:	1b5b      	subs	r3, r3, r5
    a88c:	d41a      	bmi.n	a8c4 <_malloc_r+0x90>
    a88e:	2b0b      	cmp	r3, #11
    a890:	d90f      	bls.n	a8b2 <_malloc_r+0x7e>
    a892:	600b      	str	r3, [r1, #0]
    a894:	50cd      	str	r5, [r1, r3]
    a896:	18cc      	adds	r4, r1, r3
    a898:	4630      	mov	r0, r6
    a89a:	f000 fbfa 	bl	b092 <__malloc_unlock>
    a89e:	f104 000b 	add.w	r0, r4, #11
    a8a2:	1d23      	adds	r3, r4, #4
    a8a4:	f020 0007 	bic.w	r0, r0, #7
    a8a8:	1ac3      	subs	r3, r0, r3
    a8aa:	d01b      	beq.n	a8e4 <_malloc_r+0xb0>
    a8ac:	425a      	negs	r2, r3
    a8ae:	50e2      	str	r2, [r4, r3]
    a8b0:	bd70      	pop	{r4, r5, r6, pc}
    a8b2:	428c      	cmp	r4, r1
    a8b4:	bf0d      	iteet	eq
    a8b6:	6863      	ldreq	r3, [r4, #4]
    a8b8:	684b      	ldrne	r3, [r1, #4]
    a8ba:	6063      	strne	r3, [r4, #4]
    a8bc:	6013      	streq	r3, [r2, #0]
    a8be:	bf18      	it	ne
    a8c0:	460c      	movne	r4, r1
    a8c2:	e7e9      	b.n	a898 <_malloc_r+0x64>
    a8c4:	460c      	mov	r4, r1
    a8c6:	6849      	ldr	r1, [r1, #4]
    a8c8:	e7ca      	b.n	a860 <_malloc_r+0x2c>
    a8ca:	1cc4      	adds	r4, r0, #3
    a8cc:	f024 0403 	bic.w	r4, r4, #3
    a8d0:	42a0      	cmp	r0, r4
    a8d2:	d005      	beq.n	a8e0 <_malloc_r+0xac>
    a8d4:	1a21      	subs	r1, r4, r0
    a8d6:	4630      	mov	r0, r6
    a8d8:	f000 fade 	bl	ae98 <_sbrk_r>
    a8dc:	3001      	adds	r0, #1
    a8de:	d0cd      	beq.n	a87c <_malloc_r+0x48>
    a8e0:	6025      	str	r5, [r4, #0]
    a8e2:	e7d9      	b.n	a898 <_malloc_r+0x64>
    a8e4:	bd70      	pop	{r4, r5, r6, pc}
    a8e6:	bf00      	nop
    a8e8:	200081e0 	.word	0x200081e0
    a8ec:	200081e4 	.word	0x200081e4

0000a8f0 <__sfputc_r>:
    a8f0:	6893      	ldr	r3, [r2, #8]
    a8f2:	3b01      	subs	r3, #1
    a8f4:	2b00      	cmp	r3, #0
    a8f6:	b410      	push	{r4}
    a8f8:	6093      	str	r3, [r2, #8]
    a8fa:	da08      	bge.n	a90e <__sfputc_r+0x1e>
    a8fc:	6994      	ldr	r4, [r2, #24]
    a8fe:	42a3      	cmp	r3, r4
    a900:	db02      	blt.n	a908 <__sfputc_r+0x18>
    a902:	b2cb      	uxtb	r3, r1
    a904:	2b0a      	cmp	r3, #10
    a906:	d102      	bne.n	a90e <__sfputc_r+0x1e>
    a908:	bc10      	pop	{r4}
    a90a:	f7ff bc9d 	b.w	a248 <__swbuf_r>
    a90e:	6813      	ldr	r3, [r2, #0]
    a910:	1c58      	adds	r0, r3, #1
    a912:	6010      	str	r0, [r2, #0]
    a914:	7019      	strb	r1, [r3, #0]
    a916:	b2c8      	uxtb	r0, r1
    a918:	bc10      	pop	{r4}
    a91a:	4770      	bx	lr

0000a91c <__sfputs_r>:
    a91c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a91e:	4606      	mov	r6, r0
    a920:	460f      	mov	r7, r1
    a922:	4614      	mov	r4, r2
    a924:	18d5      	adds	r5, r2, r3
    a926:	42ac      	cmp	r4, r5
    a928:	d101      	bne.n	a92e <__sfputs_r+0x12>
    a92a:	2000      	movs	r0, #0
    a92c:	e007      	b.n	a93e <__sfputs_r+0x22>
    a92e:	463a      	mov	r2, r7
    a930:	f814 1b01 	ldrb.w	r1, [r4], #1
    a934:	4630      	mov	r0, r6
    a936:	f7ff ffdb 	bl	a8f0 <__sfputc_r>
    a93a:	1c43      	adds	r3, r0, #1
    a93c:	d1f3      	bne.n	a926 <__sfputs_r+0xa>
    a93e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000a940 <_vfiprintf_r>:
    a940:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a944:	b09d      	sub	sp, #116	; 0x74
    a946:	460c      	mov	r4, r1
    a948:	4617      	mov	r7, r2
    a94a:	9303      	str	r3, [sp, #12]
    a94c:	4606      	mov	r6, r0
    a94e:	b118      	cbz	r0, a958 <_vfiprintf_r+0x18>
    a950:	6983      	ldr	r3, [r0, #24]
    a952:	b90b      	cbnz	r3, a958 <_vfiprintf_r+0x18>
    a954:	f7ff fe2a 	bl	a5ac <__sinit>
    a958:	4b7c      	ldr	r3, [pc, #496]	; (ab4c <_vfiprintf_r+0x20c>)
    a95a:	429c      	cmp	r4, r3
    a95c:	d157      	bne.n	aa0e <_vfiprintf_r+0xce>
    a95e:	6874      	ldr	r4, [r6, #4]
    a960:	89a3      	ldrh	r3, [r4, #12]
    a962:	0718      	lsls	r0, r3, #28
    a964:	d55d      	bpl.n	aa22 <_vfiprintf_r+0xe2>
    a966:	6923      	ldr	r3, [r4, #16]
    a968:	2b00      	cmp	r3, #0
    a96a:	d05a      	beq.n	aa22 <_vfiprintf_r+0xe2>
    a96c:	2300      	movs	r3, #0
    a96e:	9309      	str	r3, [sp, #36]	; 0x24
    a970:	2320      	movs	r3, #32
    a972:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    a976:	2330      	movs	r3, #48	; 0x30
    a978:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    a97c:	f04f 0b01 	mov.w	fp, #1
    a980:	46b8      	mov	r8, r7
    a982:	4645      	mov	r5, r8
    a984:	f815 3b01 	ldrb.w	r3, [r5], #1
    a988:	2b00      	cmp	r3, #0
    a98a:	d155      	bne.n	aa38 <_vfiprintf_r+0xf8>
    a98c:	ebb8 0a07 	subs.w	sl, r8, r7
    a990:	d00b      	beq.n	a9aa <_vfiprintf_r+0x6a>
    a992:	4653      	mov	r3, sl
    a994:	463a      	mov	r2, r7
    a996:	4621      	mov	r1, r4
    a998:	4630      	mov	r0, r6
    a99a:	f7ff ffbf 	bl	a91c <__sfputs_r>
    a99e:	3001      	adds	r0, #1
    a9a0:	f000 80c4 	beq.w	ab2c <_vfiprintf_r+0x1ec>
    a9a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a9a6:	4453      	add	r3, sl
    a9a8:	9309      	str	r3, [sp, #36]	; 0x24
    a9aa:	f898 3000 	ldrb.w	r3, [r8]
    a9ae:	2b00      	cmp	r3, #0
    a9b0:	f000 80bc 	beq.w	ab2c <_vfiprintf_r+0x1ec>
    a9b4:	2300      	movs	r3, #0
    a9b6:	f04f 32ff 	mov.w	r2, #4294967295
    a9ba:	9304      	str	r3, [sp, #16]
    a9bc:	9307      	str	r3, [sp, #28]
    a9be:	9205      	str	r2, [sp, #20]
    a9c0:	9306      	str	r3, [sp, #24]
    a9c2:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    a9c6:	931a      	str	r3, [sp, #104]	; 0x68
    a9c8:	2205      	movs	r2, #5
    a9ca:	7829      	ldrb	r1, [r5, #0]
    a9cc:	4860      	ldr	r0, [pc, #384]	; (ab50 <_vfiprintf_r+0x210>)
    a9ce:	f000 fb0f 	bl	aff0 <memchr>
    a9d2:	f105 0801 	add.w	r8, r5, #1
    a9d6:	9b04      	ldr	r3, [sp, #16]
    a9d8:	2800      	cmp	r0, #0
    a9da:	d131      	bne.n	aa40 <_vfiprintf_r+0x100>
    a9dc:	06d9      	lsls	r1, r3, #27
    a9de:	bf44      	itt	mi
    a9e0:	2220      	movmi	r2, #32
    a9e2:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    a9e6:	071a      	lsls	r2, r3, #28
    a9e8:	bf44      	itt	mi
    a9ea:	222b      	movmi	r2, #43	; 0x2b
    a9ec:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    a9f0:	782a      	ldrb	r2, [r5, #0]
    a9f2:	2a2a      	cmp	r2, #42	; 0x2a
    a9f4:	d02c      	beq.n	aa50 <_vfiprintf_r+0x110>
    a9f6:	9a07      	ldr	r2, [sp, #28]
    a9f8:	2100      	movs	r1, #0
    a9fa:	200a      	movs	r0, #10
    a9fc:	46a8      	mov	r8, r5
    a9fe:	3501      	adds	r5, #1
    aa00:	f898 3000 	ldrb.w	r3, [r8]
    aa04:	3b30      	subs	r3, #48	; 0x30
    aa06:	2b09      	cmp	r3, #9
    aa08:	d96d      	bls.n	aae6 <_vfiprintf_r+0x1a6>
    aa0a:	b371      	cbz	r1, aa6a <_vfiprintf_r+0x12a>
    aa0c:	e026      	b.n	aa5c <_vfiprintf_r+0x11c>
    aa0e:	4b51      	ldr	r3, [pc, #324]	; (ab54 <_vfiprintf_r+0x214>)
    aa10:	429c      	cmp	r4, r3
    aa12:	d101      	bne.n	aa18 <_vfiprintf_r+0xd8>
    aa14:	68b4      	ldr	r4, [r6, #8]
    aa16:	e7a3      	b.n	a960 <_vfiprintf_r+0x20>
    aa18:	4b4f      	ldr	r3, [pc, #316]	; (ab58 <_vfiprintf_r+0x218>)
    aa1a:	429c      	cmp	r4, r3
    aa1c:	bf08      	it	eq
    aa1e:	68f4      	ldreq	r4, [r6, #12]
    aa20:	e79e      	b.n	a960 <_vfiprintf_r+0x20>
    aa22:	4621      	mov	r1, r4
    aa24:	4630      	mov	r0, r6
    aa26:	f7ff fc61 	bl	a2ec <__swsetup_r>
    aa2a:	2800      	cmp	r0, #0
    aa2c:	d09e      	beq.n	a96c <_vfiprintf_r+0x2c>
    aa2e:	f04f 30ff 	mov.w	r0, #4294967295
    aa32:	b01d      	add	sp, #116	; 0x74
    aa34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    aa38:	2b25      	cmp	r3, #37	; 0x25
    aa3a:	d0a7      	beq.n	a98c <_vfiprintf_r+0x4c>
    aa3c:	46a8      	mov	r8, r5
    aa3e:	e7a0      	b.n	a982 <_vfiprintf_r+0x42>
    aa40:	4a43      	ldr	r2, [pc, #268]	; (ab50 <_vfiprintf_r+0x210>)
    aa42:	1a80      	subs	r0, r0, r2
    aa44:	fa0b f000 	lsl.w	r0, fp, r0
    aa48:	4318      	orrs	r0, r3
    aa4a:	9004      	str	r0, [sp, #16]
    aa4c:	4645      	mov	r5, r8
    aa4e:	e7bb      	b.n	a9c8 <_vfiprintf_r+0x88>
    aa50:	9a03      	ldr	r2, [sp, #12]
    aa52:	1d11      	adds	r1, r2, #4
    aa54:	6812      	ldr	r2, [r2, #0]
    aa56:	9103      	str	r1, [sp, #12]
    aa58:	2a00      	cmp	r2, #0
    aa5a:	db01      	blt.n	aa60 <_vfiprintf_r+0x120>
    aa5c:	9207      	str	r2, [sp, #28]
    aa5e:	e004      	b.n	aa6a <_vfiprintf_r+0x12a>
    aa60:	4252      	negs	r2, r2
    aa62:	f043 0302 	orr.w	r3, r3, #2
    aa66:	9207      	str	r2, [sp, #28]
    aa68:	9304      	str	r3, [sp, #16]
    aa6a:	f898 3000 	ldrb.w	r3, [r8]
    aa6e:	2b2e      	cmp	r3, #46	; 0x2e
    aa70:	d110      	bne.n	aa94 <_vfiprintf_r+0x154>
    aa72:	f898 3001 	ldrb.w	r3, [r8, #1]
    aa76:	2b2a      	cmp	r3, #42	; 0x2a
    aa78:	f108 0101 	add.w	r1, r8, #1
    aa7c:	d137      	bne.n	aaee <_vfiprintf_r+0x1ae>
    aa7e:	9b03      	ldr	r3, [sp, #12]
    aa80:	1d1a      	adds	r2, r3, #4
    aa82:	681b      	ldr	r3, [r3, #0]
    aa84:	9203      	str	r2, [sp, #12]
    aa86:	2b00      	cmp	r3, #0
    aa88:	bfb8      	it	lt
    aa8a:	f04f 33ff 	movlt.w	r3, #4294967295
    aa8e:	f108 0802 	add.w	r8, r8, #2
    aa92:	9305      	str	r3, [sp, #20]
    aa94:	4d31      	ldr	r5, [pc, #196]	; (ab5c <_vfiprintf_r+0x21c>)
    aa96:	f898 1000 	ldrb.w	r1, [r8]
    aa9a:	2203      	movs	r2, #3
    aa9c:	4628      	mov	r0, r5
    aa9e:	f000 faa7 	bl	aff0 <memchr>
    aaa2:	b140      	cbz	r0, aab6 <_vfiprintf_r+0x176>
    aaa4:	2340      	movs	r3, #64	; 0x40
    aaa6:	1b40      	subs	r0, r0, r5
    aaa8:	fa03 f000 	lsl.w	r0, r3, r0
    aaac:	9b04      	ldr	r3, [sp, #16]
    aaae:	4303      	orrs	r3, r0
    aab0:	9304      	str	r3, [sp, #16]
    aab2:	f108 0801 	add.w	r8, r8, #1
    aab6:	f898 1000 	ldrb.w	r1, [r8]
    aaba:	4829      	ldr	r0, [pc, #164]	; (ab60 <_vfiprintf_r+0x220>)
    aabc:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    aac0:	2206      	movs	r2, #6
    aac2:	f108 0701 	add.w	r7, r8, #1
    aac6:	f000 fa93 	bl	aff0 <memchr>
    aaca:	2800      	cmp	r0, #0
    aacc:	d034      	beq.n	ab38 <_vfiprintf_r+0x1f8>
    aace:	4b25      	ldr	r3, [pc, #148]	; (ab64 <_vfiprintf_r+0x224>)
    aad0:	bb03      	cbnz	r3, ab14 <_vfiprintf_r+0x1d4>
    aad2:	9b03      	ldr	r3, [sp, #12]
    aad4:	3307      	adds	r3, #7
    aad6:	f023 0307 	bic.w	r3, r3, #7
    aada:	3308      	adds	r3, #8
    aadc:	9303      	str	r3, [sp, #12]
    aade:	9b09      	ldr	r3, [sp, #36]	; 0x24
    aae0:	444b      	add	r3, r9
    aae2:	9309      	str	r3, [sp, #36]	; 0x24
    aae4:	e74c      	b.n	a980 <_vfiprintf_r+0x40>
    aae6:	fb00 3202 	mla	r2, r0, r2, r3
    aaea:	2101      	movs	r1, #1
    aaec:	e786      	b.n	a9fc <_vfiprintf_r+0xbc>
    aaee:	2300      	movs	r3, #0
    aaf0:	9305      	str	r3, [sp, #20]
    aaf2:	4618      	mov	r0, r3
    aaf4:	250a      	movs	r5, #10
    aaf6:	4688      	mov	r8, r1
    aaf8:	3101      	adds	r1, #1
    aafa:	f898 2000 	ldrb.w	r2, [r8]
    aafe:	3a30      	subs	r2, #48	; 0x30
    ab00:	2a09      	cmp	r2, #9
    ab02:	d903      	bls.n	ab0c <_vfiprintf_r+0x1cc>
    ab04:	2b00      	cmp	r3, #0
    ab06:	d0c5      	beq.n	aa94 <_vfiprintf_r+0x154>
    ab08:	9005      	str	r0, [sp, #20]
    ab0a:	e7c3      	b.n	aa94 <_vfiprintf_r+0x154>
    ab0c:	fb05 2000 	mla	r0, r5, r0, r2
    ab10:	2301      	movs	r3, #1
    ab12:	e7f0      	b.n	aaf6 <_vfiprintf_r+0x1b6>
    ab14:	ab03      	add	r3, sp, #12
    ab16:	9300      	str	r3, [sp, #0]
    ab18:	4622      	mov	r2, r4
    ab1a:	4b13      	ldr	r3, [pc, #76]	; (ab68 <_vfiprintf_r+0x228>)
    ab1c:	a904      	add	r1, sp, #16
    ab1e:	4630      	mov	r0, r6
    ab20:	f3af 8000 	nop.w
    ab24:	f1b0 3fff 	cmp.w	r0, #4294967295
    ab28:	4681      	mov	r9, r0
    ab2a:	d1d8      	bne.n	aade <_vfiprintf_r+0x19e>
    ab2c:	89a3      	ldrh	r3, [r4, #12]
    ab2e:	065b      	lsls	r3, r3, #25
    ab30:	f53f af7d 	bmi.w	aa2e <_vfiprintf_r+0xee>
    ab34:	9809      	ldr	r0, [sp, #36]	; 0x24
    ab36:	e77c      	b.n	aa32 <_vfiprintf_r+0xf2>
    ab38:	ab03      	add	r3, sp, #12
    ab3a:	9300      	str	r3, [sp, #0]
    ab3c:	4622      	mov	r2, r4
    ab3e:	4b0a      	ldr	r3, [pc, #40]	; (ab68 <_vfiprintf_r+0x228>)
    ab40:	a904      	add	r1, sp, #16
    ab42:	4630      	mov	r0, r6
    ab44:	f000 f888 	bl	ac58 <_printf_i>
    ab48:	e7ec      	b.n	ab24 <_vfiprintf_r+0x1e4>
    ab4a:	bf00      	nop
    ab4c:	0000c778 	.word	0x0000c778
    ab50:	0000c7b8 	.word	0x0000c7b8
    ab54:	0000c798 	.word	0x0000c798
    ab58:	0000c758 	.word	0x0000c758
    ab5c:	0000c7be 	.word	0x0000c7be
    ab60:	0000c7c2 	.word	0x0000c7c2
    ab64:	00000000 	.word	0x00000000
    ab68:	0000a91d 	.word	0x0000a91d

0000ab6c <_printf_common>:
    ab6c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ab70:	4691      	mov	r9, r2
    ab72:	461f      	mov	r7, r3
    ab74:	688a      	ldr	r2, [r1, #8]
    ab76:	690b      	ldr	r3, [r1, #16]
    ab78:	f8dd 8020 	ldr.w	r8, [sp, #32]
    ab7c:	4293      	cmp	r3, r2
    ab7e:	bfb8      	it	lt
    ab80:	4613      	movlt	r3, r2
    ab82:	f8c9 3000 	str.w	r3, [r9]
    ab86:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
    ab8a:	4606      	mov	r6, r0
    ab8c:	460c      	mov	r4, r1
    ab8e:	b112      	cbz	r2, ab96 <_printf_common+0x2a>
    ab90:	3301      	adds	r3, #1
    ab92:	f8c9 3000 	str.w	r3, [r9]
    ab96:	6823      	ldr	r3, [r4, #0]
    ab98:	0699      	lsls	r1, r3, #26
    ab9a:	bf42      	ittt	mi
    ab9c:	f8d9 3000 	ldrmi.w	r3, [r9]
    aba0:	3302      	addmi	r3, #2
    aba2:	f8c9 3000 	strmi.w	r3, [r9]
    aba6:	6825      	ldr	r5, [r4, #0]
    aba8:	f015 0506 	ands.w	r5, r5, #6
    abac:	d107      	bne.n	abbe <_printf_common+0x52>
    abae:	f104 0a19 	add.w	sl, r4, #25
    abb2:	68e3      	ldr	r3, [r4, #12]
    abb4:	f8d9 2000 	ldr.w	r2, [r9]
    abb8:	1a9b      	subs	r3, r3, r2
    abba:	429d      	cmp	r5, r3
    abbc:	db29      	blt.n	ac12 <_printf_common+0xa6>
    abbe:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    abc2:	6822      	ldr	r2, [r4, #0]
    abc4:	3300      	adds	r3, #0
    abc6:	bf18      	it	ne
    abc8:	2301      	movne	r3, #1
    abca:	0692      	lsls	r2, r2, #26
    abcc:	d42e      	bmi.n	ac2c <_printf_common+0xc0>
    abce:	f104 0243 	add.w	r2, r4, #67	; 0x43
    abd2:	4639      	mov	r1, r7
    abd4:	4630      	mov	r0, r6
    abd6:	47c0      	blx	r8
    abd8:	3001      	adds	r0, #1
    abda:	d021      	beq.n	ac20 <_printf_common+0xb4>
    abdc:	6823      	ldr	r3, [r4, #0]
    abde:	68e5      	ldr	r5, [r4, #12]
    abe0:	f8d9 2000 	ldr.w	r2, [r9]
    abe4:	f003 0306 	and.w	r3, r3, #6
    abe8:	2b04      	cmp	r3, #4
    abea:	bf08      	it	eq
    abec:	1aad      	subeq	r5, r5, r2
    abee:	68a3      	ldr	r3, [r4, #8]
    abf0:	6922      	ldr	r2, [r4, #16]
    abf2:	bf0c      	ite	eq
    abf4:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
    abf8:	2500      	movne	r5, #0
    abfa:	4293      	cmp	r3, r2
    abfc:	bfc4      	itt	gt
    abfe:	1a9b      	subgt	r3, r3, r2
    ac00:	18ed      	addgt	r5, r5, r3
    ac02:	f04f 0900 	mov.w	r9, #0
    ac06:	341a      	adds	r4, #26
    ac08:	454d      	cmp	r5, r9
    ac0a:	d11b      	bne.n	ac44 <_printf_common+0xd8>
    ac0c:	2000      	movs	r0, #0
    ac0e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ac12:	2301      	movs	r3, #1
    ac14:	4652      	mov	r2, sl
    ac16:	4639      	mov	r1, r7
    ac18:	4630      	mov	r0, r6
    ac1a:	47c0      	blx	r8
    ac1c:	3001      	adds	r0, #1
    ac1e:	d103      	bne.n	ac28 <_printf_common+0xbc>
    ac20:	f04f 30ff 	mov.w	r0, #4294967295
    ac24:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ac28:	3501      	adds	r5, #1
    ac2a:	e7c2      	b.n	abb2 <_printf_common+0x46>
    ac2c:	18e1      	adds	r1, r4, r3
    ac2e:	1c5a      	adds	r2, r3, #1
    ac30:	2030      	movs	r0, #48	; 0x30
    ac32:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
    ac36:	4422      	add	r2, r4
    ac38:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
    ac3c:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
    ac40:	3302      	adds	r3, #2
    ac42:	e7c4      	b.n	abce <_printf_common+0x62>
    ac44:	2301      	movs	r3, #1
    ac46:	4622      	mov	r2, r4
    ac48:	4639      	mov	r1, r7
    ac4a:	4630      	mov	r0, r6
    ac4c:	47c0      	blx	r8
    ac4e:	3001      	adds	r0, #1
    ac50:	d0e6      	beq.n	ac20 <_printf_common+0xb4>
    ac52:	f109 0901 	add.w	r9, r9, #1
    ac56:	e7d7      	b.n	ac08 <_printf_common+0x9c>

0000ac58 <_printf_i>:
    ac58:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    ac5c:	4617      	mov	r7, r2
    ac5e:	7e0a      	ldrb	r2, [r1, #24]
    ac60:	b085      	sub	sp, #20
    ac62:	2a6e      	cmp	r2, #110	; 0x6e
    ac64:	4698      	mov	r8, r3
    ac66:	4606      	mov	r6, r0
    ac68:	460c      	mov	r4, r1
    ac6a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    ac6c:	f101 0e43 	add.w	lr, r1, #67	; 0x43
    ac70:	f000 80bc 	beq.w	adec <_printf_i+0x194>
    ac74:	d81a      	bhi.n	acac <_printf_i+0x54>
    ac76:	2a63      	cmp	r2, #99	; 0x63
    ac78:	d02e      	beq.n	acd8 <_printf_i+0x80>
    ac7a:	d80a      	bhi.n	ac92 <_printf_i+0x3a>
    ac7c:	2a00      	cmp	r2, #0
    ac7e:	f000 80c8 	beq.w	ae12 <_printf_i+0x1ba>
    ac82:	2a58      	cmp	r2, #88	; 0x58
    ac84:	f000 808a 	beq.w	ad9c <_printf_i+0x144>
    ac88:	f104 0542 	add.w	r5, r4, #66	; 0x42
    ac8c:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
    ac90:	e02a      	b.n	ace8 <_printf_i+0x90>
    ac92:	2a64      	cmp	r2, #100	; 0x64
    ac94:	d001      	beq.n	ac9a <_printf_i+0x42>
    ac96:	2a69      	cmp	r2, #105	; 0x69
    ac98:	d1f6      	bne.n	ac88 <_printf_i+0x30>
    ac9a:	6821      	ldr	r1, [r4, #0]
    ac9c:	681a      	ldr	r2, [r3, #0]
    ac9e:	f011 0f80 	tst.w	r1, #128	; 0x80
    aca2:	d023      	beq.n	acec <_printf_i+0x94>
    aca4:	1d11      	adds	r1, r2, #4
    aca6:	6019      	str	r1, [r3, #0]
    aca8:	6813      	ldr	r3, [r2, #0]
    acaa:	e027      	b.n	acfc <_printf_i+0xa4>
    acac:	2a73      	cmp	r2, #115	; 0x73
    acae:	f000 80b4 	beq.w	ae1a <_printf_i+0x1c2>
    acb2:	d808      	bhi.n	acc6 <_printf_i+0x6e>
    acb4:	2a6f      	cmp	r2, #111	; 0x6f
    acb6:	d02a      	beq.n	ad0e <_printf_i+0xb6>
    acb8:	2a70      	cmp	r2, #112	; 0x70
    acba:	d1e5      	bne.n	ac88 <_printf_i+0x30>
    acbc:	680a      	ldr	r2, [r1, #0]
    acbe:	f042 0220 	orr.w	r2, r2, #32
    acc2:	600a      	str	r2, [r1, #0]
    acc4:	e003      	b.n	acce <_printf_i+0x76>
    acc6:	2a75      	cmp	r2, #117	; 0x75
    acc8:	d021      	beq.n	ad0e <_printf_i+0xb6>
    acca:	2a78      	cmp	r2, #120	; 0x78
    accc:	d1dc      	bne.n	ac88 <_printf_i+0x30>
    acce:	2278      	movs	r2, #120	; 0x78
    acd0:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
    acd4:	496e      	ldr	r1, [pc, #440]	; (ae90 <_printf_i+0x238>)
    acd6:	e064      	b.n	ada2 <_printf_i+0x14a>
    acd8:	681a      	ldr	r2, [r3, #0]
    acda:	f101 0542 	add.w	r5, r1, #66	; 0x42
    acde:	1d11      	adds	r1, r2, #4
    ace0:	6019      	str	r1, [r3, #0]
    ace2:	6813      	ldr	r3, [r2, #0]
    ace4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    ace8:	2301      	movs	r3, #1
    acea:	e0a3      	b.n	ae34 <_printf_i+0x1dc>
    acec:	f011 0f40 	tst.w	r1, #64	; 0x40
    acf0:	f102 0104 	add.w	r1, r2, #4
    acf4:	6019      	str	r1, [r3, #0]
    acf6:	d0d7      	beq.n	aca8 <_printf_i+0x50>
    acf8:	f9b2 3000 	ldrsh.w	r3, [r2]
    acfc:	2b00      	cmp	r3, #0
    acfe:	da03      	bge.n	ad08 <_printf_i+0xb0>
    ad00:	222d      	movs	r2, #45	; 0x2d
    ad02:	425b      	negs	r3, r3
    ad04:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
    ad08:	4962      	ldr	r1, [pc, #392]	; (ae94 <_printf_i+0x23c>)
    ad0a:	220a      	movs	r2, #10
    ad0c:	e017      	b.n	ad3e <_printf_i+0xe6>
    ad0e:	6820      	ldr	r0, [r4, #0]
    ad10:	6819      	ldr	r1, [r3, #0]
    ad12:	f010 0f80 	tst.w	r0, #128	; 0x80
    ad16:	d003      	beq.n	ad20 <_printf_i+0xc8>
    ad18:	1d08      	adds	r0, r1, #4
    ad1a:	6018      	str	r0, [r3, #0]
    ad1c:	680b      	ldr	r3, [r1, #0]
    ad1e:	e006      	b.n	ad2e <_printf_i+0xd6>
    ad20:	f010 0f40 	tst.w	r0, #64	; 0x40
    ad24:	f101 0004 	add.w	r0, r1, #4
    ad28:	6018      	str	r0, [r3, #0]
    ad2a:	d0f7      	beq.n	ad1c <_printf_i+0xc4>
    ad2c:	880b      	ldrh	r3, [r1, #0]
    ad2e:	4959      	ldr	r1, [pc, #356]	; (ae94 <_printf_i+0x23c>)
    ad30:	2a6f      	cmp	r2, #111	; 0x6f
    ad32:	bf14      	ite	ne
    ad34:	220a      	movne	r2, #10
    ad36:	2208      	moveq	r2, #8
    ad38:	2000      	movs	r0, #0
    ad3a:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
    ad3e:	6865      	ldr	r5, [r4, #4]
    ad40:	60a5      	str	r5, [r4, #8]
    ad42:	2d00      	cmp	r5, #0
    ad44:	f2c0 809c 	blt.w	ae80 <_printf_i+0x228>
    ad48:	6820      	ldr	r0, [r4, #0]
    ad4a:	f020 0004 	bic.w	r0, r0, #4
    ad4e:	6020      	str	r0, [r4, #0]
    ad50:	2b00      	cmp	r3, #0
    ad52:	d13f      	bne.n	add4 <_printf_i+0x17c>
    ad54:	2d00      	cmp	r5, #0
    ad56:	f040 8095 	bne.w	ae84 <_printf_i+0x22c>
    ad5a:	4675      	mov	r5, lr
    ad5c:	2a08      	cmp	r2, #8
    ad5e:	d10b      	bne.n	ad78 <_printf_i+0x120>
    ad60:	6823      	ldr	r3, [r4, #0]
    ad62:	07da      	lsls	r2, r3, #31
    ad64:	d508      	bpl.n	ad78 <_printf_i+0x120>
    ad66:	6923      	ldr	r3, [r4, #16]
    ad68:	6862      	ldr	r2, [r4, #4]
    ad6a:	429a      	cmp	r2, r3
    ad6c:	bfde      	ittt	le
    ad6e:	2330      	movle	r3, #48	; 0x30
    ad70:	f805 3c01 	strble.w	r3, [r5, #-1]
    ad74:	f105 35ff 	addle.w	r5, r5, #4294967295
    ad78:	ebae 0305 	sub.w	r3, lr, r5
    ad7c:	6123      	str	r3, [r4, #16]
    ad7e:	f8cd 8000 	str.w	r8, [sp]
    ad82:	463b      	mov	r3, r7
    ad84:	aa03      	add	r2, sp, #12
    ad86:	4621      	mov	r1, r4
    ad88:	4630      	mov	r0, r6
    ad8a:	f7ff feef 	bl	ab6c <_printf_common>
    ad8e:	3001      	adds	r0, #1
    ad90:	d155      	bne.n	ae3e <_printf_i+0x1e6>
    ad92:	f04f 30ff 	mov.w	r0, #4294967295
    ad96:	b005      	add	sp, #20
    ad98:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    ad9c:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
    ada0:	493c      	ldr	r1, [pc, #240]	; (ae94 <_printf_i+0x23c>)
    ada2:	6822      	ldr	r2, [r4, #0]
    ada4:	6818      	ldr	r0, [r3, #0]
    ada6:	f012 0f80 	tst.w	r2, #128	; 0x80
    adaa:	f100 0504 	add.w	r5, r0, #4
    adae:	601d      	str	r5, [r3, #0]
    adb0:	d001      	beq.n	adb6 <_printf_i+0x15e>
    adb2:	6803      	ldr	r3, [r0, #0]
    adb4:	e002      	b.n	adbc <_printf_i+0x164>
    adb6:	0655      	lsls	r5, r2, #25
    adb8:	d5fb      	bpl.n	adb2 <_printf_i+0x15a>
    adba:	8803      	ldrh	r3, [r0, #0]
    adbc:	07d0      	lsls	r0, r2, #31
    adbe:	bf44      	itt	mi
    adc0:	f042 0220 	orrmi.w	r2, r2, #32
    adc4:	6022      	strmi	r2, [r4, #0]
    adc6:	b91b      	cbnz	r3, add0 <_printf_i+0x178>
    adc8:	6822      	ldr	r2, [r4, #0]
    adca:	f022 0220 	bic.w	r2, r2, #32
    adce:	6022      	str	r2, [r4, #0]
    add0:	2210      	movs	r2, #16
    add2:	e7b1      	b.n	ad38 <_printf_i+0xe0>
    add4:	4675      	mov	r5, lr
    add6:	fbb3 f0f2 	udiv	r0, r3, r2
    adda:	fb02 3310 	mls	r3, r2, r0, r3
    adde:	5ccb      	ldrb	r3, [r1, r3]
    ade0:	f805 3d01 	strb.w	r3, [r5, #-1]!
    ade4:	4603      	mov	r3, r0
    ade6:	2800      	cmp	r0, #0
    ade8:	d1f5      	bne.n	add6 <_printf_i+0x17e>
    adea:	e7b7      	b.n	ad5c <_printf_i+0x104>
    adec:	6808      	ldr	r0, [r1, #0]
    adee:	681a      	ldr	r2, [r3, #0]
    adf0:	6949      	ldr	r1, [r1, #20]
    adf2:	f010 0f80 	tst.w	r0, #128	; 0x80
    adf6:	d004      	beq.n	ae02 <_printf_i+0x1aa>
    adf8:	1d10      	adds	r0, r2, #4
    adfa:	6018      	str	r0, [r3, #0]
    adfc:	6813      	ldr	r3, [r2, #0]
    adfe:	6019      	str	r1, [r3, #0]
    ae00:	e007      	b.n	ae12 <_printf_i+0x1ba>
    ae02:	f010 0f40 	tst.w	r0, #64	; 0x40
    ae06:	f102 0004 	add.w	r0, r2, #4
    ae0a:	6018      	str	r0, [r3, #0]
    ae0c:	6813      	ldr	r3, [r2, #0]
    ae0e:	d0f6      	beq.n	adfe <_printf_i+0x1a6>
    ae10:	8019      	strh	r1, [r3, #0]
    ae12:	2300      	movs	r3, #0
    ae14:	6123      	str	r3, [r4, #16]
    ae16:	4675      	mov	r5, lr
    ae18:	e7b1      	b.n	ad7e <_printf_i+0x126>
    ae1a:	681a      	ldr	r2, [r3, #0]
    ae1c:	1d11      	adds	r1, r2, #4
    ae1e:	6019      	str	r1, [r3, #0]
    ae20:	6815      	ldr	r5, [r2, #0]
    ae22:	6862      	ldr	r2, [r4, #4]
    ae24:	2100      	movs	r1, #0
    ae26:	4628      	mov	r0, r5
    ae28:	f000 f8e2 	bl	aff0 <memchr>
    ae2c:	b108      	cbz	r0, ae32 <_printf_i+0x1da>
    ae2e:	1b40      	subs	r0, r0, r5
    ae30:	6060      	str	r0, [r4, #4]
    ae32:	6863      	ldr	r3, [r4, #4]
    ae34:	6123      	str	r3, [r4, #16]
    ae36:	2300      	movs	r3, #0
    ae38:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    ae3c:	e79f      	b.n	ad7e <_printf_i+0x126>
    ae3e:	6923      	ldr	r3, [r4, #16]
    ae40:	462a      	mov	r2, r5
    ae42:	4639      	mov	r1, r7
    ae44:	4630      	mov	r0, r6
    ae46:	47c0      	blx	r8
    ae48:	3001      	adds	r0, #1
    ae4a:	d0a2      	beq.n	ad92 <_printf_i+0x13a>
    ae4c:	6823      	ldr	r3, [r4, #0]
    ae4e:	079b      	lsls	r3, r3, #30
    ae50:	d507      	bpl.n	ae62 <_printf_i+0x20a>
    ae52:	2500      	movs	r5, #0
    ae54:	f104 0919 	add.w	r9, r4, #25
    ae58:	68e3      	ldr	r3, [r4, #12]
    ae5a:	9a03      	ldr	r2, [sp, #12]
    ae5c:	1a9b      	subs	r3, r3, r2
    ae5e:	429d      	cmp	r5, r3
    ae60:	db05      	blt.n	ae6e <_printf_i+0x216>
    ae62:	68e0      	ldr	r0, [r4, #12]
    ae64:	9b03      	ldr	r3, [sp, #12]
    ae66:	4298      	cmp	r0, r3
    ae68:	bfb8      	it	lt
    ae6a:	4618      	movlt	r0, r3
    ae6c:	e793      	b.n	ad96 <_printf_i+0x13e>
    ae6e:	2301      	movs	r3, #1
    ae70:	464a      	mov	r2, r9
    ae72:	4639      	mov	r1, r7
    ae74:	4630      	mov	r0, r6
    ae76:	47c0      	blx	r8
    ae78:	3001      	adds	r0, #1
    ae7a:	d08a      	beq.n	ad92 <_printf_i+0x13a>
    ae7c:	3501      	adds	r5, #1
    ae7e:	e7eb      	b.n	ae58 <_printf_i+0x200>
    ae80:	2b00      	cmp	r3, #0
    ae82:	d1a7      	bne.n	add4 <_printf_i+0x17c>
    ae84:	780b      	ldrb	r3, [r1, #0]
    ae86:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    ae8a:	f104 0542 	add.w	r5, r4, #66	; 0x42
    ae8e:	e765      	b.n	ad5c <_printf_i+0x104>
    ae90:	0000c7da 	.word	0x0000c7da
    ae94:	0000c7c9 	.word	0x0000c7c9

0000ae98 <_sbrk_r>:
    ae98:	b538      	push	{r3, r4, r5, lr}
    ae9a:	4c06      	ldr	r4, [pc, #24]	; (aeb4 <_sbrk_r+0x1c>)
    ae9c:	2300      	movs	r3, #0
    ae9e:	4605      	mov	r5, r0
    aea0:	4608      	mov	r0, r1
    aea2:	6023      	str	r3, [r4, #0]
    aea4:	f7f6 fd8c 	bl	19c0 <_sbrk>
    aea8:	1c43      	adds	r3, r0, #1
    aeaa:	d102      	bne.n	aeb2 <_sbrk_r+0x1a>
    aeac:	6823      	ldr	r3, [r4, #0]
    aeae:	b103      	cbz	r3, aeb2 <_sbrk_r+0x1a>
    aeb0:	602b      	str	r3, [r5, #0]
    aeb2:	bd38      	pop	{r3, r4, r5, pc}
    aeb4:	200095f0 	.word	0x200095f0

0000aeb8 <__sread>:
    aeb8:	b510      	push	{r4, lr}
    aeba:	460c      	mov	r4, r1
    aebc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    aec0:	f000 f8e8 	bl	b094 <_read_r>
    aec4:	2800      	cmp	r0, #0
    aec6:	bfab      	itete	ge
    aec8:	6d63      	ldrge	r3, [r4, #84]	; 0x54
    aeca:	89a3      	ldrhlt	r3, [r4, #12]
    aecc:	181b      	addge	r3, r3, r0
    aece:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
    aed2:	bfac      	ite	ge
    aed4:	6563      	strge	r3, [r4, #84]	; 0x54
    aed6:	81a3      	strhlt	r3, [r4, #12]
    aed8:	bd10      	pop	{r4, pc}

0000aeda <__swrite>:
    aeda:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    aede:	461f      	mov	r7, r3
    aee0:	898b      	ldrh	r3, [r1, #12]
    aee2:	05db      	lsls	r3, r3, #23
    aee4:	4605      	mov	r5, r0
    aee6:	460c      	mov	r4, r1
    aee8:	4616      	mov	r6, r2
    aeea:	d505      	bpl.n	aef8 <__swrite+0x1e>
    aeec:	2302      	movs	r3, #2
    aeee:	2200      	movs	r2, #0
    aef0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    aef4:	f000 f868 	bl	afc8 <_lseek_r>
    aef8:	89a3      	ldrh	r3, [r4, #12]
    aefa:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    aefe:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    af02:	81a3      	strh	r3, [r4, #12]
    af04:	4632      	mov	r2, r6
    af06:	463b      	mov	r3, r7
    af08:	4628      	mov	r0, r5
    af0a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    af0e:	f000 b817 	b.w	af40 <_write_r>

0000af12 <__sseek>:
    af12:	b510      	push	{r4, lr}
    af14:	460c      	mov	r4, r1
    af16:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    af1a:	f000 f855 	bl	afc8 <_lseek_r>
    af1e:	1c43      	adds	r3, r0, #1
    af20:	89a3      	ldrh	r3, [r4, #12]
    af22:	bf15      	itete	ne
    af24:	6560      	strne	r0, [r4, #84]	; 0x54
    af26:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    af2a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    af2e:	81a3      	strheq	r3, [r4, #12]
    af30:	bf18      	it	ne
    af32:	81a3      	strhne	r3, [r4, #12]
    af34:	bd10      	pop	{r4, pc}

0000af36 <__sclose>:
    af36:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    af3a:	f000 b813 	b.w	af64 <_close_r>
	...

0000af40 <_write_r>:
    af40:	b538      	push	{r3, r4, r5, lr}
    af42:	4c07      	ldr	r4, [pc, #28]	; (af60 <_write_r+0x20>)
    af44:	4605      	mov	r5, r0
    af46:	4608      	mov	r0, r1
    af48:	4611      	mov	r1, r2
    af4a:	2200      	movs	r2, #0
    af4c:	6022      	str	r2, [r4, #0]
    af4e:	461a      	mov	r2, r3
    af50:	f7fe ff9e 	bl	9e90 <_write>
    af54:	1c43      	adds	r3, r0, #1
    af56:	d102      	bne.n	af5e <_write_r+0x1e>
    af58:	6823      	ldr	r3, [r4, #0]
    af5a:	b103      	cbz	r3, af5e <_write_r+0x1e>
    af5c:	602b      	str	r3, [r5, #0]
    af5e:	bd38      	pop	{r3, r4, r5, pc}
    af60:	200095f0 	.word	0x200095f0

0000af64 <_close_r>:
    af64:	b538      	push	{r3, r4, r5, lr}
    af66:	4c06      	ldr	r4, [pc, #24]	; (af80 <_close_r+0x1c>)
    af68:	2300      	movs	r3, #0
    af6a:	4605      	mov	r5, r0
    af6c:	4608      	mov	r0, r1
    af6e:	6023      	str	r3, [r4, #0]
    af70:	f7f6 fd38 	bl	19e4 <_close>
    af74:	1c43      	adds	r3, r0, #1
    af76:	d102      	bne.n	af7e <_close_r+0x1a>
    af78:	6823      	ldr	r3, [r4, #0]
    af7a:	b103      	cbz	r3, af7e <_close_r+0x1a>
    af7c:	602b      	str	r3, [r5, #0]
    af7e:	bd38      	pop	{r3, r4, r5, pc}
    af80:	200095f0 	.word	0x200095f0

0000af84 <_fstat_r>:
    af84:	b538      	push	{r3, r4, r5, lr}
    af86:	4c07      	ldr	r4, [pc, #28]	; (afa4 <_fstat_r+0x20>)
    af88:	2300      	movs	r3, #0
    af8a:	4605      	mov	r5, r0
    af8c:	4608      	mov	r0, r1
    af8e:	4611      	mov	r1, r2
    af90:	6023      	str	r3, [r4, #0]
    af92:	f7f6 fd2a 	bl	19ea <_fstat>
    af96:	1c43      	adds	r3, r0, #1
    af98:	d102      	bne.n	afa0 <_fstat_r+0x1c>
    af9a:	6823      	ldr	r3, [r4, #0]
    af9c:	b103      	cbz	r3, afa0 <_fstat_r+0x1c>
    af9e:	602b      	str	r3, [r5, #0]
    afa0:	bd38      	pop	{r3, r4, r5, pc}
    afa2:	bf00      	nop
    afa4:	200095f0 	.word	0x200095f0

0000afa8 <_isatty_r>:
    afa8:	b538      	push	{r3, r4, r5, lr}
    afaa:	4c06      	ldr	r4, [pc, #24]	; (afc4 <_isatty_r+0x1c>)
    afac:	2300      	movs	r3, #0
    afae:	4605      	mov	r5, r0
    afb0:	4608      	mov	r0, r1
    afb2:	6023      	str	r3, [r4, #0]
    afb4:	f7f6 fd1e 	bl	19f4 <_isatty>
    afb8:	1c43      	adds	r3, r0, #1
    afba:	d102      	bne.n	afc2 <_isatty_r+0x1a>
    afbc:	6823      	ldr	r3, [r4, #0]
    afbe:	b103      	cbz	r3, afc2 <_isatty_r+0x1a>
    afc0:	602b      	str	r3, [r5, #0]
    afc2:	bd38      	pop	{r3, r4, r5, pc}
    afc4:	200095f0 	.word	0x200095f0

0000afc8 <_lseek_r>:
    afc8:	b538      	push	{r3, r4, r5, lr}
    afca:	4c07      	ldr	r4, [pc, #28]	; (afe8 <_lseek_r+0x20>)
    afcc:	4605      	mov	r5, r0
    afce:	4608      	mov	r0, r1
    afd0:	4611      	mov	r1, r2
    afd2:	2200      	movs	r2, #0
    afd4:	6022      	str	r2, [r4, #0]
    afd6:	461a      	mov	r2, r3
    afd8:	f7f6 fd0e 	bl	19f8 <_lseek>
    afdc:	1c43      	adds	r3, r0, #1
    afde:	d102      	bne.n	afe6 <_lseek_r+0x1e>
    afe0:	6823      	ldr	r3, [r4, #0]
    afe2:	b103      	cbz	r3, afe6 <_lseek_r+0x1e>
    afe4:	602b      	str	r3, [r5, #0]
    afe6:	bd38      	pop	{r3, r4, r5, pc}
    afe8:	200095f0 	.word	0x200095f0
    afec:	00000000 	.word	0x00000000

0000aff0 <memchr>:
    aff0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    aff4:	2a10      	cmp	r2, #16
    aff6:	db2b      	blt.n	b050 <memchr+0x60>
    aff8:	f010 0f07 	tst.w	r0, #7
    affc:	d008      	beq.n	b010 <memchr+0x20>
    affe:	f810 3b01 	ldrb.w	r3, [r0], #1
    b002:	3a01      	subs	r2, #1
    b004:	428b      	cmp	r3, r1
    b006:	d02d      	beq.n	b064 <memchr+0x74>
    b008:	f010 0f07 	tst.w	r0, #7
    b00c:	b342      	cbz	r2, b060 <memchr+0x70>
    b00e:	d1f6      	bne.n	affe <memchr+0xe>
    b010:	b4f0      	push	{r4, r5, r6, r7}
    b012:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    b016:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    b01a:	f022 0407 	bic.w	r4, r2, #7
    b01e:	f07f 0700 	mvns.w	r7, #0
    b022:	2300      	movs	r3, #0
    b024:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    b028:	3c08      	subs	r4, #8
    b02a:	ea85 0501 	eor.w	r5, r5, r1
    b02e:	ea86 0601 	eor.w	r6, r6, r1
    b032:	fa85 f547 	uadd8	r5, r5, r7
    b036:	faa3 f587 	sel	r5, r3, r7
    b03a:	fa86 f647 	uadd8	r6, r6, r7
    b03e:	faa5 f687 	sel	r6, r5, r7
    b042:	b98e      	cbnz	r6, b068 <memchr+0x78>
    b044:	d1ee      	bne.n	b024 <memchr+0x34>
    b046:	bcf0      	pop	{r4, r5, r6, r7}
    b048:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    b04c:	f002 0207 	and.w	r2, r2, #7
    b050:	b132      	cbz	r2, b060 <memchr+0x70>
    b052:	f810 3b01 	ldrb.w	r3, [r0], #1
    b056:	3a01      	subs	r2, #1
    b058:	ea83 0301 	eor.w	r3, r3, r1
    b05c:	b113      	cbz	r3, b064 <memchr+0x74>
    b05e:	d1f8      	bne.n	b052 <memchr+0x62>
    b060:	2000      	movs	r0, #0
    b062:	4770      	bx	lr
    b064:	3801      	subs	r0, #1
    b066:	4770      	bx	lr
    b068:	2d00      	cmp	r5, #0
    b06a:	bf06      	itte	eq
    b06c:	4635      	moveq	r5, r6
    b06e:	3803      	subeq	r0, #3
    b070:	3807      	subne	r0, #7
    b072:	f015 0f01 	tst.w	r5, #1
    b076:	d107      	bne.n	b088 <memchr+0x98>
    b078:	3001      	adds	r0, #1
    b07a:	f415 7f80 	tst.w	r5, #256	; 0x100
    b07e:	bf02      	ittt	eq
    b080:	3001      	addeq	r0, #1
    b082:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    b086:	3001      	addeq	r0, #1
    b088:	bcf0      	pop	{r4, r5, r6, r7}
    b08a:	3801      	subs	r0, #1
    b08c:	4770      	bx	lr
    b08e:	bf00      	nop

0000b090 <__malloc_lock>:
    b090:	4770      	bx	lr

0000b092 <__malloc_unlock>:
    b092:	4770      	bx	lr

0000b094 <_read_r>:
    b094:	b538      	push	{r3, r4, r5, lr}
    b096:	4c07      	ldr	r4, [pc, #28]	; (b0b4 <_read_r+0x20>)
    b098:	4605      	mov	r5, r0
    b09a:	4608      	mov	r0, r1
    b09c:	4611      	mov	r1, r2
    b09e:	2200      	movs	r2, #0
    b0a0:	6022      	str	r2, [r4, #0]
    b0a2:	461a      	mov	r2, r3
    b0a4:	f7fe fee4 	bl	9e70 <_read>
    b0a8:	1c43      	adds	r3, r0, #1
    b0aa:	d102      	bne.n	b0b2 <_read_r+0x1e>
    b0ac:	6823      	ldr	r3, [r4, #0]
    b0ae:	b103      	cbz	r3, b0b2 <_read_r+0x1e>
    b0b0:	602b      	str	r3, [r5, #0]
    b0b2:	bd38      	pop	{r3, r4, r5, pc}
    b0b4:	200095f0 	.word	0x200095f0
    b0b8:	652f2e2e 	.word	0x652f2e2e
    b0bc:	72656874 	.word	0x72656874
    b0c0:	5f74656e 	.word	0x5f74656e
    b0c4:	2f796870 	.word	0x2f796870
    b0c8:	65687465 	.word	0x65687465
    b0cc:	74656e72 	.word	0x74656e72
    b0d0:	7968705f 	.word	0x7968705f
    b0d4:	0000632e 	.word	0x0000632e
    b0d8:	682f2e2e 	.word	0x682f2e2e
    b0dc:	732f6c61 	.word	0x732f6c61
    b0e0:	682f6372 	.word	0x682f6372
    b0e4:	695f6c61 	.word	0x695f6c61
    b0e8:	6d5f6332 	.word	0x6d5f6332
    b0ec:	6e79735f 	.word	0x6e79735f
    b0f0:	00632e63 	.word	0x00632e63
    b0f4:	682f2e2e 	.word	0x682f2e2e
    b0f8:	732f6c61 	.word	0x732f6c61
    b0fc:	682f6372 	.word	0x682f6372
    b100:	695f6c61 	.word	0x695f6c61
    b104:	00632e6f 	.word	0x00632e6f
    b108:	682f2e2e 	.word	0x682f2e2e
    b10c:	732f6c61 	.word	0x732f6c61
    b110:	682f6372 	.word	0x682f6372
    b114:	6d5f6c61 	.word	0x6d5f6c61
    b118:	615f6361 	.word	0x615f6361
    b11c:	636e7973 	.word	0x636e7973
    b120:	0000632e 	.word	0x0000632e
    b124:	682f2e2e 	.word	0x682f2e2e
    b128:	732f6c61 	.word	0x732f6c61
    b12c:	682f6372 	.word	0x682f6372
    b130:	745f6c61 	.word	0x745f6c61
    b134:	72656d69 	.word	0x72656d69
    b138:	0000632e 	.word	0x0000632e
    b13c:	682f2e2e 	.word	0x682f2e2e
    b140:	732f6c61 	.word	0x732f6c61
    b144:	682f6372 	.word	0x682f6372
    b148:	755f6c61 	.word	0x755f6c61
    b14c:	74726173 	.word	0x74726173
    b150:	7973615f 	.word	0x7973615f
    b154:	632e636e 	.word	0x632e636e
    b158:	00000000 	.word	0x00000000
    b15c:	682f2e2e 	.word	0x682f2e2e
    b160:	732f6c61 	.word	0x732f6c61
    b164:	682f6372 	.word	0x682f6372
    b168:	755f6c61 	.word	0x755f6c61
    b16c:	74726173 	.word	0x74726173
    b170:	6e79735f 	.word	0x6e79735f
    b174:	00632e63 	.word	0x00632e63
    b178:	682f2e2e 	.word	0x682f2e2e
    b17c:	752f6c61 	.word	0x752f6c61
    b180:	736c6974 	.word	0x736c6974
    b184:	6372732f 	.word	0x6372732f
    b188:	6974752f 	.word	0x6974752f
    b18c:	6c5f736c 	.word	0x6c5f736c
    b190:	2e747369 	.word	0x2e747369
    b194:	00000063 	.word	0x00000063
    b198:	682f2e2e 	.word	0x682f2e2e
    b19c:	752f6c61 	.word	0x752f6c61
    b1a0:	736c6974 	.word	0x736c6974
    b1a4:	6372732f 	.word	0x6372732f
    b1a8:	6974752f 	.word	0x6974752f
    b1ac:	725f736c 	.word	0x725f736c
    b1b0:	62676e69 	.word	0x62676e69
    b1b4:	65666675 	.word	0x65666675
    b1b8:	00632e72 	.word	0x00632e72
    b1bc:	682f2e2e 	.word	0x682f2e2e
    b1c0:	672f6c70 	.word	0x672f6c70
    b1c4:	2f63616d 	.word	0x2f63616d
    b1c8:	5f6c7068 	.word	0x5f6c7068
    b1cc:	63616d67 	.word	0x63616d67
    b1d0:	0000632e 	.word	0x0000632e
    b1d4:	40003000 	.word	0x40003000
    b1d8:	40003400 	.word	0x40003400
    b1dc:	41012000 	.word	0x41012000
    b1e0:	41014000 	.word	0x41014000
    b1e4:	43000000 	.word	0x43000000
    b1e8:	43000400 	.word	0x43000400
    b1ec:	43000800 	.word	0x43000800
    b1f0:	43000c00 	.word	0x43000c00

0000b1f4 <_usarts>:
    b1f4:	00000000 40100004 00030000 00700002     .......@......p.
    b204:	00001412 00000000 00000001 40100004     ...............@
    b214:	00030000 00700002 00001412 00000000     ......p.........

0000b224 <_i2cms>:
    b224:	00000003 00200014 00000100 000000ff     ...... .........
    b234:	00d70000 07270e00 682f2e2e 732f6c70     ......'.../hpl/s
    b244:	6f637265 70682f6d 65735f6c 6d6f6372     ercom/hpl_sercom
    b254:	0000632e 40003800 40003c00 4101a000     .c...8.@.<.@...A
    b264:	4101c000 42001400 42001800 43001400     ...A...B...B...C
    b274:	43001800                                ...C

0000b278 <_tcs>:
    b278:	006b0000 00000008 00000000 00000032     ..k.........2...
    b288:	00000000 682f2e2e 742f6c70 70682f63     ....../hpl/tc/hp
    b298:	63745f6c 0000632e 6c2f2e2e 2f706977     l_tc.c..../lwip/
    b2a8:	7069776c 342e312d 732f302e 632f6372     lwip-1.4.0/src/c
    b2b8:	2f65726f 70636864 0000632e 70636864     ore/dhcp.c..dhcp
    b2c8:	74706f5f 5f6e6f69 69617274 3a72656c     _option_trailer:
    b2d8:	63686420 3d212070 4c554e20 0000004c      dhcp != NULL...
    b2e8:	65737341 6f697472 2522206e 66202273     Assertion "%s" f
    b2f8:	656c6961 74612064 6e696c20 64252065     ailed at line %d
    b308:	206e6920 000a7325 70636864 6572635f      in %s..dhcp_cre
    b318:	5f657461 3a67736d 74656e20 21206669     ate_msg: netif !
    b328:	554e203d 00004c4c 70636864 6572635f     = NULL..dhcp_cre
    b338:	5f657461 3a67736d 63686420 3d212070     ate_msg: dhcp !=
    b348:	4c554e20 0000004c 70636864 6572635f      NULL...dhcp_cre
    b358:	5f657461 2867736d 63203a29 646c756f     ate_msg(): could
    b368:	746f6e20 6c6c6120 7461636f 62702065      not allocate pb
    b378:	00006675 6e617274 74636173 206e6f69     uf..transaction 
    b388:	78206469 25286469 000a2978 70636864     id xid(%x)..dhcp
    b398:	6c65645f 5f657465 3a67736d 63686420     _delete_msg: dhc
    b3a8:	3d212070 4c554e20 0000004c 70636864     p != NULL...dhcp
    b3b8:	6265725f 28646e69 00000029 70636864     _rebind()...dhcp
    b3c8:	6265725f 3a646e69 42455220 49444e49     _rebind: REBINDI
    b3d8:	0000474e 70636864 6265725f 3a646e69     NG..dhcp_rebind:
    b3e8:	756f6320 6e20646c 6120746f 636f6c6c      could not alloc
    b3f8:	20657461 50434844 71657220 74736575     ate DHCP request
    b408:	00000000 70636864 6265725f 28646e69     ....dhcp_rebind(
    b418:	73203a29 72207465 65757165 74207473     ): set request t
    b428:	6f656d69 25207475 6d207568 73636573     imeout %hu msecs
    b438:	0000000a 70636864 7369645f 65766f63     ....dhcp_discove
    b448:	00292872 70636864 7369645f 65766f63     r().dhcp_discove
    b458:	6d203a72 6e696b61 65722067 73657571     r: making reques
    b468:	00000074 70636864 7369645f 65766f63     t...dhcp_discove
    b478:	72203a72 6c6c6165 2928636f 00676e69     r: realloc()ing.
    b488:	70636864 7369645f 65766f63 73203a72     dhcp_discover: s
    b498:	74646e65 4944286f 564f4353 202c5245     endto(DISCOVER, 
    b4a8:	415f5049 5f524444 414f5242 53414344     IP_ADDR_BROADCAS
    b4b8:	44202c54 5f504348 56524553 505f5245     T, DHCP_SERVER_P
    b4c8:	2954524f 00000000 70636864 7369645f     ORT)....dhcp_dis
    b4d8:	65766f63 64203a72 74656c65 28676e69     cover: deleting(
    b4e8:	676e6929 00000000 70636864 7369645f     )ing....dhcp_dis
    b4f8:	65766f63 53203a72 43454c45 474e4954     cover: SELECTING
    b508:	00000000 70636864 7369645f 65766f63     ....dhcp_discove
    b518:	63203a72 646c756f 746f6e20 6c6c6120     r: could not all
    b528:	7461636f 48442065 72205043 65757165     ocate DHCP reque
    b538:	00007473 70636864 7369645f 65766f63     st..dhcp_discove
    b548:	3a292872 74657320 71657220 74736575     r(): set request
    b558:	6d697420 74756f65 75682520 65736d20      timeout %hu mse
    b568:	000a7363 70636864 6c65735f 28746365     cs..dhcp_select(
    b578:	6974656e 70253d66 63252029 68256325     netif=%p) %c%c%h
    b588:	00000a75 70636864 6c65735f 3a746365     u...dhcp_select:
    b598:	51455220 54534555 00474e49 70636864      REQUESTING.dhcp
    b5a8:	6c65735f 3a746365 756f6320 6e20646c     _select: could n
    b5b8:	6120746f 636f6c6c 20657461 50434844     ot allocate DHCP
    b5c8:	71657220 74736575 00000000 70636864      request....dhcp
    b5d8:	6c65735f 28746365 73203a29 72207465     _select(): set r
    b5e8:	65757165 74207473 6f656d69 25207475     equest timeout %
    b5f8:	6d207568 73636573 0000000a 70636864     hu msecs....dhcp
    b608:	6265725f 28746f6f 00000029 70636864     _reboot()...dhcp
    b618:	6265725f 3a746f6f 42455220 49544f4f     _reboot: REBOOTI
    b628:	0000474e 70636864 6265725f 3a746f6f     NG..dhcp_reboot:
    b638:	756f6320 6e20646c 6120746f 636f6c6c      could not alloc
    b648:	20657461 50434844 71657220 74736575     ate DHCP request
    b658:	00000000 70636864 6265725f 28746f6f     ....dhcp_reboot(
    b668:	73203a29 72207465 65757165 74207473     ): set request t
    b678:	6f656d69 25207475 6d207568 73636573     imeout %hu msecs
    b688:	0000000a 70636864 6568635f 6e286b63     ....dhcp_check(n
    b698:	66697465 2970253d 25632520 00000a63     etif=%p) %c%c...
    b6a8:	70636864 6568635f 203a6b63 6c756f63     dhcp_check: coul
    b6b8:	6f6e2064 65702074 726f6672 5241206d     d not perform AR
    b6c8:	75712050 00797265 70636864 6568635f     P query.dhcp_che
    b6d8:	29286b63 6573203a 65722074 73657571     ck(): set reques
    b6e8:	69742074 756f656d 68252074 736d2075     t timeout %hu ms
    b6f8:	0a736365 00000000 70636864 6e69625f     ecs.....dhcp_bin
    b708:	6e203a64 66697465 203d2120 4c4c554e     d: netif != NULL
    b718:	00000000 70636864 6e69625f 64203a64     ....dhcp_bind: d
    b728:	20706368 4e203d21 004c4c55 70636864     hcp != NULL.dhcp
    b738:	6e69625f 656e2864 3d666974 20297025     _bind(netif=%p) 
    b748:	63256325 0a756825 00000000 70636864     %c%c%hu.....dhcp
    b758:	6e69625f 3a292864 20317420 656e6572     _bind(): t1 rene
    b768:	206c6177 656d6974 75252072 63657320     wal timer %u sec
    b778:	00000a73 70636864 6e69625f 3a292864     s...dhcp_bind():
    b788:	74657320 71657220 74736575 6d697420      set request tim
    b798:	74756f65 20752520 6365736d 00000a73     eout %u msecs...
    b7a8:	70636864 6e69625f 3a292864 20327420     dhcp_bind(): t2 
    b7b8:	69626572 7420646e 72656d69 20752520     rebind timer %u 
    b7c8:	73636573 0000000a 70636864 6e69625f     secs....dhcp_bin
    b7d8:	3a292864 3a504920 25783020 0a783830     d(): IP: 0x%08x.
    b7e8:	00000000 70636864 6e69625f 3a292864     ....dhcp_bind():
    b7f8:	3a4e5320 25783020 0a783830 00000000      SN: 0x%08x.....
    b808:	70636864 6e69625f 3a292864 3a574720     dhcp_bind(): GW:
    b818:	25783020 0a783830 00000000 70636864      0x%08x.....dhcp
    b828:	6365725f 62702876 3d206675 29702520     _recv(pbuf = %p)
    b838:	6f726620 4844206d 73205043 65767265      from DHCP serve
    b848:	68252072 68252e75 68252e75 68252e75     r %hu.%hu.%hu.%h
    b858:	6f702075 25207472 000a7568 66756270     u port %hu..pbuf
    b868:	656c3e2d 203d206e 0a756825 00000000     ->len = %hu.....
    b878:	66756270 6f743e2d 656c5f74 203d206e     pbuf->tot_len = 
    b888:	0a756825 00000000 50434844 70657220     %hu.....DHCP rep
    b898:	6d20796c 61737365 6f206567 62702072     ly message or pb
    b8a8:	74206675 73206f6f 74726f68 00000000     uf too short....
    b8b8:	20746f6e 48442061 72205043 796c7065     not a DHCP reply
    b8c8:	73656d20 65676173 7562202c 79742074      message, but ty
    b8d8:	25206570 000a7568 6974656e 683e2d66     pe %hu..netif->h
    b8e8:	64646177 68255b72 3d3d5d75 68323025     waddr[%hu]==%02h
    b8f8:	3d212078 70657220 6d5f796c 3e2d6773     x != reply_msg->
    b908:	64616863 255b7264 3d5d7568 3230253d     chaddr[%hu]==%02
    b918:	000a7868 6e617274 74636173 206e6f69     hx..transaction 
    b928:	6d206469 616d7369 20686374 6c706572     id mismatch repl
    b938:	736d5f79 783e2d67 25286469 3d212978     y_msg->xid(%x)!=
    b948:	70636864 69783e2d 78252864 00000a29     dhcp->xid(%x)...
    b958:	206e656c 34203d3d 00000000 206e656c     len == 4....len 
    b968:	64203d3e 646f6365 656c5f65 0000006e     >= decode_len...
    b978:	206e656c 20342025 30203d3d 00000000     len % 4 == 0....
    b988:	206e656c 31203d3d 00000000 70696b73     len == 1....skip
    b998:	676e6970 74706f20 206e6f69 20756825     ping option %hu 
    b9a8:	6f206e69 6f697470 000a736e 6f636564     in options..deco
    b9b8:	6c5f6564 25206e65 3d203420 0030203d     de_len % 4 == 0.
    b9c8:	61766e69 2064696c 6f636564 6c5f6564     invalid decode_l
    b9d8:	00006e65 7265766f 64616f6c 66206465     en..overloaded f
    b9e8:	20656c69 6c656966 00000064 7265766f     ile field...over
    b9f8:	64616f6c 73206465 656d616e 65696620     loaded sname fie
    ba08:	0000646c 7265766f 64616f6c 73206465     ld..overloaded s
    ba18:	656d616e 646e6120 6c696620 69662065     name and file fi
    ba28:	00646c65 61766e69 2064696c 7265766f     eld.invalid over
    ba38:	64616f6c 74706f20 3a6e6f69 0a642520     load option: %d.
    ba48:	00000000 626f7270 206d656c 6f666e75     ....problem unfo
    ba58:	6e69646c 48442067 6d205043 61737365     lding DHCP messa
    ba68:	2d206567 6f6f7420 6f687320 6f207472     ge - too short o
    ba78:	656d206e 79726f6d 0000003f 72616573     n memory?...sear
    ba88:	6e696863 48442067 4f5f5043 4f495450     ching DHCP_OPTIO
    ba98:	454d5f4e 47415353 59545f45 00004550     N_MESSAGE_TYPE..
    baa8:	50434844 54504f5f 5f4e4f49 5353454d     DHCP_OPTION_MESS
    bab8:	5f454741 45505954 74706f20 206e6f69     AGE_TYPE option 
    bac8:	20746f6e 6e756f66 00000064 50434844     not found...DHCP
    bad8:	4b43415f 63657220 65766965 00000064     _ACK received...
    bae8:	50434844 4b414e5f 63657220 65766965     DHCP_NAK receive
    baf8:	00000064 70636864 6e61685f 5f656c64     d...dhcp_handle_
    bb08:	286b616e 6974656e 70253d66 63252029     nak(netif=%p) %c
    bb18:	68256325 00000a75 50434844 46464f5f     %c%hu...DHCP_OFF
    bb28:	72205245 69656365 20646576 44206e69     ER received in D
    bb38:	5f504348 454c4553 4e495443 74732047     HCP_SELECTING st
    bb48:	00657461 70636864 6e61685f 5f656c64     ate.dhcp_handle_
    bb58:	6566666f 656e2872 3d666974 20297025     offer(netif=%p) 
    bb68:	63256325 0a756825 00000000 70636864     %c%c%hu.....dhcp
    bb78:	6e61685f 5f656c64 6566666f 3a292872     _handle_offer():
    bb88:	72657320 20726576 30257830 000a7838      server 0x%08x..
    bb98:	70636864 6e61685f 5f656c64 6566666f     dhcp_handle_offe
    bba8:	3a292872 66666f20 66207265 3020726f     r(): offer for 0
    bbb8:	38302578 00000a78 70636864 6e61685f     x%08x...dhcp_han
    bbc8:	5f656c64 6566666f 656e2872 3d666974     dle_offer(netif=
    bbd8:	20297025 20646964 20746f6e 20746567     %p) did not get 
    bbe8:	76726573 49207265 000a2144 6974656e     server ID!..neti
    bbf8:	3d212066 4c554e20 0000004c 70636864     f != NULL...dhcp
    bc08:	666e695f 286d726f 63203a29 646c756f     _inform(): could
    bc18:	746f6e20 74626f20 206e6961 00626370      not obtain pcb.
    bc28:	70636864 666e695f 286d726f 63203a29     dhcp_inform(): c
    bc38:	74616572 6e206465 75207765 70207064     reated new udp p
    bc48:	00006263 70636864 666e695f 3a6d726f     cb..dhcp_inform:
    bc58:	464e4920 494d524f 0000474e 70636864      INFORMING..dhcp
    bc68:	666e695f 3a6d726f 756f6320 6e20646c     _inform: could n
    bc78:	6120746f 636f6c6c 20657461 50434844     ot allocate DHCP
    bc88:	71657220 74736575 00000000 70636864      request....dhcp
    bc98:	7072615f 7065725f 2928796c 00000000     _arp_reply()....
    bca8:	70636864 7072615f 7065725f 2928796c     dhcp_arp_reply()
    bcb8:	4843203a 494b4345 202c474e 20707261     : CHECKING, arp 
    bcc8:	6c706572 6f662079 78302072 78383025     reply for 0x%08x
    bcd8:	0000000a 70636864 7072615f 7065725f     ....dhcp_arp_rep
    bce8:	2928796c 7261203a 65722070 20796c70     ly(): arp reply 
    bcf8:	6374616d 20646568 68746977 66666f20     matched with off
    bd08:	64657265 64646120 73736572 6564202c     ered address, de
    bd18:	6e696c63 00676e69 70636864 6365645f     clining.dhcp_dec
    bd28:	656e696c 00002928 70636864 6365645f     line()..dhcp_dec
    bd38:	656e696c 4142203a 4e494b43 464f2047     line: BACKING OF
    bd48:	00000046 70636864 6365645f 656e696c     F...dhcp_decline
    bd58:	6f63203a 20646c75 20746f6e 6f6c6c61     : could not allo
    bd68:	65746163 43484420 65722050 73657571     cate DHCP reques
    bd78:	00000074 70636864 6365645f 656e696c     t...dhcp_decline
    bd88:	203a2928 20746573 75716572 20747365     (): set request 
    bd98:	656d6974 2074756f 20756825 6365736d     timeout %hu msec
    bda8:	00000a73 70636864 6e65725f 29287765     s...dhcp_renew()
    bdb8:	00000000 70636864 6e65725f 203a7765     ....dhcp_renew: 
    bdc8:	454e4552 474e4957 00000000 70636864     RENEWING....dhcp
    bdd8:	6e65725f 203a7765 6c756f63 6f6e2064     _renew: could no
    bde8:	6c612074 61636f6c 44206574 20504348     t allocate DHCP 
    bdf8:	75716572 00747365 70636864 6e65725f     request.dhcp_ren
    be08:	29287765 6573203a 65722074 73657571     ew(): set reques
    be18:	69742074 756f656d 68252074 736d2075     t timeout %hu ms
    be28:	0a736365 00000000 70636864 616f635f     ecs.....dhcp_coa
    be38:	5f657372 28726d74 00000029 70636864     rse_tmr()...dhcp
    be48:	616f635f 5f657372 28726d74 74203a29     _coarse_tmr(): t
    be58:	69742032 756f656d 00000074 70636864     2 timeout...dhcp
    be68:	5f32745f 656d6974 2874756f 00000029     _t2_timeout()...
    be78:	70636864 5f32745f 656d6974 2874756f     dhcp_t2_timeout(
    be88:	6d203a29 20747375 69626572 0000646e     ): must rebind..
    be98:	70636864 616f635f 5f657372 28726d74     dhcp_coarse_tmr(
    bea8:	74203a29 69742031 756f656d 00000074     ): t1 timeout...
    beb8:	70636864 5f31745f 656d6974 2874756f     dhcp_t1_timeout(
    bec8:	00000029 70636864 5f31745f 656d6974     )...dhcp_t1_time
    bed8:	2874756f 6d203a29 20747375 656e6572     out(): must rene
    bee8:	00000077 70636864 6c65725f 65736165     w...dhcp_release
    bef8:	00002928 70636864 6c65725f 65736165     ()..dhcp_release
    bf08:	4552203a 5341454c 202c4445 50434844     : RELEASED, DHCP
    bf18:	46464f5f 00000000 70636864 6c65725f     _OFF....dhcp_rel
    bf28:	65736165 6f63203a 20646c75 20746f6e     ease: could not 
    bf38:	6f6c6c61 65746163 43484420 65722050     allocate DHCP re
    bf48:	73657571 00000074 70636864 6c65725f     quest...dhcp_rel
    bf58:	65736165 203a2928 20746573 75716572     ease(): set requ
    bf68:	20747365 656d6974 2074756f 20756825     est timeout %hu 
    bf78:	6365736d 00000a73 70636864 6e69665f     msecs...dhcp_fin
    bf88:	6d745f65 3a292872 71657220 74736575     e_tmr(): request
    bf98:	6d697420 74756f65 00000000 70636864      timeout....dhcp
    bfa8:	6d69745f 74756f65 00002928 70636864     _timeout()..dhcp
    bfb8:	6d69745f 74756f65 203a2928 74736572     _timeout(): rest
    bfc8:	69747261 6420676e 6f637369 79726576     arting discovery
    bfd8:	00000000 70636864 6d69745f 74756f65     ....dhcp_timeout
    bfe8:	203a2928 55514552 49545345 202c474e     (): REQUESTING, 
    bff8:	50434844 71657220 74736575 6d697420     DHCP request tim
    c008:	6f206465 00007475 70636864 6d69745f     ed out..dhcp_tim
    c018:	74756f65 203a2928 55514552 49545345     eout(): REQUESTI
    c028:	202c474e 656c6572 6e697361 72202c67     NG, releasing, r
    c038:	61747365 6e697472 00000067 70636864     estarting...dhcp
    c048:	6d69745f 74756f65 203a2928 43454843     _timeout(): CHEC
    c058:	474e494b 5241202c 65722050 73657571     KING, ARP reques
    c068:	69742074 2064656d 0074756f 70636864     t timed out.dhcp
    c078:	6d69745f 74756f65 203a2928 454e4552     _timeout(): RENE
    c088:	474e4957 4844202c 72205043 65757165     WING, DHCP reque
    c098:	74207473 64656d69 74756f20 00000000     st timed out....
    c0a8:	70636864 6d69745f 74756f65 203a2928     dhcp_timeout(): 
    c0b8:	49424552 4e49444e 44202c47 20504348     REBINDING, DHCP 
    c0c8:	75716572 20747365 656d6974 756f2064     request timed ou
    c0d8:	00000074 70636864 6d69745f 74756f65     t...dhcp_timeout
    c0e8:	203a2928 454c4552 4e495341 44202c47     (): RELEASING, D
    c0f8:	4f435349 49524556 0000474e 70636864     ISCOVERING..dhcp
    c108:	6f74735f 6e203a70 66697465 203d2120     _stop: netif != 
    c118:	4c4c554e 00000000 70636864 6f74735f     NULL....dhcp_sto
    c128:	00292870 70636864 6174735f 6e287472     p().dhcp_start(n
    c138:	66697465 2970253d 25632520 75682563     etif=%p) %c%c%hu
    c148:	0000000a 70636864 6174735f 29287472     ....dhcp_start()
    c158:	6f4e203a 48544520 20505241 6974656e     : No ETHARP neti
    c168:	00000066 70636864 6174735f 29287472     f...dhcp_start()
    c178:	6143203a 746f6e6e 65737520 69687420     : Cannot use thi
    c188:	656e2073 20666974 68746977 43484420     s netif with DHC
    c198:	4d203a50 69205554 6f742073 6d73206f     P: MTU is too sm
    c1a8:	006c6c61 70636864 6174735f 29287472     all.dhcp_start()
    c1b8:	7473203a 69747261 6e20676e 44207765     : starting new D
    c1c8:	20504348 65696c63 0000746e 70636864     HCP client..dhcp
    c1d8:	6174735f 29287472 6f63203a 20646c75     _start(): could 
    c1e8:	20746f6e 6f6c6c61 65746163 63686420     not allocate dhc
    c1f8:	00000070 70636864 6174735f 29287472     p...dhcp_start()
    c208:	6c61203a 61636f6c 20646574 70636864     : allocated dhcp
    c218:	00000000 70636864 6174735f 29287472     ....dhcp_start()
    c228:	6572203a 72617473 676e6974 43484420     : restarting DHC
    c238:	6f632050 6769666e 74617275 006e6f69     P configuration.
    c248:	70636864 6174735f 29287472 6f63203a     dhcp_start(): co
    c258:	20646c75 20746f6e 6174626f 70206e69     uld not obtain p
    c268:	00006263 70636864 6174735f 29287472     cb..dhcp_start()
    c278:	7473203a 69747261 4420676e 20504348     : starting DHCP 
    c288:	666e6f63 72756769 6f697461 0000006e     configuration...

0000c298 <ip_addr_broadcast>:
    c298:	ffffffff                                ....

0000c29c <ip_addr_any>:
    c29c:	00000000                                ....

0000c2a0 <memp_num>:
    c2a0:	00040004 00080005 00050010 0005000f     ................
    c2b0:	00100010                                ....

0000c2b4 <memp_sizes>:
    c2b4:	0020001c 001c0098 00200014 00100018     .. ....... .....
    c2c4:	05fc0010 6c2f2e2e 2f706977 7069776c     ....../lwip/lwip
    c2d4:	342e312d 732f302e 632f6372 2f65726f     -1.4.0/src/core/
    c2e4:	706d656d 0000632e 706d656d 6c616d5f     memp.c..memp_mal
    c2f4:	3a636f6c 70797420 203c2065 504d454d     loc: type < MEMP
    c304:	58414d5f 00000000 6c2f2e2e 2f706977     _MAX....../lwip/
    c314:	7069776c 342e312d 732f302e 632f6372     lwip-1.4.0/src/c
    c324:	2f65726f 66756270 0000632e 72636e69     ore/pbuf.c..incr
    c334:	6e656d65 616d5f74 74696e67 20656475     ement_magnitude 
    c344:	70203d3c 656c3e2d 0000006e 21206828     <= p->len...(h !
    c354:	554e203d 20294c4c 28202626 3d212074     = NULL) && (t !=
    c364:	4c554e20 2820294c 676f7270 6d6d6172      NULL) (programm
    c374:	76207265 616c6f69 20736574 29495041     er violates API)
    c384:	00000000 66756270 706f635f 74203a79     ....pbuf_copy: t
    c394:	65677261 6f6e2074 69622074 6e652067     arget not big en
    c3a4:	6867756f 206f7420 646c6f68 756f7320     ough to hold sou
    c3b4:	00656372 6f745f70 203d2120 4c4c554e     rce.p_to != NULL
    c3c4:	00000000 66756270 706f635f 20292879     ....pbuf_copy() 
    c3d4:	73656f64 746f6e20 6c6c6120 7020776f     does not allow p
    c3e4:	656b6361 75712074 73657565 00000a21     acket queues!...
    c3f4:	66756270 706f635f 61705f79 61697472     pbuf_copy_partia
    c404:	69203a6c 6c61766e 62206469 00006675     l: invalid buf..
    c414:	66756270 706f635f 61705f79 61697472     pbuf_copy_partia
    c424:	69203a6c 6c61766e 64206469 70617461     l: invalid datap
    c434:	00007274 66756270 6b61745f 69203a65     tr..pbuf_take: i
    c444:	6c61766e 62206469 00006675 66756270     nvalid buf..pbuf
    c454:	6b61745f 69203a65 6c61766e 64206469     _take: invalid d
    c464:	70617461 00007274                       ataptr..

0000c46c <tcp_pcb_lists>:
    c46c:	20009308 20009310 20009300 20009314     ... ... ... ... 

0000c47c <tcp_persist_backoff>:
    c47c:	180c0603 00786030                       ....0`x.

0000c484 <tcp_backoff>:
    c484:	04030201 07070605 07070707 00000007     ................

0000c494 <tcp_state_str>:
    c494:	0000c560 0000c568 0000c570 0000c57c     `...h...p...|...
    c4a4:	0000c588 0000c594 0000c5a0 0000c5ac     ................
    c4b4:	0000c5b8 0000c5c0 0000c5cc 6c2f2e2e     ............../l
    c4c4:	2f706977 7069776c 342e312d 732f302e     wip/lwip-1.4.0/s
    c4d4:	632f6372 2f65726f 2e706374 00000063     rc/core/tcp.c...
    c4e4:	5f706374 646e6962 6163203a 6e6f206e     tcp_bind: can on
    c4f4:	6220796c 20646e69 73206e69 65746174     ly bind in state
    c504:	4f4c4320 00444553 5f706374 7473696c      CLOSED.tcp_list
    c514:	203a6e65 20626370 65726c61 20796461     en: pcb already 
    c524:	6e6e6f63 65746365 00000064 5f706374     connected...tcp_
    c534:	6e6e6f63 3a746365 6e616320 6c6e6f20     connect: can onl
    c544:	6f632079 63656e6e 72662074 73206d6f     y connect from s
    c554:	65746174 4f4c4320 00444553 534f4c43     tate CLOSED.CLOS
    c564:	00004445 5453494c 00004e45 5f4e5953     ED..LISTEN..SYN_
    c574:	544e4553 00000000 5f4e5953 44564352     SENT....SYN_RCVD
    c584:	00000000 41545345 53494c42 00444548     ....ESTABLISHED.
    c594:	5f4e4946 54494157 0000315f 5f4e4946     FIN_WAIT_1..FIN_
    c5a4:	54494157 0000325f 534f4c43 41575f45     WAIT_2..CLOSE_WA
    c5b4:	00005449 534f4c43 00474e49 5453414c     IT..CLOSING.LAST
    c5c4:	4b43415f 00000000 454d4954 4941575f     _ACK....TIME_WAI
    c5d4:	00000054                                T...

0000c5d8 <ethzero>:
	...

0000c5e0 <ethbroadcast>:
    c5e0:	ffffffff 0000ffff 6c2f2e2e 2f706977     ........../lwip/
    c5f0:	7069776c 342e312d 732f302e 6e2f6372     lwip-1.4.0/src/n
    c600:	66697465 6874652f 2e707261 00000063     etif/etharp.c...
    c610:	43484428 00002950 41545328 29434954     (DHCP)..(STATIC)
    c620:	00000000 65746e49 63616672 70552065     ....Interface Up
    c630:	3a732520 0000000a 65746e49 63616672      %s:....Interfac
    c640:	6f442065 002e6e77 6b6e694c 2e705520     e Down..Link Up.
    c650:	00000000 74736552 69747261 4420676e     ....Restarting D
    c660:	00504348 6b6e694c 776f4420 00002e6e     HCP.Link Down...
    c670:	2e2f2e2e 69616d2f 00632e6e 25203a57     .././main.c.W: %
    c680:	0a573a73 00000000 00206425 6f746f4d     s:W.....%d .Moto
    c690:	00000072 00007325 2a2a2a2a 2a2a2a2a     r...%s..********
    c6a0:	2a2a2a2a 2a2a2a2a 2a2a2a2a 2a2a2a2a     ****************
    c6b0:	000a2a2a 4d687445 726f746f 6d724173     **..EthMotorsArm
    c6c0:	5652445f 30303838 7665725f 000a3330     _DRV8800_rev03..
    c6d0:	65480a0d 206f6c6c 454d5441 6f57204c     ..Hello ATMEL Wo
    c6e0:	21646c72 0000000d 65687445 74656e72     rld!....Ethernet
    c6f0:	6e6f4320 7463656e 206e6f69 61747365      Connection esta
    c700:	73696c62 00646568 50434844 61745320     blished.DHCP Sta
    c710:	64657472 0000000d 415f5049 20524444     rted....IP_ADDR 
    c720:	3a202020 0d732520 0000000a 5f54454e        : %s.....NET_
    c730:	4b53414d 3a202020 0d732520 0000000a     MASK   : %s.....
    c740:	45544147 5f594157 3a205049 0d732520     GATEWAY_IP : %s.
    c750:	0000000a                                ....

0000c754 <_global_impure_ptr>:
    c754:	20000014                                ... 

0000c758 <__sf_fake_stderr>:
	...

0000c778 <__sf_fake_stdin>:
	...

0000c798 <__sf_fake_stdout>:
	...
    c7b8:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
    c7c8:	32313000 36353433 41393837 45444342     .0123456789ABCDE
    c7d8:	31300046 35343332 39383736 64636261     F.0123456789abcd
    c7e8:	00006665                                ef..

0000c7ec <_init>:
    c7ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c7ee:	bf00      	nop
    c7f0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    c7f2:	bc08      	pop	{r3}
    c7f4:	469e      	mov	lr, r3
    c7f6:	4770      	bx	lr

0000c7f8 <__init_array_start>:
    c7f8:	00000289 	.word	0x00000289

0000c7fc <_fini>:
    c7fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c7fe:	bf00      	nop
    c800:	bcf8      	pop	{r3, r4, r5, r6, r7}
    c802:	bc08      	pop	{r3}
    c804:	469e      	mov	lr, r3
    c806:	4770      	bx	lr

0000c808 <__fini_array_start>:
    c808:	00000265 	.word	0x00000265
