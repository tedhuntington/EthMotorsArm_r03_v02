
EthMotorsArm_r03_v02.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000c94c  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000074  20000000  0000c94c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  00020074  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  00020074  2**0
                  CONTENTS
  4 .bss          00009574  20000080  0000c9e0  00020080  2**5
                  ALLOC
  5 .stack        00010004  200095f4  00015f54  00020080  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  00020074  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  000200a2  2**0
                  CONTENTS, READONLY
  8 .debug_info   0005bb89  00000000  00000000  000200fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00008f44  00000000  00000000  0007bc84  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000205aa  00000000  00000000  00084bc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00001710  00000000  00000000  000a5172  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001f98  00000000  00000000  000a6882  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0003c3dc  00000000  00000000  000a881a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000268ca  00000000  00000000  000e4bf6  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00112ea7  00000000  00000000  0010b4c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00004718  00000000  00000000  0021e368  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	f8 95 01 20 f1 02 00 00 ed 02 00 00 ed 02 00 00     ... ............
      10:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
      2c:	ed 02 00 00 ed 02 00 00 00 00 00 00 ed 02 00 00     ................
      3c:	b5 98 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      4c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      5c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      6c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      7c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      8c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      9c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      ac:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      bc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      cc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      dc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
      f4:	b1 20 00 00 2d 2b 00 00 41 2b 00 00 55 2b 00 00     . ..-+..A+..U+..
     104:	69 2b 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     i+..............
     114:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     124:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     134:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     144:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     154:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     164:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     174:	ed 02 00 00 00 00 00 00 00 00 00 00 ed 02 00 00     ................
     184:	ed 02 00 00 ed 02 00 00 ed 02 00 00 19 1b 00 00     ................
     194:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1a4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1b4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1c4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1d4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1e4:	ed 02 00 00 ed 02 00 00 f1 2d 00 00 ed 02 00 00     .........-......
     1f4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     204:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     214:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     224:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     234:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     244:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     254:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................

00000264 <__do_global_dtors_aux>:
     264:	b510      	push	{r4, lr}
     266:	4c05      	ldr	r4, [pc, #20]	; (27c <__do_global_dtors_aux+0x18>)
     268:	7823      	ldrb	r3, [r4, #0]
     26a:	b933      	cbnz	r3, 27a <__do_global_dtors_aux+0x16>
     26c:	4b04      	ldr	r3, [pc, #16]	; (280 <__do_global_dtors_aux+0x1c>)
     26e:	b113      	cbz	r3, 276 <__do_global_dtors_aux+0x12>
     270:	4804      	ldr	r0, [pc, #16]	; (284 <__do_global_dtors_aux+0x20>)
     272:	f3af 8000 	nop.w
     276:	2301      	movs	r3, #1
     278:	7023      	strb	r3, [r4, #0]
     27a:	bd10      	pop	{r4, pc}
     27c:	20000080 	.word	0x20000080
     280:	00000000 	.word	0x00000000
     284:	0000c94c 	.word	0x0000c94c

00000288 <frame_dummy>:
     288:	4b0c      	ldr	r3, [pc, #48]	; (2bc <frame_dummy+0x34>)
     28a:	b143      	cbz	r3, 29e <frame_dummy+0x16>
     28c:	480c      	ldr	r0, [pc, #48]	; (2c0 <frame_dummy+0x38>)
     28e:	490d      	ldr	r1, [pc, #52]	; (2c4 <frame_dummy+0x3c>)
     290:	b510      	push	{r4, lr}
     292:	f3af 8000 	nop.w
     296:	480c      	ldr	r0, [pc, #48]	; (2c8 <frame_dummy+0x40>)
     298:	6803      	ldr	r3, [r0, #0]
     29a:	b923      	cbnz	r3, 2a6 <frame_dummy+0x1e>
     29c:	bd10      	pop	{r4, pc}
     29e:	480a      	ldr	r0, [pc, #40]	; (2c8 <frame_dummy+0x40>)
     2a0:	6803      	ldr	r3, [r0, #0]
     2a2:	b933      	cbnz	r3, 2b2 <frame_dummy+0x2a>
     2a4:	4770      	bx	lr
     2a6:	4b09      	ldr	r3, [pc, #36]	; (2cc <frame_dummy+0x44>)
     2a8:	2b00      	cmp	r3, #0
     2aa:	d0f7      	beq.n	29c <frame_dummy+0x14>
     2ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     2b0:	4718      	bx	r3
     2b2:	4b06      	ldr	r3, [pc, #24]	; (2cc <frame_dummy+0x44>)
     2b4:	2b00      	cmp	r3, #0
     2b6:	d0f5      	beq.n	2a4 <frame_dummy+0x1c>
     2b8:	4718      	bx	r3
     2ba:	bf00      	nop
     2bc:	00000000 	.word	0x00000000
     2c0:	0000c94c 	.word	0x0000c94c
     2c4:	20000084 	.word	0x20000084
     2c8:	0000c94c 	.word	0x0000c94c
     2cc:	00000000 	.word	0x00000000

000002d0 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     2d0:	b508      	push	{r3, lr}
	system_init();
     2d2:	4b03      	ldr	r3, [pc, #12]	; (2e0 <atmel_start_init+0x10>)
     2d4:	4798      	blx	r3
	ethernet_phys_init();
     2d6:	4b03      	ldr	r3, [pc, #12]	; (2e4 <atmel_start_init+0x14>)
     2d8:	4798      	blx	r3
	stdio_redirect_init();
     2da:	4b03      	ldr	r3, [pc, #12]	; (2e8 <atmel_start_init+0x18>)
     2dc:	4798      	blx	r3
     2de:	bd08      	pop	{r3, pc}
     2e0:	000006f5 	.word	0x000006f5
     2e4:	00000dcd 	.word	0x00000dcd
     2e8:	0000a065 	.word	0x0000a065

000002ec <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     2ec:	e7fe      	b.n	2ec <Dummy_Handler>
	...

000002f0 <Reset_Handler>:
{
     2f0:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
     2f2:	4b1c      	ldr	r3, [pc, #112]	; (364 <Reset_Handler+0x74>)
     2f4:	4a1c      	ldr	r2, [pc, #112]	; (368 <Reset_Handler+0x78>)
     2f6:	429a      	cmp	r2, r3
     2f8:	d010      	beq.n	31c <Reset_Handler+0x2c>
                for (; pDest < &_erelocate;) {
     2fa:	4b1c      	ldr	r3, [pc, #112]	; (36c <Reset_Handler+0x7c>)
     2fc:	4a19      	ldr	r2, [pc, #100]	; (364 <Reset_Handler+0x74>)
     2fe:	429a      	cmp	r2, r3
     300:	d20c      	bcs.n	31c <Reset_Handler+0x2c>
     302:	3b01      	subs	r3, #1
     304:	1a9b      	subs	r3, r3, r2
     306:	f023 0303 	bic.w	r3, r3, #3
     30a:	3304      	adds	r3, #4
     30c:	4413      	add	r3, r2
     30e:	4916      	ldr	r1, [pc, #88]	; (368 <Reset_Handler+0x78>)
                        *pDest++ = *pSrc++;
     310:	f851 0b04 	ldr.w	r0, [r1], #4
     314:	f842 0b04 	str.w	r0, [r2], #4
                for (; pDest < &_erelocate;) {
     318:	429a      	cmp	r2, r3
     31a:	d1f9      	bne.n	310 <Reset_Handler+0x20>
        for (pDest = &_szero; pDest < &_ezero;) {
     31c:	4b14      	ldr	r3, [pc, #80]	; (370 <Reset_Handler+0x80>)
     31e:	4a15      	ldr	r2, [pc, #84]	; (374 <Reset_Handler+0x84>)
     320:	429a      	cmp	r2, r3
     322:	d20a      	bcs.n	33a <Reset_Handler+0x4a>
     324:	3b01      	subs	r3, #1
     326:	1a9b      	subs	r3, r3, r2
     328:	f023 0303 	bic.w	r3, r3, #3
     32c:	3304      	adds	r3, #4
     32e:	4413      	add	r3, r2
                *pDest++ = 0;
     330:	2100      	movs	r1, #0
     332:	f842 1b04 	str.w	r1, [r2], #4
        for (pDest = &_szero; pDest < &_ezero;) {
     336:	4293      	cmp	r3, r2
     338:	d1fb      	bne.n	332 <Reset_Handler+0x42>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     33a:	4b0f      	ldr	r3, [pc, #60]	; (378 <Reset_Handler+0x88>)
     33c:	4a0f      	ldr	r2, [pc, #60]	; (37c <Reset_Handler+0x8c>)
     33e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
     342:	609a      	str	r2, [r3, #8]
        SCB->CPACR |=  (0xFu << 20);
     344:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
     348:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
     34c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
     350:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     354:	f3bf 8f6f 	isb	sy
        __libc_init_array();
     358:	4b09      	ldr	r3, [pc, #36]	; (380 <Reset_Handler+0x90>)
     35a:	4798      	blx	r3
        main();
     35c:	4b09      	ldr	r3, [pc, #36]	; (384 <Reset_Handler+0x94>)
     35e:	4798      	blx	r3
     360:	e7fe      	b.n	360 <Reset_Handler+0x70>
     362:	bf00      	nop
     364:	20000000 	.word	0x20000000
     368:	0000c94c 	.word	0x0000c94c
     36c:	20000074 	.word	0x20000074
     370:	200095f4 	.word	0x200095f4
     374:	20000080 	.word	0x20000080
     378:	e000ed00 	.word	0xe000ed00
     37c:	00000000 	.word	0x00000000
     380:	0000a085 	.word	0x0000a085
     384:	00009d0d 	.word	0x00009d0d

00000388 <USART_1_CLOCK_init>:
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     388:	4b05      	ldr	r3, [pc, #20]	; (3a0 <USART_1_CLOCK_init+0x18>)
     38a:	2242      	movs	r2, #66	; 0x42
     38c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
     390:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBAMASK_SERCOM0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM0;
     394:	4a03      	ldr	r2, [pc, #12]	; (3a4 <USART_1_CLOCK_init+0x1c>)
     396:	6953      	ldr	r3, [r2, #20]
     398:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
     39c:	6153      	str	r3, [r2, #20]
     39e:	4770      	bx	lr
     3a0:	40001c00 	.word	0x40001c00
     3a4:	40000800 	.word	0x40000800

000003a8 <USART_1_PORT_init>:
static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     3a8:	4b10      	ldr	r3, [pc, #64]	; (3ec <USART_1_PORT_init+0x44>)
     3aa:	f893 2151 	ldrb.w	r2, [r3, #337]	; 0x151
	tmp &= ~PORT_PINCFG_PMUXEN;
     3ae:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     3b2:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3b6:	f883 2151 	strb.w	r2, [r3, #337]	; 0x151
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     3ba:	f893 2138 	ldrb.w	r2, [r3, #312]	; 0x138
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     3be:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     3c2:	f042 0230 	orr.w	r2, r2, #48	; 0x30
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     3c6:	f883 2138 	strb.w	r2, [r3, #312]	; 0x138
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     3ca:	f893 2150 	ldrb.w	r2, [r3, #336]	; 0x150
	tmp &= ~PORT_PINCFG_PMUXEN;
     3ce:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     3d2:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3d6:	f883 2150 	strb.w	r2, [r3, #336]	; 0x150
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     3da:	f893 2138 	ldrb.w	r2, [r3, #312]	; 0x138
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     3de:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     3e2:	f042 0203 	orr.w	r2, r2, #3
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     3e6:	f883 2138 	strb.w	r2, [r3, #312]	; 0x138
     3ea:	4770      	bx	lr
     3ec:	41008000 	.word	0x41008000

000003f0 <USART_1_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_1_init(void)
{
     3f0:	b510      	push	{r4, lr}
     3f2:	b082      	sub	sp, #8
	USART_1_CLOCK_init();
     3f4:	4b07      	ldr	r3, [pc, #28]	; (414 <USART_1_init+0x24>)
     3f6:	4798      	blx	r3
	usart_async_init(&USART_1, SERCOM0, USART_1_buffer, USART_1_BUFFER_SIZE, (void *)NULL);
     3f8:	2300      	movs	r3, #0
     3fa:	9300      	str	r3, [sp, #0]
     3fc:	f44f 7380 	mov.w	r3, #256	; 0x100
     400:	4a05      	ldr	r2, [pc, #20]	; (418 <USART_1_init+0x28>)
     402:	4906      	ldr	r1, [pc, #24]	; (41c <USART_1_init+0x2c>)
     404:	4806      	ldr	r0, [pc, #24]	; (420 <USART_1_init+0x30>)
     406:	4c07      	ldr	r4, [pc, #28]	; (424 <USART_1_init+0x34>)
     408:	47a0      	blx	r4
	USART_1_PORT_init();
     40a:	4b07      	ldr	r3, [pc, #28]	; (428 <USART_1_init+0x38>)
     40c:	4798      	blx	r3
}
     40e:	b002      	add	sp, #8
     410:	bd10      	pop	{r4, pc}
     412:	bf00      	nop
     414:	00000389 	.word	0x00000389
     418:	2000009c 	.word	0x2000009c
     41c:	40003000 	.word	0x40003000
     420:	200081fc 	.word	0x200081fc
     424:	000015b5 	.word	0x000015b5
     428:	000003a9 	.word	0x000003a9

0000042c <USART_0_PORT_init>:
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     42c:	4b10      	ldr	r3, [pc, #64]	; (470 <USART_0_PORT_init+0x44>)
     42e:	f893 215b 	ldrb.w	r2, [r3, #347]	; 0x15b
	tmp &= ~PORT_PINCFG_PMUXEN;
     432:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     436:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     43a:	f883 215b 	strb.w	r2, [r3, #347]	; 0x15b
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     43e:	f893 213d 	ldrb.w	r2, [r3, #317]	; 0x13d
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     442:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     446:	f042 0220 	orr.w	r2, r2, #32
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     44a:	f883 213d 	strb.w	r2, [r3, #317]	; 0x13d
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     44e:	f893 215c 	ldrb.w	r2, [r3, #348]	; 0x15c
	tmp &= ~PORT_PINCFG_PMUXEN;
     452:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     456:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     45a:	f883 215c 	strb.w	r2, [r3, #348]	; 0x15c
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     45e:	f893 213e 	ldrb.w	r2, [r3, #318]	; 0x13e
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     462:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     466:	f042 0202 	orr.w	r2, r2, #2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     46a:	f883 213e 	strb.w	r2, [r3, #318]	; 0x13e
     46e:	4770      	bx	lr
     470:	41008000 	.word	0x41008000

00000474 <USART_0_CLOCK_init>:
     474:	4b05      	ldr	r3, [pc, #20]	; (48c <USART_0_CLOCK_init+0x18>)
     476:	2242      	movs	r2, #66	; 0x42
     478:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
     47c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBAMASK_SERCOM1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM1;
     480:	4a03      	ldr	r2, [pc, #12]	; (490 <USART_0_CLOCK_init+0x1c>)
     482:	6953      	ldr	r3, [r2, #20]
     484:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
     488:	6153      	str	r3, [r2, #20]
     48a:	4770      	bx	lr
     48c:	40001c00 	.word	0x40001c00
     490:	40000800 	.word	0x40000800

00000494 <USART_0_init>:

	hri_mclk_set_APBAMASK_SERCOM1_bit(MCLK);
}

void USART_0_init(void)
{
     494:	b508      	push	{r3, lr}
	USART_0_CLOCK_init();
     496:	4b05      	ldr	r3, [pc, #20]	; (4ac <USART_0_init+0x18>)
     498:	4798      	blx	r3
	usart_sync_init(&USART_0, SERCOM1, (void *)NULL);
     49a:	2200      	movs	r2, #0
     49c:	4904      	ldr	r1, [pc, #16]	; (4b0 <USART_0_init+0x1c>)
     49e:	4805      	ldr	r0, [pc, #20]	; (4b4 <USART_0_init+0x20>)
     4a0:	4b05      	ldr	r3, [pc, #20]	; (4b8 <USART_0_init+0x24>)
     4a2:	4798      	blx	r3
	USART_0_PORT_init();
     4a4:	4b05      	ldr	r3, [pc, #20]	; (4bc <USART_0_init+0x28>)
     4a6:	4798      	blx	r3
     4a8:	bd08      	pop	{r3, pc}
     4aa:	bf00      	nop
     4ac:	00000475 	.word	0x00000475
     4b0:	40003400 	.word	0x40003400
     4b4:	200081f0 	.word	0x200081f0
     4b8:	000017e1 	.word	0x000017e1
     4bc:	0000042d 	.word	0x0000042d

000004c0 <I2C_0_PORT_init>:
}

static inline void hri_port_clear_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     4c0:	4b16      	ldr	r3, [pc, #88]	; (51c <I2C_0_PORT_init+0x5c>)
     4c2:	f893 2056 	ldrb.w	r2, [r3, #86]	; 0x56
     4c6:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     4ca:	f883 2056 	strb.w	r2, [r3, #86]	; 0x56
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     4ce:	f893 2056 	ldrb.w	r2, [r3, #86]	; 0x56
	tmp &= ~PORT_PINCFG_PMUXEN;
     4d2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     4d6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     4da:	f883 2056 	strb.w	r2, [r3, #86]	; 0x56
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     4de:	f893 203b 	ldrb.w	r2, [r3, #59]	; 0x3b
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     4e2:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     4e6:	f042 0202 	orr.w	r2, r2, #2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     4ea:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     4ee:	f893 2057 	ldrb.w	r2, [r3, #87]	; 0x57
     4f2:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     4f6:	f883 2057 	strb.w	r2, [r3, #87]	; 0x57
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     4fa:	f893 2057 	ldrb.w	r2, [r3, #87]	; 0x57
	tmp &= ~PORT_PINCFG_PMUXEN;
     4fe:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     502:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     506:	f883 2057 	strb.w	r2, [r3, #87]	; 0x57
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     50a:	f893 203b 	ldrb.w	r2, [r3, #59]	; 0x3b
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     50e:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     512:	f042 0220 	orr.w	r2, r2, #32
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     516:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
     51a:	4770      	bx	lr
     51c:	41008000 	.word	0x41008000

00000520 <I2C_0_CLOCK_init>:
     520:	4b06      	ldr	r3, [pc, #24]	; (53c <I2C_0_CLOCK_init+0x1c>)
     522:	2240      	movs	r2, #64	; 0x40
     524:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
     528:	2242      	movs	r2, #66	; 0x42
     52a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBBMASK_SERCOM3_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM3;
     52e:	4a04      	ldr	r2, [pc, #16]	; (540 <I2C_0_CLOCK_init+0x20>)
     530:	6993      	ldr	r3, [r2, #24]
     532:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
     536:	6193      	str	r3, [r2, #24]
     538:	4770      	bx	lr
     53a:	bf00      	nop
     53c:	40001c00 	.word	0x40001c00
     540:	40000800 	.word	0x40000800

00000544 <I2C_0_init>:

	hri_mclk_set_APBBMASK_SERCOM3_bit(MCLK);
}

void I2C_0_init(void)
{
     544:	b508      	push	{r3, lr}
	I2C_0_CLOCK_init();
     546:	4b04      	ldr	r3, [pc, #16]	; (558 <I2C_0_init+0x14>)
     548:	4798      	blx	r3
	i2c_m_sync_init(&I2C_0, SERCOM3);
     54a:	4904      	ldr	r1, [pc, #16]	; (55c <I2C_0_init+0x18>)
     54c:	4804      	ldr	r0, [pc, #16]	; (560 <I2C_0_init+0x1c>)
     54e:	4b05      	ldr	r3, [pc, #20]	; (564 <I2C_0_init+0x20>)
     550:	4798      	blx	r3
	I2C_0_PORT_init();
     552:	4b05      	ldr	r3, [pc, #20]	; (568 <I2C_0_init+0x24>)
     554:	4798      	blx	r3
     556:	bd08      	pop	{r3, pc}
     558:	00000521 	.word	0x00000521
     55c:	41014000 	.word	0x41014000
     560:	2000824c 	.word	0x2000824c
     564:	00000f51 	.word	0x00000f51
     568:	000004c1 	.word	0x000004c1

0000056c <ETHERNET_MAC_0_PORT_init>:
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     56c:	4b50      	ldr	r3, [pc, #320]	; (6b0 <ETHERNET_MAC_0_PORT_init+0x144>)
     56e:	f893 214b 	ldrb.w	r2, [r3, #331]	; 0x14b
	tmp &= ~PORT_PINCFG_PMUXEN;
     572:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     576:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     57a:	f883 214b 	strb.w	r2, [r3, #331]	; 0x14b
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     57e:	f893 2135 	ldrb.w	r2, [r3, #309]	; 0x135
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     582:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     586:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     58a:	f883 2135 	strb.w	r2, [r3, #309]	; 0x135
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     58e:	f893 214c 	ldrb.w	r2, [r3, #332]	; 0x14c
	tmp &= ~PORT_PINCFG_PMUXEN;
     592:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     596:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     59a:	f883 214c 	strb.w	r2, [r3, #332]	; 0x14c
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     59e:	f893 2136 	ldrb.w	r2, [r3, #310]	; 0x136
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     5a2:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     5a6:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5aa:	f883 2136 	strb.w	r2, [r3, #310]	; 0x136
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5ae:	f893 204d 	ldrb.w	r2, [r3, #77]	; 0x4d
	tmp &= ~PORT_PINCFG_PMUXEN;
     5b2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5b6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5ba:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5be:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     5c2:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     5c6:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5ca:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5ce:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
	tmp &= ~PORT_PINCFG_PMUXEN;
     5d2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5d6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5da:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5de:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     5e2:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     5e6:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5ea:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5ee:	f893 2154 	ldrb.w	r2, [r3, #340]	; 0x154
	tmp &= ~PORT_PINCFG_PMUXEN;
     5f2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5f6:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5fa:	f883 2154 	strb.w	r2, [r3, #340]	; 0x154
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5fe:	f893 213a 	ldrb.w	r2, [r3, #314]	; 0x13a
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     602:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     606:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     60a:	f883 213a 	strb.w	r2, [r3, #314]	; 0x13a
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     60e:	f893 204f 	ldrb.w	r2, [r3, #79]	; 0x4f
	tmp &= ~PORT_PINCFG_PMUXEN;
     612:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     616:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     61a:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     61e:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     622:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     626:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     62a:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     62e:	f893 2052 	ldrb.w	r2, [r3, #82]	; 0x52
	tmp &= ~PORT_PINCFG_PMUXEN;
     632:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     636:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     63a:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     63e:	f893 2039 	ldrb.w	r2, [r3, #57]	; 0x39
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     642:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     646:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     64a:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     64e:	f893 2053 	ldrb.w	r2, [r3, #83]	; 0x53
	tmp &= ~PORT_PINCFG_PMUXEN;
     652:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     656:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     65a:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     65e:	f893 2039 	ldrb.w	r2, [r3, #57]	; 0x39
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     662:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     666:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     66a:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     66e:	f893 204e 	ldrb.w	r2, [r3, #78]	; 0x4e
	tmp &= ~PORT_PINCFG_PMUXEN;
     672:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     676:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     67a:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     67e:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     682:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     686:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     68a:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     68e:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
	tmp &= ~PORT_PINCFG_PMUXEN;
     692:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     696:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     69a:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     69e:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     6a2:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     6a6:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     6aa:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
     6ae:	4770      	bx	lr
     6b0:	41008000 	.word	0x41008000

000006b4 <ETHERNET_MAC_0_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_GMAC;
     6b4:	4b04      	ldr	r3, [pc, #16]	; (6c8 <ETHERNET_MAC_0_CLOCK_init+0x14>)
     6b6:	691a      	ldr	r2, [r3, #16]
     6b8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
     6bc:	611a      	str	r2, [r3, #16]
}

static inline void hri_mclk_set_APBCMASK_GMAC_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_GMAC;
     6be:	69da      	ldr	r2, [r3, #28]
     6c0:	f042 0204 	orr.w	r2, r2, #4
     6c4:	61da      	str	r2, [r3, #28]
     6c6:	4770      	bx	lr
     6c8:	40000800 	.word	0x40000800

000006cc <ETHERNET_MAC_0_init>:
	hri_mclk_set_AHBMASK_GMAC_bit(MCLK);
	hri_mclk_set_APBCMASK_GMAC_bit(MCLK);
}

void ETHERNET_MAC_0_init(void)
{
     6cc:	b508      	push	{r3, lr}
	ETHERNET_MAC_0_CLOCK_init();
     6ce:	4b04      	ldr	r3, [pc, #16]	; (6e0 <ETHERNET_MAC_0_init+0x14>)
     6d0:	4798      	blx	r3
	mac_async_init(&ETHERNET_MAC_0, GMAC);
     6d2:	4904      	ldr	r1, [pc, #16]	; (6e4 <ETHERNET_MAC_0_init+0x18>)
     6d4:	4804      	ldr	r0, [pc, #16]	; (6e8 <ETHERNET_MAC_0_init+0x1c>)
     6d6:	4b05      	ldr	r3, [pc, #20]	; (6ec <ETHERNET_MAC_0_init+0x20>)
     6d8:	4798      	blx	r3
	ETHERNET_MAC_0_PORT_init();
     6da:	4b05      	ldr	r3, [pc, #20]	; (6f0 <ETHERNET_MAC_0_init+0x24>)
     6dc:	4798      	blx	r3
     6de:	bd08      	pop	{r3, pc}
     6e0:	000006b5 	.word	0x000006b5
     6e4:	42000800 	.word	0x42000800
     6e8:	2000826c 	.word	0x2000826c
     6ec:	00001021 	.word	0x00001021
     6f0:	0000056d 	.word	0x0000056d

000006f4 <system_init>:
	mac_async_enable(&ETHERNET_MAC_0);
	mac_async_write(&ETHERNET_MAC_0, (uint8_t *)"Hello World!", 12);
}

void system_init(void)
{
     6f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     6f8:	4be2      	ldr	r3, [pc, #904]	; (a84 <system_init+0x390>)
     6fa:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     6fc:	4be2      	ldr	r3, [pc, #904]	; (a88 <system_init+0x394>)
     6fe:	2210      	movs	r2, #16
     700:	615a      	str	r2, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     702:	609a      	str	r2, [r3, #8]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     704:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     708:	629a      	str	r2, [r3, #40]	; 0x28
     70a:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
     70e:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     710:	f893 1044 	ldrb.w	r1, [r3, #68]	; 0x44
	tmp &= ~PORT_PINCFG_PMUXEN;
     714:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     718:	f883 1044 	strb.w	r1, [r3, #68]	; 0x44
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     71c:	2120      	movs	r1, #32
     71e:	6159      	str	r1, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     720:	6099      	str	r1, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     722:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
     726:	6299      	str	r1, [r3, #40]	; 0x28
     728:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     72a:	f893 1045 	ldrb.w	r1, [r3, #69]	; 0x45
	tmp &= ~PORT_PINCFG_PMUXEN;
     72e:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     732:	f883 1045 	strb.w	r1, [r3, #69]	; 0x45
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     736:	f04f 0a40 	mov.w	sl, #64	; 0x40
     73a:	f8c3 a014 	str.w	sl, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     73e:	f8c3 a008 	str.w	sl, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     742:	49d2      	ldr	r1, [pc, #840]	; (a8c <system_init+0x398>)
     744:	6299      	str	r1, [r3, #40]	; 0x28
     746:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     748:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	tmp &= ~PORT_PINCFG_PMUXEN;
     74c:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     750:	f883 1046 	strb.w	r1, [r3, #70]	; 0x46
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     754:	f04f 0980 	mov.w	r9, #128	; 0x80
     758:	f8c3 9014 	str.w	r9, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     75c:	f8c3 9008 	str.w	r9, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     760:	49cb      	ldr	r1, [pc, #812]	; (a90 <system_init+0x39c>)
     762:	6299      	str	r1, [r3, #40]	; 0x28
     764:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     766:	f893 1047 	ldrb.w	r1, [r3, #71]	; 0x47
	tmp &= ~PORT_PINCFG_PMUXEN;
     76a:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     76e:	f883 1047 	strb.w	r1, [r3, #71]	; 0x47
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     772:	f44f 7880 	mov.w	r8, #256	; 0x100
     776:	f8c3 8014 	str.w	r8, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     77a:	f8c3 8008 	str.w	r8, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     77e:	49c5      	ldr	r1, [pc, #788]	; (a94 <system_init+0x3a0>)
     780:	6299      	str	r1, [r3, #40]	; 0x28
     782:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     784:	f893 1048 	ldrb.w	r1, [r3, #72]	; 0x48
	tmp &= ~PORT_PINCFG_PMUXEN;
     788:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     78c:	f883 1048 	strb.w	r1, [r3, #72]	; 0x48
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     790:	f44f 7c00 	mov.w	ip, #512	; 0x200
     794:	f8c3 c014 	str.w	ip, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     798:	f8c3 c008 	str.w	ip, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     79c:	49be      	ldr	r1, [pc, #760]	; (a98 <system_init+0x3a4>)
     79e:	6299      	str	r1, [r3, #40]	; 0x28
     7a0:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     7a2:	f893 1049 	ldrb.w	r1, [r3, #73]	; 0x49
	tmp &= ~PORT_PINCFG_PMUXEN;
     7a6:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     7aa:	f883 1049 	strb.w	r1, [r3, #73]	; 0x49
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     7ae:	f44f 6e80 	mov.w	lr, #1024	; 0x400
     7b2:	f8c3 e014 	str.w	lr, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     7b6:	f8c3 e008 	str.w	lr, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     7ba:	49b8      	ldr	r1, [pc, #736]	; (a9c <system_init+0x3a8>)
     7bc:	6299      	str	r1, [r3, #40]	; 0x28
     7be:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     7c0:	f893 104a 	ldrb.w	r1, [r3, #74]	; 0x4a
	tmp &= ~PORT_PINCFG_PMUXEN;
     7c4:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     7c8:	f883 104a 	strb.w	r1, [r3, #74]	; 0x4a
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     7cc:	f44f 6700 	mov.w	r7, #2048	; 0x800
     7d0:	615f      	str	r7, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     7d2:	609f      	str	r7, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     7d4:	49b2      	ldr	r1, [pc, #712]	; (aa0 <system_init+0x3ac>)
     7d6:	6299      	str	r1, [r3, #40]	; 0x28
     7d8:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     7da:	f893 104b 	ldrb.w	r1, [r3, #75]	; 0x4b
	tmp &= ~PORT_PINCFG_PMUXEN;
     7de:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     7e2:	f883 104b 	strb.w	r1, [r3, #75]	; 0x4b
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     7e6:	f44f 1680 	mov.w	r6, #1048576	; 0x100000
     7ea:	615e      	str	r6, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     7ec:	609e      	str	r6, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     7ee:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
     7f2:	6299      	str	r1, [r3, #40]	; 0x28
     7f4:	48ab      	ldr	r0, [pc, #684]	; (aa4 <system_init+0x3b0>)
     7f6:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     7f8:	f893 0054 	ldrb.w	r0, [r3, #84]	; 0x54
	tmp &= ~PORT_PINCFG_PMUXEN;
     7fc:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     800:	f883 0054 	strb.w	r0, [r3, #84]	; 0x54
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     804:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
     808:	6158      	str	r0, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     80a:	6098      	str	r0, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     80c:	6299      	str	r1, [r3, #40]	; 0x28
     80e:	48a6      	ldr	r0, [pc, #664]	; (aa8 <system_init+0x3b4>)
     810:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     812:	f893 0055 	ldrb.w	r0, [r3, #85]	; 0x55
	tmp &= ~PORT_PINCFG_PMUXEN;
     816:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     81a:	f883 0055 	strb.w	r0, [r3, #85]	; 0x55
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     81e:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
     822:	615c      	str	r4, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     824:	609c      	str	r4, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     826:	6299      	str	r1, [r3, #40]	; 0x28
     828:	48a0      	ldr	r0, [pc, #640]	; (aac <system_init+0x3b8>)
     82a:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     82c:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
	tmp &= ~PORT_PINCFG_PMUXEN;
     830:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     834:	f883 0058 	strb.w	r0, [r3, #88]	; 0x58
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     838:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
     83c:	6158      	str	r0, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     83e:	6098      	str	r0, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     840:	6299      	str	r1, [r3, #40]	; 0x28
     842:	4d9b      	ldr	r5, [pc, #620]	; (ab0 <system_init+0x3bc>)
     844:	629d      	str	r5, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     846:	f893 b059 	ldrb.w	fp, [r3, #89]	; 0x59
	tmp &= ~PORT_PINCFG_PMUXEN;
     84a:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     84e:	f883 b059 	strb.w	fp, [r3, #89]	; 0x59
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     852:	f04f 0b01 	mov.w	fp, #1
     856:	f8c3 b094 	str.w	fp, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     85a:	f8c3 b088 	str.w	fp, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     85e:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
     862:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     866:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     86a:	f893 b0c0 	ldrb.w	fp, [r3, #192]	; 0xc0
	tmp &= ~PORT_PINCFG_PMUXEN;
     86e:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     872:	f883 b0c0 	strb.w	fp, [r3, #192]	; 0xc0
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     876:	f04f 0b02 	mov.w	fp, #2
     87a:	f8c3 b094 	str.w	fp, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     87e:	f8c3 b088 	str.w	fp, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     882:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
     886:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     88a:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     88e:	f893 b0c1 	ldrb.w	fp, [r3, #193]	; 0xc1
	tmp &= ~PORT_PINCFG_PMUXEN;
     892:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     896:	f883 b0c1 	strb.w	fp, [r3, #193]	; 0xc1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     89a:	f04f 0b04 	mov.w	fp, #4
     89e:	f8c3 b094 	str.w	fp, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     8a2:	f8c3 b088 	str.w	fp, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     8a6:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
     8aa:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     8ae:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8b2:	f893 b0c2 	ldrb.w	fp, [r3, #194]	; 0xc2
	tmp &= ~PORT_PINCFG_PMUXEN;
     8b6:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8ba:	f883 b0c2 	strb.w	fp, [r3, #194]	; 0xc2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     8be:	f04f 0b08 	mov.w	fp, #8
     8c2:	f8c3 b094 	str.w	fp, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     8c6:	f8c3 b088 	str.w	fp, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     8ca:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
     8ce:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     8d2:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8d6:	f893 b0c3 	ldrb.w	fp, [r3, #195]	; 0xc3
	tmp &= ~PORT_PINCFG_PMUXEN;
     8da:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8de:	f883 b0c3 	strb.w	fp, [r3, #195]	; 0xc3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     8e2:	f8c3 a094 	str.w	sl, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     8e6:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     8ea:	4d68      	ldr	r5, [pc, #416]	; (a8c <system_init+0x398>)
     8ec:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     8f0:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8f4:	f893 a0c6 	ldrb.w	sl, [r3, #198]	; 0xc6
	tmp &= ~PORT_PINCFG_PMUXEN;
     8f8:	f00a 0afe 	and.w	sl, sl, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8fc:	f883 a0c6 	strb.w	sl, [r3, #198]	; 0xc6
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     900:	f8c3 9094 	str.w	r9, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     904:	f8c3 9088 	str.w	r9, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     908:	3540      	adds	r5, #64	; 0x40
     90a:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     90e:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     912:	f893 90c7 	ldrb.w	r9, [r3, #199]	; 0xc7
	tmp &= ~PORT_PINCFG_PMUXEN;
     916:	f009 09fe 	and.w	r9, r9, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     91a:	f883 90c7 	strb.w	r9, [r3, #199]	; 0xc7
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     91e:	f8c3 8094 	str.w	r8, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     922:	f8c3 8088 	str.w	r8, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     926:	3580      	adds	r5, #128	; 0x80
     928:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     92c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     930:	f893 80c8 	ldrb.w	r8, [r3, #200]	; 0xc8
	tmp &= ~PORT_PINCFG_PMUXEN;
     934:	f008 08fe 	and.w	r8, r8, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     938:	f883 80c8 	strb.w	r8, [r3, #200]	; 0xc8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     93c:	f8c3 c094 	str.w	ip, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     940:	f8c3 c088 	str.w	ip, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     944:	f505 7580 	add.w	r5, r5, #256	; 0x100
     948:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     94c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     950:	f893 c0c9 	ldrb.w	ip, [r3, #201]	; 0xc9
	tmp &= ~PORT_PINCFG_PMUXEN;
     954:	f00c 0cfe 	and.w	ip, ip, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     958:	f883 c0c9 	strb.w	ip, [r3, #201]	; 0xc9
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     95c:	f8c3 e094 	str.w	lr, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     960:	f8c3 e088 	str.w	lr, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     964:	f505 7500 	add.w	r5, r5, #512	; 0x200
     968:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     96c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     970:	f893 e0ca 	ldrb.w	lr, [r3, #202]	; 0xca
	tmp &= ~PORT_PINCFG_PMUXEN;
     974:	f00e 0efe 	and.w	lr, lr, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     978:	f883 e0ca 	strb.w	lr, [r3, #202]	; 0xca
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     97c:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     980:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     984:	f505 6580 	add.w	r5, r5, #1024	; 0x400
     988:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     98c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     990:	f893 70cb 	ldrb.w	r7, [r3, #203]	; 0xcb
	tmp &= ~PORT_PINCFG_PMUXEN;
     994:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     998:	f883 70cb 	strb.w	r7, [r3, #203]	; 0xcb
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     99c:	f44f 5780 	mov.w	r7, #4096	; 0x1000
     9a0:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     9a4:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     9a8:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
     9ac:	f8c3 70a8 	str.w	r7, [r3, #168]	; 0xa8
     9b0:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     9b4:	f893 70cc 	ldrb.w	r7, [r3, #204]	; 0xcc
	tmp &= ~PORT_PINCFG_PMUXEN;
     9b8:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     9bc:	f883 70cc 	strb.w	r7, [r3, #204]	; 0xcc
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     9c0:	f44f 5700 	mov.w	r7, #8192	; 0x2000
     9c4:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     9c8:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     9cc:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
     9d0:	f8c3 70a8 	str.w	r7, [r3, #168]	; 0xa8
     9d4:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     9d8:	f893 70cd 	ldrb.w	r7, [r3, #205]	; 0xcd
	tmp &= ~PORT_PINCFG_PMUXEN;
     9dc:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     9e0:	f883 70cd 	strb.w	r7, [r3, #205]	; 0xcd
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     9e4:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
     9e8:	f8c3 c094 	str.w	ip, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     9ec:	f8c3 c088 	str.w	ip, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     9f0:	f04f 2b40 	mov.w	fp, #1073758208	; 0x40004000
     9f4:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     9f8:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     9fc:	f893 70ce 	ldrb.w	r7, [r3, #206]	; 0xce
	tmp &= ~PORT_PINCFG_PMUXEN;
     a00:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a04:	f883 70ce 	strb.w	r7, [r3, #206]	; 0xce
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a08:	f44f 3780 	mov.w	r7, #65536	; 0x10000
     a0c:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a10:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a14:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     a18:	4f26      	ldr	r7, [pc, #152]	; (ab4 <system_init+0x3c0>)
     a1a:	f8c3 70a8 	str.w	r7, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a1e:	f893 70d0 	ldrb.w	r7, [r3, #208]	; 0xd0
	tmp &= ~PORT_PINCFG_PMUXEN;
     a22:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a26:	f883 70d0 	strb.w	r7, [r3, #208]	; 0xd0
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a2a:	f44f 3700 	mov.w	r7, #131072	; 0x20000
     a2e:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a32:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a36:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     a3a:	4f1f      	ldr	r7, [pc, #124]	; (ab8 <system_init+0x3c4>)
     a3c:	f8c3 70a8 	str.w	r7, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a40:	f893 70d1 	ldrb.w	r7, [r3, #209]	; 0xd1
	tmp &= ~PORT_PINCFG_PMUXEN;
     a44:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a48:	f883 70d1 	strb.w	r7, [r3, #209]	; 0xd1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a4c:	f44f 2e80 	mov.w	lr, #262144	; 0x40000
     a50:	f8c3 e094 	str.w	lr, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a54:	f8c3 e088 	str.w	lr, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a58:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     a5c:	f8df a05c 	ldr.w	sl, [pc, #92]	; abc <system_init+0x3c8>
     a60:	f8c3 a0a8 	str.w	sl, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a64:	f893 70d2 	ldrb.w	r7, [r3, #210]	; 0xd2
	tmp &= ~PORT_PINCFG_PMUXEN;
     a68:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a6c:	f883 70d2 	strb.w	r7, [r3, #210]	; 0xd2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a70:	f44f 2700 	mov.w	r7, #524288	; 0x80000
     a74:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a78:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a7c:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     a80:	e01e      	b.n	ac0 <system_init+0x3cc>
     a82:	bf00      	nop
     a84:	00001a61 	.word	0x00001a61
     a88:	41008000 	.word	0x41008000
     a8c:	40000040 	.word	0x40000040
     a90:	40000080 	.word	0x40000080
     a94:	40000100 	.word	0x40000100
     a98:	40000200 	.word	0x40000200
     a9c:	40000400 	.word	0x40000400
     aa0:	40000800 	.word	0x40000800
     aa4:	c0000010 	.word	0xc0000010
     aa8:	c0000020 	.word	0xc0000020
     aac:	c0000100 	.word	0xc0000100
     ab0:	c0000200 	.word	0xc0000200
     ab4:	c0000001 	.word	0xc0000001
     ab8:	c0000002 	.word	0xc0000002
     abc:	c0000004 	.word	0xc0000004
     ac0:	f8df 918c 	ldr.w	r9, [pc, #396]	; c50 <system_init+0x55c>
     ac4:	f8c3 90a8 	str.w	r9, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     ac8:	f893 80d3 	ldrb.w	r8, [r3, #211]	; 0xd3
	tmp &= ~PORT_PINCFG_PMUXEN;
     acc:	f008 08fe 	and.w	r8, r8, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     ad0:	f883 80d3 	strb.w	r8, [r3, #211]	; 0xd3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     ad4:	f8c3 6094 	str.w	r6, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     ad8:	f8c3 6088 	str.w	r6, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     adc:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     ae0:	4d4d      	ldr	r5, [pc, #308]	; (c18 <system_init+0x524>)
     ae2:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     ae6:	f893 60d4 	ldrb.w	r6, [r3, #212]	; 0xd4
	tmp &= ~PORT_PINCFG_PMUXEN;
     aea:	f006 06fe 	and.w	r6, r6, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     aee:	f883 60d4 	strb.w	r6, [r3, #212]	; 0xd4
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     af2:	f44f 1500 	mov.w	r5, #2097152	; 0x200000
     af6:	f8c3 5094 	str.w	r5, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     afa:	f8c3 5088 	str.w	r5, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     afe:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     b02:	4d46      	ldr	r5, [pc, #280]	; (c1c <system_init+0x528>)
     b04:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b08:	f893 50d5 	ldrb.w	r5, [r3, #213]	; 0xd5
	tmp &= ~PORT_PINCFG_PMUXEN;
     b0c:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b10:	f883 50d5 	strb.w	r5, [r3, #213]	; 0xd5
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b14:	f8c3 4094 	str.w	r4, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b18:	f8c3 4088 	str.w	r4, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b1c:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     b20:	4d3f      	ldr	r5, [pc, #252]	; (c20 <system_init+0x52c>)
     b22:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b26:	f893 50d8 	ldrb.w	r5, [r3, #216]	; 0xd8
	tmp &= ~PORT_PINCFG_PMUXEN;
     b2a:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b2e:	f883 50d8 	strb.w	r5, [r3, #216]	; 0xd8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b32:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b36:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b3a:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     b3e:	4d39      	ldr	r5, [pc, #228]	; (c24 <system_init+0x530>)
     b40:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b44:	f893 50d9 	ldrb.w	r5, [r3, #217]	; 0xd9
	tmp &= ~PORT_PINCFG_PMUXEN;
     b48:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b4c:	f883 50d9 	strb.w	r5, [r3, #217]	; 0xd9
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     b50:	f8c3 c118 	str.w	ip, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b54:	f8c3 c108 	str.w	ip, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b58:	f8c3 b128 	str.w	fp, [r3, #296]	; 0x128
     b5c:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b60:	f893 214e 	ldrb.w	r2, [r3, #334]	; 0x14e
	tmp &= ~PORT_PINCFG_PMUXEN;
     b64:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b68:	f883 214e 	strb.w	r2, [r3, #334]	; 0x14e
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b6c:	f8c3 e114 	str.w	lr, [r3, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b70:	f8c3 e108 	str.w	lr, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b74:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
     b78:	f8c3 a128 	str.w	sl, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b7c:	f893 2152 	ldrb.w	r2, [r3, #338]	; 0x152
	tmp &= ~PORT_PINCFG_PMUXEN;
     b80:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b84:	f883 2152 	strb.w	r2, [r3, #338]	; 0x152
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b88:	f8c3 7114 	str.w	r7, [r3, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b8c:	f8c3 7108 	str.w	r7, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b90:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
     b94:	f8c3 9128 	str.w	r9, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b98:	f893 2153 	ldrb.w	r2, [r3, #339]	; 0x153
	tmp &= ~PORT_PINCFG_PMUXEN;
     b9c:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     ba0:	f883 2153 	strb.w	r2, [r3, #339]	; 0x153
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     ba4:	f8c3 4114 	str.w	r4, [r3, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     ba8:	f8c3 4108 	str.w	r4, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     bac:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
     bb0:	4a1b      	ldr	r2, [pc, #108]	; (c20 <system_init+0x52c>)
     bb2:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bb6:	f893 2158 	ldrb.w	r2, [r3, #344]	; 0x158
	tmp &= ~PORT_PINCFG_PMUXEN;
     bba:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bbe:	f883 2158 	strb.w	r2, [r3, #344]	; 0x158
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     bc2:	f8c3 0114 	str.w	r0, [r3, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     bc6:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     bca:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
     bce:	4a15      	ldr	r2, [pc, #84]	; (c24 <system_init+0x530>)
     bd0:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bd4:	f893 2159 	ldrb.w	r2, [r3, #345]	; 0x159
	tmp &= ~PORT_PINCFG_PMUXEN;
     bd8:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bdc:	f883 2159 	strb.w	r2, [r3, #345]	; 0x159
	// Set pin direction to output
	gpio_set_pin_direction(PC25, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(PC25, GPIO_PIN_FUNCTION_OFF);

	USART_1_init();
     be0:	4b11      	ldr	r3, [pc, #68]	; (c28 <system_init+0x534>)
     be2:	4798      	blx	r3

	USART_0_init();
     be4:	4b11      	ldr	r3, [pc, #68]	; (c2c <system_init+0x538>)
     be6:	4798      	blx	r3

	I2C_0_init();
     be8:	4b11      	ldr	r3, [pc, #68]	; (c30 <system_init+0x53c>)
     bea:	4798      	blx	r3
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC0;
     bec:	4b11      	ldr	r3, [pc, #68]	; (c34 <system_init+0x540>)
     bee:	695b      	ldr	r3, [r3, #20]
     bf0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
     bf4:	4a0f      	ldr	r2, [pc, #60]	; (c34 <system_init+0x540>)
     bf6:	6153      	str	r3, [r2, #20]
     bf8:	2242      	movs	r2, #66	; 0x42
     bfa:	4b0f      	ldr	r3, [pc, #60]	; (c38 <system_init+0x544>)
     bfc:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
	timer_init(&TIMER_0, TC0, _tc_get_timer());
     c00:	4b0e      	ldr	r3, [pc, #56]	; (c3c <system_init+0x548>)
     c02:	4798      	blx	r3
     c04:	4602      	mov	r2, r0
     c06:	490e      	ldr	r1, [pc, #56]	; (c40 <system_init+0x54c>)
     c08:	480e      	ldr	r0, [pc, #56]	; (c44 <system_init+0x550>)
     c0a:	4b0f      	ldr	r3, [pc, #60]	; (c48 <system_init+0x554>)
     c0c:	4798      	blx	r3

	TIMER_0_init();
	ETHERNET_MAC_0_init();
     c0e:	4b0f      	ldr	r3, [pc, #60]	; (c4c <system_init+0x558>)
     c10:	4798      	blx	r3
     c12:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
     c16:	bf00      	nop
     c18:	c0000010 	.word	0xc0000010
     c1c:	c0000020 	.word	0xc0000020
     c20:	c0000100 	.word	0xc0000100
     c24:	c0000200 	.word	0xc0000200
     c28:	000003f1 	.word	0x000003f1
     c2c:	00000495 	.word	0x00000495
     c30:	00000545 	.word	0x00000545
     c34:	40000800 	.word	0x40000800
     c38:	40001c00 	.word	0x40001c00
     c3c:	00002dab 	.word	0x00002dab
     c40:	40003800 	.word	0x40003800
     c44:	20008288 	.word	0x20008288
     c48:	000012e5 	.word	0x000012e5
     c4c:	000006cd 	.word	0x000006cd
     c50:	c0000008 	.word	0xc0000008

00000c54 <ethernet_phy_init>:
/**
 * \brief Perform a HW initialization to the PHY
 */
int32_t ethernet_phy_init(struct ethernet_phy_descriptor *const descr, struct mac_async_descriptor *const mac,
                          uint16_t addr)
{
     c54:	b570      	push	{r4, r5, r6, lr}
     c56:	460d      	mov	r5, r1
     c58:	4616      	mov	r6, r2
	ASSERT(descr && mac && (addr <= 0x1F));
     c5a:	4604      	mov	r4, r0
     c5c:	b160      	cbz	r0, c78 <ethernet_phy_init+0x24>
     c5e:	b169      	cbz	r1, c7c <ethernet_phy_init+0x28>
     c60:	2a1f      	cmp	r2, #31
     c62:	bf8c      	ite	hi
     c64:	2000      	movhi	r0, #0
     c66:	2001      	movls	r0, #1
     c68:	222a      	movs	r2, #42	; 0x2a
     c6a:	4905      	ldr	r1, [pc, #20]	; (c80 <ethernet_phy_init+0x2c>)
     c6c:	4b05      	ldr	r3, [pc, #20]	; (c84 <ethernet_phy_init+0x30>)
     c6e:	4798      	blx	r3

	descr->mac  = mac;
     c70:	6025      	str	r5, [r4, #0]
	descr->addr = addr;
     c72:	80a6      	strh	r6, [r4, #4]
	return ERR_NONE;
}
     c74:	2000      	movs	r0, #0
     c76:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && mac && (addr <= 0x1F));
     c78:	2000      	movs	r0, #0
     c7a:	e7f5      	b.n	c68 <ethernet_phy_init+0x14>
     c7c:	2000      	movs	r0, #0
     c7e:	e7f3      	b.n	c68 <ethernet_phy_init+0x14>
     c80:	0000b1f8 	.word	0x0000b1f8
     c84:	0000187d 	.word	0x0000187d

00000c88 <ethernet_phy_set_reg_bit>:

/**
 * \brief Setting bit for a PHY Register
 */
int32_t ethernet_phy_set_reg_bit(struct ethernet_phy_descriptor *const descr, uint16_t reg, uint16_t ofst)
{
     c88:	b5f0      	push	{r4, r5, r6, r7, lr}
     c8a:	b083      	sub	sp, #12
     c8c:	460d      	mov	r5, r1
     c8e:	4616      	mov	r6, r2
	int32_t  rst;
	uint16_t val;

	ASSERT(descr && descr->mac && (reg <= 0x1F));
     c90:	4604      	mov	r4, r0
     c92:	b1a8      	cbz	r0, cc0 <ethernet_phy_set_reg_bit+0x38>
     c94:	6803      	ldr	r3, [r0, #0]
     c96:	b1ab      	cbz	r3, cc4 <ethernet_phy_set_reg_bit+0x3c>
     c98:	291f      	cmp	r1, #31
     c9a:	bf8c      	ite	hi
     c9c:	2000      	movhi	r0, #0
     c9e:	2001      	movls	r0, #1
     ca0:	2257      	movs	r2, #87	; 0x57
     ca2:	490f      	ldr	r1, [pc, #60]	; (ce0 <ethernet_phy_set_reg_bit+0x58>)
     ca4:	4b0f      	ldr	r3, [pc, #60]	; (ce4 <ethernet_phy_set_reg_bit+0x5c>)
     ca6:	4798      	blx	r3

	rst = mac_async_read_phy_reg(descr->mac, descr->addr, reg, &val);
     ca8:	f10d 0306 	add.w	r3, sp, #6
     cac:	462a      	mov	r2, r5
     cae:	88a1      	ldrh	r1, [r4, #4]
     cb0:	6820      	ldr	r0, [r4, #0]
     cb2:	4f0d      	ldr	r7, [pc, #52]	; (ce8 <ethernet_phy_set_reg_bit+0x60>)
     cb4:	47b8      	blx	r7
	if (rst == ERR_NONE) {
     cb6:	4603      	mov	r3, r0
     cb8:	b130      	cbz	r0, cc8 <ethernet_phy_set_reg_bit+0x40>
		val |= ofst;
		rst = mac_async_write_phy_reg(descr->mac, descr->addr, reg, val);
	}
	return rst;
}
     cba:	4618      	mov	r0, r3
     cbc:	b003      	add	sp, #12
     cbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ASSERT(descr && descr->mac && (reg <= 0x1F));
     cc0:	2000      	movs	r0, #0
     cc2:	e7ed      	b.n	ca0 <ethernet_phy_set_reg_bit+0x18>
     cc4:	2000      	movs	r0, #0
     cc6:	e7eb      	b.n	ca0 <ethernet_phy_set_reg_bit+0x18>
		val |= ofst;
     cc8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
     ccc:	4333      	orrs	r3, r6
     cce:	f8ad 3006 	strh.w	r3, [sp, #6]
		rst = mac_async_write_phy_reg(descr->mac, descr->addr, reg, val);
     cd2:	462a      	mov	r2, r5
     cd4:	88a1      	ldrh	r1, [r4, #4]
     cd6:	6820      	ldr	r0, [r4, #0]
     cd8:	4c04      	ldr	r4, [pc, #16]	; (cec <ethernet_phy_set_reg_bit+0x64>)
     cda:	47a0      	blx	r4
     cdc:	4603      	mov	r3, r0
	return rst;
     cde:	e7ec      	b.n	cba <ethernet_phy_set_reg_bit+0x32>
     ce0:	0000b1f8 	.word	0x0000b1f8
     ce4:	0000187d 	.word	0x0000187d
     ce8:	000011d5 	.word	0x000011d5
     cec:	000011a1 	.word	0x000011a1

00000cf0 <ethernet_phy_restart_autoneg>:

/**
 * \brief Restart an auto negotiation of the PHY.
 */
int32_t ethernet_phy_restart_autoneg(struct ethernet_phy_descriptor *const descr)
{
     cf0:	b510      	push	{r4, lr}
	ASSERT(descr);
     cf2:	4604      	mov	r4, r0
     cf4:	2290      	movs	r2, #144	; 0x90
     cf6:	4906      	ldr	r1, [pc, #24]	; (d10 <ethernet_phy_restart_autoneg+0x20>)
     cf8:	3000      	adds	r0, #0
     cfa:	bf18      	it	ne
     cfc:	2001      	movne	r0, #1
     cfe:	4b05      	ldr	r3, [pc, #20]	; (d14 <ethernet_phy_restart_autoneg+0x24>)
     d00:	4798      	blx	r3
	return ethernet_phy_set_reg_bit(descr, MDIO_REG0_BMCR, MDIO_REG0_BIT_RESTART_AUTONEG);
     d02:	f44f 7200 	mov.w	r2, #512	; 0x200
     d06:	2100      	movs	r1, #0
     d08:	4620      	mov	r0, r4
     d0a:	4b03      	ldr	r3, [pc, #12]	; (d18 <ethernet_phy_restart_autoneg+0x28>)
     d0c:	4798      	blx	r3
}
     d0e:	bd10      	pop	{r4, pc}
     d10:	0000b1f8 	.word	0x0000b1f8
     d14:	0000187d 	.word	0x0000187d
     d18:	00000c89 	.word	0x00000c89

00000d1c <ethernet_phy_get_link_status>:

/**
 * \brief Get PHY link status
 */
int32_t ethernet_phy_get_link_status(struct ethernet_phy_descriptor *const descr, bool *status)
{
     d1c:	b530      	push	{r4, r5, lr}
     d1e:	b083      	sub	sp, #12
     d20:	460d      	mov	r5, r1
	int32_t  rst;
	uint16_t val;

	ASSERT(descr && descr->mac && status);
     d22:	4604      	mov	r4, r0
     d24:	b1c8      	cbz	r0, d5a <ethernet_phy_get_link_status+0x3e>
     d26:	6803      	ldr	r3, [r0, #0]
     d28:	b1cb      	cbz	r3, d5e <ethernet_phy_get_link_status+0x42>
     d2a:	1c08      	adds	r0, r1, #0
     d2c:	bf18      	it	ne
     d2e:	2001      	movne	r0, #1
     d30:	22a9      	movs	r2, #169	; 0xa9
     d32:	490c      	ldr	r1, [pc, #48]	; (d64 <ethernet_phy_get_link_status+0x48>)
     d34:	4b0c      	ldr	r3, [pc, #48]	; (d68 <ethernet_phy_get_link_status+0x4c>)
     d36:	4798      	blx	r3
	rst = mac_async_read_phy_reg(descr->mac, descr->addr, MDIO_REG1_BMSR, &val);
     d38:	f10d 0306 	add.w	r3, sp, #6
     d3c:	2201      	movs	r2, #1
     d3e:	88a1      	ldrh	r1, [r4, #4]
     d40:	6820      	ldr	r0, [r4, #0]
     d42:	4c0a      	ldr	r4, [pc, #40]	; (d6c <ethernet_phy_get_link_status+0x50>)
     d44:	47a0      	blx	r4
	if (rst == ERR_NONE) {
     d46:	4602      	mov	r2, r0
     d48:	b920      	cbnz	r0, d54 <ethernet_phy_get_link_status+0x38>
		*status = (val & MDIO_REG1_BIT_LINK_STATUS) ? true : false;
     d4a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
     d4e:	f3c3 0380 	ubfx	r3, r3, #2, #1
     d52:	702b      	strb	r3, [r5, #0]
	}
	return rst;
}
     d54:	4610      	mov	r0, r2
     d56:	b003      	add	sp, #12
     d58:	bd30      	pop	{r4, r5, pc}
	ASSERT(descr && descr->mac && status);
     d5a:	2000      	movs	r0, #0
     d5c:	e7e8      	b.n	d30 <ethernet_phy_get_link_status+0x14>
     d5e:	2000      	movs	r0, #0
     d60:	e7e6      	b.n	d30 <ethernet_phy_get_link_status+0x14>
     d62:	bf00      	nop
     d64:	0000b1f8 	.word	0x0000b1f8
     d68:	0000187d 	.word	0x0000187d
     d6c:	000011d5 	.word	0x000011d5

00000d70 <ETHERNET_PHY_0_init>:
#include <atmel_start_pins.h>

struct ethernet_phy_descriptor ETHERNET_PHY_0_desc;

void ETHERNET_PHY_0_init(void)
{
     d70:	b510      	push	{r4, lr}
	mac_async_enable(&ETHERNET_MAC_0);
     d72:	4c05      	ldr	r4, [pc, #20]	; (d88 <ETHERNET_PHY_0_init+0x18>)
     d74:	4620      	mov	r0, r4
     d76:	4b05      	ldr	r3, [pc, #20]	; (d8c <ETHERNET_PHY_0_init+0x1c>)
     d78:	4798      	blx	r3
	ethernet_phy_init(&ETHERNET_PHY_0_desc, &ETHERNET_MAC_0, CONF_ETHERNET_PHY_0_IEEE8023_MII_PHY_ADDRESS);
     d7a:	2200      	movs	r2, #0
     d7c:	4621      	mov	r1, r4
     d7e:	4804      	ldr	r0, [pc, #16]	; (d90 <ETHERNET_PHY_0_init+0x20>)
     d80:	4b04      	ldr	r3, [pc, #16]	; (d94 <ETHERNET_PHY_0_init+0x24>)
     d82:	4798      	blx	r3
     d84:	bd10      	pop	{r4, pc}
     d86:	bf00      	nop
     d88:	2000826c 	.word	0x2000826c
     d8c:	00001051 	.word	0x00001051
     d90:	200081e8 	.word	0x200081e8
     d94:	00000c55 	.word	0x00000c55

00000d98 <ETHERNET_PHY_0_example>:
	ethernet_phy_write_reg(&ETHERNET_PHY_0_desc, MDIO_REG0_BMCR, CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0);
#endif /* CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0_SETTING */
}

void ETHERNET_PHY_0_example(void)
{
     d98:	b530      	push	{r4, r5, lr}
     d9a:	b083      	sub	sp, #12
	bool    link_state;
	int32_t rst;
	/* Restart an auto-negotiation */
	rst = ethernet_phy_restart_autoneg(&ETHERNET_PHY_0_desc);
     d9c:	4808      	ldr	r0, [pc, #32]	; (dc0 <ETHERNET_PHY_0_example+0x28>)
     d9e:	4b09      	ldr	r3, [pc, #36]	; (dc4 <ETHERNET_PHY_0_example+0x2c>)
     da0:	4798      	blx	r3
	while (rst != ERR_NONE) {
     da2:	b100      	cbz	r0, da6 <ETHERNET_PHY_0_example+0xe>
     da4:	e7fe      	b.n	da4 <ETHERNET_PHY_0_example+0xc>
	}

	/* Wait for PHY link up */
	do {
		rst = ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_state);
     da6:	4d06      	ldr	r5, [pc, #24]	; (dc0 <ETHERNET_PHY_0_example+0x28>)
     da8:	4c07      	ldr	r4, [pc, #28]	; (dc8 <ETHERNET_PHY_0_example+0x30>)
     daa:	f10d 0107 	add.w	r1, sp, #7
     dae:	4628      	mov	r0, r5
     db0:	47a0      	blx	r4
	} while (rst == ERR_NONE && link_state == false);  //tph true
     db2:	b918      	cbnz	r0, dbc <ETHERNET_PHY_0_example+0x24>
     db4:	f89d 3007 	ldrb.w	r3, [sp, #7]
     db8:	2b00      	cmp	r3, #0
     dba:	d0f6      	beq.n	daa <ETHERNET_PHY_0_example+0x12>
}
     dbc:	b003      	add	sp, #12
     dbe:	bd30      	pop	{r4, r5, pc}
     dc0:	200081e8 	.word	0x200081e8
     dc4:	00000cf1 	.word	0x00000cf1
     dc8:	00000d1d 	.word	0x00000d1d

00000dcc <ethernet_phys_init>:


void ethernet_phys_init(void)
{
     dcc:	b508      	push	{r3, lr}
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     dce:	4b0d      	ldr	r3, [pc, #52]	; (e04 <ethernet_phys_init+0x38>)
     dd0:	f44f 4280 	mov.w	r2, #16384	; 0x4000
     dd4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     dd8:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
     ddc:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
     de0:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
     de4:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     de8:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     dec:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     df0:	f8c3 0128 	str.w	r0, [r3, #296]	; 0x128
     df4:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     df8:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
//not needed to use as regular gpio?	gpio_set_pin_function(PA14, PINMUX_PA18L_GMAC_GTX0);

	gpio_set_pin_direction(PHY_YELLOW_LED_PIN,GPIO_DIRECTION_OUT);
	gpio_set_pin_level(PHY_YELLOW_LED_PIN,true);

	ETHERNET_PHY_0_init();
     dfc:	4b02      	ldr	r3, [pc, #8]	; (e08 <ethernet_phys_init+0x3c>)
     dfe:	4798      	blx	r3
     e00:	bd08      	pop	{r3, pc}
     e02:	bf00      	nop
     e04:	41008000 	.word	0x41008000
     e08:	00000d71 	.word	0x00000d71

00000e0c <LWIP_MACIF_stack_init>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 * @return ERR_OK  if the loopif is initialized
 */
err_t LWIP_MACIF_stack_init(struct netif *netif)
{
     e0c:	b508      	push	{r3, lr}
	LWIP_ASSERT("netif != NULL", (netif != NULL));
	LWIP_ASSERT("netif->state != NULL", (netif->state != NULL));

	netif->output     = etharp_output;
     e0e:	4a0e      	ldr	r2, [pc, #56]	; (e48 <LWIP_MACIF_stack_init+0x3c>)
     e10:	6142      	str	r2, [r0, #20]
	netif->linkoutput = mac_low_level_output;
     e12:	4a0e      	ldr	r2, [pc, #56]	; (e4c <LWIP_MACIF_stack_init+0x40>)
     e14:	6182      	str	r2, [r0, #24]

	/* device capabilities */
	LWIP_MACIF_desc.flags = CONF_LWIP_MACIF_FLAG;
     e16:	4b0e      	ldr	r3, [pc, #56]	; (e50 <LWIP_MACIF_stack_init+0x44>)
     e18:	226a      	movs	r2, #106	; 0x6a
     e1a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
	LWIP_MACIF_desc.mtu   = CONF_LWIP_MACIF_MTU;
     e1e:	f44f 62c0 	mov.w	r2, #1536	; 0x600
     e22:	859a      	strh	r2, [r3, #44]	; 0x2c

	/* set MAC hardware address length */
	memcpy(LWIP_MACIF_desc.hwaddr, LWIP_MACIF_hwaddr, NETIF_MAX_HWADDR_LEN);
     e24:	4a0b      	ldr	r2, [pc, #44]	; (e54 <LWIP_MACIF_stack_init+0x48>)
     e26:	6811      	ldr	r1, [r2, #0]
     e28:	f8c3 102f 	str.w	r1, [r3, #47]	; 0x2f
     e2c:	8892      	ldrh	r2, [r2, #4]
     e2e:	f8a3 2033 	strh.w	r2, [r3, #51]	; 0x33
	LWIP_MACIF_desc.hwaddr_len = ETHARP_HWADDR_LEN;
     e32:	2206      	movs	r2, #6
     e34:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

#if LWIP_NETIF_HOSTNAME
	/* Initialize interface hostname */
	LWIP_MACIF_desc.hostname = CONF_LWIP_MACIF_HOSTNAME;
#endif
	memcpy(LWIP_MACIF_desc.name, CONF_LWIP_MACIF_HOSTNAME_ABBR, 2);
     e38:	f646 6265 	movw	r2, #28261	; 0x6e65
     e3c:	86da      	strh	r2, [r3, #54]	; 0x36

	/* initialize the mac hardware */
	mac_low_level_init(netif);
     e3e:	4b06      	ldr	r3, [pc, #24]	; (e58 <LWIP_MACIF_stack_init+0x4c>)
     e40:	4798      	blx	r3

	return ERR_OK;
}
     e42:	2000      	movs	r0, #0
     e44:	bd08      	pop	{r3, pc}
     e46:	bf00      	nop
     e48:	0000939d 	.word	0x0000939d
     e4c:	00002e3d 	.word	0x00002e3d
     e50:	200082ac 	.word	0x200082ac
     e54:	200082a4 	.word	0x200082a4
     e58:	00002e11 	.word	0x00002e11

00000e5c <LWIP_MACIF_init>:
void LWIP_MACIF_init(u8_t hwaddr[6])
{
     e5c:	b510      	push	{r4, lr}
     e5e:	b088      	sub	sp, #32
	struct ip_addr ip;
	struct ip_addr nm;
	struct ip_addr gw;
#if CONF_LWIP_MACIF_DHCP
	ip_addr_set_zero(&ip);
     e60:	2200      	movs	r2, #0
     e62:	9207      	str	r2, [sp, #28]
	ip_addr_set_zero(&nm);
     e64:	9206      	str	r2, [sp, #24]
	ip_addr_set_zero(&gw);
     e66:	ab08      	add	r3, sp, #32
     e68:	f843 2d0c 	str.w	r2, [r3, #-12]!
#else
	ipaddr_aton(CONF_LWIP_MACIF_IP, &ip);
	ipaddr_aton(CONF_LWIP_MACIF_NETMASK, &nm);
	ipaddr_aton(CONF_LWIP_MACIF_GATEWAY, &gw);
#endif
	memcpy(LWIP_MACIF_hwaddr, hwaddr, 6);
     e6c:	4a08      	ldr	r2, [pc, #32]	; (e90 <LWIP_MACIF_init+0x34>)
     e6e:	6801      	ldr	r1, [r0, #0]
     e70:	6011      	str	r1, [r2, #0]
     e72:	8881      	ldrh	r1, [r0, #4]
     e74:	8091      	strh	r1, [r2, #4]

	netif_add(&LWIP_MACIF_desc, &ip, &nm, &gw, (void *)&ETHERNET_MAC_0, LWIP_MACIF_stack_init, ethernet_input);
     e76:	4a07      	ldr	r2, [pc, #28]	; (e94 <LWIP_MACIF_init+0x38>)
     e78:	9202      	str	r2, [sp, #8]
     e7a:	4a07      	ldr	r2, [pc, #28]	; (e98 <LWIP_MACIF_init+0x3c>)
     e7c:	9201      	str	r2, [sp, #4]
     e7e:	4a07      	ldr	r2, [pc, #28]	; (e9c <LWIP_MACIF_init+0x40>)
     e80:	9200      	str	r2, [sp, #0]
     e82:	aa06      	add	r2, sp, #24
     e84:	a907      	add	r1, sp, #28
     e86:	4806      	ldr	r0, [pc, #24]	; (ea0 <LWIP_MACIF_init+0x44>)
     e88:	4c06      	ldr	r4, [pc, #24]	; (ea4 <LWIP_MACIF_init+0x48>)
     e8a:	47a0      	blx	r4
}
     e8c:	b008      	add	sp, #32
     e8e:	bd10      	pop	{r4, pc}
     e90:	200082a4 	.word	0x200082a4
     e94:	000094bd 	.word	0x000094bd
     e98:	00000e0d 	.word	0x00000e0d
     e9c:	2000826c 	.word	0x2000826c
     ea0:	200082ac 	.word	0x200082ac
     ea4:	00005b05 	.word	0x00005b05

00000ea8 <eth_ipstack_init>:

void eth_ipstack_init(void)
{
     ea8:	b508      	push	{r3, lr}
	lwip_init();
     eaa:	4b01      	ldr	r3, [pc, #4]	; (eb0 <eth_ipstack_init+0x8>)
     eac:	4798      	blx	r3
     eae:	bd08      	pop	{r3, pc}
     eb0:	00004859 	.word	0x00004859

00000eb4 <atomic_enter_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
     eb4:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
     eb8:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
     eba:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
     ebc:	f3bf 8f5f 	dmb	sy
     ec0:	4770      	bx	lr

00000ec2 <atomic_leave_critical>:
     ec2:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
     ec6:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
     ec8:	f383 8810 	msr	PRIMASK, r3
     ecc:	4770      	bx	lr
	...

00000ed0 <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
     ed0:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
     ed2:	4b04      	ldr	r3, [pc, #16]	; (ee4 <delay_ms+0x14>)
     ed4:	681c      	ldr	r4, [r3, #0]
     ed6:	4b04      	ldr	r3, [pc, #16]	; (ee8 <delay_ms+0x18>)
     ed8:	4798      	blx	r3
     eda:	4601      	mov	r1, r0
     edc:	4620      	mov	r0, r4
     ede:	4b03      	ldr	r3, [pc, #12]	; (eec <delay_ms+0x1c>)
     ee0:	4798      	blx	r3
     ee2:	bd10      	pop	{r4, pc}
     ee4:	2000019c 	.word	0x2000019c
     ee8:	00001a35 	.word	0x00001a35
     eec:	00001a59 	.word	0x00001a59

00000ef0 <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
     ef0:	b510      	push	{r4, lr}
     ef2:	b084      	sub	sp, #16
     ef4:	4614      	mov	r4, r2
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
     ef6:	8903      	ldrh	r3, [r0, #8]
     ef8:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
     efc:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP;
     efe:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     f02:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = (uint8_t *)buf;
     f06:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     f08:	a901      	add	r1, sp, #4
     f0a:	3814      	subs	r0, #20
     f0c:	4b03      	ldr	r3, [pc, #12]	; (f1c <i2c_m_sync_write+0x2c>)
     f0e:	4798      	blx	r3
	if (ret) {
		return ret;
	}

	return n;
}
     f10:	2800      	cmp	r0, #0
     f12:	bf08      	it	eq
     f14:	4620      	moveq	r0, r4
     f16:	b004      	add	sp, #16
     f18:	bd10      	pop	{r4, pc}
     f1a:	bf00      	nop
     f1c:	00002611 	.word	0x00002611

00000f20 <i2c_m_sync_read>:
{
     f20:	b510      	push	{r4, lr}
     f22:	b084      	sub	sp, #16
     f24:	4614      	mov	r4, r2
	msg.addr   = i2c->slave_addr;
     f26:	8903      	ldrh	r3, [r0, #8]
     f28:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
     f2c:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
     f2e:	f248 0301 	movw	r3, #32769	; 0x8001
     f32:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = buf;
     f36:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     f38:	a901      	add	r1, sp, #4
     f3a:	3814      	subs	r0, #20
     f3c:	4b03      	ldr	r3, [pc, #12]	; (f4c <i2c_m_sync_read+0x2c>)
     f3e:	4798      	blx	r3
}
     f40:	2800      	cmp	r0, #0
     f42:	bf08      	it	eq
     f44:	4620      	moveq	r0, r4
     f46:	b004      	add	sp, #16
     f48:	bd10      	pop	{r4, pc}
     f4a:	bf00      	nop
     f4c:	00002611 	.word	0x00002611

00000f50 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
     f50:	b538      	push	{r3, r4, r5, lr}
     f52:	460d      	mov	r5, r1
	int32_t init_status;
	ASSERT(i2c);
     f54:	4604      	mov	r4, r0
     f56:	225e      	movs	r2, #94	; 0x5e
     f58:	4908      	ldr	r1, [pc, #32]	; (f7c <i2c_m_sync_init+0x2c>)
     f5a:	3000      	adds	r0, #0
     f5c:	bf18      	it	ne
     f5e:	2001      	movne	r0, #1
     f60:	4b07      	ldr	r3, [pc, #28]	; (f80 <i2c_m_sync_init+0x30>)
     f62:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
     f64:	4629      	mov	r1, r5
     f66:	4620      	mov	r0, r4
     f68:	4b06      	ldr	r3, [pc, #24]	; (f84 <i2c_m_sync_init+0x34>)
     f6a:	4798      	blx	r3
	if (init_status) {
     f6c:	4603      	mov	r3, r0
     f6e:	b918      	cbnz	r0, f78 <i2c_m_sync_init+0x28>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
     f70:	4a05      	ldr	r2, [pc, #20]	; (f88 <i2c_m_sync_init+0x38>)
     f72:	61a2      	str	r2, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
     f74:	4a05      	ldr	r2, [pc, #20]	; (f8c <i2c_m_sync_init+0x3c>)
     f76:	6162      	str	r2, [r4, #20]

	return ERR_NONE;
}
     f78:	4618      	mov	r0, r3
     f7a:	bd38      	pop	{r3, r4, r5, pc}
     f7c:	0000b218 	.word	0x0000b218
     f80:	0000187d 	.word	0x0000187d
     f84:	00002569 	.word	0x00002569
     f88:	00000f21 	.word	0x00000f21
     f8c:	00000ef1 	.word	0x00000ef1

00000f90 <i2c_m_sync_enable>:

/**
 * \brief Sync version of i2c enable
 */
int32_t i2c_m_sync_enable(struct i2c_m_sync_desc *i2c)
{
     f90:	b508      	push	{r3, lr}
	return _i2c_m_sync_enable(&i2c->device);
     f92:	4b01      	ldr	r3, [pc, #4]	; (f98 <i2c_m_sync_enable+0x8>)
     f94:	4798      	blx	r3
}
     f96:	bd08      	pop	{r3, pc}
     f98:	00002599 	.word	0x00002599

00000f9c <i2c_m_sync_set_slaveaddr>:
/**
 * \brief Sync version of i2c set slave address
 */
int32_t i2c_m_sync_set_slaveaddr(struct i2c_m_sync_desc *i2c, int16_t addr, int32_t addr_len)
{
	return i2c->slave_addr = (addr & 0x3ff) | (addr_len & I2C_M_TEN);
     f9c:	f3c1 0109 	ubfx	r1, r1, #0, #10
     fa0:	f402 6280 	and.w	r2, r2, #1024	; 0x400
     fa4:	430a      	orrs	r2, r1
     fa6:	8382      	strh	r2, [r0, #28]
}
     fa8:	4610      	mov	r0, r2
     faa:	4770      	bx	lr

00000fac <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     fac:	b570      	push	{r4, r5, r6, lr}
     fae:	460d      	mov	r5, r1
     fb0:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
     fb2:	4604      	mov	r4, r0
     fb4:	b160      	cbz	r0, fd0 <io_write+0x24>
     fb6:	1c08      	adds	r0, r1, #0
     fb8:	bf18      	it	ne
     fba:	2001      	movne	r0, #1
     fbc:	2234      	movs	r2, #52	; 0x34
     fbe:	4905      	ldr	r1, [pc, #20]	; (fd4 <io_write+0x28>)
     fc0:	4b05      	ldr	r3, [pc, #20]	; (fd8 <io_write+0x2c>)
     fc2:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
     fc4:	6823      	ldr	r3, [r4, #0]
     fc6:	4632      	mov	r2, r6
     fc8:	4629      	mov	r1, r5
     fca:	4620      	mov	r0, r4
     fcc:	4798      	blx	r3
}
     fce:	bd70      	pop	{r4, r5, r6, pc}
     fd0:	2000      	movs	r0, #0
     fd2:	e7f3      	b.n	fbc <io_write+0x10>
     fd4:	0000b234 	.word	0x0000b234
     fd8:	0000187d 	.word	0x0000187d

00000fdc <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
     fdc:	b570      	push	{r4, r5, r6, lr}
     fde:	460d      	mov	r5, r1
     fe0:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
     fe2:	4604      	mov	r4, r0
     fe4:	b160      	cbz	r0, 1000 <io_read+0x24>
     fe6:	1c08      	adds	r0, r1, #0
     fe8:	bf18      	it	ne
     fea:	2001      	movne	r0, #1
     fec:	223d      	movs	r2, #61	; 0x3d
     fee:	4905      	ldr	r1, [pc, #20]	; (1004 <io_read+0x28>)
     ff0:	4b05      	ldr	r3, [pc, #20]	; (1008 <io_read+0x2c>)
     ff2:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
     ff4:	6863      	ldr	r3, [r4, #4]
     ff6:	4632      	mov	r2, r6
     ff8:	4629      	mov	r1, r5
     ffa:	4620      	mov	r0, r4
     ffc:	4798      	blx	r3
}
     ffe:	bd70      	pop	{r4, r5, r6, pc}
    1000:	2000      	movs	r0, #0
    1002:	e7f3      	b.n	fec <io_read+0x10>
    1004:	0000b234 	.word	0x0000b234
    1008:	0000187d 	.word	0x0000187d

0000100c <mac_read_cb>:
 * \internal data receivced handler
 *
 * \param[in] dev The pointer to MAC device structure
 */
static void mac_read_cb(struct _mac_async_device *dev)
{
    100c:	b508      	push	{r3, lr}
	struct mac_async_descriptor *const descr = CONTAINER_OF(dev, struct mac_async_descriptor, dev);

	if (descr->cb.receive) {
    100e:	6943      	ldr	r3, [r0, #20]
    1010:	b103      	cbz	r3, 1014 <mac_read_cb+0x8>
		descr->cb.receive(descr);
    1012:	4798      	blx	r3
    1014:	bd08      	pop	{r3, pc}

00001016 <mac_write_cb>:
 * \internal data transmit handler
 *
 * \param[in] dev The pointer to MAC device structure
 */
static void mac_write_cb(struct _mac_async_device *dev)
{
    1016:	b508      	push	{r3, lr}
	struct mac_async_descriptor *const descr = CONTAINER_OF(dev, struct mac_async_descriptor, dev);

	if (descr->cb.transmit) {
    1018:	6983      	ldr	r3, [r0, #24]
    101a:	b103      	cbz	r3, 101e <mac_write_cb+0x8>
		descr->cb.transmit(descr);
    101c:	4798      	blx	r3
    101e:	bd08      	pop	{r3, pc}

00001020 <mac_async_init>:
{
    1020:	b538      	push	{r3, r4, r5, lr}
    1022:	460c      	mov	r4, r1
	ASSERT(descr && hw);
    1024:	4605      	mov	r5, r0
    1026:	b158      	cbz	r0, 1040 <mac_async_init+0x20>
    1028:	1c08      	adds	r0, r1, #0
    102a:	bf18      	it	ne
    102c:	2001      	movne	r0, #1
    102e:	2231      	movs	r2, #49	; 0x31
    1030:	4904      	ldr	r1, [pc, #16]	; (1044 <mac_async_init+0x24>)
    1032:	4b05      	ldr	r3, [pc, #20]	; (1048 <mac_async_init+0x28>)
    1034:	4798      	blx	r3
	return _mac_async_init(&descr->dev, hw);
    1036:	4621      	mov	r1, r4
    1038:	4628      	mov	r0, r5
    103a:	4b04      	ldr	r3, [pc, #16]	; (104c <mac_async_init+0x2c>)
    103c:	4798      	blx	r3
}
    103e:	bd38      	pop	{r3, r4, r5, pc}
    1040:	2000      	movs	r0, #0
    1042:	e7f4      	b.n	102e <mac_async_init+0xe>
    1044:	0000b248 	.word	0x0000b248
    1048:	0000187d 	.word	0x0000187d
    104c:	00001b75 	.word	0x00001b75

00001050 <mac_async_enable>:
{
    1050:	b510      	push	{r4, lr}
	ASSERT(descr);
    1052:	4604      	mov	r4, r0
    1054:	2245      	movs	r2, #69	; 0x45
    1056:	4905      	ldr	r1, [pc, #20]	; (106c <mac_async_enable+0x1c>)
    1058:	3000      	adds	r0, #0
    105a:	bf18      	it	ne
    105c:	2001      	movne	r0, #1
    105e:	4b04      	ldr	r3, [pc, #16]	; (1070 <mac_async_enable+0x20>)
    1060:	4798      	blx	r3
	return _mac_async_enable(&descr->dev);
    1062:	4620      	mov	r0, r4
    1064:	4b03      	ldr	r3, [pc, #12]	; (1074 <mac_async_enable+0x24>)
    1066:	4798      	blx	r3
}
    1068:	bd10      	pop	{r4, pc}
    106a:	bf00      	nop
    106c:	0000b248 	.word	0x0000b248
    1070:	0000187d 	.word	0x0000187d
    1074:	00001c3d 	.word	0x00001c3d

00001078 <mac_async_write>:
{
    1078:	b570      	push	{r4, r5, r6, lr}
    107a:	460c      	mov	r4, r1
    107c:	4615      	mov	r5, r2
	ASSERT(descr && buf && len);
    107e:	4606      	mov	r6, r0
    1080:	b168      	cbz	r0, 109e <mac_async_write+0x26>
    1082:	b171      	cbz	r1, 10a2 <mac_async_write+0x2a>
    1084:	1c10      	adds	r0, r2, #0
    1086:	bf18      	it	ne
    1088:	2001      	movne	r0, #1
    108a:	2257      	movs	r2, #87	; 0x57
    108c:	4906      	ldr	r1, [pc, #24]	; (10a8 <mac_async_write+0x30>)
    108e:	4b07      	ldr	r3, [pc, #28]	; (10ac <mac_async_write+0x34>)
    1090:	4798      	blx	r3
	return _mac_async_write(&descr->dev, buf, len);
    1092:	462a      	mov	r2, r5
    1094:	4621      	mov	r1, r4
    1096:	4630      	mov	r0, r6
    1098:	4b05      	ldr	r3, [pc, #20]	; (10b0 <mac_async_write+0x38>)
    109a:	4798      	blx	r3
}
    109c:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && len);
    109e:	2000      	movs	r0, #0
    10a0:	e7f3      	b.n	108a <mac_async_write+0x12>
    10a2:	2000      	movs	r0, #0
    10a4:	e7f1      	b.n	108a <mac_async_write+0x12>
    10a6:	bf00      	nop
    10a8:	0000b248 	.word	0x0000b248
    10ac:	0000187d 	.word	0x0000187d
    10b0:	00001c4d 	.word	0x00001c4d

000010b4 <mac_async_read>:
{
    10b4:	b570      	push	{r4, r5, r6, lr}
    10b6:	460d      	mov	r5, r1
    10b8:	4616      	mov	r6, r2
	ASSERT(descr);
    10ba:	4604      	mov	r4, r0
    10bc:	2261      	movs	r2, #97	; 0x61
    10be:	4906      	ldr	r1, [pc, #24]	; (10d8 <mac_async_read+0x24>)
    10c0:	3000      	adds	r0, #0
    10c2:	bf18      	it	ne
    10c4:	2001      	movne	r0, #1
    10c6:	4b05      	ldr	r3, [pc, #20]	; (10dc <mac_async_read+0x28>)
    10c8:	4798      	blx	r3
	return _mac_async_read(&descr->dev, buf, len);
    10ca:	4632      	mov	r2, r6
    10cc:	4629      	mov	r1, r5
    10ce:	4620      	mov	r0, r4
    10d0:	4b03      	ldr	r3, [pc, #12]	; (10e0 <mac_async_read+0x2c>)
    10d2:	4798      	blx	r3
}
    10d4:	bd70      	pop	{r4, r5, r6, pc}
    10d6:	bf00      	nop
    10d8:	0000b248 	.word	0x0000b248
    10dc:	0000187d 	.word	0x0000187d
    10e0:	00001d85 	.word	0x00001d85

000010e4 <mac_async_read_len>:
{
    10e4:	b510      	push	{r4, lr}
	ASSERT(descr);
    10e6:	4604      	mov	r4, r0
    10e8:	226b      	movs	r2, #107	; 0x6b
    10ea:	4905      	ldr	r1, [pc, #20]	; (1100 <mac_async_read_len+0x1c>)
    10ec:	3000      	adds	r0, #0
    10ee:	bf18      	it	ne
    10f0:	2001      	movne	r0, #1
    10f2:	4b04      	ldr	r3, [pc, #16]	; (1104 <mac_async_read_len+0x20>)
    10f4:	4798      	blx	r3
	return _mac_async_read_len(&descr->dev);
    10f6:	4620      	mov	r0, r4
    10f8:	4b03      	ldr	r3, [pc, #12]	; (1108 <mac_async_read_len+0x24>)
    10fa:	4798      	blx	r3
}
    10fc:	bd10      	pop	{r4, pc}
    10fe:	bf00      	nop
    1100:	0000b248 	.word	0x0000b248
    1104:	0000187d 	.word	0x0000187d
    1108:	00001eb9 	.word	0x00001eb9

0000110c <mac_async_register_callback>:
{
    110c:	b570      	push	{r4, r5, r6, lr}
    110e:	460c      	mov	r4, r1
    1110:	4616      	mov	r6, r2
	ASSERT(descr);
    1112:	4605      	mov	r5, r0
    1114:	2289      	movs	r2, #137	; 0x89
    1116:	4910      	ldr	r1, [pc, #64]	; (1158 <mac_async_register_callback+0x4c>)
    1118:	3000      	adds	r0, #0
    111a:	bf18      	it	ne
    111c:	2001      	movne	r0, #1
    111e:	4b0f      	ldr	r3, [pc, #60]	; (115c <mac_async_register_callback+0x50>)
    1120:	4798      	blx	r3
	switch (type) {
    1122:	b124      	cbz	r4, 112e <mac_async_register_callback+0x22>
    1124:	2c01      	cmp	r4, #1
    1126:	d00c      	beq.n	1142 <mac_async_register_callback+0x36>
		return ERR_INVALID_ARG;
    1128:	f06f 000c 	mvn.w	r0, #12
}
    112c:	bd70      	pop	{r4, r5, r6, pc}
		descr->cb.receive = (mac_async_cb_t)func;
    112e:	616e      	str	r6, [r5, #20]
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_read_cb);
    1130:	2e00      	cmp	r6, #0
    1132:	4a0b      	ldr	r2, [pc, #44]	; (1160 <mac_async_register_callback+0x54>)
    1134:	bf08      	it	eq
    1136:	2200      	moveq	r2, #0
    1138:	2100      	movs	r1, #0
    113a:	4628      	mov	r0, r5
    113c:	4b09      	ldr	r3, [pc, #36]	; (1164 <mac_async_register_callback+0x58>)
    113e:	4798      	blx	r3
    1140:	bd70      	pop	{r4, r5, r6, pc}
		descr->cb.transmit = (mac_async_cb_t)func;
    1142:	61ae      	str	r6, [r5, #24]
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_write_cb);
    1144:	2e00      	cmp	r6, #0
    1146:	4a08      	ldr	r2, [pc, #32]	; (1168 <mac_async_register_callback+0x5c>)
    1148:	bf08      	it	eq
    114a:	2200      	moveq	r2, #0
    114c:	2101      	movs	r1, #1
    114e:	4628      	mov	r0, r5
    1150:	4b04      	ldr	r3, [pc, #16]	; (1164 <mac_async_register_callback+0x58>)
    1152:	4798      	blx	r3
    1154:	bd70      	pop	{r4, r5, r6, pc}
    1156:	bf00      	nop
    1158:	0000b248 	.word	0x0000b248
    115c:	0000187d 	.word	0x0000187d
    1160:	0000100d 	.word	0x0000100d
    1164:	00001f21 	.word	0x00001f21
    1168:	00001017 	.word	0x00001017

0000116c <mac_async_set_filter>:
{
    116c:	b570      	push	{r4, r5, r6, lr}
    116e:	460e      	mov	r6, r1
    1170:	4614      	mov	r4, r2
	ASSERT(descr && filter);
    1172:	4605      	mov	r5, r0
    1174:	b160      	cbz	r0, 1190 <mac_async_set_filter+0x24>
    1176:	1c10      	adds	r0, r2, #0
    1178:	bf18      	it	ne
    117a:	2001      	movne	r0, #1
    117c:	229b      	movs	r2, #155	; 0x9b
    117e:	4905      	ldr	r1, [pc, #20]	; (1194 <mac_async_set_filter+0x28>)
    1180:	4b05      	ldr	r3, [pc, #20]	; (1198 <mac_async_set_filter+0x2c>)
    1182:	4798      	blx	r3
	return _mac_async_set_filter(&descr->dev, index, filter);
    1184:	4622      	mov	r2, r4
    1186:	4631      	mov	r1, r6
    1188:	4628      	mov	r0, r5
    118a:	4b04      	ldr	r3, [pc, #16]	; (119c <mac_async_set_filter+0x30>)
    118c:	4798      	blx	r3
}
    118e:	bd70      	pop	{r4, r5, r6, pc}
    1190:	2000      	movs	r0, #0
    1192:	e7f3      	b.n	117c <mac_async_set_filter+0x10>
    1194:	0000b248 	.word	0x0000b248
    1198:	0000187d 	.word	0x0000187d
    119c:	00001f51 	.word	0x00001f51

000011a0 <mac_async_write_phy_reg>:
{
    11a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    11a2:	460d      	mov	r5, r1
    11a4:	4616      	mov	r6, r2
    11a6:	461f      	mov	r7, r3
	ASSERT(descr);
    11a8:	4604      	mov	r4, r0
    11aa:	22af      	movs	r2, #175	; 0xaf
    11ac:	4906      	ldr	r1, [pc, #24]	; (11c8 <mac_async_write_phy_reg+0x28>)
    11ae:	3000      	adds	r0, #0
    11b0:	bf18      	it	ne
    11b2:	2001      	movne	r0, #1
    11b4:	4b05      	ldr	r3, [pc, #20]	; (11cc <mac_async_write_phy_reg+0x2c>)
    11b6:	4798      	blx	r3
	return _mac_async_write_phy_reg(&descr->dev, addr, reg, val);
    11b8:	463b      	mov	r3, r7
    11ba:	4632      	mov	r2, r6
    11bc:	4629      	mov	r1, r5
    11be:	4620      	mov	r0, r4
    11c0:	4c03      	ldr	r4, [pc, #12]	; (11d0 <mac_async_write_phy_reg+0x30>)
    11c2:	47a0      	blx	r4
}
    11c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    11c6:	bf00      	nop
    11c8:	0000b248 	.word	0x0000b248
    11cc:	0000187d 	.word	0x0000187d
    11d0:	00001f99 	.word	0x00001f99

000011d4 <mac_async_read_phy_reg>:
{
    11d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    11d6:	460e      	mov	r6, r1
    11d8:	4617      	mov	r7, r2
    11da:	461c      	mov	r4, r3
	ASSERT(descr && val);
    11dc:	4605      	mov	r5, r0
    11de:	b168      	cbz	r0, 11fc <mac_async_read_phy_reg+0x28>
    11e0:	1c18      	adds	r0, r3, #0
    11e2:	bf18      	it	ne
    11e4:	2001      	movne	r0, #1
    11e6:	22b8      	movs	r2, #184	; 0xb8
    11e8:	4905      	ldr	r1, [pc, #20]	; (1200 <mac_async_read_phy_reg+0x2c>)
    11ea:	4b06      	ldr	r3, [pc, #24]	; (1204 <mac_async_read_phy_reg+0x30>)
    11ec:	4798      	blx	r3
	return _mac_async_read_phy_reg(&descr->dev, addr, reg, val);
    11ee:	4623      	mov	r3, r4
    11f0:	463a      	mov	r2, r7
    11f2:	4631      	mov	r1, r6
    11f4:	4628      	mov	r0, r5
    11f6:	4c04      	ldr	r4, [pc, #16]	; (1208 <mac_async_read_phy_reg+0x34>)
    11f8:	47a0      	blx	r4
}
    11fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    11fc:	2000      	movs	r0, #0
    11fe:	e7f2      	b.n	11e6 <mac_async_read_phy_reg+0x12>
    1200:	0000b248 	.word	0x0000b248
    1204:	0000187d 	.word	0x0000187d
    1208:	00001fd9 	.word	0x00001fd9

0000120c <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
    120c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    120e:	4684      	mov	ip, r0
 * \return A pointer to the head of the given list or NULL if the list is
 * empty
 */
static inline void *list_get_head(const struct list_descriptor *const list)
{
	return (void *)list->head;
    1210:	6807      	ldr	r7, [r0, #0]
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);

	if (!head) {
    1212:	b12f      	cbz	r7, 1220 <timer_add_timer_task+0x14>
		if (it->time_label <= time) {
			time_left = it->interval - (time - it->time_label);
		} else {
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
		}
		if (time_left >= new_task->interval)
    1214:	688d      	ldr	r5, [r1, #8]
    1216:	463c      	mov	r4, r7
    1218:	2600      	movs	r6, #0
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    121a:	f1c2 0e01 	rsb	lr, r2, #1
    121e:	e00b      	b.n	1238 <timer_add_timer_task+0x2c>
		list_insert_as_head(list, new_task);
    1220:	4b0e      	ldr	r3, [pc, #56]	; (125c <timer_add_timer_task+0x50>)
    1222:	4798      	blx	r3
		return;
    1224:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    1226:	4473      	add	r3, lr
    1228:	68a0      	ldr	r0, [r4, #8]
    122a:	4403      	add	r3, r0
		if (time_left >= new_task->interval)
    122c:	42ab      	cmp	r3, r5
    122e:	d20a      	bcs.n	1246 <timer_add_timer_task+0x3a>
 * \return A pointer to the next list element or NULL if there is not next
 * element
 */
static inline void *list_get_next_element(const void *const element)
{
	return element ? ((struct list_element *)element)->next : NULL;
    1230:	6823      	ldr	r3, [r4, #0]
    1232:	4626      	mov	r6, r4
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
    1234:	b153      	cbz	r3, 124c <timer_add_timer_task+0x40>
    1236:	461c      	mov	r4, r3
		if (it->time_label <= time) {
    1238:	6863      	ldr	r3, [r4, #4]
    123a:	4293      	cmp	r3, r2
    123c:	d8f3      	bhi.n	1226 <timer_add_timer_task+0x1a>
			time_left = it->interval - (time - it->time_label);
    123e:	68a0      	ldr	r0, [r4, #8]
    1240:	4403      	add	r3, r0
    1242:	1a9b      	subs	r3, r3, r2
    1244:	e7f2      	b.n	122c <timer_add_timer_task+0x20>
			break;
		prev = it;
	}

	if (it == head) {
    1246:	42a7      	cmp	r7, r4
    1248:	d004      	beq.n	1254 <timer_add_timer_task+0x48>
    124a:	4634      	mov	r4, r6
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
    124c:	4620      	mov	r0, r4
    124e:	4b04      	ldr	r3, [pc, #16]	; (1260 <timer_add_timer_task+0x54>)
    1250:	4798      	blx	r3
    1252:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		list_insert_as_head(list, new_task);
    1254:	4660      	mov	r0, ip
    1256:	4b01      	ldr	r3, [pc, #4]	; (125c <timer_add_timer_task+0x50>)
    1258:	4798      	blx	r3
    125a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    125c:	000018a5 	.word	0x000018a5
    1260:	000018d1 	.word	0x000018d1

00001264 <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
    1264:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return (void *)list->head;
    1268:	6944      	ldr	r4, [r0, #20]
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
    126a:	6907      	ldr	r7, [r0, #16]
    126c:	3701      	adds	r7, #1
    126e:	6107      	str	r7, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    1270:	7e03      	ldrb	r3, [r0, #24]
    1272:	f013 0f01 	tst.w	r3, #1
    1276:	d113      	bne.n	12a0 <timer_process_counted+0x3c>
    1278:	7e03      	ldrb	r3, [r0, #24]
    127a:	f013 0f02 	tst.w	r3, #2
    127e:	d10f      	bne.n	12a0 <timer_process_counted+0x3c>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
		return;
	}

	while (it && ((time - it->time_label) >= it->interval)) {
    1280:	b354      	cbz	r4, 12d8 <timer_process_counted+0x74>
    1282:	6863      	ldr	r3, [r4, #4]
    1284:	1afb      	subs	r3, r7, r3
    1286:	68a2      	ldr	r2, [r4, #8]
    1288:	4293      	cmp	r3, r2
    128a:	d307      	bcc.n	129c <timer_process_counted+0x38>
    128c:	4606      	mov	r6, r0
		struct timer_task *tmp = it;

		list_remove_head(&timer->tasks);
    128e:	f100 0814 	add.w	r8, r0, #20
    1292:	f8df 9048 	ldr.w	r9, [pc, #72]	; 12dc <timer_process_counted+0x78>
		if (TIMER_TASK_REPEAT == tmp->mode) {
			tmp->time_label = time;
			timer_add_timer_task(&timer->tasks, tmp, time);
    1296:	f8df a048 	ldr.w	sl, [pc, #72]	; 12e0 <timer_process_counted+0x7c>
    129a:	e012      	b.n	12c2 <timer_process_counted+0x5e>
    129c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
    12a0:	7e03      	ldrb	r3, [r0, #24]
    12a2:	f043 0302 	orr.w	r3, r3, #2
    12a6:	7603      	strb	r3, [r0, #24]
		return;
    12a8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    12ac:	6975      	ldr	r5, [r6, #20]
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);

		tmp->cb(tmp);
    12ae:	68e3      	ldr	r3, [r4, #12]
    12b0:	4620      	mov	r0, r4
    12b2:	4798      	blx	r3
	while (it && ((time - it->time_label) >= it->interval)) {
    12b4:	b185      	cbz	r5, 12d8 <timer_process_counted+0x74>
		it = (struct timer_task *)list_get_head(&timer->tasks);
    12b6:	462c      	mov	r4, r5
	while (it && ((time - it->time_label) >= it->interval)) {
    12b8:	686b      	ldr	r3, [r5, #4]
    12ba:	1afb      	subs	r3, r7, r3
    12bc:	68aa      	ldr	r2, [r5, #8]
    12be:	4293      	cmp	r3, r2
    12c0:	d30a      	bcc.n	12d8 <timer_process_counted+0x74>
		list_remove_head(&timer->tasks);
    12c2:	4640      	mov	r0, r8
    12c4:	47c8      	blx	r9
		if (TIMER_TASK_REPEAT == tmp->mode) {
    12c6:	7c23      	ldrb	r3, [r4, #16]
    12c8:	2b01      	cmp	r3, #1
    12ca:	d1ef      	bne.n	12ac <timer_process_counted+0x48>
			tmp->time_label = time;
    12cc:	6067      	str	r7, [r4, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
    12ce:	463a      	mov	r2, r7
    12d0:	4621      	mov	r1, r4
    12d2:	4640      	mov	r0, r8
    12d4:	47d0      	blx	sl
    12d6:	e7e9      	b.n	12ac <timer_process_counted+0x48>
    12d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    12dc:	000018d9 	.word	0x000018d9
    12e0:	0000120d 	.word	0x0000120d

000012e4 <timer_init>:
{
    12e4:	b538      	push	{r3, r4, r5, lr}
    12e6:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    12e8:	4604      	mov	r4, r0
    12ea:	b178      	cbz	r0, 130c <timer_init+0x28>
    12ec:	1c08      	adds	r0, r1, #0
    12ee:	bf18      	it	ne
    12f0:	2001      	movne	r0, #1
    12f2:	223b      	movs	r2, #59	; 0x3b
    12f4:	4906      	ldr	r1, [pc, #24]	; (1310 <timer_init+0x2c>)
    12f6:	4b07      	ldr	r3, [pc, #28]	; (1314 <timer_init+0x30>)
    12f8:	4798      	blx	r3
	_timer_init(&descr->device, hw);
    12fa:	4629      	mov	r1, r5
    12fc:	4620      	mov	r0, r4
    12fe:	4b06      	ldr	r3, [pc, #24]	; (1318 <timer_init+0x34>)
    1300:	4798      	blx	r3
	descr->time                           = 0;
    1302:	2000      	movs	r0, #0
    1304:	6120      	str	r0, [r4, #16]
	descr->device.timer_cb.period_expired = timer_process_counted;
    1306:	4b05      	ldr	r3, [pc, #20]	; (131c <timer_init+0x38>)
    1308:	6023      	str	r3, [r4, #0]
}
    130a:	bd38      	pop	{r3, r4, r5, pc}
    130c:	2000      	movs	r0, #0
    130e:	e7f0      	b.n	12f2 <timer_init+0xe>
    1310:	0000b264 	.word	0x0000b264
    1314:	0000187d 	.word	0x0000187d
    1318:	00002bdd 	.word	0x00002bdd
    131c:	00001265 	.word	0x00001265

00001320 <timer_start>:
{
    1320:	b510      	push	{r4, lr}
	ASSERT(descr);
    1322:	4604      	mov	r4, r0
    1324:	2253      	movs	r2, #83	; 0x53
    1326:	4909      	ldr	r1, [pc, #36]	; (134c <timer_start+0x2c>)
    1328:	3000      	adds	r0, #0
    132a:	bf18      	it	ne
    132c:	2001      	movne	r0, #1
    132e:	4b08      	ldr	r3, [pc, #32]	; (1350 <timer_start+0x30>)
    1330:	4798      	blx	r3
	if (_timer_is_started(&descr->device)) {
    1332:	4620      	mov	r0, r4
    1334:	4b07      	ldr	r3, [pc, #28]	; (1354 <timer_start+0x34>)
    1336:	4798      	blx	r3
    1338:	b920      	cbnz	r0, 1344 <timer_start+0x24>
	_timer_start(&descr->device);
    133a:	4620      	mov	r0, r4
    133c:	4b06      	ldr	r3, [pc, #24]	; (1358 <timer_start+0x38>)
    133e:	4798      	blx	r3
	return ERR_NONE;
    1340:	2000      	movs	r0, #0
    1342:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    1344:	f06f 0010 	mvn.w	r0, #16
}
    1348:	bd10      	pop	{r4, pc}
    134a:	bf00      	nop
    134c:	0000b264 	.word	0x0000b264
    1350:	0000187d 	.word	0x0000187d
    1354:	00002d99 	.word	0x00002d99
    1358:	00002d85 	.word	0x00002d85

0000135c <timer_add_task>:
{
    135c:	b570      	push	{r4, r5, r6, lr}
    135e:	b082      	sub	sp, #8
    1360:	460d      	mov	r5, r1
	ASSERT(descr && task);
    1362:	4604      	mov	r4, r0
    1364:	b318      	cbz	r0, 13ae <timer_add_task+0x52>
    1366:	1c08      	adds	r0, r1, #0
    1368:	bf18      	it	ne
    136a:	2001      	movne	r0, #1
    136c:	227a      	movs	r2, #122	; 0x7a
    136e:	491e      	ldr	r1, [pc, #120]	; (13e8 <timer_add_task+0x8c>)
    1370:	4b1e      	ldr	r3, [pc, #120]	; (13ec <timer_add_task+0x90>)
    1372:	4798      	blx	r3
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    1374:	7e23      	ldrb	r3, [r4, #24]
    1376:	f043 0301 	orr.w	r3, r3, #1
    137a:	7623      	strb	r3, [r4, #24]
	if (is_list_element(&descr->tasks, task)) {
    137c:	f104 0614 	add.w	r6, r4, #20
    1380:	4629      	mov	r1, r5
    1382:	4630      	mov	r0, r6
    1384:	4b1a      	ldr	r3, [pc, #104]	; (13f0 <timer_add_task+0x94>)
    1386:	4798      	blx	r3
    1388:	b998      	cbnz	r0, 13b2 <timer_add_task+0x56>
	task->time_label = descr->time;
    138a:	6923      	ldr	r3, [r4, #16]
    138c:	606b      	str	r3, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    138e:	6922      	ldr	r2, [r4, #16]
    1390:	4629      	mov	r1, r5
    1392:	4630      	mov	r0, r6
    1394:	4b17      	ldr	r3, [pc, #92]	; (13f4 <timer_add_task+0x98>)
    1396:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    1398:	7e23      	ldrb	r3, [r4, #24]
    139a:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    139e:	7623      	strb	r3, [r4, #24]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
    13a0:	7e23      	ldrb	r3, [r4, #24]
    13a2:	f013 0f02 	tst.w	r3, #2
    13a6:	d110      	bne.n	13ca <timer_add_task+0x6e>
	return ERR_NONE;
    13a8:	2000      	movs	r0, #0
}
    13aa:	b002      	add	sp, #8
    13ac:	bd70      	pop	{r4, r5, r6, pc}
    13ae:	2000      	movs	r0, #0
    13b0:	e7dc      	b.n	136c <timer_add_task+0x10>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    13b2:	7e23      	ldrb	r3, [r4, #24]
    13b4:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    13b8:	7623      	strb	r3, [r4, #24]
		ASSERT(false);
    13ba:	227f      	movs	r2, #127	; 0x7f
    13bc:	490a      	ldr	r1, [pc, #40]	; (13e8 <timer_add_task+0x8c>)
    13be:	2000      	movs	r0, #0
    13c0:	4b0a      	ldr	r3, [pc, #40]	; (13ec <timer_add_task+0x90>)
    13c2:	4798      	blx	r3
		return ERR_ALREADY_INITIALIZED;
    13c4:	f06f 0011 	mvn.w	r0, #17
    13c8:	e7ef      	b.n	13aa <timer_add_task+0x4e>
		CRITICAL_SECTION_ENTER()
    13ca:	a801      	add	r0, sp, #4
    13cc:	4b0a      	ldr	r3, [pc, #40]	; (13f8 <timer_add_task+0x9c>)
    13ce:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    13d0:	7e23      	ldrb	r3, [r4, #24]
    13d2:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    13d6:	7623      	strb	r3, [r4, #24]
		_timer_set_irq(&descr->device);
    13d8:	4620      	mov	r0, r4
    13da:	4b08      	ldr	r3, [pc, #32]	; (13fc <timer_add_task+0xa0>)
    13dc:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
    13de:	a801      	add	r0, sp, #4
    13e0:	4b07      	ldr	r3, [pc, #28]	; (1400 <timer_add_task+0xa4>)
    13e2:	4798      	blx	r3
	return ERR_NONE;
    13e4:	2000      	movs	r0, #0
    13e6:	e7e0      	b.n	13aa <timer_add_task+0x4e>
    13e8:	0000b264 	.word	0x0000b264
    13ec:	0000187d 	.word	0x0000187d
    13f0:	00001883 	.word	0x00001883
    13f4:	0000120d 	.word	0x0000120d
    13f8:	00000eb5 	.word	0x00000eb5
    13fc:	00002db1 	.word	0x00002db1
    1400:	00000ec3 	.word	0x00000ec3

00001404 <usart_transmission_complete>:
 * \brief Process completion of data sending
 *
 * \param[in] device The pointer to device structure
 */
static void usart_transmission_complete(struct _usart_async_device *device)
{
    1404:	b508      	push	{r3, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
    1406:	2300      	movs	r3, #0
    1408:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.tx_done) {
    140a:	69c3      	ldr	r3, [r0, #28]
    140c:	b11b      	cbz	r3, 1416 <usart_transmission_complete+0x12>
    140e:	f1a0 0208 	sub.w	r2, r0, #8
		descr->usart_cb.tx_done(descr);
    1412:	4610      	mov	r0, r2
    1414:	4798      	blx	r3
    1416:	bd08      	pop	{r3, pc}

00001418 <usart_error>:
 * \brief Process error interrupt
 *
 * \param[in] device The pointer to device structure
 */
static void usart_error(struct _usart_async_device *device)
{
    1418:	b508      	push	{r3, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
    141a:	2300      	movs	r3, #0
    141c:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.error) {
    141e:	6a43      	ldr	r3, [r0, #36]	; 0x24
    1420:	b11b      	cbz	r3, 142a <usart_error+0x12>
    1422:	f1a0 0208 	sub.w	r2, r0, #8
		descr->usart_cb.error(descr);
    1426:	4610      	mov	r0, r2
    1428:	4798      	blx	r3
    142a:	bd08      	pop	{r3, pc}

0000142c <usart_fill_rx_buffer>:
{
    142c:	b538      	push	{r3, r4, r5, lr}
    142e:	4604      	mov	r4, r0
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
    1430:	f1a0 0508 	sub.w	r5, r0, #8
	ringbuffer_put(&descr->rx, data);
    1434:	302c      	adds	r0, #44	; 0x2c
    1436:	4b03      	ldr	r3, [pc, #12]	; (1444 <usart_fill_rx_buffer+0x18>)
    1438:	4798      	blx	r3
	if (descr->usart_cb.rx_done) {
    143a:	6a23      	ldr	r3, [r4, #32]
    143c:	b10b      	cbz	r3, 1442 <usart_fill_rx_buffer+0x16>
		descr->usart_cb.rx_done(descr);
    143e:	4628      	mov	r0, r5
    1440:	4798      	blx	r3
    1442:	bd38      	pop	{r3, r4, r5, pc}
    1444:	00001979 	.word	0x00001979

00001448 <usart_async_write>:
{
    1448:	b570      	push	{r4, r5, r6, lr}
    144a:	460e      	mov	r6, r1
    144c:	4615      	mov	r5, r2
	ASSERT(descr && buf && length);
    144e:	4604      	mov	r4, r0
    1450:	b1e0      	cbz	r0, 148c <usart_async_write+0x44>
    1452:	b1e9      	cbz	r1, 1490 <usart_async_write+0x48>
    1454:	1c10      	adds	r0, r2, #0
    1456:	bf18      	it	ne
    1458:	2001      	movne	r0, #1
    145a:	f240 123b 	movw	r2, #315	; 0x13b
    145e:	490f      	ldr	r1, [pc, #60]	; (149c <usart_async_write+0x54>)
    1460:	4b0f      	ldr	r3, [pc, #60]	; (14a0 <usart_async_write+0x58>)
    1462:	4798      	blx	r3
	if (descr->tx_por != descr->tx_buffer_length) {
    1464:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
    1468:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
    146c:	429a      	cmp	r2, r3
    146e:	d111      	bne.n	1494 <usart_async_write+0x4c>
	descr->tx_buffer        = (uint8_t *)buf;
    1470:	64a6      	str	r6, [r4, #72]	; 0x48
	descr->tx_buffer_length = length;
    1472:	f8a4 504c 	strh.w	r5, [r4, #76]	; 0x4c
	descr->tx_por           = 0;
    1476:	2300      	movs	r3, #0
    1478:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	descr->stat             = USART_ASYNC_STATUS_BUSY;
    147c:	2301      	movs	r3, #1
    147e:	6323      	str	r3, [r4, #48]	; 0x30
	_usart_async_enable_byte_sent_irq(&descr->device);
    1480:	f104 0008 	add.w	r0, r4, #8
    1484:	4b07      	ldr	r3, [pc, #28]	; (14a4 <usart_async_write+0x5c>)
    1486:	4798      	blx	r3
	return (int32_t)length;
    1488:	4628      	mov	r0, r5
    148a:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && length);
    148c:	2000      	movs	r0, #0
    148e:	e7e4      	b.n	145a <usart_async_write+0x12>
    1490:	2000      	movs	r0, #0
    1492:	e7e2      	b.n	145a <usart_async_write+0x12>
		return ERR_NO_RESOURCE;
    1494:	f06f 001b 	mvn.w	r0, #27
}
    1498:	bd70      	pop	{r4, r5, r6, pc}
    149a:	bf00      	nop
    149c:	0000b27c 	.word	0x0000b27c
    14a0:	0000187d 	.word	0x0000187d
    14a4:	000024eb 	.word	0x000024eb

000014a8 <usart_process_byte_sent>:
{
    14a8:	b510      	push	{r4, lr}
    14aa:	4604      	mov	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
    14ac:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
    14ae:	f8b0 2044 	ldrh.w	r2, [r0, #68]	; 0x44
    14b2:	429a      	cmp	r2, r3
    14b4:	d009      	beq.n	14ca <usart_process_byte_sent+0x22>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
    14b6:	6c02      	ldr	r2, [r0, #64]	; 0x40
    14b8:	1c59      	adds	r1, r3, #1
    14ba:	8781      	strh	r1, [r0, #60]	; 0x3c
    14bc:	5cd1      	ldrb	r1, [r2, r3]
    14be:	4b04      	ldr	r3, [pc, #16]	; (14d0 <usart_process_byte_sent+0x28>)
    14c0:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
    14c2:	4620      	mov	r0, r4
    14c4:	4b03      	ldr	r3, [pc, #12]	; (14d4 <usart_process_byte_sent+0x2c>)
    14c6:	4798      	blx	r3
    14c8:	bd10      	pop	{r4, pc}
		_usart_async_enable_tx_done_irq(&descr->device);
    14ca:	4b03      	ldr	r3, [pc, #12]	; (14d8 <usart_process_byte_sent+0x30>)
    14cc:	4798      	blx	r3
    14ce:	bd10      	pop	{r4, pc}
    14d0:	000024bf 	.word	0x000024bf
    14d4:	000024eb 	.word	0x000024eb
    14d8:	000024f3 	.word	0x000024f3

000014dc <usart_async_read>:
{
    14dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    14e0:	b082      	sub	sp, #8
    14e2:	460f      	mov	r7, r1
    14e4:	4690      	mov	r8, r2
	ASSERT(descr && buf && length);
    14e6:	4606      	mov	r6, r0
    14e8:	b1a0      	cbz	r0, 1514 <usart_async_read+0x38>
    14ea:	b199      	cbz	r1, 1514 <usart_async_read+0x38>
    14ec:	2a00      	cmp	r2, #0
    14ee:	d12d      	bne.n	154c <usart_async_read+0x70>
    14f0:	f44f 72ac 	mov.w	r2, #344	; 0x158
    14f4:	4929      	ldr	r1, [pc, #164]	; (159c <usart_async_read+0xc0>)
    14f6:	2000      	movs	r0, #0
    14f8:	4b29      	ldr	r3, [pc, #164]	; (15a0 <usart_async_read+0xc4>)
    14fa:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
    14fc:	a801      	add	r0, sp, #4
    14fe:	4b29      	ldr	r3, [pc, #164]	; (15a4 <usart_async_read+0xc8>)
    1500:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
    1502:	f106 0034 	add.w	r0, r6, #52	; 0x34
    1506:	4b28      	ldr	r3, [pc, #160]	; (15a8 <usart_async_read+0xcc>)
    1508:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
    150a:	a801      	add	r0, sp, #4
    150c:	4b27      	ldr	r3, [pc, #156]	; (15ac <usart_async_read+0xd0>)
    150e:	4798      	blx	r3
	uint16_t                       was_read = 0;
    1510:	2500      	movs	r5, #0
	return (int32_t)was_read;
    1512:	e03e      	b.n	1592 <usart_async_read+0xb6>
	ASSERT(descr && buf && length);
    1514:	f44f 72ac 	mov.w	r2, #344	; 0x158
    1518:	4920      	ldr	r1, [pc, #128]	; (159c <usart_async_read+0xc0>)
    151a:	2000      	movs	r0, #0
    151c:	4b20      	ldr	r3, [pc, #128]	; (15a0 <usart_async_read+0xc4>)
    151e:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
    1520:	a801      	add	r0, sp, #4
    1522:	4b20      	ldr	r3, [pc, #128]	; (15a4 <usart_async_read+0xc8>)
    1524:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
    1526:	f106 0a34 	add.w	sl, r6, #52	; 0x34
    152a:	4650      	mov	r0, sl
    152c:	4b1e      	ldr	r3, [pc, #120]	; (15a8 <usart_async_read+0xcc>)
    152e:	4798      	blx	r3
    1530:	4681      	mov	r9, r0
	CRITICAL_SECTION_LEAVE()
    1532:	a801      	add	r0, sp, #4
    1534:	4b1d      	ldr	r3, [pc, #116]	; (15ac <usart_async_read+0xd0>)
    1536:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
    1538:	f1b9 0f00 	cmp.w	r9, #0
    153c:	d004      	beq.n	1548 <usart_async_read+0x6c>
    153e:	f1b8 0f00 	cmp.w	r8, #0
    1542:	d119      	bne.n	1578 <usart_async_read+0x9c>
	uint16_t                       was_read = 0;
    1544:	2500      	movs	r5, #0
    1546:	e024      	b.n	1592 <usart_async_read+0xb6>
    1548:	2500      	movs	r5, #0
    154a:	e022      	b.n	1592 <usart_async_read+0xb6>
	ASSERT(descr && buf && length);
    154c:	f44f 72ac 	mov.w	r2, #344	; 0x158
    1550:	4912      	ldr	r1, [pc, #72]	; (159c <usart_async_read+0xc0>)
    1552:	2001      	movs	r0, #1
    1554:	4b12      	ldr	r3, [pc, #72]	; (15a0 <usart_async_read+0xc4>)
    1556:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
    1558:	a801      	add	r0, sp, #4
    155a:	4b12      	ldr	r3, [pc, #72]	; (15a4 <usart_async_read+0xc8>)
    155c:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
    155e:	f106 0a34 	add.w	sl, r6, #52	; 0x34
    1562:	4650      	mov	r0, sl
    1564:	4b10      	ldr	r3, [pc, #64]	; (15a8 <usart_async_read+0xcc>)
    1566:	4798      	blx	r3
    1568:	4681      	mov	r9, r0
	CRITICAL_SECTION_LEAVE()
    156a:	a801      	add	r0, sp, #4
    156c:	4b0f      	ldr	r3, [pc, #60]	; (15ac <usart_async_read+0xd0>)
    156e:	4798      	blx	r3
	uint16_t                       was_read = 0;
    1570:	2500      	movs	r5, #0
	while ((was_read < num) && (was_read < length)) {
    1572:	f1b9 0f00 	cmp.w	r9, #0
    1576:	d00c      	beq.n	1592 <usart_async_read+0xb6>
{
    1578:	2400      	movs	r4, #0
		ringbuffer_get(&descr->rx, &buf[was_read++]);
    157a:	4e0d      	ldr	r6, [pc, #52]	; (15b0 <usart_async_read+0xd4>)
    157c:	1c60      	adds	r0, r4, #1
    157e:	b285      	uxth	r5, r0
    1580:	1939      	adds	r1, r7, r4
    1582:	4650      	mov	r0, sl
    1584:	47b0      	blx	r6
    1586:	3401      	adds	r4, #1
	while ((was_read < num) && (was_read < length)) {
    1588:	454c      	cmp	r4, r9
    158a:	d202      	bcs.n	1592 <usart_async_read+0xb6>
    158c:	b2a3      	uxth	r3, r4
    158e:	4598      	cmp	r8, r3
    1590:	d8f4      	bhi.n	157c <usart_async_read+0xa0>
}
    1592:	4628      	mov	r0, r5
    1594:	b002      	add	sp, #8
    1596:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    159a:	bf00      	nop
    159c:	0000b27c 	.word	0x0000b27c
    15a0:	0000187d 	.word	0x0000187d
    15a4:	00000eb5 	.word	0x00000eb5
    15a8:	000019b9 	.word	0x000019b9
    15ac:	00000ec3 	.word	0x00000ec3
    15b0:	00001935 	.word	0x00001935

000015b4 <usart_async_init>:
{
    15b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    15b6:	460d      	mov	r5, r1
    15b8:	4616      	mov	r6, r2
    15ba:	461f      	mov	r7, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
    15bc:	4604      	mov	r4, r0
    15be:	b320      	cbz	r0, 160a <usart_async_init+0x56>
    15c0:	b329      	cbz	r1, 160e <usart_async_init+0x5a>
    15c2:	b332      	cbz	r2, 1612 <usart_async_init+0x5e>
    15c4:	1c18      	adds	r0, r3, #0
    15c6:	bf18      	it	ne
    15c8:	2001      	movne	r0, #1
    15ca:	223a      	movs	r2, #58	; 0x3a
    15cc:	4913      	ldr	r1, [pc, #76]	; (161c <usart_async_init+0x68>)
    15ce:	4b14      	ldr	r3, [pc, #80]	; (1620 <usart_async_init+0x6c>)
    15d0:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
    15d2:	463a      	mov	r2, r7
    15d4:	4631      	mov	r1, r6
    15d6:	f104 0034 	add.w	r0, r4, #52	; 0x34
    15da:	4b12      	ldr	r3, [pc, #72]	; (1624 <usart_async_init+0x70>)
    15dc:	4798      	blx	r3
    15de:	b9d0      	cbnz	r0, 1616 <usart_async_init+0x62>
	init_status = _usart_async_init(&descr->device, hw);
    15e0:	4629      	mov	r1, r5
    15e2:	f104 0008 	add.w	r0, r4, #8
    15e6:	4b10      	ldr	r3, [pc, #64]	; (1628 <usart_async_init+0x74>)
    15e8:	4798      	blx	r3
	if (init_status) {
    15ea:	4603      	mov	r3, r0
    15ec:	b958      	cbnz	r0, 1606 <usart_async_init+0x52>
	descr->io.read  = usart_async_read;
    15ee:	4a0f      	ldr	r2, [pc, #60]	; (162c <usart_async_init+0x78>)
    15f0:	6062      	str	r2, [r4, #4]
	descr->io.write = usart_async_write;
    15f2:	4a0f      	ldr	r2, [pc, #60]	; (1630 <usart_async_init+0x7c>)
    15f4:	6022      	str	r2, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_process_byte_sent;
    15f6:	4a0f      	ldr	r2, [pc, #60]	; (1634 <usart_async_init+0x80>)
    15f8:	60a2      	str	r2, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_fill_rx_buffer;
    15fa:	4a0f      	ldr	r2, [pc, #60]	; (1638 <usart_async_init+0x84>)
    15fc:	60e2      	str	r2, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_transmission_complete;
    15fe:	4a0f      	ldr	r2, [pc, #60]	; (163c <usart_async_init+0x88>)
    1600:	6122      	str	r2, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_error;
    1602:	4a0f      	ldr	r2, [pc, #60]	; (1640 <usart_async_init+0x8c>)
    1604:	6162      	str	r2, [r4, #20]
}
    1606:	4618      	mov	r0, r3
    1608:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
    160a:	2000      	movs	r0, #0
    160c:	e7dd      	b.n	15ca <usart_async_init+0x16>
    160e:	2000      	movs	r0, #0
    1610:	e7db      	b.n	15ca <usart_async_init+0x16>
    1612:	2000      	movs	r0, #0
    1614:	e7d9      	b.n	15ca <usart_async_init+0x16>
		return ERR_INVALID_ARG;
    1616:	f06f 030c 	mvn.w	r3, #12
    161a:	e7f4      	b.n	1606 <usart_async_init+0x52>
    161c:	0000b27c 	.word	0x0000b27c
    1620:	0000187d 	.word	0x0000187d
    1624:	000018e5 	.word	0x000018e5
    1628:	0000240d 	.word	0x0000240d
    162c:	000014dd 	.word	0x000014dd
    1630:	00001449 	.word	0x00001449
    1634:	000014a9 	.word	0x000014a9
    1638:	0000142d 	.word	0x0000142d
    163c:	00001405 	.word	0x00001405
    1640:	00001419 	.word	0x00001419

00001644 <usart_async_enable>:
{
    1644:	b510      	push	{r4, lr}
	ASSERT(descr);
    1646:	4604      	mov	r4, r0
    1648:	2261      	movs	r2, #97	; 0x61
    164a:	4906      	ldr	r1, [pc, #24]	; (1664 <usart_async_enable+0x20>)
    164c:	3000      	adds	r0, #0
    164e:	bf18      	it	ne
    1650:	2001      	movne	r0, #1
    1652:	4b05      	ldr	r3, [pc, #20]	; (1668 <usart_async_enable+0x24>)
    1654:	4798      	blx	r3
	_usart_async_enable(&descr->device);
    1656:	f104 0008 	add.w	r0, r4, #8
    165a:	4b04      	ldr	r3, [pc, #16]	; (166c <usart_async_enable+0x28>)
    165c:	4798      	blx	r3
}
    165e:	2000      	movs	r0, #0
    1660:	bd10      	pop	{r4, pc}
    1662:	bf00      	nop
    1664:	0000b27c 	.word	0x0000b27c
    1668:	0000187d 	.word	0x0000187d
    166c:	000024a5 	.word	0x000024a5

00001670 <usart_async_get_io_descriptor>:
{
    1670:	b538      	push	{r3, r4, r5, lr}
    1672:	460c      	mov	r4, r1
	ASSERT(descr && io);
    1674:	4605      	mov	r5, r0
    1676:	b148      	cbz	r0, 168c <usart_async_get_io_descriptor+0x1c>
    1678:	1c08      	adds	r0, r1, #0
    167a:	bf18      	it	ne
    167c:	2001      	movne	r0, #1
    167e:	2277      	movs	r2, #119	; 0x77
    1680:	4903      	ldr	r1, [pc, #12]	; (1690 <usart_async_get_io_descriptor+0x20>)
    1682:	4b04      	ldr	r3, [pc, #16]	; (1694 <usart_async_get_io_descriptor+0x24>)
    1684:	4798      	blx	r3
	*io = &descr->io;
    1686:	6025      	str	r5, [r4, #0]
}
    1688:	2000      	movs	r0, #0
    168a:	bd38      	pop	{r3, r4, r5, pc}
    168c:	2000      	movs	r0, #0
    168e:	e7f6      	b.n	167e <usart_async_get_io_descriptor+0xe>
    1690:	0000b27c 	.word	0x0000b27c
    1694:	0000187d 	.word	0x0000187d

00001698 <usart_async_register_callback>:
{
    1698:	b570      	push	{r4, r5, r6, lr}
    169a:	460c      	mov	r4, r1
    169c:	4616      	mov	r6, r2
	ASSERT(descr);
    169e:	4605      	mov	r5, r0
    16a0:	2283      	movs	r2, #131	; 0x83
    16a2:	4917      	ldr	r1, [pc, #92]	; (1700 <usart_async_register_callback+0x68>)
    16a4:	3000      	adds	r0, #0
    16a6:	bf18      	it	ne
    16a8:	2001      	movne	r0, #1
    16aa:	4b16      	ldr	r3, [pc, #88]	; (1704 <usart_async_register_callback+0x6c>)
    16ac:	4798      	blx	r3
	switch (type) {
    16ae:	2c01      	cmp	r4, #1
    16b0:	d010      	beq.n	16d4 <usart_async_register_callback+0x3c>
    16b2:	b124      	cbz	r4, 16be <usart_async_register_callback+0x26>
    16b4:	2c02      	cmp	r4, #2
    16b6:	d018      	beq.n	16ea <usart_async_register_callback+0x52>
		return ERR_INVALID_ARG;
    16b8:	f06f 000c 	mvn.w	r0, #12
}
    16bc:	bd70      	pop	{r4, r5, r6, pc}
		descr->usart_cb.rx_done = cb;
    16be:	62ae      	str	r6, [r5, #40]	; 0x28
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
    16c0:	1c32      	adds	r2, r6, #0
    16c2:	bf18      	it	ne
    16c4:	2201      	movne	r2, #1
    16c6:	2101      	movs	r1, #1
    16c8:	f105 0008 	add.w	r0, r5, #8
    16cc:	4b0e      	ldr	r3, [pc, #56]	; (1708 <usart_async_register_callback+0x70>)
    16ce:	4798      	blx	r3
	return ERR_NONE;
    16d0:	2000      	movs	r0, #0
		break;
    16d2:	bd70      	pop	{r4, r5, r6, pc}
		descr->usart_cb.tx_done = cb;
    16d4:	626e      	str	r6, [r5, #36]	; 0x24
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
    16d6:	1c32      	adds	r2, r6, #0
    16d8:	bf18      	it	ne
    16da:	2201      	movne	r2, #1
    16dc:	2102      	movs	r1, #2
    16de:	f105 0008 	add.w	r0, r5, #8
    16e2:	4b09      	ldr	r3, [pc, #36]	; (1708 <usart_async_register_callback+0x70>)
    16e4:	4798      	blx	r3
	return ERR_NONE;
    16e6:	2000      	movs	r0, #0
		break;
    16e8:	bd70      	pop	{r4, r5, r6, pc}
		descr->usart_cb.error = cb;
    16ea:	62ee      	str	r6, [r5, #44]	; 0x2c
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
    16ec:	1c32      	adds	r2, r6, #0
    16ee:	bf18      	it	ne
    16f0:	2201      	movne	r2, #1
    16f2:	2103      	movs	r1, #3
    16f4:	f105 0008 	add.w	r0, r5, #8
    16f8:	4b03      	ldr	r3, [pc, #12]	; (1708 <usart_async_register_callback+0x70>)
    16fa:	4798      	blx	r3
	return ERR_NONE;
    16fc:	2000      	movs	r0, #0
		break;
    16fe:	bd70      	pop	{r4, r5, r6, pc}
    1700:	0000b27c 	.word	0x0000b27c
    1704:	0000187d 	.word	0x0000187d
    1708:	000024fd 	.word	0x000024fd

0000170c <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    170c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1710:	460f      	mov	r7, r1
    1712:	4690      	mov	r8, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    1714:	4604      	mov	r4, r0
    1716:	b328      	cbz	r0, 1764 <usart_sync_write+0x58>
    1718:	b331      	cbz	r1, 1768 <usart_sync_write+0x5c>
    171a:	1c10      	adds	r0, r2, #0
    171c:	bf18      	it	ne
    171e:	2001      	movne	r0, #1
    1720:	22f1      	movs	r2, #241	; 0xf1
    1722:	4912      	ldr	r1, [pc, #72]	; (176c <usart_sync_write+0x60>)
    1724:	4b12      	ldr	r3, [pc, #72]	; (1770 <usart_sync_write+0x64>)
    1726:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    1728:	3408      	adds	r4, #8
    172a:	4d12      	ldr	r5, [pc, #72]	; (1774 <usart_sync_write+0x68>)
    172c:	4620      	mov	r0, r4
    172e:	47a8      	blx	r5
    1730:	2800      	cmp	r0, #0
    1732:	d0fb      	beq.n	172c <usart_sync_write+0x20>
    1734:	3f01      	subs	r7, #1
    1736:	2600      	movs	r6, #0
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    1738:	f8df 9040 	ldr.w	r9, [pc, #64]	; 177c <usart_sync_write+0x70>
		while (!_usart_sync_is_ready_to_send(&descr->device))
    173c:	4d0d      	ldr	r5, [pc, #52]	; (1774 <usart_sync_write+0x68>)
		_usart_sync_write_byte(&descr->device, buf[offset]);
    173e:	f817 1f01 	ldrb.w	r1, [r7, #1]!
    1742:	4620      	mov	r0, r4
    1744:	47c8      	blx	r9
		while (!_usart_sync_is_ready_to_send(&descr->device))
    1746:	4620      	mov	r0, r4
    1748:	47a8      	blx	r5
    174a:	2800      	cmp	r0, #0
    174c:	d0fb      	beq.n	1746 <usart_sync_write+0x3a>
			;
	} while (++offset < length);
    174e:	3601      	adds	r6, #1
    1750:	4546      	cmp	r6, r8
    1752:	d3f4      	bcc.n	173e <usart_sync_write+0x32>
	while (!_usart_sync_is_transmit_done(&descr->device))
    1754:	4d08      	ldr	r5, [pc, #32]	; (1778 <usart_sync_write+0x6c>)
    1756:	4620      	mov	r0, r4
    1758:	47a8      	blx	r5
    175a:	2800      	cmp	r0, #0
    175c:	d0fb      	beq.n	1756 <usart_sync_write+0x4a>
		;
	return (int32_t)offset;
}
    175e:	4630      	mov	r0, r6
    1760:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    1764:	2000      	movs	r0, #0
    1766:	e7db      	b.n	1720 <usart_sync_write+0x14>
    1768:	2000      	movs	r0, #0
    176a:	e7d9      	b.n	1720 <usart_sync_write+0x14>
    176c:	0000b29c 	.word	0x0000b29c
    1770:	0000187d 	.word	0x0000187d
    1774:	000024cd 	.word	0x000024cd
    1778:	000024d7 	.word	0x000024d7
    177c:	000024b9 	.word	0x000024b9

00001780 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    1780:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1784:	460f      	mov	r7, r1
    1786:	4690      	mov	r8, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    1788:	4604      	mov	r4, r0
    178a:	b1e0      	cbz	r0, 17c6 <usart_sync_read+0x46>
    178c:	b1e9      	cbz	r1, 17ca <usart_sync_read+0x4a>
    178e:	1c10      	adds	r0, r2, #0
    1790:	bf18      	it	ne
    1792:	2001      	movne	r0, #1
    1794:	f44f 7286 	mov.w	r2, #268	; 0x10c
    1798:	490d      	ldr	r1, [pc, #52]	; (17d0 <usart_sync_read+0x50>)
    179a:	4b0e      	ldr	r3, [pc, #56]	; (17d4 <usart_sync_read+0x54>)
    179c:	4798      	blx	r3
    179e:	3f01      	subs	r7, #1
	uint32_t                      offset = 0;
    17a0:	2600      	movs	r6, #0
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    17a2:	3408      	adds	r4, #8
    17a4:	4d0c      	ldr	r5, [pc, #48]	; (17d8 <usart_sync_read+0x58>)
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    17a6:	f8df 9034 	ldr.w	r9, [pc, #52]	; 17dc <usart_sync_read+0x5c>
		while (!_usart_sync_is_byte_received(&descr->device))
    17aa:	4620      	mov	r0, r4
    17ac:	47a8      	blx	r5
    17ae:	2800      	cmp	r0, #0
    17b0:	d0fb      	beq.n	17aa <usart_sync_read+0x2a>
		buf[offset] = _usart_sync_read_byte(&descr->device);
    17b2:	4620      	mov	r0, r4
    17b4:	47c8      	blx	r9
    17b6:	f807 0f01 	strb.w	r0, [r7, #1]!
	} while (++offset < length);
    17ba:	3601      	adds	r6, #1
    17bc:	4546      	cmp	r6, r8
    17be:	d3f4      	bcc.n	17aa <usart_sync_read+0x2a>

	return (int32_t)offset;
}
    17c0:	4630      	mov	r0, r6
    17c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    17c6:	2000      	movs	r0, #0
    17c8:	e7e4      	b.n	1794 <usart_sync_read+0x14>
    17ca:	2000      	movs	r0, #0
    17cc:	e7e2      	b.n	1794 <usart_sync_read+0x14>
    17ce:	bf00      	nop
    17d0:	0000b29c 	.word	0x0000b29c
    17d4:	0000187d 	.word	0x0000187d
    17d8:	000024e1 	.word	0x000024e1
    17dc:	000024c5 	.word	0x000024c5

000017e0 <usart_sync_init>:
{
    17e0:	b538      	push	{r3, r4, r5, lr}
    17e2:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    17e4:	4604      	mov	r4, r0
    17e6:	b198      	cbz	r0, 1810 <usart_sync_init+0x30>
    17e8:	1c08      	adds	r0, r1, #0
    17ea:	bf18      	it	ne
    17ec:	2001      	movne	r0, #1
    17ee:	2234      	movs	r2, #52	; 0x34
    17f0:	4908      	ldr	r1, [pc, #32]	; (1814 <usart_sync_init+0x34>)
    17f2:	4b09      	ldr	r3, [pc, #36]	; (1818 <usart_sync_init+0x38>)
    17f4:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    17f6:	4629      	mov	r1, r5
    17f8:	f104 0008 	add.w	r0, r4, #8
    17fc:	4b07      	ldr	r3, [pc, #28]	; (181c <usart_sync_init+0x3c>)
    17fe:	4798      	blx	r3
	if (init_status) {
    1800:	4603      	mov	r3, r0
    1802:	b918      	cbnz	r0, 180c <usart_sync_init+0x2c>
	descr->io.read  = usart_sync_read;
    1804:	4a06      	ldr	r2, [pc, #24]	; (1820 <usart_sync_init+0x40>)
    1806:	6062      	str	r2, [r4, #4]
	descr->io.write = usart_sync_write;
    1808:	4a06      	ldr	r2, [pc, #24]	; (1824 <usart_sync_init+0x44>)
    180a:	6022      	str	r2, [r4, #0]
}
    180c:	4618      	mov	r0, r3
    180e:	bd38      	pop	{r3, r4, r5, pc}
    1810:	2000      	movs	r0, #0
    1812:	e7ec      	b.n	17ee <usart_sync_init+0xe>
    1814:	0000b29c 	.word	0x0000b29c
    1818:	0000187d 	.word	0x0000187d
    181c:	000023e1 	.word	0x000023e1
    1820:	00001781 	.word	0x00001781
    1824:	0000170d 	.word	0x0000170d

00001828 <usart_sync_enable>:
{
    1828:	b510      	push	{r4, lr}
	ASSERT(descr);
    182a:	4604      	mov	r4, r0
    182c:	2253      	movs	r2, #83	; 0x53
    182e:	4906      	ldr	r1, [pc, #24]	; (1848 <usart_sync_enable+0x20>)
    1830:	3000      	adds	r0, #0
    1832:	bf18      	it	ne
    1834:	2001      	movne	r0, #1
    1836:	4b05      	ldr	r3, [pc, #20]	; (184c <usart_sync_enable+0x24>)
    1838:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
    183a:	f104 0008 	add.w	r0, r4, #8
    183e:	4b04      	ldr	r3, [pc, #16]	; (1850 <usart_sync_enable+0x28>)
    1840:	4798      	blx	r3
}
    1842:	2000      	movs	r0, #0
    1844:	bd10      	pop	{r4, pc}
    1846:	bf00      	nop
    1848:	0000b29c 	.word	0x0000b29c
    184c:	0000187d 	.word	0x0000187d
    1850:	00002491 	.word	0x00002491

00001854 <usart_sync_get_io_descriptor>:
{
    1854:	b538      	push	{r3, r4, r5, lr}
    1856:	460c      	mov	r4, r1
	ASSERT(descr && io);
    1858:	4605      	mov	r5, r0
    185a:	b148      	cbz	r0, 1870 <usart_sync_get_io_descriptor+0x1c>
    185c:	1c08      	adds	r0, r1, #0
    185e:	bf18      	it	ne
    1860:	2001      	movne	r0, #1
    1862:	2269      	movs	r2, #105	; 0x69
    1864:	4903      	ldr	r1, [pc, #12]	; (1874 <usart_sync_get_io_descriptor+0x20>)
    1866:	4b04      	ldr	r3, [pc, #16]	; (1878 <usart_sync_get_io_descriptor+0x24>)
    1868:	4798      	blx	r3
	*io = &descr->io;
    186a:	6025      	str	r5, [r4, #0]
}
    186c:	2000      	movs	r0, #0
    186e:	bd38      	pop	{r3, r4, r5, pc}
    1870:	2000      	movs	r0, #0
    1872:	e7f6      	b.n	1862 <usart_sync_get_io_descriptor+0xe>
    1874:	0000b29c 	.word	0x0000b29c
    1878:	0000187d 	.word	0x0000187d

0000187c <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    187c:	b900      	cbnz	r0, 1880 <assert+0x4>
		__asm("BKPT #0");
    187e:	be00      	bkpt	0x0000
    1880:	4770      	bx	lr

00001882 <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
    1882:	6803      	ldr	r3, [r0, #0]
    1884:	b14b      	cbz	r3, 189a <is_list_element+0x18>
		if (it == element) {
    1886:	428b      	cmp	r3, r1
    1888:	d009      	beq.n	189e <is_list_element+0x1c>
	for (it = list->head; it; it = it->next) {
    188a:	681b      	ldr	r3, [r3, #0]
    188c:	b11b      	cbz	r3, 1896 <is_list_element+0x14>
		if (it == element) {
    188e:	4299      	cmp	r1, r3
    1890:	d1fb      	bne.n	188a <is_list_element+0x8>
			return true;
    1892:	2001      	movs	r0, #1
		}
	}

	return false;
}
    1894:	4770      	bx	lr
	return false;
    1896:	2000      	movs	r0, #0
    1898:	4770      	bx	lr
    189a:	2000      	movs	r0, #0
    189c:	4770      	bx	lr
			return true;
    189e:	2001      	movs	r0, #1
    18a0:	4770      	bx	lr
	...

000018a4 <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
    18a4:	b538      	push	{r3, r4, r5, lr}
    18a6:	4604      	mov	r4, r0
    18a8:	460d      	mov	r5, r1
	ASSERT(!is_list_element(list, element));
    18aa:	4b06      	ldr	r3, [pc, #24]	; (18c4 <list_insert_as_head+0x20>)
    18ac:	4798      	blx	r3
    18ae:	f080 0001 	eor.w	r0, r0, #1
    18b2:	2239      	movs	r2, #57	; 0x39
    18b4:	4904      	ldr	r1, [pc, #16]	; (18c8 <list_insert_as_head+0x24>)
    18b6:	b2c0      	uxtb	r0, r0
    18b8:	4b04      	ldr	r3, [pc, #16]	; (18cc <list_insert_as_head+0x28>)
    18ba:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
    18bc:	6823      	ldr	r3, [r4, #0]
    18be:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
    18c0:	6025      	str	r5, [r4, #0]
    18c2:	bd38      	pop	{r3, r4, r5, pc}
    18c4:	00001883 	.word	0x00001883
    18c8:	0000b2b8 	.word	0x0000b2b8
    18cc:	0000187d 	.word	0x0000187d

000018d0 <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
    18d0:	6803      	ldr	r3, [r0, #0]
    18d2:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
    18d4:	6001      	str	r1, [r0, #0]
    18d6:	4770      	bx	lr

000018d8 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
    18d8:	6803      	ldr	r3, [r0, #0]
    18da:	b10b      	cbz	r3, 18e0 <list_remove_head+0x8>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
    18dc:	681a      	ldr	r2, [r3, #0]
    18de:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
	}

	return NULL;
}
    18e0:	4618      	mov	r0, r3
    18e2:	4770      	bx	lr

000018e4 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
    18e4:	b570      	push	{r4, r5, r6, lr}
    18e6:	460e      	mov	r6, r1
    18e8:	4615      	mov	r5, r2
	ASSERT(rb && buf && size);
    18ea:	4604      	mov	r4, r0
    18ec:	b178      	cbz	r0, 190e <ringbuffer_init+0x2a>
    18ee:	b181      	cbz	r1, 1912 <ringbuffer_init+0x2e>
    18f0:	b1a2      	cbz	r2, 191c <ringbuffer_init+0x38>
    18f2:	2001      	movs	r0, #1
    18f4:	2228      	movs	r2, #40	; 0x28
    18f6:	490d      	ldr	r1, [pc, #52]	; (192c <ringbuffer_init+0x48>)
    18f8:	4b0d      	ldr	r3, [pc, #52]	; (1930 <ringbuffer_init+0x4c>)
    18fa:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
    18fc:	1e6b      	subs	r3, r5, #1
    18fe:	421d      	tst	r5, r3
    1900:	d109      	bne.n	1916 <ringbuffer_init+0x32>
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
    1902:	6063      	str	r3, [r4, #4]
	rb->read_index  = 0;
    1904:	2000      	movs	r0, #0
    1906:	60a0      	str	r0, [r4, #8]
	rb->write_index = rb->read_index;
    1908:	60e0      	str	r0, [r4, #12]
	rb->buf         = (uint8_t *)buf;
    190a:	6026      	str	r6, [r4, #0]

	return ERR_NONE;
    190c:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
    190e:	2000      	movs	r0, #0
    1910:	e7f0      	b.n	18f4 <ringbuffer_init+0x10>
    1912:	2000      	movs	r0, #0
    1914:	e7ee      	b.n	18f4 <ringbuffer_init+0x10>
		return ERR_INVALID_ARG;
    1916:	f06f 000c 	mvn.w	r0, #12
    191a:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
    191c:	2228      	movs	r2, #40	; 0x28
    191e:	4903      	ldr	r1, [pc, #12]	; (192c <ringbuffer_init+0x48>)
    1920:	2000      	movs	r0, #0
    1922:	4b03      	ldr	r3, [pc, #12]	; (1930 <ringbuffer_init+0x4c>)
    1924:	4798      	blx	r3
	if ((size & (size - 1)) != 0) {
    1926:	1e6b      	subs	r3, r5, #1
    1928:	e7eb      	b.n	1902 <ringbuffer_init+0x1e>
    192a:	bf00      	nop
    192c:	0000b2d8 	.word	0x0000b2d8
    1930:	0000187d 	.word	0x0000187d

00001934 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
    1934:	b538      	push	{r3, r4, r5, lr}
    1936:	460d      	mov	r5, r1
	ASSERT(rb && data);
    1938:	4604      	mov	r4, r0
    193a:	b1a0      	cbz	r0, 1966 <ringbuffer_get+0x32>
    193c:	1c08      	adds	r0, r1, #0
    193e:	bf18      	it	ne
    1940:	2001      	movne	r0, #1
    1942:	2240      	movs	r2, #64	; 0x40
    1944:	490a      	ldr	r1, [pc, #40]	; (1970 <ringbuffer_get+0x3c>)
    1946:	4b0b      	ldr	r3, [pc, #44]	; (1974 <ringbuffer_get+0x40>)
    1948:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
    194a:	68a3      	ldr	r3, [r4, #8]
    194c:	68e2      	ldr	r2, [r4, #12]
    194e:	429a      	cmp	r2, r3
    1950:	d00b      	beq.n	196a <ringbuffer_get+0x36>
		*data = rb->buf[rb->read_index & rb->size];
    1952:	6862      	ldr	r2, [r4, #4]
    1954:	4013      	ands	r3, r2
    1956:	6822      	ldr	r2, [r4, #0]
    1958:	5cd3      	ldrb	r3, [r2, r3]
    195a:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
    195c:	68a3      	ldr	r3, [r4, #8]
    195e:	3301      	adds	r3, #1
    1960:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
    1962:	2000      	movs	r0, #0
    1964:	bd38      	pop	{r3, r4, r5, pc}
    1966:	2000      	movs	r0, #0
    1968:	e7eb      	b.n	1942 <ringbuffer_get+0xe>
	}

	return ERR_NOT_FOUND;
    196a:	f06f 0009 	mvn.w	r0, #9
}
    196e:	bd38      	pop	{r3, r4, r5, pc}
    1970:	0000b2d8 	.word	0x0000b2d8
    1974:	0000187d 	.word	0x0000187d

00001978 <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
    1978:	b538      	push	{r3, r4, r5, lr}
    197a:	460d      	mov	r5, r1
	ASSERT(rb);
    197c:	4604      	mov	r4, r0
    197e:	2251      	movs	r2, #81	; 0x51
    1980:	490b      	ldr	r1, [pc, #44]	; (19b0 <ringbuffer_put+0x38>)
    1982:	3000      	adds	r0, #0
    1984:	bf18      	it	ne
    1986:	2001      	movne	r0, #1
    1988:	4b0a      	ldr	r3, [pc, #40]	; (19b4 <ringbuffer_put+0x3c>)
    198a:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
    198c:	68e3      	ldr	r3, [r4, #12]
    198e:	6862      	ldr	r2, [r4, #4]
    1990:	4013      	ands	r3, r2
    1992:	6822      	ldr	r2, [r4, #0]
    1994:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
    1996:	68e3      	ldr	r3, [r4, #12]
    1998:	6861      	ldr	r1, [r4, #4]
    199a:	68a2      	ldr	r2, [r4, #8]
    199c:	1a9a      	subs	r2, r3, r2
    199e:	428a      	cmp	r2, r1
		rb->read_index = rb->write_index - rb->size;
    19a0:	bf84      	itt	hi
    19a2:	1a59      	subhi	r1, r3, r1
    19a4:	60a1      	strhi	r1, [r4, #8]
	}

	rb->write_index++;
    19a6:	3301      	adds	r3, #1
    19a8:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
    19aa:	2000      	movs	r0, #0
    19ac:	bd38      	pop	{r3, r4, r5, pc}
    19ae:	bf00      	nop
    19b0:	0000b2d8 	.word	0x0000b2d8
    19b4:	0000187d 	.word	0x0000187d

000019b8 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
    19b8:	b510      	push	{r4, lr}
	ASSERT(rb);
    19ba:	4604      	mov	r4, r0
    19bc:	2267      	movs	r2, #103	; 0x67
    19be:	4905      	ldr	r1, [pc, #20]	; (19d4 <ringbuffer_num+0x1c>)
    19c0:	3000      	adds	r0, #0
    19c2:	bf18      	it	ne
    19c4:	2001      	movne	r0, #1
    19c6:	4b04      	ldr	r3, [pc, #16]	; (19d8 <ringbuffer_num+0x20>)
    19c8:	4798      	blx	r3

	return rb->write_index - rb->read_index;
    19ca:	68e0      	ldr	r0, [r4, #12]
    19cc:	68a3      	ldr	r3, [r4, #8]
}
    19ce:	1ac0      	subs	r0, r0, r3
    19d0:	bd10      	pop	{r4, pc}
    19d2:	bf00      	nop
    19d4:	0000b2d8 	.word	0x0000b2d8
    19d8:	0000187d 	.word	0x0000187d

000019dc <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
    19dc:	4603      	mov	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    19de:	4a06      	ldr	r2, [pc, #24]	; (19f8 <_sbrk+0x1c>)
    19e0:	6812      	ldr	r2, [r2, #0]
    19e2:	b122      	cbz	r2, 19ee <_sbrk+0x12>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
    19e4:	4a04      	ldr	r2, [pc, #16]	; (19f8 <_sbrk+0x1c>)
    19e6:	6810      	ldr	r0, [r2, #0]

	heap += incr;
    19e8:	4403      	add	r3, r0
    19ea:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
    19ec:	4770      	bx	lr
		heap = (unsigned char *)&_end;
    19ee:	4903      	ldr	r1, [pc, #12]	; (19fc <_sbrk+0x20>)
    19f0:	4a01      	ldr	r2, [pc, #4]	; (19f8 <_sbrk+0x1c>)
    19f2:	6011      	str	r1, [r2, #0]
    19f4:	e7f6      	b.n	19e4 <_sbrk+0x8>
    19f6:	bf00      	nop
    19f8:	200001a0 	.word	0x200001a0
    19fc:	200195f8 	.word	0x200195f8

00001a00 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
    1a00:	f04f 30ff 	mov.w	r0, #4294967295
    1a04:	4770      	bx	lr

00001a06 <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
    1a06:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    1a0a:	604b      	str	r3, [r1, #4]

	return 0;
}
    1a0c:	2000      	movs	r0, #0
    1a0e:	4770      	bx	lr

00001a10 <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
    1a10:	2001      	movs	r0, #1
    1a12:	4770      	bx	lr

00001a14 <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
    1a14:	2000      	movs	r0, #0
    1a16:	4770      	bx	lr

00001a18 <_irq_set>:
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1a18:	0943      	lsrs	r3, r0, #5
    1a1a:	f000 001f 	and.w	r0, r0, #31
    1a1e:	2201      	movs	r2, #1
    1a20:	fa02 f000 	lsl.w	r0, r2, r0
    1a24:	3340      	adds	r3, #64	; 0x40
    1a26:	4a02      	ldr	r2, [pc, #8]	; (1a30 <_irq_set+0x18>)
    1a28:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    1a2c:	4770      	bx	lr
    1a2e:	bf00      	nop
    1a30:	e000e100 	.word	0xe000e100

00001a34 <_get_cycles_for_ms>:
 */
static inline uint32_t _get_cycles_for_ms_internal(const uint16_t ms, const uint32_t freq, const uint8_t power)
{
	switch (power) {
	case 9:
		return (ms * (freq / 1000000) + 2) / 3 * 1000;
    1a34:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
    1a38:	00c3      	lsls	r3, r0, #3
    1a3a:	3302      	adds	r3, #2
    1a3c:	4804      	ldr	r0, [pc, #16]	; (1a50 <_get_cycles_for_ms+0x1c>)
    1a3e:	fba0 2303 	umull	r2, r3, r0, r3
    1a42:	085b      	lsrs	r3, r3, #1
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
    1a44:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    1a48:	fb00 f003 	mul.w	r0, r0, r3
    1a4c:	4770      	bx	lr
    1a4e:	bf00      	nop
    1a50:	aaaaaaab 	.word	0xaaaaaaab
    1a54:	00000000 	.word	0x00000000

00001a58 <_delay_cycles>:
	__asm(".align 3 \n"
	      "__delay:\n"
	      "subs r1, r1, #1\n"
	      "bhi __delay\n");
#elif defined __GNUC__
	__asm(".syntax unified\n"
    1a58:	3901      	subs	r1, #1
    1a5a:	d8fd      	bhi.n	1a58 <_delay_cycles>
    1a5c:	4770      	bx	lr
    1a5e:	bf00      	nop

00001a60 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    1a60:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    1a62:	4a09      	ldr	r2, [pc, #36]	; (1a88 <_init_chip+0x28>)
    1a64:	8813      	ldrh	r3, [r2, #0]
    1a66:	b29b      	uxth	r3, r3
    1a68:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    1a6a:	4b08      	ldr	r3, [pc, #32]	; (1a8c <_init_chip+0x2c>)
    1a6c:	4798      	blx	r3
	_oscctrl_init_sources();
    1a6e:	4b08      	ldr	r3, [pc, #32]	; (1a90 <_init_chip+0x30>)
    1a70:	4798      	blx	r3
	_mclk_init();
    1a72:	4b08      	ldr	r3, [pc, #32]	; (1a94 <_init_chip+0x34>)
    1a74:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    1a76:	2002      	movs	r0, #2
    1a78:	4c07      	ldr	r4, [pc, #28]	; (1a98 <_init_chip+0x38>)
    1a7a:	47a0      	blx	r4
#endif
	_oscctrl_init_referenced_generators();
    1a7c:	4b07      	ldr	r3, [pc, #28]	; (1a9c <_init_chip+0x3c>)
    1a7e:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    1a80:	f640 70fd 	movw	r0, #4093	; 0xffd
    1a84:	47a0      	blx	r4
    1a86:	bd10      	pop	{r4, pc}
    1a88:	41004000 	.word	0x41004000
    1a8c:	00002029 	.word	0x00002029
    1a90:	0000203d 	.word	0x0000203d
    1a94:	0000201d 	.word	0x0000201d
    1a98:	00001aa1 	.word	0x00001aa1
    1a9c:	0000206d 	.word	0x0000206d

00001aa0 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    1aa0:	f010 0f01 	tst.w	r0, #1
    1aa4:	d008      	beq.n	1ab8 <_gclk_init_generators_by_fref+0x18>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1aa6:	4a17      	ldr	r2, [pc, #92]	; (1b04 <_gclk_init_generators_by_fref+0x64>)
    1aa8:	4b17      	ldr	r3, [pc, #92]	; (1b08 <_gclk_init_generators_by_fref+0x68>)
    1aaa:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1aac:	4619      	mov	r1, r3
    1aae:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    1ab2:	684b      	ldr	r3, [r1, #4]
    1ab4:	4213      	tst	r3, r2
    1ab6:	d1fc      	bne.n	1ab2 <_gclk_init_generators_by_fref+0x12>
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
    1ab8:	f010 0f02 	tst.w	r0, #2
    1abc:	d008      	beq.n	1ad0 <_gclk_init_generators_by_fref+0x30>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1abe:	4a13      	ldr	r2, [pc, #76]	; (1b0c <_gclk_init_generators_by_fref+0x6c>)
    1ac0:	4b11      	ldr	r3, [pc, #68]	; (1b08 <_gclk_init_generators_by_fref+0x68>)
    1ac2:	625a      	str	r2, [r3, #36]	; 0x24
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1ac4:	4619      	mov	r1, r3
    1ac6:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    1aca:	684b      	ldr	r3, [r1, #4]
    1acc:	4213      	tst	r3, r2
    1ace:	d1fc      	bne.n	1aca <_gclk_init_generators_by_fref+0x2a>
		        | (CONF_GCLK_GENERATOR_1_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_1_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_2_CONFIG == 1
	if (bm & (1ul << 2)) {
    1ad0:	f010 0f04 	tst.w	r0, #4
    1ad4:	d008      	beq.n	1ae8 <_gclk_init_generators_by_fref+0x48>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1ad6:	4a0e      	ldr	r2, [pc, #56]	; (1b10 <_gclk_init_generators_by_fref+0x70>)
    1ad8:	4b0b      	ldr	r3, [pc, #44]	; (1b08 <_gclk_init_generators_by_fref+0x68>)
    1ada:	629a      	str	r2, [r3, #40]	; 0x28
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1adc:	4619      	mov	r1, r3
    1ade:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    1ae2:	684b      	ldr	r3, [r1, #4]
    1ae4:	4213      	tst	r3, r2
    1ae6:	d1fc      	bne.n	1ae2 <_gclk_init_generators_by_fref+0x42>
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    1ae8:	f010 0f08 	tst.w	r0, #8
    1aec:	d008      	beq.n	1b00 <_gclk_init_generators_by_fref+0x60>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1aee:	4a09      	ldr	r2, [pc, #36]	; (1b14 <_gclk_init_generators_by_fref+0x74>)
    1af0:	4b05      	ldr	r3, [pc, #20]	; (1b08 <_gclk_init_generators_by_fref+0x68>)
    1af2:	62da      	str	r2, [r3, #44]	; 0x2c
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1af4:	4619      	mov	r1, r3
    1af6:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    1afa:	684b      	ldr	r3, [r1, #4]
    1afc:	4213      	tst	r3, r2
    1afe:	d1fc      	bne.n	1afa <_gclk_init_generators_by_fref+0x5a>
    1b00:	4770      	bx	lr
    1b02:	bf00      	nop
    1b04:	00010907 	.word	0x00010907
    1b08:	40001c00 	.word	0x40001c00
    1b0c:	00060900 	.word	0x00060900
    1b10:	00060901 	.word	0x00060901
    1b14:	00010904 	.word	0x00010904

00001b18 <GMAC_Handler>:

/*
 * \internal GMAC interrupt handler
 */
void GMAC_Handler(void)
{
    1b18:	b500      	push	{lr}
    1b1a:	b083      	sub	sp, #12
	volatile uint32_t tsr;
	volatile uint32_t rsr;

	tsr = hri_gmac_read_TSR_reg(_gmac_dev->hw);
    1b1c:	4b14      	ldr	r3, [pc, #80]	; (1b70 <GMAC_Handler+0x58>)
    1b1e:	6818      	ldr	r0, [r3, #0]
    1b20:	6803      	ldr	r3, [r0, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_tsr_reg_t hri_gmac_read_TSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->TSR.reg;
    1b22:	695a      	ldr	r2, [r3, #20]
    1b24:	9201      	str	r2, [sp, #4]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_rsr_reg_t hri_gmac_read_RSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->RSR.reg;
    1b26:	6a1a      	ldr	r2, [r3, #32]
	rsr = hri_gmac_read_RSR_reg(_gmac_dev->hw);
    1b28:	9200      	str	r2, [sp, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_isr_reg_t hri_gmac_read_ISR_reg(const void *const hw)
{
	return ((Gmac *)hw)->ISR.reg;
    1b2a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	/* Must be Clear ISR (Clear on read) */
	hri_gmac_read_ISR_reg(_gmac_dev->hw);

	/* Frame transmited */
	if (tsr & GMAC_TSR_TXCOMP) {
    1b2c:	9a01      	ldr	r2, [sp, #4]
    1b2e:	f012 0f20 	tst.w	r2, #32
    1b32:	d00b      	beq.n	1b4c <GMAC_Handler+0x34>
		hri_gmac_write_TSR_reg(_gmac_dev->hw, tsr);
    1b34:	9a01      	ldr	r2, [sp, #4]
	((Gmac *)hw)->TSR.reg = data;
    1b36:	615a      	str	r2, [r3, #20]
		if ((_txbuf_descrs[_txbuf_index].status.bm.used) && (_gmac_dev->cb.transmited != NULL)) {
    1b38:	4b0d      	ldr	r3, [pc, #52]	; (1b70 <GMAC_Handler+0x58>)
    1b3a:	685a      	ldr	r2, [r3, #4]
    1b3c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1b40:	7bdb      	ldrb	r3, [r3, #15]
    1b42:	09db      	lsrs	r3, r3, #7
    1b44:	d002      	beq.n	1b4c <GMAC_Handler+0x34>
    1b46:	6843      	ldr	r3, [r0, #4]
    1b48:	b103      	cbz	r3, 1b4c <GMAC_Handler+0x34>
			_gmac_dev->cb.transmited(_gmac_dev);
    1b4a:	4798      	blx	r3
		}
	}

	/* Frame received */
	if (rsr & GMAC_RSR_REC) {
    1b4c:	9b00      	ldr	r3, [sp, #0]
    1b4e:	f013 0f02 	tst.w	r3, #2
    1b52:	d004      	beq.n	1b5e <GMAC_Handler+0x46>
		if (_gmac_dev->cb.received != NULL) {
    1b54:	4b06      	ldr	r3, [pc, #24]	; (1b70 <GMAC_Handler+0x58>)
    1b56:	6818      	ldr	r0, [r3, #0]
    1b58:	6883      	ldr	r3, [r0, #8]
    1b5a:	b103      	cbz	r3, 1b5e <GMAC_Handler+0x46>
			_gmac_dev->cb.received(_gmac_dev);
    1b5c:	4798      	blx	r3
		}
	}
	hri_gmac_write_RSR_reg(_gmac_dev->hw, rsr);
    1b5e:	4b04      	ldr	r3, [pc, #16]	; (1b70 <GMAC_Handler+0x58>)
    1b60:	681b      	ldr	r3, [r3, #0]
    1b62:	681b      	ldr	r3, [r3, #0]
    1b64:	9a00      	ldr	r2, [sp, #0]
	((Gmac *)hw)->RSR.reg = data;
    1b66:	621a      	str	r2, [r3, #32]
}
    1b68:	b003      	add	sp, #12
    1b6a:	f85d fb04 	ldr.w	pc, [sp], #4
    1b6e:	bf00      	nop
    1b70:	200001c0 	.word	0x200001c0

00001b74 <_mac_async_init>:

int32_t _mac_async_init(struct _mac_async_device *const dev, void *const hw)
{
    1b74:	b430      	push	{r4, r5}
	dev->hw = hw;
    1b76:	6001      	str	r1, [r0, #0]
	((Gmac *)hw)->NCR.reg = data;
    1b78:	4b29      	ldr	r3, [pc, #164]	; (1c20 <_mac_async_init+0xac>)
    1b7a:	600b      	str	r3, [r1, #0]
	                       (CONF_GMAC_NCR_LBL ? GMAC_NCR_LBL : 0) | (CONF_GMAC_NCR_MPE ? GMAC_NCR_MPE : 0)
	                           | (CONF_GMAC_NCR_WESTAT ? GMAC_NCR_WESTAT : 0) | (CONF_GMAC_NCR_BP ? GMAC_NCR_BP : 0)
	                           | (CONF_GMAC_NCR_ENPBPR ? GMAC_NCR_ENPBPR : 0)
	                           | (CONF_GMAC_NCR_TXPBPF ? GMAC_NCR_TXPBPF : 0));
	hri_gmac_write_NCFGR_reg(
	    dev->hw,
    1b7c:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->NCFGR.reg = data;
    1b7e:	4a29      	ldr	r2, [pc, #164]	; (1c24 <_mac_async_init+0xb0>)
    1b80:	605a      	str	r2, [r3, #4]
	        | (CONF_GMAC_NCFGR_LFERD ? GMAC_NCFGR_LFERD : 0) | (CONF_GMAC_NCFGR_RFCS ? GMAC_NCFGR_RFCS : 0)
	        | GMAC_NCFGR_CLK(CONF_GMAC_NCFGR_CLK) | (CONF_GMAC_NCFGR_DCPF ? GMAC_NCFGR_DCPF : 0)
	        | (CONF_GMAC_NCFGR_RXCOEN ? GMAC_NCFGR_RXCOEN : 0) | (CONF_GMAC_NCFGR_EFRHD ? GMAC_NCFGR_EFRHD : 0)
	        | (CONF_GMAC_NCFGR_IRXFCS ? GMAC_NCFGR_IRXFCS : 0) | (CONF_GMAC_NCFGR_IPGSEN ? GMAC_NCFGR_IPGSEN : 0)
	        | (CONF_GMAC_NCFGR_RXBP ? GMAC_NCFGR_RXBP : 0) | (CONF_GMAC_NCFGR_IRXER ? GMAC_NCFGR_IRXER : 0));
	hri_gmac_write_UR_reg(dev->hw, (CONF_GMAC_UR_MII ? GMAC_UR_MII : 0));
    1b82:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->UR.reg = data;
    1b84:	2300      	movs	r3, #0
    1b86:	60d3      	str	r3, [r2, #12]
	hri_gmac_write_DCFGR_reg(
	    dev->hw,
    1b88:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->DCFGR.reg = data;
    1b8a:	4927      	ldr	r1, [pc, #156]	; (1c28 <_mac_async_init+0xb4>)
    1b8c:	6111      	str	r1, [r2, #16]
	    GMAC_DCFGR_FBLDO(CONF_GMAC_DCFGR_FBLDO) | (CONF_GMAC_DCFGR_ESMA ? GMAC_DCFGR_ESMA : 0)
	        | (CONF_GMAC_DCFGR_ESPA ? GMAC_DCFGR_ESPA : 0) | GMAC_DCFGR_RXBMS(CONF_GMAC_DCFGR_RXBMS)
	        | (CONF_GMAC_DCFGR_TXPBMS ? GMAC_DCFGR_TXPBMS : 0) | (CONF_GMAC_DCFGR_TXCOEN ? GMAC_DCFGR_TXCOEN : 0)
	        | GMAC_DCFGR_DRBS(CONF_GMAC_DCFGR_DRBS) | (CONF_GMAC_DCFGR_DDRP ? GMAC_DCFGR_DDRP : 0));
	hri_gmac_write_WOL_reg(dev->hw, 0);
    1b8e:	6802      	ldr	r2, [r0, #0]
}

static inline void hri_gmac_write_WOL_reg(const void *const hw, hri_gmac_wol_reg_t data)
{
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->WOL.reg = data;
    1b90:	f8c2 30b8 	str.w	r3, [r2, #184]	; 0xb8
	hri_gmac_write_IPGS_reg(dev->hw, GMAC_IPGS_FL((CONF_GMAC_IPGS_FL_MUL << 8) | CONF_GMAC_IPGS_FL_DIV));
    1b94:	6802      	ldr	r2, [r0, #0]
}

static inline void hri_gmac_write_IPGS_reg(const void *const hw, hri_gmac_ipgs_reg_t data)
{
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->IPGS.reg = data;
    1b96:	f240 1101 	movw	r1, #257	; 0x101
    1b9a:	f8c2 10bc 	str.w	r1, [r2, #188]	; 0xbc
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    1b9e:	4923      	ldr	r1, [pc, #140]	; (1c2c <_mac_async_init+0xb8>)
    1ba0:	f101 0220 	add.w	r2, r1, #32
    1ba4:	608a      	str	r2, [r1, #8]
		_txbuf_descrs[i].status.val     = 0;
    1ba6:	60cb      	str	r3, [r1, #12]
		_txbuf_descrs[i].status.bm.used = 1;
    1ba8:	2280      	movs	r2, #128	; 0x80
    1baa:	73ca      	strb	r2, [r1, #15]
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    1bac:	f201 52fc 	addw	r2, r1, #1532	; 0x5fc
    1bb0:	610a      	str	r2, [r1, #16]
		_txbuf_descrs[i].status.val     = 0;
    1bb2:	614b      	str	r3, [r1, #20]
	_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    1bb4:	22c0      	movs	r2, #192	; 0xc0
    1bb6:	75ca      	strb	r2, [r1, #23]
	_txbuf_index                                            = 0;
    1bb8:	604b      	str	r3, [r1, #4]
	_last_txbuf_index                                       = 0;
    1bba:	f8c1 3bd8 	str.w	r3, [r1, #3032]	; 0xbd8
    1bbe:	f501 633e 	add.w	r3, r1, #3040	; 0xbe0
    1bc2:	4a1b      	ldr	r2, [pc, #108]	; (1c30 <_mac_async_init+0xbc>)
    1bc4:	f501 519f 	add.w	r1, r1, #5088	; 0x13e0
		_rxbuf_descrs[i].status.val  = 0;
    1bc8:	2400      	movs	r4, #0
		_rxbuf_descrs[i].address.val = (uint32_t)_rxbuf[i];
    1bca:	f842 3c04 	str.w	r3, [r2, #-4]
		_rxbuf_descrs[i].status.val  = 0;
    1bce:	f842 4b08 	str.w	r4, [r2], #8
    1bd2:	3380      	adds	r3, #128	; 0x80
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1bd4:	428b      	cmp	r3, r1
    1bd6:	d1f8      	bne.n	1bca <_mac_async_init+0x56>
	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    1bd8:	4b16      	ldr	r3, [pc, #88]	; (1c34 <_mac_async_init+0xc0>)
    1bda:	f893 2360 	ldrb.w	r2, [r3, #864]	; 0x360
    1bde:	f042 0202 	orr.w	r2, r2, #2
    1be2:	f883 2360 	strb.w	r2, [r3, #864]	; 0x360
	_rxbuf_index                                             = 0;
    1be6:	2100      	movs	r1, #0
    1be8:	f8c3 1368 	str.w	r1, [r3, #872]	; 0x368
	hri_gmac_write_TBQB_reg(dev->hw, (uint32_t)_txbuf_descrs);
    1bec:	6804      	ldr	r4, [r0, #0]
    1bee:	4a0f      	ldr	r2, [pc, #60]	; (1c2c <_mac_async_init+0xb8>)
    1bf0:	f102 0508 	add.w	r5, r2, #8
	((Gmac *)hw)->TBQB.reg = data;
    1bf4:	61e5      	str	r5, [r4, #28]
	hri_gmac_write_RBQB_reg(dev->hw, (uint32_t)_rxbuf_descrs);
    1bf6:	6804      	ldr	r4, [r0, #0]
    1bf8:	f503 733a 	add.w	r3, r3, #744	; 0x2e8
	((Gmac *)hw)->RBQB.reg = data;
    1bfc:	61a3      	str	r3, [r4, #24]
	_mac_init_bufdescr(dev);

	_gmac_dev = dev;
    1bfe:	6010      	str	r0, [r2, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1c00:	4b0d      	ldr	r3, [pc, #52]	; (1c38 <_mac_async_init+0xc4>)
    1c02:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    1c06:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
    1c0a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1c0e:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1c12:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1c16:	609a      	str	r2, [r3, #8]
	NVIC_DisableIRQ(GMAC_IRQn);
	NVIC_ClearPendingIRQ(GMAC_IRQn);
	NVIC_EnableIRQ(GMAC_IRQn);

	return ERR_NONE;
}
    1c18:	4608      	mov	r0, r1
    1c1a:	bc30      	pop	{r4, r5}
    1c1c:	4770      	bx	lr
    1c1e:	bf00      	nop
    1c20:	00030010 	.word	0x00030010
    1c24:	00100103 	.word	0x00100103
    1c28:	00020704 	.word	0x00020704
    1c2c:	200001c0 	.word	0x200001c0
    1c30:	200015a4 	.word	0x200015a4
    1c34:	200012b8 	.word	0x200012b8
    1c38:	e000e100 	.word	0xe000e100

00001c3c <_mac_async_enable>:
	return ERR_NONE;
}

int32_t _mac_async_enable(struct _mac_async_device *const dev)
{
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
    1c3c:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->NCR.reg |= mask;
    1c3e:	6813      	ldr	r3, [r2, #0]
    1c40:	f043 030c 	orr.w	r3, r3, #12
    1c44:	6013      	str	r3, [r2, #0]
	return ERR_NONE;
}
    1c46:	2000      	movs	r0, #0
    1c48:	4770      	bx	lr
	...

00001c4c <_mac_async_write>:
	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
	return ERR_NONE;
}

int32_t _mac_async_write(struct _mac_async_device *const dev, uint8_t *buf, uint32_t len)
{
    1c4c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1c50:	4682      	mov	sl, r0
    1c52:	4614      	mov	r4, r2
	uint32_t pos;
	uint32_t blen;
	uint32_t i;

	if (_txbuf_descrs[_last_txbuf_index].status.bm.used && !_txbuf_descrs[_last_txbuf_index].status.bm.last_buf) {
    1c54:	4b49      	ldr	r3, [pc, #292]	; (1d7c <_mac_async_write+0x130>)
    1c56:	f8d3 2bd8 	ldr.w	r2, [r3, #3032]	; 0xbd8
    1c5a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1c5e:	7bdb      	ldrb	r3, [r3, #15]
    1c60:	09db      	lsrs	r3, r3, #7
    1c62:	d016      	beq.n	1c92 <_mac_async_write+0x46>
    1c64:	4b45      	ldr	r3, [pc, #276]	; (1d7c <_mac_async_write+0x130>)
    1c66:	f8d3 2bd8 	ldr.w	r2, [r3, #3032]	; 0xbd8
    1c6a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1c6e:	7b5b      	ldrb	r3, [r3, #13]
    1c70:	09db      	lsrs	r3, r3, #7
    1c72:	d10e      	bne.n	1c92 <_mac_async_write+0x46>
		/* Set used flag from first descriptor to last descriptor,
		 * as DMA olny set the first used flag */
		for (i = 1; i < CONF_GMAC_TXDESCR_NUM; i++) {
			pos = _last_txbuf_index + i;
    1c74:	4b41      	ldr	r3, [pc, #260]	; (1d7c <_mac_async_write+0x130>)
    1c76:	f8d3 3bd8 	ldr.w	r3, [r3, #3032]	; 0xbd8
    1c7a:	1c5a      	adds	r2, r3, #1
			if (pos >= CONF_GMAC_TXDESCR_NUM) {
    1c7c:	2a01      	cmp	r2, #1
				pos -= CONF_GMAC_TXDESCR_NUM;
    1c7e:	bf88      	it	hi
    1c80:	f103 32ff 	addhi.w	r2, r3, #4294967295
			}
			_txbuf_descrs[pos].status.bm.used = 1;
    1c84:	4b3d      	ldr	r3, [pc, #244]	; (1d7c <_mac_async_write+0x130>)
    1c86:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1c8a:	7bda      	ldrb	r2, [r3, #15]
    1c8c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    1c90:	73da      	strb	r2, [r3, #15]
				break;
			}
		}
	}

	if (!_txbuf_descrs[_txbuf_index].status.bm.used) {
    1c92:	4b3a      	ldr	r3, [pc, #232]	; (1d7c <_mac_async_write+0x130>)
    1c94:	685a      	ldr	r2, [r3, #4]
    1c96:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1c9a:	7bdb      	ldrb	r3, [r3, #15]
    1c9c:	09db      	lsrs	r3, r3, #7
    1c9e:	d064      	beq.n	1d6a <_mac_async_write+0x11e>
		return ERR_NO_RESOURCE;
	}

	/* Check if have enough buffers, the first buffer already checked */
	if (len > CONF_GMAC_TXBUF_SIZE) {
    1ca0:	f240 53dc 	movw	r3, #1500	; 0x5dc
    1ca4:	429c      	cmp	r4, r3
    1ca6:	d90c      	bls.n	1cc2 <_mac_async_write+0x76>
		for (i = 1; i < CONF_GMAC_TXDESCR_NUM; i++) {
			pos = _txbuf_index + i;
    1ca8:	4b34      	ldr	r3, [pc, #208]	; (1d7c <_mac_async_write+0x130>)
    1caa:	685b      	ldr	r3, [r3, #4]
    1cac:	1c5a      	adds	r2, r3, #1
			if (pos >= CONF_GMAC_TXDESCR_NUM) {
    1cae:	2a01      	cmp	r2, #1
				pos -= CONF_GMAC_TXDESCR_NUM;
    1cb0:	bf88      	it	hi
    1cb2:	f103 32ff 	addhi.w	r2, r3, #4294967295
			}

			if (!_txbuf_descrs[pos].status.bm.used) {
    1cb6:	4b31      	ldr	r3, [pc, #196]	; (1d7c <_mac_async_write+0x130>)
    1cb8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1cbc:	7bdb      	ldrb	r3, [r3, #15]
    1cbe:	09db      	lsrs	r3, r3, #7
    1cc0:	d057      	beq.n	1d72 <_mac_async_write+0x126>
			if ((len - (CONF_GMAC_TXBUF_SIZE * i)) < CONF_GMAC_TXBUF_SIZE) {
				break;
			}
		}
	}
	_last_txbuf_index = _txbuf_index;
    1cc2:	4b2e      	ldr	r3, [pc, #184]	; (1d7c <_mac_async_write+0x130>)
    1cc4:	685a      	ldr	r2, [r3, #4]
    1cc6:	f8c3 2bd8 	str.w	r2, [r3, #3032]	; 0xbd8
    1cca:	460f      	mov	r7, r1
    1ccc:	f601 38b8 	addw	r8, r1, #3000	; 0xbb8

	/* Write data to transmit buffer */
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    1cd0:	461e      	mov	r6, r3
    1cd2:	f103 0b20 	add.w	fp, r3, #32
    1cd6:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 1d80 <_mac_async_write+0x134>
    1cda:	e027      	b.n	1d2c <_mac_async_write+0xe0>

		if (len > 0) {
			/* Here the Used flag be set to zero */
			_txbuf_descrs[_txbuf_index].status.val = blen;
		} else {
			_txbuf_descrs[_txbuf_index].status.val         = blen;
    1cdc:	4b27      	ldr	r3, [pc, #156]	; (1d7c <_mac_async_write+0x130>)
    1cde:	685a      	ldr	r2, [r3, #4]
    1ce0:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    1ce4:	60d5      	str	r5, [r2, #12]
			_txbuf_descrs[_txbuf_index].status.bm.last_buf = 1;
    1ce6:	685a      	ldr	r2, [r3, #4]
    1ce8:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    1cec:	7b51      	ldrb	r1, [r2, #13]
    1cee:	f041 0180 	orr.w	r1, r1, #128	; 0x80
    1cf2:	7351      	strb	r1, [r2, #13]
		}
		_txbuf_index++;
    1cf4:	685a      	ldr	r2, [r3, #4]
    1cf6:	3201      	adds	r2, #1
    1cf8:	605a      	str	r2, [r3, #4]
		if (_txbuf_index == CONF_GMAC_TXDESCR_NUM) {
    1cfa:	685b      	ldr	r3, [r3, #4]
    1cfc:	2b02      	cmp	r3, #2
    1cfe:	d106      	bne.n	1d0e <_mac_async_write+0xc2>
			_txbuf_index                                            = 0;
    1d00:	4b1e      	ldr	r3, [pc, #120]	; (1d7c <_mac_async_write+0x130>)
    1d02:	2200      	movs	r2, #0
    1d04:	605a      	str	r2, [r3, #4]
			_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    1d06:	7dda      	ldrb	r2, [r3, #23]
    1d08:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    1d0c:	75da      	strb	r2, [r3, #23]
  __ASM volatile ("dsb 0xF":::"memory");
    1d0e:	f3bf 8f4f 	dsb	sy

	/* Data synchronization barrier */
	__DSB();

	/* Active Transmit */
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_TSTART);
    1d12:	f8da 2000 	ldr.w	r2, [sl]
    1d16:	6813      	ldr	r3, [r2, #0]
    1d18:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    1d1c:	6013      	str	r3, [r2, #0]

	return ERR_NONE;
    1d1e:	2000      	movs	r0, #0
    1d20:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1d24:	f207 57dc 	addw	r7, r7, #1500	; 0x5dc
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
    1d28:	4547      	cmp	r7, r8
    1d2a:	d0f0      	beq.n	1d0e <_mac_async_write+0xc2>
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
    1d2c:	f240 53dc 	movw	r3, #1500	; 0x5dc
    1d30:	4625      	mov	r5, r4
    1d32:	429c      	cmp	r4, r3
    1d34:	bf28      	it	cs
    1d36:	461d      	movcs	r5, r3
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    1d38:	6870      	ldr	r0, [r6, #4]
    1d3a:	462a      	mov	r2, r5
    1d3c:	4639      	mov	r1, r7
    1d3e:	fb03 b000 	mla	r0, r3, r0, fp
    1d42:	47c8      	blx	r9
		if (len > 0) {
    1d44:	1b64      	subs	r4, r4, r5
    1d46:	d0c9      	beq.n	1cdc <_mac_async_write+0x90>
			_txbuf_descrs[_txbuf_index].status.val = blen;
    1d48:	6873      	ldr	r3, [r6, #4]
    1d4a:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
    1d4e:	60dd      	str	r5, [r3, #12]
		_txbuf_index++;
    1d50:	6873      	ldr	r3, [r6, #4]
    1d52:	3301      	adds	r3, #1
    1d54:	6073      	str	r3, [r6, #4]
		if (_txbuf_index == CONF_GMAC_TXDESCR_NUM) {
    1d56:	6873      	ldr	r3, [r6, #4]
    1d58:	2b02      	cmp	r3, #2
    1d5a:	d1e3      	bne.n	1d24 <_mac_async_write+0xd8>
			_txbuf_index                                            = 0;
    1d5c:	2300      	movs	r3, #0
    1d5e:	6073      	str	r3, [r6, #4]
			_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    1d60:	7df3      	ldrb	r3, [r6, #23]
    1d62:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    1d66:	75f3      	strb	r3, [r6, #23]
    1d68:	e7dc      	b.n	1d24 <_mac_async_write+0xd8>
		return ERR_NO_RESOURCE;
    1d6a:	f06f 001b 	mvn.w	r0, #27
    1d6e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				return ERR_NO_RESOURCE;
    1d72:	f06f 001b 	mvn.w	r0, #27
    1d76:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1d7a:	bf00      	nop
    1d7c:	200001c0 	.word	0x200001c0
    1d80:	0000a0eb 	.word	0x0000a0eb

00001d84 <_mac_async_read>:
}

uint32_t _mac_async_read(struct _mac_async_device *const dev, uint8_t *buf, uint32_t len)
{
    1d84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1d88:	b083      	sub	sp, #12
    1d8a:	9101      	str	r1, [sp, #4]
    1d8c:	4691      	mov	r9, r2
	uint32_t i;
	uint32_t j;
	uint32_t pos;
	uint32_t n;
	uint32_t sof       = 0xFFFFFFFF; /* Start of Frame index */
    1d8e:	f04f 37ff 	mov.w	r7, #4294967295
	uint32_t eof       = 0xFFFFFFFF; /* End of Frame index */
	uint32_t total_len = 0;          /* Total length of received package */

	(void)dev;
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1d92:	2400      	movs	r4, #0
		pos = _rxbuf_index + i;
    1d94:	4a45      	ldr	r2, [pc, #276]	; (1eac <_mac_async_read+0x128>)
    1d96:	e002      	b.n	1d9e <_mac_async_read+0x1a>
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1d98:	3401      	adds	r4, #1
    1d9a:	2c10      	cmp	r4, #16
    1d9c:	d074      	beq.n	1e88 <_mac_async_read+0x104>
		pos = _rxbuf_index + i;
    1d9e:	f8d2 3368 	ldr.w	r3, [r2, #872]	; 0x368
    1da2:	4423      	add	r3, r4

		if (pos >= CONF_GMAC_RXDESCR_NUM) {
    1da4:	2b0f      	cmp	r3, #15
			pos -= CONF_GMAC_RXDESCR_NUM;
    1da6:	bf88      	it	hi
    1da8:	3b10      	subhi	r3, #16
		}

		/* No more data for Ethernet package */
		if (!_rxbuf_descrs[pos].address.bm.ownership) {
    1daa:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
    1dae:	f891 12e8 	ldrb.w	r1, [r1, #744]	; 0x2e8
    1db2:	f011 0f01 	tst.w	r1, #1
    1db6:	d061      	beq.n	1e7c <_mac_async_read+0xf8>
			break;
		}

		if (_rxbuf_descrs[pos].status.bm.sof) {
    1db8:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
    1dbc:	f891 12ed 	ldrb.w	r1, [r1, #749]	; 0x2ed
    1dc0:	f3c1 1180 	ubfx	r1, r1, #6, #1
    1dc4:	2900      	cmp	r1, #0
    1dc6:	bf18      	it	ne
    1dc8:	4627      	movne	r7, r4
			sof = i;
		}

		if ((_rxbuf_descrs[pos].status.bm.eof) && (sof != 0xFFFFFFFF)) {
    1dca:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
    1dce:	f891 12ed 	ldrb.w	r1, [r1, #749]	; 0x2ed
    1dd2:	09c9      	lsrs	r1, r1, #7
    1dd4:	d0e0      	beq.n	1d98 <_mac_async_read+0x14>
    1dd6:	f1b7 3fff 	cmp.w	r7, #4294967295
    1dda:	d0dd      	beq.n	1d98 <_mac_async_read+0x14>
			/* eof now indicate the number of bufs the frame used */
			eof = i;
			n   = _rxbuf_descrs[pos].status.bm.len;
    1ddc:	4a33      	ldr	r2, [pc, #204]	; (1eac <_mac_async_read+0x128>)
    1dde:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    1de2:	f8b3 32ec 	ldrh.w	r3, [r3, #748]	; 0x2ec
    1de6:	f3c3 030c 	ubfx	r3, r3, #0, #13
			len = min(n, len);
    1dea:	4599      	cmp	r9, r3
    1dec:	bf28      	it	cs
    1dee:	4699      	movcs	r9, r3
			/* Break process since the last data has been found */
			break;
		}
	}

	if (eof != 0xFFFFFFFF) {
    1df0:	f1b4 3fff 	cmp.w	r4, #4294967295
		j = eof + 1;
    1df4:	bf18      	it	ne
    1df6:	f104 0801 	addne.w	r8, r4, #1
	if (eof != 0xFFFFFFFF) {
    1dfa:	d14b      	bne.n	1e94 <_mac_async_read+0x110>
    1dfc:	46b8      	mov	r8, r7
    1dfe:	e049      	b.n	1e94 <_mac_async_read+0x110>
			buf += n;
			total_len += n;
			len -= n;
		}

		_rxbuf_descrs[_rxbuf_index].address.bm.ownership = 0;
    1e00:	f8d5 3368 	ldr.w	r3, [r5, #872]	; 0x368
    1e04:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
    1e08:	f893 22e8 	ldrb.w	r2, [r3, #744]	; 0x2e8
    1e0c:	f36f 0200 	bfc	r2, #0, #1
    1e10:	f883 22e8 	strb.w	r2, [r3, #744]	; 0x2e8
		_rxbuf_index++;
    1e14:	f8d5 3368 	ldr.w	r3, [r5, #872]	; 0x368
    1e18:	3301      	adds	r3, #1
    1e1a:	f8c5 3368 	str.w	r3, [r5, #872]	; 0x368

		if (_rxbuf_index == CONF_GMAC_RXDESCR_NUM) {
    1e1e:	f8d5 3368 	ldr.w	r3, [r5, #872]	; 0x368
    1e22:	2b10      	cmp	r3, #16
			_rxbuf_index = 0;
    1e24:	bf04      	itt	eq
    1e26:	2300      	moveq	r3, #0
    1e28:	f8c5 3368 	streq.w	r3, [r5, #872]	; 0x368
	for (i = 0; i < j; i++) {
    1e2c:	3601      	adds	r6, #1
    1e2e:	4546      	cmp	r6, r8
    1e30:	d020      	beq.n	1e74 <_mac_async_read+0xf0>
		if (eof != 0xFFFFFFFF && i >= sof && i <= eof && len > 0) {
    1e32:	f1b4 3fff 	cmp.w	r4, #4294967295
    1e36:	d0e3      	beq.n	1e00 <_mac_async_read+0x7c>
    1e38:	42be      	cmp	r6, r7
    1e3a:	d3e1      	bcc.n	1e00 <_mac_async_read+0x7c>
    1e3c:	42a6      	cmp	r6, r4
    1e3e:	d8df      	bhi.n	1e00 <_mac_async_read+0x7c>
    1e40:	f1b9 0f00 	cmp.w	r9, #0
    1e44:	d0dc      	beq.n	1e00 <_mac_async_read+0x7c>
			n = min(len, CONF_GMAC_RXBUF_SIZE);
    1e46:	46cb      	mov	fp, r9
    1e48:	f1b9 0f80 	cmp.w	r9, #128	; 0x80
    1e4c:	bf28      	it	cs
    1e4e:	f04f 0b80 	movcs.w	fp, #128	; 0x80
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    1e52:	f8d5 1368 	ldr.w	r1, [r5, #872]	; 0x368
    1e56:	465a      	mov	r2, fp
    1e58:	4b15      	ldr	r3, [pc, #84]	; (1eb0 <_mac_async_read+0x12c>)
    1e5a:	eb03 11c1 	add.w	r1, r3, r1, lsl #7
    1e5e:	9801      	ldr	r0, [sp, #4]
    1e60:	4b14      	ldr	r3, [pc, #80]	; (1eb4 <_mac_async_read+0x130>)
    1e62:	4798      	blx	r3
			buf += n;
    1e64:	9b01      	ldr	r3, [sp, #4]
    1e66:	445b      	add	r3, fp
    1e68:	9301      	str	r3, [sp, #4]
			total_len += n;
    1e6a:	44da      	add	sl, fp
			len -= n;
    1e6c:	eba9 090b 	sub.w	r9, r9, fp
    1e70:	e7c6      	b.n	1e00 <_mac_async_read+0x7c>
	uint32_t total_len = 0;          /* Total length of received package */
    1e72:	46c2      	mov	sl, r8
		}
	}

	return total_len;
}
    1e74:	4650      	mov	r0, sl
    1e76:	b003      	add	sp, #12
    1e78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (sof != 0xFFFFFFFF) {
    1e7c:	f1b7 3fff 	cmp.w	r7, #4294967295
    1e80:	d105      	bne.n	1e8e <_mac_async_read+0x10a>
    1e82:	46a0      	mov	r8, r4
    1e84:	463c      	mov	r4, r7
    1e86:	e005      	b.n	1e94 <_mac_async_read+0x110>
    1e88:	f1b7 3fff 	cmp.w	r7, #4294967295
    1e8c:	d00a      	beq.n	1ea4 <_mac_async_read+0x120>
		if (_rxbuf_descrs[pos].status.bm.sof) {
    1e8e:	46b8      	mov	r8, r7
    1e90:	f04f 34ff 	mov.w	r4, #4294967295
	for (i = 0; i < j; i++) {
    1e94:	f1b8 0f00 	cmp.w	r8, #0
    1e98:	d0eb      	beq.n	1e72 <_mac_async_read+0xee>
	} else if (sof != 0xFFFFFFFF) {
    1e9a:	f04f 0a00 	mov.w	sl, #0
    1e9e:	4656      	mov	r6, sl
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    1ea0:	4d02      	ldr	r5, [pc, #8]	; (1eac <_mac_async_read+0x128>)
    1ea2:	e7c6      	b.n	1e32 <_mac_async_read+0xae>
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1ea4:	46a0      	mov	r8, r4
	} else if (sof != 0xFFFFFFFF) {
    1ea6:	463c      	mov	r4, r7
    1ea8:	e7f7      	b.n	1e9a <_mac_async_read+0x116>
    1eaa:	bf00      	nop
    1eac:	200012b8 	.word	0x200012b8
    1eb0:	20000da0 	.word	0x20000da0
    1eb4:	0000a0eb 	.word	0x0000a0eb

00001eb8 <_mac_async_read_len>:

uint32_t _mac_async_read_len(struct _mac_async_device *const dev)
{
    1eb8:	b470      	push	{r4, r5, r6}
	uint32_t i;
	uint32_t pos;
	bool     sof       = false; /* Start of Frame */
	uint32_t total_len = 0;     /* Total length of received package */
    1eba:	2000      	movs	r0, #0
	bool     sof       = false; /* Start of Frame */
    1ebc:	4606      	mov	r6, r0

	(void)dev;

	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1ebe:	4601      	mov	r1, r0
		pos = _rxbuf_index + i;
    1ec0:	4a16      	ldr	r2, [pc, #88]	; (1f1c <_mac_async_read_len+0x64>)

		if (_rxbuf_descrs[pos].status.bm.sof) {
			sof = true;
		}
		if (sof == true) {
			total_len += _rxbuf_descrs[pos].status.bm.len;
    1ec2:	2501      	movs	r5, #1
    1ec4:	e010      	b.n	1ee8 <_mac_async_read_len+0x30>
    1ec6:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
    1eca:	f8b4 42ec 	ldrh.w	r4, [r4, #748]	; 0x2ec
    1ece:	f3c4 040c 	ubfx	r4, r4, #0, #13
    1ed2:	4420      	add	r0, r4
    1ed4:	462e      	mov	r6, r5
		}

		if (_rxbuf_descrs[pos].status.bm.eof) {
    1ed6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    1eda:	f893 32ed 	ldrb.w	r3, [r3, #749]	; 0x2ed
    1ede:	09db      	lsrs	r3, r3, #7
    1ee0:	d119      	bne.n	1f16 <_mac_async_read_len+0x5e>
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1ee2:	3101      	adds	r1, #1
    1ee4:	2910      	cmp	r1, #16
    1ee6:	d016      	beq.n	1f16 <_mac_async_read_len+0x5e>
		pos = _rxbuf_index + i;
    1ee8:	f8d2 3368 	ldr.w	r3, [r2, #872]	; 0x368
    1eec:	440b      	add	r3, r1
		if (pos >= CONF_GMAC_RXDESCR_NUM) {
    1eee:	2b0f      	cmp	r3, #15
			pos -= CONF_GMAC_RXDESCR_NUM;
    1ef0:	bf88      	it	hi
    1ef2:	3b10      	subhi	r3, #16
		if (!(_rxbuf_descrs[pos].address.bm.ownership)) {
    1ef4:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
    1ef8:	f894 42e8 	ldrb.w	r4, [r4, #744]	; 0x2e8
    1efc:	f014 0f01 	tst.w	r4, #1
    1f00:	d009      	beq.n	1f16 <_mac_async_read_len+0x5e>
		if (_rxbuf_descrs[pos].status.bm.sof) {
    1f02:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
    1f06:	f894 42ed 	ldrb.w	r4, [r4, #749]	; 0x2ed
    1f0a:	f014 0f40 	tst.w	r4, #64	; 0x40
    1f0e:	d1da      	bne.n	1ec6 <_mac_async_read_len+0xe>
		if (sof == true) {
    1f10:	2e00      	cmp	r6, #0
    1f12:	d0e0      	beq.n	1ed6 <_mac_async_read_len+0x1e>
    1f14:	e7d7      	b.n	1ec6 <_mac_async_read_len+0xe>
			break;
		}
	}

	return total_len;
}
    1f16:	bc70      	pop	{r4, r5, r6}
    1f18:	4770      	bx	lr
    1f1a:	bf00      	nop
    1f1c:	200012b8 	.word	0x200012b8

00001f20 <_mac_async_register_callback>:
}

int32_t _mac_async_register_callback(struct _mac_async_device *const dev, const enum mac_async_cb_type type,
                                     const FUNC_PTR func)
{
	switch (type) {
    1f20:	b169      	cbz	r1, 1f3e <_mac_async_register_callback+0x1e>
    1f22:	2901      	cmp	r1, #1
    1f24:	d111      	bne.n	1f4a <_mac_async_register_callback+0x2a>
	case MAC_ASYNC_TRANSMIT_CB:
		dev->cb.transmited = (_mac_async_cb_t)func;
    1f26:	6042      	str	r2, [r0, #4]
		if (func) {
    1f28:	b122      	cbz	r2, 1f34 <_mac_async_register_callback+0x14>
			hri_gmac_set_IMR_TCOMP_bit(dev->hw);
    1f2a:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->IER.reg = GMAC_IMR_TCOMP;
    1f2c:	2280      	movs	r2, #128	; 0x80
    1f2e:	629a      	str	r2, [r3, #40]	; 0x28
		}
		break;
	default:
		return ERR_INVALID_ARG;
	}
	return ERR_NONE;
    1f30:	2000      	movs	r0, #0
    1f32:	4770      	bx	lr
			hri_gmac_clear_IMR_TCOMP_bit(dev->hw);
    1f34:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->IDR.reg = GMAC_IMR_TCOMP;
    1f36:	2280      	movs	r2, #128	; 0x80
    1f38:	62da      	str	r2, [r3, #44]	; 0x2c
	return ERR_NONE;
    1f3a:	2000      	movs	r0, #0
    1f3c:	4770      	bx	lr
		dev->cb.received = (_mac_async_cb_t)func;
    1f3e:	6082      	str	r2, [r0, #8]
			hri_gmac_set_IMR_RCOMP_bit(dev->hw);
    1f40:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->IER.reg = GMAC_IMR_RCOMP;
    1f42:	2202      	movs	r2, #2
    1f44:	629a      	str	r2, [r3, #40]	; 0x28
	return ERR_NONE;
    1f46:	2000      	movs	r0, #0
    1f48:	4770      	bx	lr
		return ERR_INVALID_ARG;
    1f4a:	f06f 000c 	mvn.w	r0, #12
}
    1f4e:	4770      	bx	lr

00001f50 <_mac_async_set_filter>:

int32_t _mac_async_set_filter(struct _mac_async_device *const dev, uint8_t index, struct mac_async_filter *filter)
{
    1f50:	b570      	push	{r4, r5, r6, lr}
    1f52:	4606      	mov	r6, r0
    1f54:	460c      	mov	r4, r1
    1f56:	4615      	mov	r5, r2
	ASSERT(index < 4);
    1f58:	f240 12cf 	movw	r2, #463	; 0x1cf
    1f5c:	490c      	ldr	r1, [pc, #48]	; (1f90 <_mac_async_set_filter+0x40>)
    1f5e:	2c03      	cmp	r4, #3
    1f60:	bf8c      	ite	hi
    1f62:	2000      	movhi	r0, #0
    1f64:	2001      	movls	r0, #1
    1f66:	4b0b      	ldr	r3, [pc, #44]	; (1f94 <_mac_async_set_filter+0x44>)
    1f68:	4798      	blx	r3

	hri_gmac_write_SAB_reg(dev->hw, index, *((uint32_t *)(filter->mac)));
    1f6a:	6833      	ldr	r3, [r6, #0]
    1f6c:	6829      	ldr	r1, [r5, #0]
	((Gmac *)hw)->Sa[submodule_index].SAB.reg = data;
    1f6e:	f104 0211 	add.w	r2, r4, #17
    1f72:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
	hri_gmac_write_SAT_reg(dev->hw, index, *((uint16_t *)(filter->mac + 4)));
    1f76:	6833      	ldr	r3, [r6, #0]
    1f78:	88a9      	ldrh	r1, [r5, #4]
	((Gmac *)hw)->Sa[submodule_index].SAT.reg = data;
    1f7a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1f7e:	6059      	str	r1, [r3, #4]

	hri_gmac_write_TIDM_reg(dev->hw, index, GMAC_TIDM_TID(*((uint16_t *)(filter->tid)) | filter->tid_enable << 31));
    1f80:	6833      	ldr	r3, [r6, #0]
    1f82:	88ea      	ldrh	r2, [r5, #6]
	((Gmac *)hw)->TIDM[index].reg = data;
    1f84:	342a      	adds	r4, #42	; 0x2a
    1f86:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
	return ERR_NONE;
}
    1f8a:	2000      	movs	r0, #0
    1f8c:	bd70      	pop	{r4, r5, r6, pc}
    1f8e:	bf00      	nop
    1f90:	0000b2fc 	.word	0x0000b2fc
    1f94:	0000187d 	.word	0x0000187d

00001f98 <_mac_async_write_phy_reg>:

	return ERR_NONE;
}

int32_t _mac_async_write_phy_reg(struct _mac_async_device *const dev, uint16_t addr, uint16_t reg, uint16_t data)
{
    1f98:	b430      	push	{r4, r5}
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_MPE);
    1f9a:	6805      	ldr	r5, [r0, #0]
	((Gmac *)hw)->NCR.reg |= mask;
    1f9c:	682c      	ldr	r4, [r5, #0]
    1f9e:	f044 0410 	orr.w	r4, r4, #16
    1fa2:	602c      	str	r4, [r5, #0]
	hri_gmac_write_MAN_reg(dev->hw,
    1fa4:	6804      	ldr	r4, [r0, #0]
	                       GMAC_MAN_OP(1) |            /* 0x01 write operation */
	                           CONF_GMAC_CLTTO << 30 | /* Clause 22/45 operation */
	                           GMAC_MAN_WTN(2) |       /* Must be written to 0x2 */
	                           GMAC_MAN_PHYA(addr) | GMAC_MAN_REGA(reg) | GMAC_MAN_DATA(data));
    1fa6:	0492      	lsls	r2, r2, #18
    1fa8:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
    1fac:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    1fb0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    1fb4:	431a      	orrs	r2, r3
    1fb6:	05c9      	lsls	r1, r1, #23
    1fb8:	f001 6178 	and.w	r1, r1, #260046848	; 0xf800000
    1fbc:	430a      	orrs	r2, r1
	((Gmac *)hw)->MAN.reg = data;
    1fbe:	6362      	str	r2, [r4, #52]	; 0x34
	/* Wait for the write operation complete */
	while (!hri_gmac_get_NSR_IDLE_bit(dev->hw)) {
    1fc0:	6802      	ldr	r2, [r0, #0]
	return (((Gmac *)hw)->NSR.reg & GMAC_NSR_IDLE) >> GMAC_NSR_IDLE_Pos;
    1fc2:	6893      	ldr	r3, [r2, #8]
    1fc4:	f013 0f04 	tst.w	r3, #4
    1fc8:	d0fb      	beq.n	1fc2 <_mac_async_write_phy_reg+0x2a>
	((Gmac *)hw)->NCR.reg &= ~mask;
    1fca:	6813      	ldr	r3, [r2, #0]
    1fcc:	f023 0310 	bic.w	r3, r3, #16
    1fd0:	6013      	str	r3, [r2, #0]
	}

	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_MPE);
	return ERR_NONE;
}
    1fd2:	2000      	movs	r0, #0
    1fd4:	bc30      	pop	{r4, r5}
    1fd6:	4770      	bx	lr

00001fd8 <_mac_async_read_phy_reg>:

int32_t _mac_async_read_phy_reg(struct _mac_async_device *const dev, uint16_t addr, uint16_t reg, uint16_t *data)
{
    1fd8:	b430      	push	{r4, r5}
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_MPE);
    1fda:	6805      	ldr	r5, [r0, #0]
	((Gmac *)hw)->NCR.reg |= mask;
    1fdc:	682c      	ldr	r4, [r5, #0]
    1fde:	f044 0410 	orr.w	r4, r4, #16
    1fe2:	602c      	str	r4, [r5, #0]
	hri_gmac_write_MAN_reg(dev->hw,
    1fe4:	6804      	ldr	r4, [r0, #0]
	                       GMAC_MAN_OP(2) |            /* 0x02 read operation */
	                           CONF_GMAC_CLTTO << 30 | /* Clause 22/45 operation */
	                           GMAC_MAN_WTN(0x2) |     /* Must be written to 0x2 */
	                           GMAC_MAN_PHYA(addr) | GMAC_MAN_REGA(reg));
    1fe6:	0492      	lsls	r2, r2, #18
    1fe8:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
    1fec:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
    1ff0:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
    1ff4:	05c9      	lsls	r1, r1, #23
    1ff6:	f001 6178 	and.w	r1, r1, #260046848	; 0xf800000
    1ffa:	430a      	orrs	r2, r1
	((Gmac *)hw)->MAN.reg = data;
    1ffc:	6362      	str	r2, [r4, #52]	; 0x34

	/* Wait for the read operation complete */
	while (!hri_gmac_get_NSR_IDLE_bit(dev->hw)) {
    1ffe:	6801      	ldr	r1, [r0, #0]
	return (((Gmac *)hw)->NSR.reg & GMAC_NSR_IDLE) >> GMAC_NSR_IDLE_Pos;
    2000:	688a      	ldr	r2, [r1, #8]
    2002:	f012 0f04 	tst.w	r2, #4
    2006:	d0fb      	beq.n	2000 <_mac_async_read_phy_reg+0x28>
	return ((Gmac *)hw)->MAN.reg;
    2008:	6b4a      	ldr	r2, [r1, #52]	; 0x34
	}

	*data = GMAC_MAN_DATA(hri_gmac_read_MAN_reg(dev->hw));
    200a:	801a      	strh	r2, [r3, #0]
	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_MPE);
    200c:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->NCR.reg &= ~mask;
    200e:	6813      	ldr	r3, [r2, #0]
    2010:	f023 0310 	bic.w	r3, r3, #16
    2014:	6013      	str	r3, [r2, #0]

	return ERR_NONE;
}
    2016:	2000      	movs	r0, #0
    2018:	bc30      	pop	{r4, r5}
    201a:	4770      	bx	lr

0000201c <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    201c:	2201      	movs	r2, #1
    201e:	4b01      	ldr	r3, [pc, #4]	; (2024 <_mclk_init+0x8>)
    2020:	715a      	strb	r2, [r3, #5]
    2022:	4770      	bx	lr
    2024:	40000800 	.word	0x40000800

00002028 <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    2028:	4b03      	ldr	r3, [pc, #12]	; (2038 <_osc32kctrl_init_sources+0x10>)
    202a:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    202c:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    2030:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    2032:	2201      	movs	r2, #1
    2034:	741a      	strb	r2, [r3, #16]
    2036:	4770      	bx	lr
    2038:	40001400 	.word	0x40001400

0000203c <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_XOSCCTRL_reg(const void *const hw, uint8_t index, hri_oscctrl_xoscctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
    203c:	4a08      	ldr	r2, [pc, #32]	; (2060 <_oscctrl_init_sources+0x24>)
    203e:	4b09      	ldr	r3, [pc, #36]	; (2064 <_oscctrl_init_sources+0x28>)
    2040:	615a      	str	r2, [r3, #20]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY0) >> OSCCTRL_STATUS_XOSCRDY0_Pos;
    2042:	461a      	mov	r2, r3
    2044:	6913      	ldr	r3, [r2, #16]
	        | (CONF_XOSC0_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC0_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC0_CONFIG == 1
#if CONF_XOSC0_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY0_bit(hw))
    2046:	f013 0f01 	tst.w	r3, #1
    204a:	d0fb      	beq.n	2044 <_oscctrl_init_sources+0x8>
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
    204c:	4a06      	ldr	r2, [pc, #24]	; (2068 <_oscctrl_init_sources+0x2c>)
    204e:	4b05      	ldr	r3, [pc, #20]	; (2064 <_oscctrl_init_sources+0x28>)
    2050:	619a      	str	r2, [r3, #24]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1) >> OSCCTRL_STATUS_XOSCRDY1_Pos;
    2052:	461a      	mov	r2, r3
    2054:	6913      	ldr	r3, [r2, #16]
	        | (CONF_XOSC1_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC1_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC1_CONFIG == 1
#if CONF_XOSC1_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY1_bit(hw))
    2056:	f013 0f02 	tst.w	r3, #2
    205a:	d0fb      	beq.n	2054 <_oscctrl_init_sources+0x18>
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    205c:	4770      	bx	lr
    205e:	bf00      	nop
    2060:	03002602 	.word	0x03002602
    2064:	40001000 	.word	0x40001000
    2068:	03002606 	.word	0x03002606

0000206c <_oscctrl_init_referenced_generators>:
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLRATIO.reg = data;
    206c:	223b      	movs	r2, #59	; 0x3b
    206e:	4b0e      	ldr	r3, [pc, #56]	; (20a8 <_oscctrl_init_referenced_generators+0x3c>)
    2070:	635a      	str	r2, [r3, #52]	; 0x34
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    2072:	461a      	mov	r2, r3
    2074:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
    2076:	f013 0f06 	tst.w	r3, #6
    207a:	d1fb      	bne.n	2074 <_oscctrl_init_referenced_generators+0x8>
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLB.reg = data;
    207c:	4b0a      	ldr	r3, [pc, #40]	; (20a8 <_oscctrl_init_referenced_generators+0x3c>)
    207e:	4a0b      	ldr	r2, [pc, #44]	; (20ac <_oscctrl_init_referenced_generators+0x40>)
    2080:	639a      	str	r2, [r3, #56]	; 0x38
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLA.reg = data;
    2082:	2202      	movs	r2, #2
    2084:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    2088:	461a      	mov	r2, r3
    208a:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
    208c:	f013 0f02 	tst.w	r3, #2
    2090:	d1fb      	bne.n	208a <_oscctrl_init_referenced_generators+0x1e>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_LOCK)
    2092:	4b05      	ldr	r3, [pc, #20]	; (20a8 <_oscctrl_init_referenced_generators+0x3c>)
    2094:	6c1a      	ldr	r2, [r3, #64]	; 0x40
#endif
#endif

#if CONF_FDPLL0_CONFIG == 1
#if CONF_FDPLL0_ENABLE == 1
	while (!(hri_oscctrl_get_DPLLSTATUS_LOCK_bit(hw, 0) || hri_oscctrl_get_DPLLSTATUS_CLKRDY_bit(hw, 0)))
    2096:	f012 0f01 	tst.w	r2, #1
    209a:	d103      	bne.n	20a4 <_oscctrl_init_referenced_generators+0x38>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_CLKRDY)
    209c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    209e:	f012 0f02 	tst.w	r2, #2
    20a2:	d0f7      	beq.n	2094 <_oscctrl_init_referenced_generators+0x28>
    20a4:	4770      	bx	lr
    20a6:	bf00      	nop
    20a8:	40001000 	.word	0x40001000
    20ac:	00020040 	.word	0x00020040

000020b0 <RAMECC_Handler>:

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    20b0:	b500      	push	{lr}
    20b2:	b083      	sub	sp, #12
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    20b4:	4b0d      	ldr	r3, [pc, #52]	; (20ec <RAMECC_Handler+0x3c>)
    20b6:	789b      	ldrb	r3, [r3, #2]
    20b8:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    20ba:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    20bc:	9b01      	ldr	r3, [sp, #4]
    20be:	f013 0f02 	tst.w	r3, #2
    20c2:	d006      	beq.n	20d2 <RAMECC_Handler+0x22>
    20c4:	4b0a      	ldr	r3, [pc, #40]	; (20f0 <RAMECC_Handler+0x40>)
    20c6:	681b      	ldr	r3, [r3, #0]
    20c8:	b11b      	cbz	r3, 20d2 <RAMECC_Handler+0x22>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    20ca:	4a08      	ldr	r2, [pc, #32]	; (20ec <RAMECC_Handler+0x3c>)
    20cc:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.dual_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    20ce:	4798      	blx	r3
    20d0:	e009      	b.n	20e6 <RAMECC_Handler+0x36>
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    20d2:	9b01      	ldr	r3, [sp, #4]
    20d4:	f013 0f01 	tst.w	r3, #1
    20d8:	d005      	beq.n	20e6 <RAMECC_Handler+0x36>
    20da:	4b05      	ldr	r3, [pc, #20]	; (20f0 <RAMECC_Handler+0x40>)
    20dc:	685b      	ldr	r3, [r3, #4]
    20de:	b113      	cbz	r3, 20e6 <RAMECC_Handler+0x36>
    20e0:	4a02      	ldr	r2, [pc, #8]	; (20ec <RAMECC_Handler+0x3c>)
    20e2:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    20e4:	4798      	blx	r3
	} else {
		return;
	}
}
    20e6:	b003      	add	sp, #12
    20e8:	f85d fb04 	ldr.w	pc, [sp], #4
    20ec:	41020000 	.word	0x41020000
    20f0:	200082e8 	.word	0x200082e8

000020f4 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    20f4:	b470      	push	{r4, r5, r6}
    20f6:	b089      	sub	sp, #36	; 0x24
    20f8:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    20fa:	466c      	mov	r4, sp
    20fc:	4d0d      	ldr	r5, [pc, #52]	; (2134 <_sercom_get_hardware_index+0x40>)
    20fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2100:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    2102:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    2106:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    210a:	9b00      	ldr	r3, [sp, #0]
    210c:	42b3      	cmp	r3, r6
    210e:	d00d      	beq.n	212c <_sercom_get_hardware_index+0x38>
    2110:	4631      	mov	r1, r6
    2112:	ab01      	add	r3, sp, #4
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    2114:	2001      	movs	r0, #1
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    2116:	f853 2b04 	ldr.w	r2, [r3], #4
    211a:	428a      	cmp	r2, r1
    211c:	d007      	beq.n	212e <_sercom_get_hardware_index+0x3a>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    211e:	3001      	adds	r0, #1
    2120:	2808      	cmp	r0, #8
    2122:	d1f8      	bne.n	2116 <_sercom_get_hardware_index+0x22>
			return i;
		}
	}
	return 0;
    2124:	2000      	movs	r0, #0
}
    2126:	b009      	add	sp, #36	; 0x24
    2128:	bc70      	pop	{r4, r5, r6}
    212a:	4770      	bx	lr
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    212c:	2000      	movs	r0, #0
			return i;
    212e:	b2c0      	uxtb	r0, r0
    2130:	e7f9      	b.n	2126 <_sercom_get_hardware_index+0x32>
    2132:	bf00      	nop
    2134:	0000b314 	.word	0x0000b314

00002138 <_sercom_usart_interrupt_handler>:
 * \internal Sercom interrupt handler
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _sercom_usart_interrupt_handler(struct _usart_async_device *device)
{
    2138:	b510      	push	{r4, lr}
	void *hw = device->hw;
    213a:	6984      	ldr	r4, [r0, #24]
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
}

static inline bool hri_sercomusart_get_interrupt_DRE_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    213c:	7e23      	ldrb	r3, [r4, #24]

	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
    213e:	f013 0f01 	tst.w	r3, #1
    2142:	d003      	beq.n	214c <_sercom_usart_interrupt_handler+0x14>
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
}

static inline bool hri_sercomusart_get_INTEN_DRE_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
    2144:	7da3      	ldrb	r3, [r4, #22]
    2146:	f013 0f01 	tst.w	r3, #1
    214a:	d112      	bne.n	2172 <_sercom_usart_interrupt_handler+0x3a>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    214c:	7e23      	ldrb	r3, [r4, #24]
		hri_sercomusart_clear_INTEN_DRE_bit(hw);
		device->usart_cb.tx_byte_sent(device);
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
    214e:	f013 0f02 	tst.w	r3, #2
    2152:	d003      	beq.n	215c <_sercom_usart_interrupt_handler+0x24>
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
}

static inline bool hri_sercomusart_get_INTEN_TXC_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
    2154:	7da3      	ldrb	r3, [r4, #22]
    2156:	f013 0f02 	tst.w	r3, #2
    215a:	d10f      	bne.n	217c <_sercom_usart_interrupt_handler+0x44>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    215c:	7e23      	ldrb	r3, [r4, #24]
		hri_sercomusart_clear_INTEN_TXC_bit(hw);
		device->usart_cb.tx_done_cb(device);
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
    215e:	f013 0f04 	tst.w	r3, #4
    2162:	d015      	beq.n	2190 <_sercom_usart_interrupt_handler+0x58>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
    2164:	8b63      	ldrh	r3, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
    2166:	f003 0337 	and.w	r3, r3, #55	; 0x37
    216a:	b163      	cbz	r3, 2186 <_sercom_usart_interrupt_handler+0x4e>
	((Sercom *)hw)->USART.STATUS.reg = mask;
    216c:	23ff      	movs	r3, #255	; 0xff
    216e:	8363      	strh	r3, [r4, #26]
    2170:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
    2172:	2301      	movs	r3, #1
    2174:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_byte_sent(device);
    2176:	6803      	ldr	r3, [r0, #0]
    2178:	4798      	blx	r3
    217a:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
    217c:	2302      	movs	r3, #2
    217e:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_done_cb(device);
    2180:	6883      	ldr	r3, [r0, #8]
    2182:	4798      	blx	r3
    2184:	bd10      	pop	{r4, pc}
	return ((Sercom *)hw)->USART.DATA.reg;
    2186:	6aa1      	ldr	r1, [r4, #40]	; 0x28
		       | SERCOM_USART_STATUS_ISF | SERCOM_USART_STATUS_COLL)) {
			hri_sercomusart_clear_STATUS_reg(hw, SERCOM_USART_STATUS_MASK);
			return;
		}

		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
    2188:	6843      	ldr	r3, [r0, #4]
    218a:	b2c9      	uxtb	r1, r1
    218c:	4798      	blx	r3
    218e:	bd10      	pop	{r4, pc}
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
    2190:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
    2192:	09db      	lsrs	r3, r3, #7
    2194:	d100      	bne.n	2198 <_sercom_usart_interrupt_handler+0x60>
    2196:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
    2198:	2380      	movs	r3, #128	; 0x80
    219a:	7623      	strb	r3, [r4, #24]
		uint32_t status;

		hri_sercomusart_clear_interrupt_ERROR_bit(hw);
		device->usart_cb.error_cb(device);
    219c:	68c3      	ldr	r3, [r0, #12]
    219e:	4798      	blx	r3
	return ((Sercom *)hw)->USART.STATUS.reg;
    21a0:	8b63      	ldrh	r3, [r4, #26]
    21a2:	b29b      	uxth	r3, r3
	((Sercom *)hw)->USART.STATUS.reg = mask;
    21a4:	8363      	strh	r3, [r4, #26]
    21a6:	e7f6      	b.n	2196 <_sercom_usart_interrupt_handler+0x5e>

000021a8 <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
    21a8:	b508      	push	{r3, lr}
	return SERCOM0_0_IRQn + (_sercom_get_hardware_index(hw) << 2);
    21aa:	4b03      	ldr	r3, [pc, #12]	; (21b8 <_sercom_get_irq_num+0x10>)
    21ac:	4798      	blx	r3
    21ae:	0080      	lsls	r0, r0, #2
    21b0:	302e      	adds	r0, #46	; 0x2e
}
    21b2:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
    21b6:	bd08      	pop	{r3, pc}
    21b8:	000020f5 	.word	0x000020f5

000021bc <_usart_init>:
{
    21bc:	b510      	push	{r4, lr}
    21be:	4604      	mov	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    21c0:	4b41      	ldr	r3, [pc, #260]	; (22c8 <_usart_init+0x10c>)
    21c2:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
    21c4:	2800      	cmp	r0, #0
    21c6:	d05c      	beq.n	2282 <_usart_init+0xc6>
    21c8:	2801      	cmp	r0, #1
    21ca:	d05c      	beq.n	2286 <_usart_init+0xca>
	ASSERT(false);
    21cc:	f240 226b 	movw	r2, #619	; 0x26b
    21d0:	493e      	ldr	r1, [pc, #248]	; (22cc <_usart_init+0x110>)
    21d2:	2000      	movs	r0, #0
    21d4:	4b3e      	ldr	r3, [pc, #248]	; (22d0 <_usart_init+0x114>)
    21d6:	4798      	blx	r3
	return 0;
    21d8:	2100      	movs	r1, #0
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    21da:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    21dc:	f013 0f01 	tst.w	r3, #1
    21e0:	d122      	bne.n	2228 <_usart_init+0x6c>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
    21e2:	004b      	lsls	r3, r1, #1
    21e4:	185a      	adds	r2, r3, r1
    21e6:	4b3b      	ldr	r3, [pc, #236]	; (22d4 <_usart_init+0x118>)
    21e8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    21ec:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    21ee:	f002 021c 	and.w	r2, r2, #28
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    21f2:	69e3      	ldr	r3, [r4, #28]
    21f4:	f013 0f03 	tst.w	r3, #3
    21f8:	d1fb      	bne.n	21f2 <_usart_init+0x36>
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    21fa:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    21fc:	f013 0f02 	tst.w	r3, #2
    2200:	d00b      	beq.n	221a <_usart_init+0x5e>
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    2202:	6823      	ldr	r3, [r4, #0]
    2204:	f023 0302 	bic.w	r3, r3, #2
    2208:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    220a:	69e3      	ldr	r3, [r4, #28]
    220c:	f013 0f03 	tst.w	r3, #3
    2210:	d1fb      	bne.n	220a <_usart_init+0x4e>
    2212:	69e3      	ldr	r3, [r4, #28]
    2214:	f013 0f02 	tst.w	r3, #2
    2218:	d1fb      	bne.n	2212 <_usart_init+0x56>
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
    221a:	f042 0201 	orr.w	r2, r2, #1
	((Sercom *)hw)->USART.CTRLA.reg = data;
    221e:	6022      	str	r2, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    2220:	69e3      	ldr	r3, [r4, #28]
    2222:	f013 0f03 	tst.w	r3, #3
    2226:	d1fb      	bne.n	2220 <_usart_init+0x64>
    2228:	69e3      	ldr	r3, [r4, #28]
    222a:	f013 0f01 	tst.w	r3, #1
    222e:	d1fb      	bne.n	2228 <_usart_init+0x6c>
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    2230:	460a      	mov	r2, r1
    2232:	004b      	lsls	r3, r1, #1
    2234:	440b      	add	r3, r1
    2236:	4927      	ldr	r1, [pc, #156]	; (22d4 <_usart_init+0x118>)
    2238:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
    223c:	6a48      	ldr	r0, [r1, #36]	; 0x24
	((Sercom *)hw)->USART.CTRLA.reg = data;
    223e:	6020      	str	r0, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    2240:	69e3      	ldr	r3, [r4, #28]
    2242:	f013 0f03 	tst.w	r3, #3
    2246:	d1fb      	bne.n	2240 <_usart_init+0x84>
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
    2248:	0053      	lsls	r3, r2, #1
    224a:	1899      	adds	r1, r3, r2
    224c:	4b21      	ldr	r3, [pc, #132]	; (22d4 <_usart_init+0x118>)
    224e:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    2252:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	((Sercom *)hw)->USART.CTRLB.reg = data;
    2254:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    2256:	69e3      	ldr	r3, [r4, #28]
    2258:	f013 0f1f 	tst.w	r3, #31
    225c:	d1fb      	bne.n	2256 <_usart_init+0x9a>
	hri_sercomusart_write_CTRLC_reg(hw, _usarts[i].ctrl_c);
    225e:	0053      	lsls	r3, r2, #1
    2260:	1899      	adds	r1, r3, r2
    2262:	4b1c      	ldr	r3, [pc, #112]	; (22d4 <_usart_init+0x118>)
    2264:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    2268:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	((Sercom *)hw)->USART.CTRLC.reg = data;
    226a:	60a3      	str	r3, [r4, #8]
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
    226c:	f410 4fc0 	tst.w	r0, #24576	; 0x6000
    2270:	d10b      	bne.n	228a <_usart_init+0xce>
		hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
    2272:	0053      	lsls	r3, r2, #1
    2274:	1899      	adds	r1, r3, r2
    2276:	4b17      	ldr	r3, [pc, #92]	; (22d4 <_usart_init+0x118>)
    2278:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    227c:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
	((Sercom *)hw)->USART.BAUD.reg = data;
    227e:	81a3      	strh	r3, [r4, #12]
    2280:	e011      	b.n	22a6 <_usart_init+0xea>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    2282:	2100      	movs	r1, #0
    2284:	e7a9      	b.n	21da <_usart_init+0x1e>
		if (_usarts[i].number == sercom_offset) {
    2286:	2101      	movs	r1, #1
    2288:	e7a7      	b.n	21da <_usart_init+0x1e>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
    228a:	4b12      	ldr	r3, [pc, #72]	; (22d4 <_usart_init+0x118>)
    228c:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    2290:	8e18      	ldrh	r0, [r3, #48]	; 0x30
    2292:	89a1      	ldrh	r1, [r4, #12]
    2294:	f360 010c 	bfi	r1, r0, #0, #13
    2298:	81a1      	strh	r1, [r4, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
    229a:	f893 1032 	ldrb.w	r1, [r3, #50]	; 0x32
    229e:	89a3      	ldrh	r3, [r4, #12]
    22a0:	f361 334f 	bfi	r3, r1, #13, #3
    22a4:	81a3      	strh	r3, [r4, #12]
	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
    22a6:	4b0b      	ldr	r3, [pc, #44]	; (22d4 <_usart_init+0x118>)
    22a8:	0051      	lsls	r1, r2, #1
    22aa:	1888      	adds	r0, r1, r2
    22ac:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    22b0:	f890 0033 	ldrb.w	r0, [r0, #51]	; 0x33
	((Sercom *)hw)->USART.RXPL.reg = data;
    22b4:	73a0      	strb	r0, [r4, #14]
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
    22b6:	440a      	add	r2, r1
    22b8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    22bc:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    22c0:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
}
    22c4:	2000      	movs	r0, #0
    22c6:	bd10      	pop	{r4, pc}
    22c8:	000020f5 	.word	0x000020f5
    22cc:	0000b37c 	.word	0x0000b37c
    22d0:	0000187d 	.word	0x0000187d
    22d4:	0000b314 	.word	0x0000b314

000022d8 <_get_i2cm_index>:
{
    22d8:	b508      	push	{r3, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    22da:	4b07      	ldr	r3, [pc, #28]	; (22f8 <_get_i2cm_index+0x20>)
    22dc:	4798      	blx	r3
		if (_i2cms[i].number == sercom_offset) {
    22de:	2803      	cmp	r0, #3
    22e0:	d008      	beq.n	22f4 <_get_i2cm_index+0x1c>
	ASSERT(false);
    22e2:	f240 32ce 	movw	r2, #974	; 0x3ce
    22e6:	4905      	ldr	r1, [pc, #20]	; (22fc <_get_i2cm_index+0x24>)
    22e8:	2000      	movs	r0, #0
    22ea:	4b05      	ldr	r3, [pc, #20]	; (2300 <_get_i2cm_index+0x28>)
    22ec:	4798      	blx	r3
	return -1;
    22ee:	f04f 30ff 	mov.w	r0, #4294967295
}
    22f2:	bd08      	pop	{r3, pc}
			return i;
    22f4:	2000      	movs	r0, #0
    22f6:	bd08      	pop	{r3, pc}
    22f8:	000020f5 	.word	0x000020f5
    22fc:	0000b37c 	.word	0x0000b37c
    2300:	0000187d 	.word	0x0000187d

00002304 <_i2c_m_sync_init_impl>:
	}
	return ERR_NONE;
}

static int32_t _i2c_m_sync_init_impl(struct _i2c_m_service *const service, void *const hw)
{
    2304:	b538      	push	{r3, r4, r5, lr}
    2306:	4605      	mov	r5, r0
    2308:	460c      	mov	r4, r1
	uint8_t i = _get_i2cm_index(hw);
    230a:	4608      	mov	r0, r1
    230c:	4b32      	ldr	r3, [pc, #200]	; (23d8 <_i2c_m_sync_init_impl+0xd4>)
    230e:	4798      	blx	r3
    2310:	b2c0      	uxtb	r0, r0
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
    2312:	69e3      	ldr	r3, [r4, #28]

	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
    2314:	f013 0f01 	tst.w	r3, #1
    2318:	d122      	bne.n	2360 <_i2c_m_sync_init_impl+0x5c>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
    231a:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    231e:	4a2f      	ldr	r2, [pc, #188]	; (23dc <_i2c_m_sync_init_impl+0xd8>)
    2320:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    2324:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    2326:	f002 021c 	and.w	r2, r2, #28
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    232a:	69e3      	ldr	r3, [r4, #28]
    232c:	f013 0f03 	tst.w	r3, #3
    2330:	d1fb      	bne.n	232a <_i2c_m_sync_init_impl+0x26>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    2332:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
    2334:	f013 0f02 	tst.w	r3, #2
    2338:	d00b      	beq.n	2352 <_i2c_m_sync_init_impl+0x4e>
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
    233a:	6823      	ldr	r3, [r4, #0]
    233c:	f023 0302 	bic.w	r3, r3, #2
    2340:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2342:	69e3      	ldr	r3, [r4, #28]
    2344:	f013 0f03 	tst.w	r3, #3
    2348:	d1fb      	bne.n	2342 <_i2c_m_sync_init_impl+0x3e>
    234a:	69e3      	ldr	r3, [r4, #28]
    234c:	f013 0f02 	tst.w	r3, #2
    2350:	d1fb      	bne.n	234a <_i2c_m_sync_init_impl+0x46>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
		}
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
    2352:	f042 0201 	orr.w	r2, r2, #1
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    2356:	6022      	str	r2, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2358:	69e3      	ldr	r3, [r4, #28]
    235a:	f013 0f03 	tst.w	r3, #3
    235e:	d1fb      	bne.n	2358 <_i2c_m_sync_init_impl+0x54>
    2360:	69e3      	ldr	r3, [r4, #28]
    2362:	f013 0f01 	tst.w	r3, #1
    2366:	d1fb      	bne.n	2360 <_i2c_m_sync_init_impl+0x5c>
	}
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);

	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
    2368:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    236c:	4a1b      	ldr	r2, [pc, #108]	; (23dc <_i2c_m_sync_init_impl+0xd8>)
    236e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    2372:	6d5a      	ldr	r2, [r3, #84]	; 0x54
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    2374:	6022      	str	r2, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2376:	69e3      	ldr	r3, [r4, #28]
    2378:	f013 0f03 	tst.w	r3, #3
    237c:	d1fb      	bne.n	2376 <_i2c_m_sync_init_impl+0x72>
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
    237e:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    2382:	4916      	ldr	r1, [pc, #88]	; (23dc <_i2c_m_sync_init_impl+0xd8>)
    2384:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
    2388:	6d9b      	ldr	r3, [r3, #88]	; 0x58
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
    238a:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    238c:	69e3      	ldr	r3, [r4, #28]
    238e:	f013 0f04 	tst.w	r3, #4
    2392:	d1fb      	bne.n	238c <_i2c_m_sync_init_impl+0x88>
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
    2394:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    2398:	4910      	ldr	r1, [pc, #64]	; (23dc <_i2c_m_sync_init_impl+0xd8>)
    239a:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
    239e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
	((Sercom *)hw)->I2CM.BAUD.reg = data;
    23a0:	60e3      	str	r3, [r4, #12]

	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
    23a2:	f3c2 6301 	ubfx	r3, r2, #24, #2
    23a6:	81ab      	strh	r3, [r5, #12]
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
    23a8:	6a62      	ldr	r2, [r4, #36]	; 0x24
	tmp &= ~SERCOM_I2CM_ADDR_HS;
    23aa:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
    23ae:	2b01      	cmp	r3, #1
    23b0:	bf94      	ite	ls
    23b2:	2300      	movls	r3, #0
    23b4:	2301      	movhi	r3, #1
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
    23b6:	ea42 3383 	orr.w	r3, r2, r3, lsl #14
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
    23ba:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    23bc:	69e3      	ldr	r3, [r4, #28]
    23be:	f013 0f04 	tst.w	r3, #4
    23c2:	d1fb      	bne.n	23bc <_i2c_m_sync_init_impl+0xb8>

	service->trise = _i2cms[i].trise;
    23c4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    23c8:	4b04      	ldr	r3, [pc, #16]	; (23dc <_i2c_m_sync_init_impl+0xd8>)
    23ca:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    23ce:	f8b0 3062 	ldrh.w	r3, [r0, #98]	; 0x62
    23d2:	81eb      	strh	r3, [r5, #14]

	return ERR_NONE;
}
    23d4:	2000      	movs	r0, #0
    23d6:	bd38      	pop	{r3, r4, r5, pc}
    23d8:	000022d9 	.word	0x000022d9
    23dc:	0000b314 	.word	0x0000b314

000023e0 <_usart_sync_init>:
{
    23e0:	b538      	push	{r3, r4, r5, lr}
    23e2:	460c      	mov	r4, r1
	ASSERT(device);
    23e4:	4605      	mov	r5, r0
    23e6:	22bd      	movs	r2, #189	; 0xbd
    23e8:	4905      	ldr	r1, [pc, #20]	; (2400 <_usart_sync_init+0x20>)
    23ea:	3000      	adds	r0, #0
    23ec:	bf18      	it	ne
    23ee:	2001      	movne	r0, #1
    23f0:	4b04      	ldr	r3, [pc, #16]	; (2404 <_usart_sync_init+0x24>)
    23f2:	4798      	blx	r3
	device->hw = hw;
    23f4:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
    23f6:	4620      	mov	r0, r4
    23f8:	4b03      	ldr	r3, [pc, #12]	; (2408 <_usart_sync_init+0x28>)
    23fa:	4798      	blx	r3
}
    23fc:	bd38      	pop	{r3, r4, r5, pc}
    23fe:	bf00      	nop
    2400:	0000b37c 	.word	0x0000b37c
    2404:	0000187d 	.word	0x0000187d
    2408:	000021bd 	.word	0x000021bd

0000240c <_usart_async_init>:
{
    240c:	b570      	push	{r4, r5, r6, lr}
    240e:	460d      	mov	r5, r1
	ASSERT(device);
    2410:	4606      	mov	r6, r0
    2412:	22cb      	movs	r2, #203	; 0xcb
    2414:	4918      	ldr	r1, [pc, #96]	; (2478 <_usart_async_init+0x6c>)
    2416:	3000      	adds	r0, #0
    2418:	bf18      	it	ne
    241a:	2001      	movne	r0, #1
    241c:	4b17      	ldr	r3, [pc, #92]	; (247c <_usart_async_init+0x70>)
    241e:	4798      	blx	r3
	init_status = _usart_init(hw);
    2420:	4628      	mov	r0, r5
    2422:	4b17      	ldr	r3, [pc, #92]	; (2480 <_usart_async_init+0x74>)
    2424:	4798      	blx	r3
	if (init_status) {
    2426:	4604      	mov	r4, r0
    2428:	b108      	cbz	r0, 242e <_usart_async_init+0x22>
}
    242a:	4620      	mov	r0, r4
    242c:	bd70      	pop	{r4, r5, r6, pc}
	device->hw = hw;
    242e:	61b5      	str	r5, [r6, #24]
	if (hw == SERCOM0) {
    2430:	4b14      	ldr	r3, [pc, #80]	; (2484 <_usart_async_init+0x78>)
    2432:	429d      	cmp	r5, r3
		_sercom0_dev = (struct _usart_async_device *)dev;
    2434:	bf04      	itt	eq
    2436:	4b14      	ldreq	r3, [pc, #80]	; (2488 <_usart_async_init+0x7c>)
    2438:	601e      	streq	r6, [r3, #0]
	uint8_t irq = _sercom_get_irq_num(hw);
    243a:	4628      	mov	r0, r5
    243c:	4b13      	ldr	r3, [pc, #76]	; (248c <_usart_async_init+0x80>)
    243e:	4798      	blx	r3
    2440:	1d01      	adds	r1, r0, #4
    2442:	b2c9      	uxtb	r1, r1
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2444:	2501      	movs	r5, #1
    2446:	f000 021f 	and.w	r2, r0, #31
    244a:	fa05 f202 	lsl.w	r2, r5, r2
    244e:	0943      	lsrs	r3, r0, #5
    2450:	009b      	lsls	r3, r3, #2
    2452:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    2456:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    245a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    245e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2462:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2466:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    246a:	601a      	str	r2, [r3, #0]
		irq++;
    246c:	3001      	adds	r0, #1
    246e:	b2c0      	uxtb	r0, r0
	for (uint32_t i = 0; i < 4; i++) {
    2470:	4281      	cmp	r1, r0
    2472:	d1e8      	bne.n	2446 <_usart_async_init+0x3a>
    2474:	e7d9      	b.n	242a <_usart_async_init+0x1e>
    2476:	bf00      	nop
    2478:	0000b37c 	.word	0x0000b37c
    247c:	0000187d 	.word	0x0000187d
    2480:	000021bd 	.word	0x000021bd
    2484:	40003000 	.word	0x40003000
    2488:	20001624 	.word	0x20001624
    248c:	000021a9 	.word	0x000021a9

00002490 <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    2490:	6802      	ldr	r2, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    2492:	6813      	ldr	r3, [r2, #0]
    2494:	f043 0302 	orr.w	r3, r3, #2
    2498:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    249a:	69d3      	ldr	r3, [r2, #28]
    249c:	f013 0f03 	tst.w	r3, #3
    24a0:	d1fb      	bne.n	249a <_usart_sync_enable+0xa>
}
    24a2:	4770      	bx	lr

000024a4 <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    24a4:	6982      	ldr	r2, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    24a6:	6813      	ldr	r3, [r2, #0]
    24a8:	f043 0302 	orr.w	r3, r3, #2
    24ac:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    24ae:	69d3      	ldr	r3, [r2, #28]
    24b0:	f013 0f03 	tst.w	r3, #3
    24b4:	d1fb      	bne.n	24ae <_usart_async_enable+0xa>
}
    24b6:	4770      	bx	lr

000024b8 <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    24b8:	6803      	ldr	r3, [r0, #0]
	((Sercom *)hw)->USART.DATA.reg = data;
    24ba:	6299      	str	r1, [r3, #40]	; 0x28
    24bc:	4770      	bx	lr

000024be <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    24be:	6983      	ldr	r3, [r0, #24]
    24c0:	6299      	str	r1, [r3, #40]	; 0x28
    24c2:	4770      	bx	lr

000024c4 <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
    24c4:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
    24c6:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
    24c8:	b2c0      	uxtb	r0, r0
    24ca:	4770      	bx	lr

000024cc <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    24cc:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    24ce:	7e18      	ldrb	r0, [r3, #24]
}
    24d0:	f000 0001 	and.w	r0, r0, #1
    24d4:	4770      	bx	lr

000024d6 <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    24d6:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    24d8:	7e18      	ldrb	r0, [r3, #24]
}
    24da:	f3c0 0040 	ubfx	r0, r0, #1, #1
    24de:	4770      	bx	lr

000024e0 <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    24e0:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    24e2:	7e18      	ldrb	r0, [r3, #24]
}
    24e4:	f3c0 0080 	ubfx	r0, r0, #2, #1
    24e8:	4770      	bx	lr

000024ea <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
    24ea:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
    24ec:	2201      	movs	r2, #1
    24ee:	759a      	strb	r2, [r3, #22]
    24f0:	4770      	bx	lr

000024f2 <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
    24f2:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
    24f4:	2202      	movs	r2, #2
    24f6:	759a      	strb	r2, [r3, #22]
    24f8:	4770      	bx	lr
	...

000024fc <_usart_async_set_irq_state>:
{
    24fc:	b570      	push	{r4, r5, r6, lr}
    24fe:	460c      	mov	r4, r1
    2500:	4616      	mov	r6, r2
	ASSERT(device);
    2502:	4605      	mov	r5, r0
    2504:	f240 222b 	movw	r2, #555	; 0x22b
    2508:	4915      	ldr	r1, [pc, #84]	; (2560 <_usart_async_set_irq_state+0x64>)
    250a:	3000      	adds	r0, #0
    250c:	bf18      	it	ne
    250e:	2001      	movne	r0, #1
    2510:	4b14      	ldr	r3, [pc, #80]	; (2564 <_usart_async_set_irq_state+0x68>)
    2512:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
    2514:	f014 0ffd 	tst.w	r4, #253	; 0xfd
    2518:	d10d      	bne.n	2536 <_usart_async_set_irq_state+0x3a>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
    251a:	69ab      	ldr	r3, [r5, #24]
	if (value == 0x0) {
    251c:	b92e      	cbnz	r6, 252a <_usart_async_set_irq_state+0x2e>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
    251e:	2201      	movs	r2, #1
    2520:	751a      	strb	r2, [r3, #20]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
    2522:	69ab      	ldr	r3, [r5, #24]
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
    2524:	2202      	movs	r2, #2
    2526:	751a      	strb	r2, [r3, #20]
    2528:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
    252a:	2201      	movs	r2, #1
    252c:	759a      	strb	r2, [r3, #22]
    252e:	69ab      	ldr	r3, [r5, #24]
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
    2530:	2202      	movs	r2, #2
    2532:	759a      	strb	r2, [r3, #22]
    2534:	bd70      	pop	{r4, r5, r6, pc}
	} else if (USART_ASYNC_RX_DONE == type) {
    2536:	2c01      	cmp	r4, #1
    2538:	d002      	beq.n	2540 <_usart_async_set_irq_state+0x44>
	} else if (USART_ASYNC_ERROR == type) {
    253a:	2c03      	cmp	r4, #3
    253c:	d008      	beq.n	2550 <_usart_async_set_irq_state+0x54>
    253e:	bd70      	pop	{r4, r5, r6, pc}
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
    2540:	69ab      	ldr	r3, [r5, #24]
	if (value == 0x0) {
    2542:	b916      	cbnz	r6, 254a <_usart_async_set_irq_state+0x4e>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_RXC;
    2544:	2204      	movs	r2, #4
    2546:	751a      	strb	r2, [r3, #20]
    2548:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_RXC;
    254a:	2204      	movs	r2, #4
    254c:	759a      	strb	r2, [r3, #22]
    254e:	bd70      	pop	{r4, r5, r6, pc}
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
    2550:	69ab      	ldr	r3, [r5, #24]
	if (value == 0x0) {
    2552:	b116      	cbz	r6, 255a <_usart_async_set_irq_state+0x5e>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
    2554:	2280      	movs	r2, #128	; 0x80
    2556:	759a      	strb	r2, [r3, #22]
}
    2558:	e7f1      	b.n	253e <_usart_async_set_irq_state+0x42>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
    255a:	2280      	movs	r2, #128	; 0x80
    255c:	751a      	strb	r2, [r3, #20]
    255e:	bd70      	pop	{r4, r5, r6, pc}
    2560:	0000b37c 	.word	0x0000b37c
    2564:	0000187d 	.word	0x0000187d

00002568 <_i2c_m_sync_init>:
{
    2568:	b538      	push	{r3, r4, r5, lr}
    256a:	460d      	mov	r5, r1
	ASSERT(i2c_dev);
    256c:	4604      	mov	r4, r0
    256e:	f44f 62a8 	mov.w	r2, #1344	; 0x540
    2572:	4906      	ldr	r1, [pc, #24]	; (258c <_i2c_m_sync_init+0x24>)
    2574:	3000      	adds	r0, #0
    2576:	bf18      	it	ne
    2578:	2001      	movne	r0, #1
    257a:	4b05      	ldr	r3, [pc, #20]	; (2590 <_i2c_m_sync_init+0x28>)
    257c:	4798      	blx	r3
	i2c_dev->hw = hw;
    257e:	6125      	str	r5, [r4, #16]
	return _i2c_m_sync_init_impl(&i2c_dev->service, hw);
    2580:	4629      	mov	r1, r5
    2582:	4620      	mov	r0, r4
    2584:	4b03      	ldr	r3, [pc, #12]	; (2594 <_i2c_m_sync_init+0x2c>)
    2586:	4798      	blx	r3
}
    2588:	bd38      	pop	{r3, r4, r5, pc}
    258a:	bf00      	nop
    258c:	0000b37c 	.word	0x0000b37c
    2590:	0000187d 	.word	0x0000187d
    2594:	00002305 	.word	0x00002305

00002598 <_i2c_m_sync_enable>:
{
    2598:	b570      	push	{r4, r5, r6, lr}
	ASSERT(i2c_dev);
    259a:	4e1b      	ldr	r6, [pc, #108]	; (2608 <_i2c_m_sync_enable+0x70>)
    259c:	4604      	mov	r4, r0
    259e:	f240 525d 	movw	r2, #1373	; 0x55d
    25a2:	4631      	mov	r1, r6
    25a4:	3000      	adds	r0, #0
    25a6:	bf18      	it	ne
    25a8:	2001      	movne	r0, #1
    25aa:	4d18      	ldr	r5, [pc, #96]	; (260c <_i2c_m_sync_enable+0x74>)
    25ac:	47a8      	blx	r5
	return _i2c_m_enable_implementation(i2c_dev->hw);
    25ae:	6924      	ldr	r4, [r4, #16]
	ASSERT(hw);
    25b0:	f240 622d 	movw	r2, #1581	; 0x62d
    25b4:	4631      	mov	r1, r6
    25b6:	1c20      	adds	r0, r4, #0
    25b8:	bf18      	it	ne
    25ba:	2001      	movne	r0, #1
    25bc:	47a8      	blx	r5
	((Sercom *)hw)->I2CM.CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
    25be:	6823      	ldr	r3, [r4, #0]
    25c0:	f043 0302 	orr.w	r3, r3, #2
    25c4:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    25c6:	69e3      	ldr	r3, [r4, #28]
    25c8:	f013 0f03 	tst.w	r3, #3
    25cc:	d1fb      	bne.n	25c6 <_i2c_m_sync_enable+0x2e>
    25ce:	2104      	movs	r1, #4
}

static inline void hri_sercomi2cm_clear_STATUS_reg(const void *const hw, hri_sercomi2cm_status_reg_t mask)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.STATUS.reg = mask;
    25d0:	2010      	movs	r0, #16
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    25d2:	f64f 72ff 	movw	r2, #65535	; 0xffff
    25d6:	69e3      	ldr	r3, [r4, #28]
    25d8:	f013 0f04 	tst.w	r3, #4
    25dc:	d1fb      	bne.n	25d6 <_i2c_m_sync_enable+0x3e>
	return (((Sercom *)hw)->I2CM.STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE_Msk) >> SERCOM_I2CM_STATUS_BUSSTATE_Pos;
    25de:	8b63      	ldrh	r3, [r4, #26]
	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
    25e0:	f3c3 1301 	ubfx	r3, r3, #4, #2
    25e4:	2b01      	cmp	r3, #1
    25e6:	d009      	beq.n	25fc <_i2c_m_sync_enable+0x64>
		if (timeout <= 0) {
    25e8:	3a01      	subs	r2, #1
    25ea:	d1f4      	bne.n	25d6 <_i2c_m_sync_enable+0x3e>
			if (--timeout_attempt)
    25ec:	3901      	subs	r1, #1
    25ee:	d007      	beq.n	2600 <_i2c_m_sync_enable+0x68>
	((Sercom *)hw)->I2CM.STATUS.reg = mask;
    25f0:	8360      	strh	r0, [r4, #26]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    25f2:	69e3      	ldr	r3, [r4, #28]
    25f4:	f013 0f04 	tst.w	r3, #4
    25f8:	d1fb      	bne.n	25f2 <_i2c_m_sync_enable+0x5a>
    25fa:	e7ea      	b.n	25d2 <_i2c_m_sync_enable+0x3a>
	return ERR_NONE;
    25fc:	2000      	movs	r0, #0
    25fe:	bd70      	pop	{r4, r5, r6, pc}
				return I2C_ERR_BUSY;
    2600:	f06f 0005 	mvn.w	r0, #5
}
    2604:	bd70      	pop	{r4, r5, r6, pc}
    2606:	bf00      	nop
    2608:	0000b37c 	.word	0x0000b37c
    260c:	0000187d 	.word	0x0000187d

00002610 <_i2c_m_sync_transfer>:
{
    2610:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2614:	4605      	mov	r5, r0
    2616:	460e      	mov	r6, r1
	void *   hw = i2c_dev->hw;
    2618:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
    261a:	f110 0800 	adds.w	r8, r0, #0
    261e:	bf18      	it	ne
    2620:	f04f 0801 	movne.w	r8, #1
    2624:	f8df 92c4 	ldr.w	r9, [pc, #708]	; 28ec <_i2c_m_sync_transfer+0x2dc>
    2628:	f44f 62bf 	mov.w	r2, #1528	; 0x5f8
    262c:	4649      	mov	r1, r9
    262e:	4640      	mov	r0, r8
    2630:	4fad      	ldr	r7, [pc, #692]	; (28e8 <_i2c_m_sync_transfer+0x2d8>)
    2632:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
    2634:	6928      	ldr	r0, [r5, #16]
    2636:	f240 52f9 	movw	r2, #1529	; 0x5f9
    263a:	4649      	mov	r1, r9
    263c:	3000      	adds	r0, #0
    263e:	bf18      	it	ne
    2640:	2001      	movne	r0, #1
    2642:	47b8      	blx	r7
	ASSERT(msg);
    2644:	f240 52fa 	movw	r2, #1530	; 0x5fa
    2648:	4649      	mov	r1, r9
    264a:	1c30      	adds	r0, r6, #0
    264c:	bf18      	it	ne
    264e:	2001      	movne	r0, #1
    2650:	47b8      	blx	r7
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    2652:	886b      	ldrh	r3, [r5, #2]
    2654:	f413 7f80 	tst.w	r3, #256	; 0x100
    2658:	f040 8218 	bne.w	2a8c <_i2c_m_sync_transfer+0x47c>
	msg->flags |= I2C_M_BUSY;
    265c:	8873      	ldrh	r3, [r6, #2]
    265e:	b29b      	uxth	r3, r3
    2660:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    2664:	8073      	strh	r3, [r6, #2]
	i2c_dev->service.msg = *msg;
    2666:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
    266a:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
    266e:	6863      	ldr	r3, [r4, #4]
    2670:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    2674:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2676:	69e3      	ldr	r3, [r4, #28]
    2678:	f013 0f04 	tst.w	r3, #4
    267c:	d1fb      	bne.n	2676 <_i2c_m_sync_transfer+0x66>
	void *             hw    = i2c_dev->hw;
    267e:	692f      	ldr	r7, [r5, #16]
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    2680:	f8d7 9000 	ldr.w	r9, [r7]
	ASSERT(i2c_dev);
    2684:	f240 52cd 	movw	r2, #1485	; 0x5cd
    2688:	4998      	ldr	r1, [pc, #608]	; (28ec <_i2c_m_sync_transfer+0x2dc>)
    268a:	4640      	mov	r0, r8
    268c:	4b96      	ldr	r3, [pc, #600]	; (28e8 <_i2c_m_sync_transfer+0x2d8>)
    268e:	4798      	blx	r3
	if (msg->len == 1 && sclsm) {
    2690:	686b      	ldr	r3, [r5, #4]
    2692:	2b01      	cmp	r3, #1
    2694:	d05e      	beq.n	2754 <_i2c_m_sync_transfer+0x144>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    2696:	687b      	ldr	r3, [r7, #4]
    2698:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
    269c:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    269e:	69fb      	ldr	r3, [r7, #28]
    26a0:	f013 0f04 	tst.w	r3, #4
    26a4:	d1fb      	bne.n	269e <_i2c_m_sync_transfer+0x8e>
	if (msg->addr & I2C_M_TEN) {
    26a6:	882b      	ldrh	r3, [r5, #0]
    26a8:	f413 6f80 	tst.w	r3, #1024	; 0x400
    26ac:	d05e      	beq.n	276c <_i2c_m_sync_transfer+0x15c>
		if (msg->flags & I2C_M_RD) {
    26ae:	886a      	ldrh	r2, [r5, #2]
    26b0:	f012 0f01 	tst.w	r2, #1
    26b4:	d004      	beq.n	26c0 <_i2c_m_sync_transfer+0xb0>
			msg->flags |= I2C_M_TEN;
    26b6:	886a      	ldrh	r2, [r5, #2]
    26b8:	b292      	uxth	r2, r2
    26ba:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    26be:	806a      	strh	r2, [r5, #2]
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    26c0:	f240 72fe 	movw	r2, #2046	; 0x7fe
    26c4:	ea02 0243 	and.w	r2, r2, r3, lsl #1
    26c8:	69fb      	ldr	r3, [r7, #28]
    26ca:	f013 0f04 	tst.w	r3, #4
    26ce:	d1fb      	bne.n	26c8 <_i2c_m_sync_transfer+0xb8>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    26d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    26d2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
		hri_sercomi2cm_write_ADDR_reg(hw,
    26d6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    26da:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    26dc:	627b      	str	r3, [r7, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    26de:	69fb      	ldr	r3, [r7, #28]
    26e0:	f013 0f04 	tst.w	r3, #4
    26e4:	d1fb      	bne.n	26de <_i2c_m_sync_transfer+0xce>
	void *   hw      = i2c_dev->hw;
    26e6:	6929      	ldr	r1, [r5, #16]
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    26e8:	7e0b      	ldrb	r3, [r1, #24]
    26ea:	b2db      	uxtb	r3, r3
    26ec:	f64f 72ff 	movw	r2, #65535	; 0xffff
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    26f0:	f013 0f03 	tst.w	r3, #3
    26f4:	d103      	bne.n	26fe <_i2c_m_sync_transfer+0xee>
    26f6:	7e0b      	ldrb	r3, [r1, #24]
    26f8:	b2db      	uxtb	r3, r3
		if (timeout-- == 0) {
    26fa:	3a01      	subs	r2, #1
    26fc:	d1f8      	bne.n	26f0 <_i2c_m_sync_transfer+0xe0>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    26fe:	6839      	ldr	r1, [r7, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2700:	69fa      	ldr	r2, [r7, #28]
    2702:	f012 0f04 	tst.w	r2, #4
    2706:	d1fb      	bne.n	2700 <_i2c_m_sync_transfer+0xf0>
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    2708:	8b7a      	ldrh	r2, [r7, #26]
    270a:	b292      	uxth	r2, r2
	if (flags & MB_FLAG) {
    270c:	f013 0f01 	tst.w	r3, #1
    2710:	f000 80a3 	beq.w	285a <_i2c_m_sync_transfer+0x24a>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    2714:	f012 0f02 	tst.w	r2, #2
    2718:	d03c      	beq.n	2794 <_i2c_m_sync_transfer+0x184>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    271a:	2301      	movs	r3, #1
    271c:	763b      	strb	r3, [r7, #24]
			msg->flags |= I2C_M_FAIL;
    271e:	886b      	ldrh	r3, [r5, #2]
    2720:	b29b      	uxth	r3, r3
    2722:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    2726:	806b      	strh	r3, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
    2728:	886b      	ldrh	r3, [r5, #2]
    272a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    272e:	041b      	lsls	r3, r3, #16
    2730:	0c1b      	lsrs	r3, r3, #16
    2732:	806b      	strh	r3, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    2734:	f002 0201 	and.w	r2, r2, #1
			return I2C_ERR_BAD_ADDRESS;
    2738:	2a00      	cmp	r2, #0
    273a:	bf14      	ite	ne
    273c:	f06f 0004 	mvnne.w	r0, #4
    2740:	f06f 0003 	mvneq.w	r0, #3
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    2744:	886b      	ldrh	r3, [r5, #2]
    2746:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    274a:	041b      	lsls	r3, r3, #16
    274c:	0c1b      	lsrs	r3, r3, #16
    274e:	806b      	strh	r3, [r5, #2]
		return ret;
    2750:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (msg->len == 1 && sclsm) {
    2754:	f019 6f00 	tst.w	r9, #134217728	; 0x8000000
    2758:	d09d      	beq.n	2696 <_i2c_m_sync_transfer+0x86>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    275a:	687b      	ldr	r3, [r7, #4]
    275c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    2760:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2762:	69fb      	ldr	r3, [r7, #28]
    2764:	f013 0f04 	tst.w	r3, #4
    2768:	d1fb      	bne.n	2762 <_i2c_m_sync_transfer+0x152>
    276a:	e79c      	b.n	26a6 <_i2c_m_sync_transfer+0x96>
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
    276c:	8869      	ldrh	r1, [r5, #2]
    276e:	005a      	lsls	r2, r3, #1
    2770:	b2d2      	uxtb	r2, r2
    2772:	f001 0301 	and.w	r3, r1, #1
    2776:	431a      	orrs	r2, r3
    2778:	69fb      	ldr	r3, [r7, #28]
    277a:	f013 0f04 	tst.w	r3, #4
    277e:	d1fb      	bne.n	2778 <_i2c_m_sync_transfer+0x168>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    2780:	6a7b      	ldr	r3, [r7, #36]	; 0x24
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    2782:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
		hri_sercomi2cm_write_ADDR_reg(hw,
    2786:	431a      	orrs	r2, r3
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    2788:	627a      	str	r2, [r7, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    278a:	69fb      	ldr	r3, [r7, #28]
    278c:	f013 0f04 	tst.w	r3, #4
    2790:	d1fb      	bne.n	278a <_i2c_m_sync_transfer+0x17a>
    2792:	e7a8      	b.n	26e6 <_i2c_m_sync_transfer+0xd6>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    2794:	f012 0f04 	tst.w	r2, #4
    2798:	d11d      	bne.n	27d6 <_i2c_m_sync_transfer+0x1c6>
			if (msg->flags & I2C_M_TEN) {
    279a:	886b      	ldrh	r3, [r5, #2]
    279c:	f413 6f80 	tst.w	r3, #1024	; 0x400
    27a0:	d037      	beq.n	2812 <_i2c_m_sync_transfer+0x202>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
    27a2:	882b      	ldrh	r3, [r5, #0]
    27a4:	09db      	lsrs	r3, r3, #7
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    27a6:	f003 0206 	and.w	r2, r3, #6
    27aa:	69fb      	ldr	r3, [r7, #28]
    27ac:	f013 0f04 	tst.w	r3, #4
    27b0:	d1fb      	bne.n	27aa <_i2c_m_sync_transfer+0x19a>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    27b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    27b4:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
				hri_sercomi2cm_write_ADDR_reg(hw,
    27b8:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
    27bc:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    27be:	627b      	str	r3, [r7, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    27c0:	69fb      	ldr	r3, [r7, #28]
    27c2:	f013 0f04 	tst.w	r3, #4
    27c6:	d1fb      	bne.n	27c0 <_i2c_m_sync_transfer+0x1b0>
				msg->flags &= ~I2C_M_TEN;
    27c8:	886b      	ldrh	r3, [r5, #2]
    27ca:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    27ce:	041b      	lsls	r3, r3, #16
    27d0:	0c1b      	lsrs	r3, r3, #16
    27d2:	806b      	strh	r3, [r5, #2]
    27d4:	e069      	b.n	28aa <_i2c_m_sync_transfer+0x29a>
				if (msg->len > 0) {
    27d6:	686b      	ldr	r3, [r5, #4]
    27d8:	2b00      	cmp	r3, #0
    27da:	dd04      	ble.n	27e6 <_i2c_m_sync_transfer+0x1d6>
					msg->flags |= I2C_M_FAIL;
    27dc:	886b      	ldrh	r3, [r5, #2]
    27de:	b29b      	uxth	r3, r3
    27e0:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    27e4:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
    27e6:	886b      	ldrh	r3, [r5, #2]
    27e8:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    27ec:	d108      	bne.n	2800 <_i2c_m_sync_transfer+0x1f0>
				msg->flags &= ~I2C_M_BUSY;
    27ee:	886b      	ldrh	r3, [r5, #2]
    27f0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    27f4:	041b      	lsls	r3, r3, #16
    27f6:	0c1b      	lsrs	r3, r3, #16
    27f8:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
    27fa:	f06f 0001 	mvn.w	r0, #1
    27fe:	e7a1      	b.n	2744 <_i2c_m_sync_transfer+0x134>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    2800:	687b      	ldr	r3, [r7, #4]
    2802:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    2806:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2808:	69fb      	ldr	r3, [r7, #28]
    280a:	f013 0f04 	tst.w	r3, #4
    280e:	d1fb      	bne.n	2808 <_i2c_m_sync_transfer+0x1f8>
    2810:	e7ed      	b.n	27ee <_i2c_m_sync_transfer+0x1de>
			if (msg->len == 0) {
    2812:	686b      	ldr	r3, [r5, #4]
    2814:	b99b      	cbnz	r3, 283e <_i2c_m_sync_transfer+0x22e>
				if (msg->flags & I2C_M_STOP) {
    2816:	886b      	ldrh	r3, [r5, #2]
    2818:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    281c:	d106      	bne.n	282c <_i2c_m_sync_transfer+0x21c>
				msg->flags &= ~I2C_M_BUSY;
    281e:	886b      	ldrh	r3, [r5, #2]
    2820:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    2824:	041b      	lsls	r3, r3, #16
    2826:	0c1b      	lsrs	r3, r3, #16
    2828:	806b      	strh	r3, [r5, #2]
    282a:	e03e      	b.n	28aa <_i2c_m_sync_transfer+0x29a>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    282c:	687b      	ldr	r3, [r7, #4]
    282e:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    2832:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2834:	69fb      	ldr	r3, [r7, #28]
    2836:	f013 0f04 	tst.w	r3, #4
    283a:	d1fb      	bne.n	2834 <_i2c_m_sync_transfer+0x224>
    283c:	e7ef      	b.n	281e <_i2c_m_sync_transfer+0x20e>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    283e:	68ab      	ldr	r3, [r5, #8]
    2840:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
    2842:	62bb      	str	r3, [r7, #40]	; 0x28
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2844:	69fb      	ldr	r3, [r7, #28]
    2846:	f013 0f04 	tst.w	r3, #4
    284a:	d1fb      	bne.n	2844 <_i2c_m_sync_transfer+0x234>
				msg->buffer++;
    284c:	68ab      	ldr	r3, [r5, #8]
    284e:	3301      	adds	r3, #1
    2850:	60ab      	str	r3, [r5, #8]
				msg->len--;
    2852:	686b      	ldr	r3, [r5, #4]
    2854:	3b01      	subs	r3, #1
    2856:	606b      	str	r3, [r5, #4]
    2858:	e027      	b.n	28aa <_i2c_m_sync_transfer+0x29a>
	} else if (flags & SB_FLAG) {
    285a:	f013 0f02 	tst.w	r3, #2
    285e:	d024      	beq.n	28aa <_i2c_m_sync_transfer+0x29a>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    2860:	686b      	ldr	r3, [r5, #4]
    2862:	2b00      	cmp	r3, #0
    2864:	d03a      	beq.n	28dc <_i2c_m_sync_transfer+0x2cc>
    2866:	f012 0f04 	tst.w	r2, #4
    286a:	d137      	bne.n	28dc <_i2c_m_sync_transfer+0x2cc>
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
    286c:	f3c1 61c0 	ubfx	r1, r1, #27, #1
			msg->len--;
    2870:	3b01      	subs	r3, #1
    2872:	606b      	str	r3, [r5, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    2874:	2b00      	cmp	r3, #0
    2876:	f040 810d 	bne.w	2a94 <_i2c_m_sync_transfer+0x484>
    287a:	2900      	cmp	r1, #0
    287c:	f000 8110 	beq.w	2aa0 <_i2c_m_sync_transfer+0x490>
				if (msg->flags & I2C_M_STOP) {
    2880:	886b      	ldrh	r3, [r5, #2]
    2882:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    2886:	d118      	bne.n	28ba <_i2c_m_sync_transfer+0x2aa>
				msg->flags &= ~I2C_M_BUSY;
    2888:	886b      	ldrh	r3, [r5, #2]
    288a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    288e:	041b      	lsls	r3, r3, #16
    2890:	0c1b      	lsrs	r3, r3, #16
    2892:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    2894:	68aa      	ldr	r2, [r5, #8]
    2896:	1c53      	adds	r3, r2, #1
    2898:	60ab      	str	r3, [r5, #8]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    289a:	69fb      	ldr	r3, [r7, #28]
    289c:	f013 0f04 	tst.w	r3, #4
    28a0:	d1fb      	bne.n	289a <_i2c_m_sync_transfer+0x28a>
	return ((Sercom *)hw)->I2CM.DATA.reg;
    28a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    28a4:	7013      	strb	r3, [r2, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    28a6:	2302      	movs	r3, #2
    28a8:	763b      	strb	r3, [r7, #24]
			return I2C_NACK;
    28aa:	2200      	movs	r2, #0
	return I2C_OK;
    28ac:	4610      	mov	r0, r2
    28ae:	2702      	movs	r7, #2
			return I2C_NACK;
    28b0:	f06f 0c01 	mvn.w	ip, #1
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    28b4:	f04f 0e01 	mov.w	lr, #1
    28b8:	e0b0      	b.n	2a1c <_i2c_m_sync_transfer+0x40c>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    28ba:	687b      	ldr	r3, [r7, #4]
    28bc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    28c0:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    28c2:	69fb      	ldr	r3, [r7, #28]
    28c4:	f013 0f04 	tst.w	r3, #4
    28c8:	d1fb      	bne.n	28c2 <_i2c_m_sync_transfer+0x2b2>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    28ca:	687b      	ldr	r3, [r7, #4]
    28cc:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    28d0:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    28d2:	69fb      	ldr	r3, [r7, #28]
    28d4:	f013 0f04 	tst.w	r3, #4
    28d8:	d1fb      	bne.n	28d2 <_i2c_m_sync_transfer+0x2c2>
    28da:	e7d5      	b.n	2888 <_i2c_m_sync_transfer+0x278>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    28dc:	2302      	movs	r3, #2
    28de:	763b      	strb	r3, [r7, #24]
    28e0:	f06f 0001 	mvn.w	r0, #1
    28e4:	e72e      	b.n	2744 <_i2c_m_sync_transfer+0x134>
    28e6:	bf00      	nop
    28e8:	0000187d 	.word	0x0000187d
    28ec:	0000b37c 	.word	0x0000b37c
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    28f0:	6863      	ldr	r3, [r4, #4]
    28f2:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    28f6:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    28f8:	69e3      	ldr	r3, [r4, #28]
    28fa:	f013 0f04 	tst.w	r3, #4
    28fe:	d1fb      	bne.n	28f8 <_i2c_m_sync_transfer+0x2e8>
    2900:	e0a1      	b.n	2a46 <_i2c_m_sync_transfer+0x436>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    2902:	f012 0f04 	tst.w	r2, #4
    2906:	d11e      	bne.n	2946 <_i2c_m_sync_transfer+0x336>
			if (msg->flags & I2C_M_TEN) {
    2908:	886b      	ldrh	r3, [r5, #2]
    290a:	f413 6f80 	tst.w	r3, #1024	; 0x400
    290e:	d037      	beq.n	2980 <_i2c_m_sync_transfer+0x370>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
    2910:	882b      	ldrh	r3, [r5, #0]
    2912:	09db      	lsrs	r3, r3, #7
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    2914:	f003 0206 	and.w	r2, r3, #6
    2918:	69e3      	ldr	r3, [r4, #28]
    291a:	f013 0f04 	tst.w	r3, #4
    291e:	d1fb      	bne.n	2918 <_i2c_m_sync_transfer+0x308>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    2920:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2922:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
				hri_sercomi2cm_write_ADDR_reg(hw,
    2926:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
    292a:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    292c:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    292e:	69e3      	ldr	r3, [r4, #28]
    2930:	f013 0f04 	tst.w	r3, #4
    2934:	d1fb      	bne.n	292e <_i2c_m_sync_transfer+0x31e>
				msg->flags &= ~I2C_M_TEN;
    2936:	886b      	ldrh	r3, [r5, #2]
    2938:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    293c:	041b      	lsls	r3, r3, #16
    293e:	0c1b      	lsrs	r3, r3, #16
    2940:	806b      	strh	r3, [r5, #2]
				return I2C_OK;
    2942:	4602      	mov	r2, r0
    2944:	e06a      	b.n	2a1c <_i2c_m_sync_transfer+0x40c>
				if (msg->len > 0) {
    2946:	686b      	ldr	r3, [r5, #4]
    2948:	2b00      	cmp	r3, #0
    294a:	dd04      	ble.n	2956 <_i2c_m_sync_transfer+0x346>
					msg->flags |= I2C_M_FAIL;
    294c:	886b      	ldrh	r3, [r5, #2]
    294e:	b29b      	uxth	r3, r3
    2950:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    2954:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
    2956:	886b      	ldrh	r3, [r5, #2]
    2958:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    295c:	d107      	bne.n	296e <_i2c_m_sync_transfer+0x35e>
				msg->flags &= ~I2C_M_BUSY;
    295e:	886b      	ldrh	r3, [r5, #2]
    2960:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    2964:	041b      	lsls	r3, r3, #16
    2966:	0c1b      	lsrs	r3, r3, #16
    2968:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
    296a:	4662      	mov	r2, ip
    296c:	e056      	b.n	2a1c <_i2c_m_sync_transfer+0x40c>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    296e:	6863      	ldr	r3, [r4, #4]
    2970:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    2974:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2976:	69e3      	ldr	r3, [r4, #28]
    2978:	f013 0f04 	tst.w	r3, #4
    297c:	d1fb      	bne.n	2976 <_i2c_m_sync_transfer+0x366>
    297e:	e7ee      	b.n	295e <_i2c_m_sync_transfer+0x34e>
			if (msg->len == 0) {
    2980:	686b      	ldr	r3, [r5, #4]
    2982:	b9a3      	cbnz	r3, 29ae <_i2c_m_sync_transfer+0x39e>
				if (msg->flags & I2C_M_STOP) {
    2984:	886b      	ldrh	r3, [r5, #2]
    2986:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    298a:	d107      	bne.n	299c <_i2c_m_sync_transfer+0x38c>
				msg->flags &= ~I2C_M_BUSY;
    298c:	886b      	ldrh	r3, [r5, #2]
    298e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    2992:	041b      	lsls	r3, r3, #16
    2994:	0c1b      	lsrs	r3, r3, #16
    2996:	806b      	strh	r3, [r5, #2]
			return I2C_OK;
    2998:	4602      	mov	r2, r0
    299a:	e03f      	b.n	2a1c <_i2c_m_sync_transfer+0x40c>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    299c:	6863      	ldr	r3, [r4, #4]
    299e:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    29a2:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    29a4:	69e3      	ldr	r3, [r4, #28]
    29a6:	f013 0f04 	tst.w	r3, #4
    29aa:	d1fb      	bne.n	29a4 <_i2c_m_sync_transfer+0x394>
    29ac:	e7ee      	b.n	298c <_i2c_m_sync_transfer+0x37c>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    29ae:	68ab      	ldr	r3, [r5, #8]
    29b0:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
    29b2:	62a3      	str	r3, [r4, #40]	; 0x28
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    29b4:	69e3      	ldr	r3, [r4, #28]
    29b6:	f013 0f04 	tst.w	r3, #4
    29ba:	d1fb      	bne.n	29b4 <_i2c_m_sync_transfer+0x3a4>
				msg->buffer++;
    29bc:	68ab      	ldr	r3, [r5, #8]
    29be:	3301      	adds	r3, #1
    29c0:	60ab      	str	r3, [r5, #8]
				msg->len--;
    29c2:	686b      	ldr	r3, [r5, #4]
    29c4:	3b01      	subs	r3, #1
    29c6:	606b      	str	r3, [r5, #4]
			return I2C_OK;
    29c8:	4602      	mov	r2, r0
    29ca:	e027      	b.n	2a1c <_i2c_m_sync_transfer+0x40c>
	} else if (flags & SB_FLAG) {
    29cc:	f013 0f02 	tst.w	r3, #2
    29d0:	d057      	beq.n	2a82 <_i2c_m_sync_transfer+0x472>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    29d2:	686b      	ldr	r3, [r5, #4]
    29d4:	2b00      	cmp	r3, #0
    29d6:	d051      	beq.n	2a7c <_i2c_m_sync_transfer+0x46c>
    29d8:	f012 0f04 	tst.w	r2, #4
    29dc:	d14e      	bne.n	2a7c <_i2c_m_sync_transfer+0x46c>
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
    29de:	f3c1 61c0 	ubfx	r1, r1, #27, #1
			msg->len--;
    29e2:	3b01      	subs	r3, #1
    29e4:	606b      	str	r3, [r5, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    29e6:	2b00      	cmp	r3, #0
    29e8:	f040 808c 	bne.w	2b04 <_i2c_m_sync_transfer+0x4f4>
    29ec:	2900      	cmp	r1, #0
    29ee:	f000 808f 	beq.w	2b10 <_i2c_m_sync_transfer+0x500>
				if (msg->flags & I2C_M_STOP) {
    29f2:	886b      	ldrh	r3, [r5, #2]
    29f4:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    29f8:	d12f      	bne.n	2a5a <_i2c_m_sync_transfer+0x44a>
				msg->flags &= ~I2C_M_BUSY;
    29fa:	886b      	ldrh	r3, [r5, #2]
    29fc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    2a00:	041b      	lsls	r3, r3, #16
    2a02:	0c1b      	lsrs	r3, r3, #16
    2a04:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    2a06:	68aa      	ldr	r2, [r5, #8]
    2a08:	1c53      	adds	r3, r2, #1
    2a0a:	60ab      	str	r3, [r5, #8]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2a0c:	69e3      	ldr	r3, [r4, #28]
    2a0e:	f013 0f04 	tst.w	r3, #4
    2a12:	d1fb      	bne.n	2a0c <_i2c_m_sync_transfer+0x3fc>
	return ((Sercom *)hw)->I2CM.DATA.reg;
    2a14:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2a16:	7013      	strb	r3, [r2, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    2a18:	7627      	strb	r7, [r4, #24]
	return I2C_OK;
    2a1a:	4602      	mov	r2, r0
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    2a1c:	886b      	ldrh	r3, [r5, #2]
    2a1e:	f413 7f80 	tst.w	r3, #256	; 0x100
    2a22:	d030      	beq.n	2a86 <_i2c_m_sync_transfer+0x476>
	void *   hw      = i2c_dev->hw;
    2a24:	6929      	ldr	r1, [r5, #16]
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    2a26:	7e0b      	ldrb	r3, [r1, #24]
    2a28:	b2db      	uxtb	r3, r3
    2a2a:	f64f 72ff 	movw	r2, #65535	; 0xffff
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    2a2e:	f013 0f03 	tst.w	r3, #3
    2a32:	d142      	bne.n	2aba <_i2c_m_sync_transfer+0x4aa>
    2a34:	7e0b      	ldrb	r3, [r1, #24]
    2a36:	b2db      	uxtb	r3, r3
		if (timeout-- == 0) {
    2a38:	3a01      	subs	r2, #1
    2a3a:	d1f8      	bne.n	2a2e <_i2c_m_sync_transfer+0x41e>
			if (msg->flags & I2C_M_STOP) {
    2a3c:	8873      	ldrh	r3, [r6, #2]
    2a3e:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    2a42:	f47f af55 	bne.w	28f0 <_i2c_m_sync_transfer+0x2e0>
			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    2a46:	886b      	ldrh	r3, [r5, #2]
    2a48:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    2a4c:	041b      	lsls	r3, r3, #16
    2a4e:	0c1b      	lsrs	r3, r3, #16
    2a50:	806b      	strh	r3, [r5, #2]
			return I2C_ERR_BUS;
    2a52:	f06f 0004 	mvn.w	r0, #4
			return ret;
    2a56:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    2a5a:	6863      	ldr	r3, [r4, #4]
    2a5c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    2a60:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2a62:	69e3      	ldr	r3, [r4, #28]
    2a64:	f013 0f04 	tst.w	r3, #4
    2a68:	d1fb      	bne.n	2a62 <_i2c_m_sync_transfer+0x452>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    2a6a:	6863      	ldr	r3, [r4, #4]
    2a6c:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
    2a70:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2a72:	69e3      	ldr	r3, [r4, #28]
    2a74:	f013 0f04 	tst.w	r3, #4
    2a78:	d1fb      	bne.n	2a72 <_i2c_m_sync_transfer+0x462>
    2a7a:	e7be      	b.n	29fa <_i2c_m_sync_transfer+0x3ea>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    2a7c:	7627      	strb	r7, [r4, #24]
			return I2C_NACK;
    2a7e:	4662      	mov	r2, ip
    2a80:	e7cc      	b.n	2a1c <_i2c_m_sync_transfer+0x40c>
	return I2C_OK;
    2a82:	4602      	mov	r2, r0
    2a84:	e7ca      	b.n	2a1c <_i2c_m_sync_transfer+0x40c>
    2a86:	4610      	mov	r0, r2
    2a88:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return I2C_ERR_BUSY;
    2a8c:	f06f 0005 	mvn.w	r0, #5
    2a90:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    2a94:	2b01      	cmp	r3, #1
    2a96:	f47f aefd 	bne.w	2894 <_i2c_m_sync_transfer+0x284>
    2a9a:	2900      	cmp	r1, #0
    2a9c:	f43f aefa 	beq.w	2894 <_i2c_m_sync_transfer+0x284>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    2aa0:	687b      	ldr	r3, [r7, #4]
    2aa2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    2aa6:	607b      	str	r3, [r7, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2aa8:	69fb      	ldr	r3, [r7, #28]
    2aaa:	f013 0f04 	tst.w	r3, #4
    2aae:	d1fb      	bne.n	2aa8 <_i2c_m_sync_transfer+0x498>
			if (msg->len == 0) {
    2ab0:	686b      	ldr	r3, [r5, #4]
    2ab2:	2b00      	cmp	r3, #0
    2ab4:	f43f aee4 	beq.w	2880 <_i2c_m_sync_transfer+0x270>
    2ab8:	e6ec      	b.n	2894 <_i2c_m_sync_transfer+0x284>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    2aba:	6821      	ldr	r1, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2abc:	69e2      	ldr	r2, [r4, #28]
    2abe:	f012 0f04 	tst.w	r2, #4
    2ac2:	d1fb      	bne.n	2abc <_i2c_m_sync_transfer+0x4ac>
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    2ac4:	8b62      	ldrh	r2, [r4, #26]
    2ac6:	b292      	uxth	r2, r2
	if (flags & MB_FLAG) {
    2ac8:	f013 0f01 	tst.w	r3, #1
    2acc:	f43f af7e 	beq.w	29cc <_i2c_m_sync_transfer+0x3bc>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    2ad0:	f012 0f02 	tst.w	r2, #2
    2ad4:	f43f af15 	beq.w	2902 <_i2c_m_sync_transfer+0x2f2>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    2ad8:	f884 e018 	strb.w	lr, [r4, #24]
			msg->flags |= I2C_M_FAIL;
    2adc:	886b      	ldrh	r3, [r5, #2]
    2ade:	b29b      	uxth	r3, r3
    2ae0:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    2ae4:	806b      	strh	r3, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
    2ae6:	886b      	ldrh	r3, [r5, #2]
    2ae8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    2aec:	041b      	lsls	r3, r3, #16
    2aee:	0c1b      	lsrs	r3, r3, #16
    2af0:	806b      	strh	r3, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    2af2:	f002 0201 	and.w	r2, r2, #1
			return I2C_ERR_BAD_ADDRESS;
    2af6:	2a00      	cmp	r2, #0
    2af8:	bf14      	ite	ne
    2afa:	f06f 0204 	mvnne.w	r2, #4
    2afe:	f06f 0203 	mvneq.w	r2, #3
    2b02:	e78b      	b.n	2a1c <_i2c_m_sync_transfer+0x40c>
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    2b04:	2b01      	cmp	r3, #1
    2b06:	f47f af7e 	bne.w	2a06 <_i2c_m_sync_transfer+0x3f6>
    2b0a:	2900      	cmp	r1, #0
    2b0c:	f43f af7b 	beq.w	2a06 <_i2c_m_sync_transfer+0x3f6>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    2b10:	6863      	ldr	r3, [r4, #4]
    2b12:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    2b16:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2b18:	69e3      	ldr	r3, [r4, #28]
    2b1a:	f013 0f04 	tst.w	r3, #4
    2b1e:	d1fb      	bne.n	2b18 <_i2c_m_sync_transfer+0x508>
			if (msg->len == 0) {
    2b20:	686b      	ldr	r3, [r5, #4]
    2b22:	2b00      	cmp	r3, #0
    2b24:	f43f af65 	beq.w	29f2 <_i2c_m_sync_transfer+0x3e2>
    2b28:	e76d      	b.n	2a06 <_i2c_m_sync_transfer+0x3f6>
    2b2a:	bf00      	nop

00002b2c <SERCOM0_0_Handler>:

/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_0_Handler(void)
{
    2b2c:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom0_dev);
    2b2e:	4b02      	ldr	r3, [pc, #8]	; (2b38 <SERCOM0_0_Handler+0xc>)
    2b30:	6818      	ldr	r0, [r3, #0]
    2b32:	4b02      	ldr	r3, [pc, #8]	; (2b3c <SERCOM0_0_Handler+0x10>)
    2b34:	4798      	blx	r3
    2b36:	bd08      	pop	{r3, pc}
    2b38:	20001624 	.word	0x20001624
    2b3c:	00002139 	.word	0x00002139

00002b40 <SERCOM0_1_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_1_Handler(void)
{
    2b40:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom0_dev);
    2b42:	4b02      	ldr	r3, [pc, #8]	; (2b4c <SERCOM0_1_Handler+0xc>)
    2b44:	6818      	ldr	r0, [r3, #0]
    2b46:	4b02      	ldr	r3, [pc, #8]	; (2b50 <SERCOM0_1_Handler+0x10>)
    2b48:	4798      	blx	r3
    2b4a:	bd08      	pop	{r3, pc}
    2b4c:	20001624 	.word	0x20001624
    2b50:	00002139 	.word	0x00002139

00002b54 <SERCOM0_2_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_2_Handler(void)
{
    2b54:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom0_dev);
    2b56:	4b02      	ldr	r3, [pc, #8]	; (2b60 <SERCOM0_2_Handler+0xc>)
    2b58:	6818      	ldr	r0, [r3, #0]
    2b5a:	4b02      	ldr	r3, [pc, #8]	; (2b64 <SERCOM0_2_Handler+0x10>)
    2b5c:	4798      	blx	r3
    2b5e:	bd08      	pop	{r3, pc}
    2b60:	20001624 	.word	0x20001624
    2b64:	00002139 	.word	0x00002139

00002b68 <SERCOM0_3_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_3_Handler(void)
{
    2b68:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom0_dev);
    2b6a:	4b02      	ldr	r3, [pc, #8]	; (2b74 <SERCOM0_3_Handler+0xc>)
    2b6c:	6818      	ldr	r0, [r3, #0]
    2b6e:	4b02      	ldr	r3, [pc, #8]	; (2b78 <SERCOM0_3_Handler+0x10>)
    2b70:	4798      	blx	r3
    2b72:	bd08      	pop	{r3, pc}
    2b74:	20001624 	.word	0x20001624
    2b78:	00002139 	.word	0x00002139

00002b7c <get_tc_index>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The index of TC configuration
 */
static int8_t get_tc_index(const void *const hw)
{
    2b7c:	b570      	push	{r4, r5, r6, lr}
    2b7e:	b088      	sub	sp, #32
    2b80:	4606      	mov	r6, r0
 * \param[in] hw The pointer to hardware instance
 */
static inline uint8_t _get_hardware_offset(const void *const hw)
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
    2b82:	466c      	mov	r4, sp
    2b84:	4d12      	ldr	r5, [pc, #72]	; (2bd0 <get_tc_index+0x54>)
    2b86:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2b88:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    2b8a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    2b8e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
    2b92:	9b00      	ldr	r3, [sp, #0]
    2b94:	42b3      	cmp	r3, r6
    2b96:	d00b      	beq.n	2bb0 <get_tc_index+0x34>
    2b98:	4630      	mov	r0, r6
    2b9a:	aa01      	add	r2, sp, #4
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    2b9c:	2301      	movs	r3, #1
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
    2b9e:	f852 1b04 	ldr.w	r1, [r2], #4
    2ba2:	4281      	cmp	r1, r0
    2ba4:	d005      	beq.n	2bb2 <get_tc_index+0x36>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    2ba6:	3301      	adds	r3, #1
    2ba8:	2b08      	cmp	r3, #8
    2baa:	d1f8      	bne.n	2b9e <get_tc_index+0x22>
			return i;
    2bac:	2000      	movs	r0, #0
    2bae:	e00b      	b.n	2bc8 <get_tc_index+0x4c>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    2bb0:	2300      	movs	r3, #0
		if (_tcs[i].number == index) {
    2bb2:	f013 0fff 	tst.w	r3, #255	; 0xff
    2bb6:	d009      	beq.n	2bcc <get_tc_index+0x50>
	ASSERT(false);
    2bb8:	f44f 729e 	mov.w	r2, #316	; 0x13c
    2bbc:	4905      	ldr	r1, [pc, #20]	; (2bd4 <get_tc_index+0x58>)
    2bbe:	2000      	movs	r0, #0
    2bc0:	4b05      	ldr	r3, [pc, #20]	; (2bd8 <get_tc_index+0x5c>)
    2bc2:	4798      	blx	r3
	return -1;
    2bc4:	f04f 30ff 	mov.w	r0, #4294967295
}
    2bc8:	b008      	add	sp, #32
    2bca:	bd70      	pop	{r4, r5, r6, pc}
			return i;
    2bcc:	2000      	movs	r0, #0
    2bce:	e7fb      	b.n	2bc8 <get_tc_index+0x4c>
    2bd0:	0000b398 	.word	0x0000b398
    2bd4:	0000b3cc 	.word	0x0000b3cc
    2bd8:	0000187d 	.word	0x0000187d

00002bdc <_timer_init>:
{
    2bdc:	b570      	push	{r4, r5, r6, lr}
    2bde:	4606      	mov	r6, r0
    2be0:	460c      	mov	r4, r1
	int8_t i = get_tc_index(hw);
    2be2:	4608      	mov	r0, r1
    2be4:	4b60      	ldr	r3, [pc, #384]	; (2d68 <_timer_init+0x18c>)
    2be6:	4798      	blx	r3
    2be8:	4605      	mov	r5, r0
	device->hw = hw;
    2bea:	60f4      	str	r4, [r6, #12]
	ASSERT(ARRAY_SIZE(_tcs));
    2bec:	228d      	movs	r2, #141	; 0x8d
    2bee:	495f      	ldr	r1, [pc, #380]	; (2d6c <_timer_init+0x190>)
    2bf0:	2001      	movs	r0, #1
    2bf2:	4b5f      	ldr	r3, [pc, #380]	; (2d70 <_timer_init+0x194>)
    2bf4:	4798      	blx	r3
	};
}

static inline bool hri_tc_is_syncing(const void *const hw, hri_tc_syncbusy_reg_t reg)
{
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
    2bf6:	6923      	ldr	r3, [r4, #16]
	if (!hri_tc_is_syncing(hw, TC_SYNCBUSY_SWRST)) {
    2bf8:	f013 0f01 	tst.w	r3, #1
    2bfc:	d119      	bne.n	2c32 <_timer_init+0x56>
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2bfe:	6923      	ldr	r3, [r4, #16]
    2c00:	f013 0f03 	tst.w	r3, #3
    2c04:	d1fb      	bne.n	2bfe <_timer_init+0x22>

static inline hri_tc_ctrla_reg_t hri_tc_get_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    2c06:	6823      	ldr	r3, [r4, #0]
		if (hri_tc_get_CTRLA_reg(hw, TC_CTRLA_ENABLE)) {
    2c08:	f013 0f02 	tst.w	r3, #2
    2c0c:	d00b      	beq.n	2c26 <_timer_init+0x4a>
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
    2c0e:	6823      	ldr	r3, [r4, #0]
    2c10:	f023 0302 	bic.w	r3, r3, #2
    2c14:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2c16:	6923      	ldr	r3, [r4, #16]
    2c18:	f013 0f03 	tst.w	r3, #3
    2c1c:	d1fb      	bne.n	2c16 <_timer_init+0x3a>
    2c1e:	6923      	ldr	r3, [r4, #16]
    2c20:	f013 0f02 	tst.w	r3, #2
    2c24:	d1fb      	bne.n	2c1e <_timer_init+0x42>
}

static inline void hri_tc_write_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    2c26:	2301      	movs	r3, #1
    2c28:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2c2a:	6923      	ldr	r3, [r4, #16]
    2c2c:	f013 0f03 	tst.w	r3, #3
    2c30:	d1fb      	bne.n	2c2a <_timer_init+0x4e>
    2c32:	6923      	ldr	r3, [r4, #16]
    2c34:	f013 0f01 	tst.w	r3, #1
    2c38:	d1fb      	bne.n	2c32 <_timer_init+0x56>
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
    2c3a:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2c3e:	4a4d      	ldr	r2, [pc, #308]	; (2d74 <_timer_init+0x198>)
    2c40:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2c44:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    2c46:	6022      	str	r2, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2c48:	6923      	ldr	r3, [r4, #16]
    2c4a:	f013 0f03 	tst.w	r3, #3
    2c4e:	d1fb      	bne.n	2c48 <_timer_init+0x6c>
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
    2c50:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2c54:	4947      	ldr	r1, [pc, #284]	; (2d74 <_timer_init+0x198>)
    2c56:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    2c5a:	f893 102a 	ldrb.w	r1, [r3, #42]	; 0x2a
}

static inline void hri_tc_write_DBGCTRL_reg(const void *const hw, hri_tc_dbgctrl_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.DBGCTRL.reg = data;
    2c5e:	73e1      	strb	r1, [r4, #15]
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
    2c60:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
    2c62:	80e3      	strh	r3, [r4, #6]
	((Tc *)hw)->COUNT16.WAVE.reg = data;
    2c64:	2301      	movs	r3, #1
    2c66:	7323      	strb	r3, [r4, #12]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
    2c68:	f002 020c 	and.w	r2, r2, #12
    2c6c:	2a08      	cmp	r2, #8
    2c6e:	d048      	beq.n	2d02 <_timer_init+0x126>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
    2c70:	2a00      	cmp	r2, #0
    2c72:	d158      	bne.n	2d26 <_timer_init+0x14a>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)_tcs[i].cc0);
    2c74:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2c78:	4a3e      	ldr	r2, [pc, #248]	; (2d74 <_timer_init+0x198>)
    2c7a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2c7e:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
}

static inline void hri_tccount16_write_CC_reg(const void *const hw, uint8_t index, hri_tccount16_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    2c80:	83a3      	strh	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2c82:	6923      	ldr	r3, [r4, #16]
    2c84:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2c88:	d1fb      	bne.n	2c82 <_timer_init+0xa6>
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    2c8a:	2300      	movs	r3, #0
    2c8c:	83e3      	strh	r3, [r4, #30]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2c8e:	6923      	ldr	r3, [r4, #16]
    2c90:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2c94:	d1fb      	bne.n	2c8e <_timer_init+0xb2>
	((Tc *)hw)->COUNT16.INTENSET.reg = TC_INTENSET_OVF;
    2c96:	2301      	movs	r3, #1
    2c98:	7263      	strb	r3, [r4, #9]
	if (hw == TC0) {
    2c9a:	4b37      	ldr	r3, [pc, #220]	; (2d78 <_timer_init+0x19c>)
    2c9c:	429c      	cmp	r4, r3
		_tc0_dev = (struct _timer_device *)dev;
    2c9e:	bf04      	itt	eq
    2ca0:	4b36      	ldreq	r3, [pc, #216]	; (2d7c <_timer_init+0x1a0>)
    2ca2:	601e      	streq	r6, [r3, #0]
	NVIC_DisableIRQ(_tcs[i].irq);
    2ca4:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2ca8:	4a32      	ldr	r2, [pc, #200]	; (2d74 <_timer_init+0x198>)
    2caa:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2cae:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
    2cb2:	2b00      	cmp	r3, #0
    2cb4:	db23      	blt.n	2cfe <_timer_init+0x122>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2cb6:	095a      	lsrs	r2, r3, #5
    2cb8:	f003 031f 	and.w	r3, r3, #31
    2cbc:	2101      	movs	r1, #1
    2cbe:	fa01 f303 	lsl.w	r3, r1, r3
    2cc2:	3220      	adds	r2, #32
    2cc4:	492e      	ldr	r1, [pc, #184]	; (2d80 <_timer_init+0x1a4>)
    2cc6:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    2cca:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2cce:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(_tcs[i].irq);
    2cd2:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    2cd6:	4b27      	ldr	r3, [pc, #156]	; (2d74 <_timer_init+0x198>)
    2cd8:	eb03 0585 	add.w	r5, r3, r5, lsl #2
    2cdc:	f9b5 3022 	ldrsh.w	r3, [r5, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
    2ce0:	2b00      	cmp	r3, #0
    2ce2:	db0c      	blt.n	2cfe <_timer_init+0x122>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2ce4:	0959      	lsrs	r1, r3, #5
    2ce6:	f003 031f 	and.w	r3, r3, #31
    2cea:	2201      	movs	r2, #1
    2cec:	fa02 f303 	lsl.w	r3, r2, r3
    2cf0:	4a23      	ldr	r2, [pc, #140]	; (2d80 <_timer_init+0x1a4>)
    2cf2:	f101 0060 	add.w	r0, r1, #96	; 0x60
    2cf6:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2cfa:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
    2cfe:	2000      	movs	r0, #0
    2d00:	bd70      	pop	{r4, r5, r6, pc}
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
    2d02:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2d06:	4a1b      	ldr	r2, [pc, #108]	; (2d74 <_timer_init+0x198>)
    2d08:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2d0c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}

static inline void hri_tccount32_write_CC_reg(const void *const hw, uint8_t index, hri_tccount32_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    2d0e:	61e3      	str	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2d10:	6923      	ldr	r3, [r4, #16]
    2d12:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2d16:	d1fb      	bne.n	2d10 <_timer_init+0x134>
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    2d18:	2300      	movs	r3, #0
    2d1a:	6223      	str	r3, [r4, #32]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2d1c:	6923      	ldr	r3, [r4, #16]
    2d1e:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2d22:	d1fb      	bne.n	2d1c <_timer_init+0x140>
    2d24:	e7b7      	b.n	2c96 <_timer_init+0xba>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT8) {
    2d26:	2a04      	cmp	r2, #4
    2d28:	d1b5      	bne.n	2c96 <_timer_init+0xba>
		hri_tccount8_write_CC_reg(hw, 0, (uint8_t)_tcs[i].cc0);
    2d2a:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2d2e:	4a11      	ldr	r2, [pc, #68]	; (2d74 <_timer_init+0x198>)
    2d30:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2d34:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
	((Tc *)hw)->COUNT8.CC[index].reg = data;
    2d38:	7723      	strb	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2d3a:	6923      	ldr	r3, [r4, #16]
    2d3c:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2d40:	d1fb      	bne.n	2d3a <_timer_init+0x15e>
	((Tc *)hw)->COUNT8.CC[index].reg = data;
    2d42:	2300      	movs	r3, #0
    2d44:	7763      	strb	r3, [r4, #29]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2d46:	6923      	ldr	r3, [r4, #16]
    2d48:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2d4c:	d1fb      	bne.n	2d46 <_timer_init+0x16a>
		hri_tccount8_write_PER_reg(hw, _tcs[i].per);
    2d4e:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2d52:	4a08      	ldr	r2, [pc, #32]	; (2d74 <_timer_init+0x198>)
    2d54:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2d58:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
	((Tc *)hw)->COUNT8.PER.reg = data;
    2d5c:	76e3      	strb	r3, [r4, #27]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2d5e:	6923      	ldr	r3, [r4, #16]
    2d60:	f013 0f20 	tst.w	r3, #32
    2d64:	d1fb      	bne.n	2d5e <_timer_init+0x182>
    2d66:	e796      	b.n	2c96 <_timer_init+0xba>
    2d68:	00002b7d 	.word	0x00002b7d
    2d6c:	0000b3cc 	.word	0x0000b3cc
    2d70:	0000187d 	.word	0x0000187d
    2d74:	0000b398 	.word	0x0000b398
    2d78:	40003800 	.word	0x40003800
    2d7c:	20001628 	.word	0x20001628
    2d80:	e000e100 	.word	0xe000e100

00002d84 <_timer_start>:
	hri_tc_set_CTRLA_ENABLE_bit(device->hw);
    2d84:	68c2      	ldr	r2, [r0, #12]
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
    2d86:	6813      	ldr	r3, [r2, #0]
    2d88:	f043 0302 	orr.w	r3, r3, #2
    2d8c:	6013      	str	r3, [r2, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2d8e:	6913      	ldr	r3, [r2, #16]
    2d90:	f013 0f03 	tst.w	r3, #3
    2d94:	d1fb      	bne.n	2d8e <_timer_start+0xa>
}
    2d96:	4770      	bx	lr

00002d98 <_timer_is_started>:
	return hri_tc_get_CTRLA_ENABLE_bit(device->hw);
    2d98:	68c2      	ldr	r2, [r0, #12]
    2d9a:	6913      	ldr	r3, [r2, #16]
    2d9c:	f013 0f03 	tst.w	r3, #3
    2da0:	d1fb      	bne.n	2d9a <_timer_is_started+0x2>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    2da2:	6810      	ldr	r0, [r2, #0]
}
    2da4:	f3c0 0040 	ubfx	r0, r0, #1, #1
    2da8:	4770      	bx	lr

00002daa <_tc_get_timer>:
}
    2daa:	2000      	movs	r0, #0
    2dac:	4770      	bx	lr
	...

00002db0 <_timer_set_irq>:
{
    2db0:	b510      	push	{r4, lr}
	int8_t      i  = get_tc_index(hw);
    2db2:	68c0      	ldr	r0, [r0, #12]
    2db4:	4b09      	ldr	r3, [pc, #36]	; (2ddc <_timer_set_irq+0x2c>)
    2db6:	4798      	blx	r3
    2db8:	4604      	mov	r4, r0
	ASSERT(ARRAY_SIZE(_tcs));
    2dba:	f240 120f 	movw	r2, #271	; 0x10f
    2dbe:	4908      	ldr	r1, [pc, #32]	; (2de0 <_timer_set_irq+0x30>)
    2dc0:	2001      	movs	r0, #1
    2dc2:	4b08      	ldr	r3, [pc, #32]	; (2de4 <_timer_set_irq+0x34>)
    2dc4:	4798      	blx	r3
	_irq_set(_tcs[i].irq);
    2dc6:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    2dca:	4b07      	ldr	r3, [pc, #28]	; (2de8 <_timer_set_irq+0x38>)
    2dcc:	eb03 0484 	add.w	r4, r3, r4, lsl #2
    2dd0:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
    2dd4:	4b05      	ldr	r3, [pc, #20]	; (2dec <_timer_set_irq+0x3c>)
    2dd6:	4798      	blx	r3
    2dd8:	bd10      	pop	{r4, pc}
    2dda:	bf00      	nop
    2ddc:	00002b7d 	.word	0x00002b7d
    2de0:	0000b3cc 	.word	0x0000b3cc
    2de4:	0000187d 	.word	0x0000187d
    2de8:	0000b398 	.word	0x0000b398
    2dec:	00001a19 	.word	0x00001a19

00002df0 <TC0_Handler>:
{
    2df0:	b508      	push	{r3, lr}
	tc_interrupt_handler(_tc0_dev);
    2df2:	4b06      	ldr	r3, [pc, #24]	; (2e0c <TC0_Handler+0x1c>)
    2df4:	6818      	ldr	r0, [r3, #0]
	void *const hw = device->hw;
    2df6:	68c3      	ldr	r3, [r0, #12]
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
    2df8:	7a9a      	ldrb	r2, [r3, #10]
	if (hri_tc_get_interrupt_OVF_bit(hw)) {
    2dfa:	f012 0f01 	tst.w	r2, #1
    2dfe:	d100      	bne.n	2e02 <TC0_Handler+0x12>
    2e00:	bd08      	pop	{r3, pc}
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
    2e02:	2201      	movs	r2, #1
    2e04:	729a      	strb	r2, [r3, #10]
		device->timer_cb.period_expired(device);
    2e06:	6803      	ldr	r3, [r0, #0]
    2e08:	4798      	blx	r3
}
    2e0a:	e7f9      	b.n	2e00 <TC0_Handler+0x10>
    2e0c:	20001628 	.word	0x20001628

00002e10 <mac_low_level_init>:

/**
 * \brief Initialize the MAC hardware
 */
void mac_low_level_init(struct netif *netif)
{
    2e10:	b510      	push	{r4, lr}
    2e12:	b084      	sub	sp, #16
	struct mac_async_descriptor *mac;
	struct mac_async_filter      filter;

	mac = (struct mac_async_descriptor *)(netif->state);
    2e14:	6a44      	ldr	r4, [r0, #36]	; 0x24

	/* set MAC hardware address */
	memcpy(filter.mac, netif->hwaddr, NETIF_MAX_HWADDR_LEN);
    2e16:	4603      	mov	r3, r0
    2e18:	f853 0f2f 	ldr.w	r0, [r3, #47]!
    2e1c:	9001      	str	r0, [sp, #4]
    2e1e:	889b      	ldrh	r3, [r3, #4]
    2e20:	f8ad 3008 	strh.w	r3, [sp, #8]
	filter.tid_enable = false; //true; //tph false;
    2e24:	2100      	movs	r1, #0
    2e26:	f88d 100c 	strb.w	r1, [sp, #12]
	mac_async_set_filter(mac, 0, &filter);
    2e2a:	aa01      	add	r2, sp, #4
    2e2c:	4620      	mov	r0, r4
    2e2e:	4b02      	ldr	r3, [pc, #8]	; (2e38 <mac_low_level_init+0x28>)
    2e30:	4798      	blx	r3
}
    2e32:	b004      	add	sp, #16
    2e34:	bd10      	pop	{r4, pc}
    2e36:	bf00      	nop
    2e38:	0000116d 	.word	0x0000116d

00002e3c <mac_low_level_output>:

/**
 * \berif Transmission packet though the MAC hardware.
 */
err_t mac_low_level_output(struct netif *netif, struct pbuf *p)
{
    2e3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2e40:	460f      	mov	r7, r1
	struct mac_async_descriptor *mac;
	struct pbuf *                q;
	void *                       tbuf;
	uint8_t *                    pos;

	mac = (struct mac_async_descriptor *)(netif->state);
    2e42:	f8d0 8024 	ldr.w	r8, [r0, #36]	; 0x24

#if ETH_PAD_SIZE
	pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
#endif

	if (p->tot_len == p->len) {
    2e46:	890a      	ldrh	r2, [r1, #8]
    2e48:	894b      	ldrh	r3, [r1, #10]
    2e4a:	4293      	cmp	r3, r2
    2e4c:	d01f      	beq.n	2e8e <mac_low_level_output+0x52>
		mac_async_write(mac, p->payload, p->tot_len);
	} else {
		tbuf = mem_malloc(LWIP_MEM_ALIGN_SIZE(p->tot_len));
    2e4e:	3203      	adds	r2, #3
    2e50:	f64f 70fc 	movw	r0, #65532	; 0xfffc
    2e54:	4010      	ands	r0, r2
    2e56:	4b13      	ldr	r3, [pc, #76]	; (2ea4 <mac_low_level_output+0x68>)
    2e58:	4798      	blx	r3
		pos  = tbuf;
		if (tbuf == NULL) {
    2e5a:	4681      	mov	r9, r0
    2e5c:	b1f0      	cbz	r0, 2e9c <mac_low_level_output+0x60>
			return ERR_MEM;
		}
		for (q = p; q != NULL; q = q->next) {
    2e5e:	b15f      	cbz	r7, 2e78 <mac_low_level_output+0x3c>
    2e60:	4605      	mov	r5, r0
    2e62:	463c      	mov	r4, r7
			memcpy(pos, q->payload, q->len);
    2e64:	4e10      	ldr	r6, [pc, #64]	; (2ea8 <mac_low_level_output+0x6c>)
    2e66:	8962      	ldrh	r2, [r4, #10]
    2e68:	6861      	ldr	r1, [r4, #4]
    2e6a:	4628      	mov	r0, r5
    2e6c:	47b0      	blx	r6
			pos += q->len;
    2e6e:	8963      	ldrh	r3, [r4, #10]
    2e70:	441d      	add	r5, r3
		for (q = p; q != NULL; q = q->next) {
    2e72:	6824      	ldr	r4, [r4, #0]
    2e74:	2c00      	cmp	r4, #0
    2e76:	d1f6      	bne.n	2e66 <mac_low_level_output+0x2a>
		}
		mac_async_write(mac, tbuf, p->tot_len);
    2e78:	893a      	ldrh	r2, [r7, #8]
    2e7a:	4649      	mov	r1, r9
    2e7c:	4640      	mov	r0, r8
    2e7e:	4b0b      	ldr	r3, [pc, #44]	; (2eac <mac_low_level_output+0x70>)
    2e80:	4798      	blx	r3
		mem_free(tbuf);
    2e82:	4648      	mov	r0, r9
    2e84:	4b0a      	ldr	r3, [pc, #40]	; (2eb0 <mac_low_level_output+0x74>)
    2e86:	4798      	blx	r3
	pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
#endif

	LINK_STATS_INC(link.xmit);

	return ERR_OK;
    2e88:	2000      	movs	r0, #0
    2e8a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		mac_async_write(mac, p->payload, p->tot_len);
    2e8e:	6849      	ldr	r1, [r1, #4]
    2e90:	4640      	mov	r0, r8
    2e92:	4b06      	ldr	r3, [pc, #24]	; (2eac <mac_low_level_output+0x70>)
    2e94:	4798      	blx	r3
	return ERR_OK;
    2e96:	2000      	movs	r0, #0
    2e98:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			return ERR_MEM;
    2e9c:	f04f 30ff 	mov.w	r0, #4294967295
}
    2ea0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2ea4:	000058c5 	.word	0x000058c5
    2ea8:	0000a0eb 	.word	0x0000a0eb
    2eac:	00001079 	.word	0x00001079
    2eb0:	00005771 	.word	0x00005771

00002eb4 <ethernetif_mac_input>:

/**
 * \brief Process incoming ethernet packet.
 */
void ethernetif_mac_input(struct netif *netif)
{
    2eb4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2eb8:	4606      	mov	r6, r0
	len = mac_async_read_len(mac); /* Obtain the size of the packet */
    2eba:	4f1b      	ldr	r7, [pc, #108]	; (2f28 <ethernetif_mac_input+0x74>)
	p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
    2ebc:	f8df 9078 	ldr.w	r9, [pc, #120]	; 2f38 <ethernetif_mac_input+0x84>
		mac_async_read(mac, p->payload, p->len);
    2ec0:	f8df 8068 	ldr.w	r8, [pc, #104]	; 2f2c <ethernetif_mac_input+0x78>
    2ec4:	e00b      	b.n	2ede <ethernetif_mac_input+0x2a>
		mac_async_read(mac, NULL, 0);
    2ec6:	2200      	movs	r2, #0
    2ec8:	4611      	mov	r1, r2
    2eca:	4628      	mov	r0, r5
    2ecc:	4b17      	ldr	r3, [pc, #92]	; (2f2c <ethernetif_mac_input+0x78>)
    2ece:	4798      	blx	r3
    2ed0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			/* PPPoE packet? */
		case ETHTYPE_PPPOEDISC:
		case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */
			/* full packet send to tcpip_thread to process */
			if (netif->input(p, netif) != ERR_OK) {
    2ed4:	6933      	ldr	r3, [r6, #16]
    2ed6:	4631      	mov	r1, r6
    2ed8:	4620      	mov	r0, r4
    2eda:	4798      	blx	r3
    2edc:	b9e8      	cbnz	r0, 2f1a <ethernetif_mac_input+0x66>
	mac = (struct mac_async_descriptor *)(netif->state);
    2ede:	6a75      	ldr	r5, [r6, #36]	; 0x24
	len = mac_async_read_len(mac); /* Obtain the size of the packet */
    2ee0:	4628      	mov	r0, r5
    2ee2:	47b8      	blx	r7
    2ee4:	b281      	uxth	r1, r0
	if (len == 0) {
    2ee6:	b1e1      	cbz	r1, 2f22 <ethernetif_mac_input+0x6e>
	p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
    2ee8:	2200      	movs	r2, #0
    2eea:	2003      	movs	r0, #3
    2eec:	47c8      	blx	r9
	if (p != NULL) {
    2eee:	4604      	mov	r4, r0
    2ef0:	2800      	cmp	r0, #0
    2ef2:	d0e8      	beq.n	2ec6 <ethernetif_mac_input+0x12>
		mac_async_read(mac, p->payload, p->len);
    2ef4:	8942      	ldrh	r2, [r0, #10]
    2ef6:	6841      	ldr	r1, [r0, #4]
    2ef8:	4628      	mov	r0, r5
    2efa:	47c0      	blx	r8
		switch (htons(ethhdr->type)) {
    2efc:	6863      	ldr	r3, [r4, #4]
    2efe:	8998      	ldrh	r0, [r3, #12]
    2f00:	4b0b      	ldr	r3, [pc, #44]	; (2f30 <ethernetif_mac_input+0x7c>)
    2f02:	4798      	blx	r3
    2f04:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
    2f08:	d0e4      	beq.n	2ed4 <ethernetif_mac_input+0x20>
    2f0a:	f640 0306 	movw	r3, #2054	; 0x806
    2f0e:	4298      	cmp	r0, r3
    2f10:	d0e0      	beq.n	2ed4 <ethernetif_mac_input+0x20>
				p = NULL;
			}
			break;

		default:
			pbuf_free(p);
    2f12:	4620      	mov	r0, r4
    2f14:	4b07      	ldr	r3, [pc, #28]	; (2f34 <ethernetif_mac_input+0x80>)
    2f16:	4798      	blx	r3
			p = NULL;
			break;
    2f18:	e7e1      	b.n	2ede <ethernetif_mac_input+0x2a>
				pbuf_free(p);
    2f1a:	4620      	mov	r0, r4
    2f1c:	4b05      	ldr	r3, [pc, #20]	; (2f34 <ethernetif_mac_input+0x80>)
    2f1e:	4798      	blx	r3
    2f20:	e7dd      	b.n	2ede <ethernetif_mac_input+0x2a>
    2f22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2f26:	bf00      	nop
    2f28:	000010e5 	.word	0x000010e5
    2f2c:	000010b5 	.word	0x000010b5
    2f30:	00002f3d 	.word	0x00002f3d
    2f34:	00005d21 	.word	0x00005d21
    2f38:	00005d89 	.word	0x00005d89

00002f3c <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t lwip_htons(u16_t n)
{
	return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
    2f3c:	0a03      	lsrs	r3, r0, #8
    2f3e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
}
    2f42:	b280      	uxth	r0, r0
    2f44:	4770      	bx	lr

00002f46 <lwip_ntohs>:
	return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
    2f46:	0a03      	lsrs	r3, r0, #8
    2f48:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 * @return n in host byte order
 */
u16_t lwip_ntohs(u16_t n)
{
	return lwip_htons(n);
}
    2f4c:	b280      	uxth	r0, r0
    2f4e:	4770      	bx	lr

00002f50 <lwip_htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t lwip_htonl(u32_t n)
{
	return ((n & 0xff) << 24) | ((n & 0xff00) << 8) | ((n & 0xff0000UL) >> 8) | ((n & 0xff000000UL) >> 24);
    2f50:	0e03      	lsrs	r3, r0, #24
    2f52:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
    2f56:	0202      	lsls	r2, r0, #8
    2f58:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    2f5c:	4313      	orrs	r3, r2
    2f5e:	0a00      	lsrs	r0, r0, #8
    2f60:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
}
    2f64:	4318      	orrs	r0, r3
    2f66:	4770      	bx	lr

00002f68 <lwip_ntohl>:
 *
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t lwip_ntohl(u32_t n)
{
    2f68:	b508      	push	{r3, lr}
	return lwip_htonl(n);
    2f6a:	4b01      	ldr	r3, [pc, #4]	; (2f70 <lwip_ntohl+0x8>)
    2f6c:	4798      	blx	r3
}
    2f6e:	bd08      	pop	{r3, pc}
    2f70:	00002f51 	.word	0x00002f51

00002f74 <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
	if (new_state != dhcp->state) {
    2f74:	7b03      	ldrb	r3, [r0, #12]
    2f76:	428b      	cmp	r3, r1
    2f78:	d003      	beq.n	2f82 <dhcp_set_state+0xe>
		dhcp->state           = new_state;
    2f7a:	7301      	strb	r1, [r0, #12]
		dhcp->tries           = 0;
    2f7c:	2300      	movs	r3, #0
    2f7e:	7343      	strb	r3, [r0, #13]
		dhcp->request_timeout = 0;
    2f80:	8343      	strh	r3, [r0, #26]
    2f82:	4770      	bx	lr

00002f84 <dhcp_option>:
 * Concatenate an option type and length field to the outgoing
 * DHCP message.
 *
 */
static void dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
    2f84:	b430      	push	{r4, r5}
	LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    2f86:	6943      	ldr	r3, [r0, #20]
    2f88:	8b04      	ldrh	r4, [r0, #24]
    2f8a:	1c65      	adds	r5, r4, #1
    2f8c:	8305      	strh	r5, [r0, #24]
    2f8e:	4423      	add	r3, r4
    2f90:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
    2f94:	6943      	ldr	r3, [r0, #20]
    2f96:	8b01      	ldrh	r1, [r0, #24]
    2f98:	1c4c      	adds	r4, r1, #1
    2f9a:	8304      	strh	r4, [r0, #24]
    2f9c:	440b      	add	r3, r1
    2f9e:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
}
    2fa2:	bc30      	pop	{r4, r5}
    2fa4:	4770      	bx	lr

00002fa6 <dhcp_option_byte>:
/*
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
    2fa6:	b410      	push	{r4}
	LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = value;
    2fa8:	6943      	ldr	r3, [r0, #20]
    2faa:	8b02      	ldrh	r2, [r0, #24]
    2fac:	1c54      	adds	r4, r2, #1
    2fae:	8304      	strh	r4, [r0, #24]
    2fb0:	4413      	add	r3, r2
    2fb2:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    2fb6:	f85d 4b04 	ldr.w	r4, [sp], #4
    2fba:	4770      	bx	lr

00002fbc <dhcp_option_short>:

static void dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
    2fbc:	b410      	push	{r4}
	LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    2fbe:	6943      	ldr	r3, [r0, #20]
    2fc0:	8b02      	ldrh	r2, [r0, #24]
    2fc2:	1c54      	adds	r4, r2, #1
    2fc4:	8304      	strh	r4, [r0, #24]
    2fc6:	4413      	add	r3, r2
    2fc8:	0a0a      	lsrs	r2, r1, #8
    2fca:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)(value & 0x00ffU);
    2fce:	6943      	ldr	r3, [r0, #20]
    2fd0:	8b02      	ldrh	r2, [r0, #24]
    2fd2:	1c54      	adds	r4, r2, #1
    2fd4:	8304      	strh	r4, [r0, #24]
    2fd6:	4413      	add	r3, r2
    2fd8:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    2fdc:	f85d 4b04 	ldr.w	r4, [sp], #4
    2fe0:	4770      	bx	lr

00002fe2 <dhcp_option_long>:

static void dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
    2fe2:	b410      	push	{r4}
	LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
    2fe4:	6943      	ldr	r3, [r0, #20]
    2fe6:	8b02      	ldrh	r2, [r0, #24]
    2fe8:	1c54      	adds	r4, r2, #1
    2fea:	8304      	strh	r4, [r0, #24]
    2fec:	4413      	add	r3, r2
    2fee:	0e0a      	lsrs	r2, r1, #24
    2ff0:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
    2ff4:	6943      	ldr	r3, [r0, #20]
    2ff6:	8b02      	ldrh	r2, [r0, #24]
    2ff8:	1c54      	adds	r4, r2, #1
    2ffa:	8304      	strh	r4, [r0, #24]
    2ffc:	4413      	add	r3, r2
    2ffe:	0c0a      	lsrs	r2, r1, #16
    3000:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    3004:	6943      	ldr	r3, [r0, #20]
    3006:	8b02      	ldrh	r2, [r0, #24]
    3008:	1c54      	adds	r4, r2, #1
    300a:	8304      	strh	r4, [r0, #24]
    300c:	4413      	add	r3, r2
    300e:	0a0a      	lsrs	r2, r1, #8
    3010:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
    3014:	6943      	ldr	r3, [r0, #20]
    3016:	8b02      	ldrh	r2, [r0, #24]
    3018:	1c54      	adds	r4, r2, #1
    301a:	8304      	strh	r4, [r0, #24]
    301c:	4413      	add	r3, r2
    301e:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    3022:	f85d 4b04 	ldr.w	r4, [sp], #4
    3026:	4770      	bx	lr

00003028 <dhcp_option_trailer>:
 * necessary, up to three padding bytes.
 *
 * @param dhcp DHCP state structure
 */
static void dhcp_option_trailer(struct dhcp *dhcp)
{
    3028:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    302a:	b150      	cbz	r0, 3042 <dhcp_option_trailer+0x1a>
    302c:	4601      	mov	r1, r0
	LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
	LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n",
	            dhcp->options_out_len < DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
    302e:	6943      	ldr	r3, [r0, #20]
    3030:	8b02      	ldrh	r2, [r0, #24]
    3032:	1c50      	adds	r0, r2, #1
    3034:	8308      	strh	r0, [r1, #24]
    3036:	4413      	add	r3, r2
    3038:	22ff      	movs	r2, #255	; 0xff
    303a:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	/* packet is too small, or not 4 byte aligned? */
	while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3))
	       && (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
		/* add a fill/padding byte */
		dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    303e:	2400      	movs	r4, #0
	while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3))
    3040:	e00d      	b.n	305e <dhcp_option_trailer+0x36>
	LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    3042:	4b09      	ldr	r3, [pc, #36]	; (3068 <dhcp_option_trailer+0x40>)
    3044:	f240 62e7 	movw	r2, #1767	; 0x6e7
    3048:	4908      	ldr	r1, [pc, #32]	; (306c <dhcp_option_trailer+0x44>)
    304a:	4809      	ldr	r0, [pc, #36]	; (3070 <dhcp_option_trailer+0x48>)
    304c:	4c09      	ldr	r4, [pc, #36]	; (3074 <dhcp_option_trailer+0x4c>)
    304e:	47a0      	blx	r4
    3050:	e7fe      	b.n	3050 <dhcp_option_trailer+0x28>
		dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    3052:	694a      	ldr	r2, [r1, #20]
    3054:	1c58      	adds	r0, r3, #1
    3056:	8308      	strh	r0, [r1, #24]
    3058:	4413      	add	r3, r2
    305a:	f883 40f0 	strb.w	r4, [r3, #240]	; 0xf0
	while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3))
    305e:	8b0b      	ldrh	r3, [r1, #24]
    3060:	2b43      	cmp	r3, #67	; 0x43
    3062:	d9f6      	bls.n	3052 <dhcp_option_trailer+0x2a>
	}
}
    3064:	bd10      	pop	{r4, pc}
    3066:	bf00      	nop
    3068:	0000b3e0 	.word	0x0000b3e0
    306c:	0000b404 	.word	0x0000b404
    3070:	0000b428 	.word	0x0000b428
    3074:	0000a111 	.word	0x0000a111

00003078 <dhcp_create_msg>:
{
    3078:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
    307c:	2800      	cmp	r0, #0
    307e:	f000 809f 	beq.w	31c0 <dhcp_create_msg+0x148>
    3082:	460c      	mov	r4, r1
    3084:	4615      	mov	r5, r2
    3086:	4606      	mov	r6, r0
	LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    3088:	2900      	cmp	r1, #0
    308a:	f000 80a1 	beq.w	31d0 <dhcp_create_msg+0x158>
	dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
    308e:	2200      	movs	r2, #0
    3090:	f44f 719a 	mov.w	r1, #308	; 0x134
    3094:	4610      	mov	r0, r2
    3096:	4b56      	ldr	r3, [pc, #344]	; (31f0 <dhcp_create_msg+0x178>)
    3098:	4798      	blx	r3
    309a:	6120      	str	r0, [r4, #16]
	if (dhcp->p_out == NULL) {
    309c:	2800      	cmp	r0, #0
    309e:	f000 809f 	beq.w	31e0 <dhcp_create_msg+0x168>
	if (dhcp->tries == 0) {
    30a2:	7b63      	ldrb	r3, [r4, #13]
    30a4:	b91b      	cbnz	r3, 30ae <dhcp_create_msg+0x36>
		xid++;
    30a6:	4a53      	ldr	r2, [pc, #332]	; (31f4 <dhcp_create_msg+0x17c>)
    30a8:	6813      	ldr	r3, [r2, #0]
    30aa:	3301      	adds	r3, #1
    30ac:	6013      	str	r3, [r2, #0]
	dhcp->xid = xid;
    30ae:	4b51      	ldr	r3, [pc, #324]	; (31f4 <dhcp_create_msg+0x17c>)
    30b0:	6819      	ldr	r1, [r3, #0]
    30b2:	6021      	str	r1, [r4, #0]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("transaction id xid(%" X32_F ")\n", xid));
    30b4:	4850      	ldr	r0, [pc, #320]	; (31f8 <dhcp_create_msg+0x180>)
    30b6:	4b51      	ldr	r3, [pc, #324]	; (31fc <dhcp_create_msg+0x184>)
    30b8:	4798      	blx	r3
	dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
    30ba:	6923      	ldr	r3, [r4, #16]
    30bc:	685a      	ldr	r2, [r3, #4]
    30be:	6162      	str	r2, [r4, #20]
	dhcp->msg_out->op = DHCP_BOOTREQUEST;
    30c0:	2301      	movs	r3, #1
    30c2:	7013      	strb	r3, [r2, #0]
	dhcp->msg_out->htype = DHCP_HTYPE_ETH;
    30c4:	6962      	ldr	r2, [r4, #20]
    30c6:	7053      	strb	r3, [r2, #1]
	dhcp->msg_out->hlen  = netif->hwaddr_len;
    30c8:	6963      	ldr	r3, [r4, #20]
    30ca:	f896 202e 	ldrb.w	r2, [r6, #46]	; 0x2e
    30ce:	709a      	strb	r2, [r3, #2]
	dhcp->msg_out->hops  = 0;
    30d0:	6963      	ldr	r3, [r4, #20]
    30d2:	2700      	movs	r7, #0
    30d4:	70df      	strb	r7, [r3, #3]
	dhcp->msg_out->xid   = htonl(dhcp->xid);
    30d6:	f8d4 8014 	ldr.w	r8, [r4, #20]
    30da:	6820      	ldr	r0, [r4, #0]
    30dc:	4b48      	ldr	r3, [pc, #288]	; (3200 <dhcp_create_msg+0x188>)
    30de:	4798      	blx	r3
    30e0:	f8c8 0004 	str.w	r0, [r8, #4]
	dhcp->msg_out->secs  = 0;
    30e4:	6963      	ldr	r3, [r4, #20]
    30e6:	721f      	strb	r7, [r3, #8]
    30e8:	725f      	strb	r7, [r3, #9]
	dhcp->msg_out->flags = 0;
    30ea:	6963      	ldr	r3, [r4, #20]
    30ec:	729f      	strb	r7, [r3, #10]
    30ee:	72df      	strb	r7, [r3, #11]
	ip_addr_set_zero(&dhcp->msg_out->ciaddr);
    30f0:	6963      	ldr	r3, [r4, #20]
    30f2:	731f      	strb	r7, [r3, #12]
    30f4:	735f      	strb	r7, [r3, #13]
    30f6:	739f      	strb	r7, [r3, #14]
    30f8:	73df      	strb	r7, [r3, #15]
	if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE)
    30fa:	2d08      	cmp	r5, #8
    30fc:	d008      	beq.n	3110 <dhcp_create_msg+0x98>
    30fe:	2d04      	cmp	r5, #4
    3100:	d006      	beq.n	3110 <dhcp_create_msg+0x98>
	    || ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    3102:	2d03      	cmp	r5, #3
    3104:	d107      	bne.n	3116 <dhcp_create_msg+0x9e>
	        ((dhcp->state == DHCP_RENEWING) || dhcp->state == DHCP_REBINDING))) {
    3106:	7b23      	ldrb	r3, [r4, #12]
    3108:	3b04      	subs	r3, #4
	    || ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    310a:	b2db      	uxtb	r3, r3
    310c:	2b01      	cmp	r3, #1
    310e:	d802      	bhi.n	3116 <dhcp_create_msg+0x9e>
		ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
    3110:	6963      	ldr	r3, [r4, #20]
    3112:	6872      	ldr	r2, [r6, #4]
    3114:	60da      	str	r2, [r3, #12]
	ip_addr_set_zero(&dhcp->msg_out->yiaddr);
    3116:	6962      	ldr	r2, [r4, #20]
    3118:	2300      	movs	r3, #0
    311a:	7413      	strb	r3, [r2, #16]
    311c:	7453      	strb	r3, [r2, #17]
    311e:	7493      	strb	r3, [r2, #18]
    3120:	74d3      	strb	r3, [r2, #19]
	ip_addr_set_zero(&dhcp->msg_out->siaddr);
    3122:	6962      	ldr	r2, [r4, #20]
    3124:	7513      	strb	r3, [r2, #20]
    3126:	7553      	strb	r3, [r2, #21]
    3128:	7593      	strb	r3, [r2, #22]
    312a:	75d3      	strb	r3, [r2, #23]
	ip_addr_set_zero(&dhcp->msg_out->giaddr);
    312c:	6962      	ldr	r2, [r4, #20]
    312e:	7613      	strb	r3, [r2, #24]
    3130:	7653      	strb	r3, [r2, #25]
    3132:	7693      	strb	r3, [r2, #26]
    3134:	76d3      	strb	r3, [r2, #27]
    3136:	f106 012f 	add.w	r1, r6, #47	; 0x2f
		dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0 /* pad byte*/;
    313a:	469c      	mov	ip, r3
    313c:	6962      	ldr	r2, [r4, #20]
    313e:	f896 e02e 	ldrb.w	lr, [r6, #46]	; 0x2e
    3142:	b29f      	uxth	r7, r3
    3144:	45be      	cmp	lr, r7
    3146:	bf8c      	ite	hi
    3148:	780f      	ldrbhi	r7, [r1, #0]
    314a:	4667      	movls	r7, ip
    314c:	441a      	add	r2, r3
    314e:	7717      	strb	r7, [r2, #28]
    3150:	3301      	adds	r3, #1
    3152:	3101      	adds	r1, #1
	for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    3154:	2b10      	cmp	r3, #16
    3156:	d1f1      	bne.n	313c <dhcp_create_msg+0xc4>
    3158:	2300      	movs	r3, #0
		dhcp->msg_out->sname[i] = 0;
    315a:	4619      	mov	r1, r3
    315c:	6962      	ldr	r2, [r4, #20]
    315e:	441a      	add	r2, r3
    3160:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
    3164:	3301      	adds	r3, #1
	for (i = 0; i < DHCP_SNAME_LEN; i++) {
    3166:	2b40      	cmp	r3, #64	; 0x40
    3168:	d1f8      	bne.n	315c <dhcp_create_msg+0xe4>
    316a:	2300      	movs	r3, #0
		dhcp->msg_out->file[i] = 0;
    316c:	4619      	mov	r1, r3
    316e:	6962      	ldr	r2, [r4, #20]
    3170:	441a      	add	r2, r3
    3172:	f882 106c 	strb.w	r1, [r2, #108]	; 0x6c
    3176:	3301      	adds	r3, #1
	for (i = 0; i < DHCP_FILE_LEN; i++) {
    3178:	2b80      	cmp	r3, #128	; 0x80
    317a:	d1f8      	bne.n	316e <dhcp_create_msg+0xf6>
	dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
    317c:	6962      	ldr	r2, [r4, #20]
    317e:	2300      	movs	r3, #0
    3180:	2163      	movs	r1, #99	; 0x63
    3182:	f882 10ec 	strb.w	r1, [r2, #236]	; 0xec
    3186:	f06f 007d 	mvn.w	r0, #125	; 0x7d
    318a:	f882 00ed 	strb.w	r0, [r2, #237]	; 0xed
    318e:	2053      	movs	r0, #83	; 0x53
    3190:	f882 00ee 	strb.w	r0, [r2, #238]	; 0xee
    3194:	f882 10ef 	strb.w	r1, [r2, #239]	; 0xef
	dhcp->options_out_len = 0;
    3198:	8323      	strh	r3, [r4, #24]
		dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
    319a:	6962      	ldr	r2, [r4, #20]
    319c:	441a      	add	r2, r3
    319e:	f882 30f0 	strb.w	r3, [r2, #240]	; 0xf0
    31a2:	3301      	adds	r3, #1
	for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    31a4:	2b44      	cmp	r3, #68	; 0x44
    31a6:	d1f8      	bne.n	319a <dhcp_create_msg+0x122>
	dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    31a8:	2201      	movs	r2, #1
    31aa:	2135      	movs	r1, #53	; 0x35
    31ac:	4620      	mov	r0, r4
    31ae:	4b15      	ldr	r3, [pc, #84]	; (3204 <dhcp_create_msg+0x18c>)
    31b0:	4798      	blx	r3
	dhcp_option_byte(dhcp, message_type);
    31b2:	4629      	mov	r1, r5
    31b4:	4620      	mov	r0, r4
    31b6:	4b14      	ldr	r3, [pc, #80]	; (3208 <dhcp_create_msg+0x190>)
    31b8:	4798      	blx	r3
	return ERR_OK;
    31ba:	2000      	movs	r0, #0
}
    31bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
    31c0:	4b12      	ldr	r3, [pc, #72]	; (320c <dhcp_create_msg+0x194>)
    31c2:	f44f 62d1 	mov.w	r2, #1672	; 0x688
    31c6:	4912      	ldr	r1, [pc, #72]	; (3210 <dhcp_create_msg+0x198>)
    31c8:	4812      	ldr	r0, [pc, #72]	; (3214 <dhcp_create_msg+0x19c>)
    31ca:	4c0c      	ldr	r4, [pc, #48]	; (31fc <dhcp_create_msg+0x184>)
    31cc:	47a0      	blx	r4
    31ce:	e7fe      	b.n	31ce <dhcp_create_msg+0x156>
	LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    31d0:	4b0e      	ldr	r3, [pc, #56]	; (320c <dhcp_create_msg+0x194>)
    31d2:	f240 6289 	movw	r2, #1673	; 0x689
    31d6:	4910      	ldr	r1, [pc, #64]	; (3218 <dhcp_create_msg+0x1a0>)
    31d8:	480e      	ldr	r0, [pc, #56]	; (3214 <dhcp_create_msg+0x19c>)
    31da:	4c08      	ldr	r4, [pc, #32]	; (31fc <dhcp_create_msg+0x184>)
    31dc:	47a0      	blx	r4
    31de:	e7fe      	b.n	31de <dhcp_create_msg+0x166>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    31e0:	480e      	ldr	r0, [pc, #56]	; (321c <dhcp_create_msg+0x1a4>)
    31e2:	4b0f      	ldr	r3, [pc, #60]	; (3220 <dhcp_create_msg+0x1a8>)
    31e4:	4798      	blx	r3
		return ERR_MEM;
    31e6:	f04f 30ff 	mov.w	r0, #4294967295
    31ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    31ee:	bf00      	nop
    31f0:	00005d89 	.word	0x00005d89
    31f4:	20000000 	.word	0x20000000
    31f8:	0000b4bc 	.word	0x0000b4bc
    31fc:	0000a111 	.word	0x0000a111
    3200:	00002f51 	.word	0x00002f51
    3204:	00002f85 	.word	0x00002f85
    3208:	00002fa7 	.word	0x00002fa7
    320c:	0000b3e0 	.word	0x0000b3e0
    3210:	0000b450 	.word	0x0000b450
    3214:	0000b428 	.word	0x0000b428
    3218:	0000b470 	.word	0x0000b470
    321c:	0000b490 	.word	0x0000b490
    3220:	0000a1f9 	.word	0x0000a1f9

00003224 <dhcp_delete_msg>:
{
    3224:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
    3226:	b140      	cbz	r0, 323a <dhcp_delete_msg+0x16>
    3228:	4604      	mov	r4, r0
	if (dhcp->p_out != NULL) {
    322a:	6900      	ldr	r0, [r0, #16]
    322c:	b108      	cbz	r0, 3232 <dhcp_delete_msg+0xe>
		pbuf_free(dhcp->p_out);
    322e:	4b07      	ldr	r3, [pc, #28]	; (324c <dhcp_delete_msg+0x28>)
    3230:	4798      	blx	r3
	dhcp->p_out   = NULL;
    3232:	2300      	movs	r3, #0
    3234:	6123      	str	r3, [r4, #16]
	dhcp->msg_out = NULL;
    3236:	6163      	str	r3, [r4, #20]
    3238:	bd10      	pop	{r4, pc}
	LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
    323a:	4b05      	ldr	r3, [pc, #20]	; (3250 <dhcp_delete_msg+0x2c>)
    323c:	f240 62d3 	movw	r2, #1747	; 0x6d3
    3240:	4904      	ldr	r1, [pc, #16]	; (3254 <dhcp_delete_msg+0x30>)
    3242:	4805      	ldr	r0, [pc, #20]	; (3258 <dhcp_delete_msg+0x34>)
    3244:	4c05      	ldr	r4, [pc, #20]	; (325c <dhcp_delete_msg+0x38>)
    3246:	47a0      	blx	r4
    3248:	e7fe      	b.n	3248 <dhcp_delete_msg+0x24>
    324a:	bf00      	nop
    324c:	00005d21 	.word	0x00005d21
    3250:	0000b3e0 	.word	0x0000b3e0
    3254:	0000b4d4 	.word	0x0000b4d4
    3258:	0000b428 	.word	0x0000b428
    325c:	0000a111 	.word	0x0000a111

00003260 <dhcp_rebind>:
{
    3260:	b570      	push	{r4, r5, r6, lr}
    3262:	b082      	sub	sp, #8
    3264:	4606      	mov	r6, r0
	struct dhcp *dhcp = netif->dhcp;
    3266:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
    3268:	4827      	ldr	r0, [pc, #156]	; (3308 <dhcp_rebind+0xa8>)
    326a:	4b28      	ldr	r3, [pc, #160]	; (330c <dhcp_rebind+0xac>)
    326c:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_REBINDING);
    326e:	2104      	movs	r1, #4
    3270:	4620      	mov	r0, r4
    3272:	4b27      	ldr	r3, [pc, #156]	; (3310 <dhcp_rebind+0xb0>)
    3274:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    3276:	2203      	movs	r2, #3
    3278:	4621      	mov	r1, r4
    327a:	4630      	mov	r0, r6
    327c:	4b25      	ldr	r3, [pc, #148]	; (3314 <dhcp_rebind+0xb4>)
    327e:	4798      	blx	r3
	if (result == ERR_OK) {
    3280:	4605      	mov	r5, r0
    3282:	2800      	cmp	r0, #0
    3284:	d139      	bne.n	32fa <dhcp_rebind+0x9a>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    3286:	2202      	movs	r2, #2
    3288:	2139      	movs	r1, #57	; 0x39
    328a:	4620      	mov	r0, r4
    328c:	4b22      	ldr	r3, [pc, #136]	; (3318 <dhcp_rebind+0xb8>)
    328e:	4798      	blx	r3
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    3290:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
    3292:	4620      	mov	r0, r4
    3294:	4b21      	ldr	r3, [pc, #132]	; (331c <dhcp_rebind+0xbc>)
    3296:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    3298:	4620      	mov	r0, r4
    329a:	4b21      	ldr	r3, [pc, #132]	; (3320 <dhcp_rebind+0xc0>)
    329c:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    329e:	8b21      	ldrh	r1, [r4, #24]
    32a0:	31f0      	adds	r1, #240	; 0xf0
    32a2:	b289      	uxth	r1, r1
    32a4:	6920      	ldr	r0, [r4, #16]
    32a6:	4b1f      	ldr	r3, [pc, #124]	; (3324 <dhcp_rebind+0xc4>)
    32a8:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    32aa:	6921      	ldr	r1, [r4, #16]
    32ac:	6860      	ldr	r0, [r4, #4]
    32ae:	9600      	str	r6, [sp, #0]
    32b0:	2343      	movs	r3, #67	; 0x43
    32b2:	4a1d      	ldr	r2, [pc, #116]	; (3328 <dhcp_rebind+0xc8>)
    32b4:	4e1d      	ldr	r6, [pc, #116]	; (332c <dhcp_rebind+0xcc>)
    32b6:	47b0      	blx	r6
		dhcp_delete_msg(dhcp);
    32b8:	4620      	mov	r0, r4
    32ba:	4b1d      	ldr	r3, [pc, #116]	; (3330 <dhcp_rebind+0xd0>)
    32bc:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
    32be:	481d      	ldr	r0, [pc, #116]	; (3334 <dhcp_rebind+0xd4>)
    32c0:	4b12      	ldr	r3, [pc, #72]	; (330c <dhcp_rebind+0xac>)
    32c2:	4798      	blx	r3
	dhcp->tries++;
    32c4:	7b61      	ldrb	r1, [r4, #13]
    32c6:	3101      	adds	r1, #1
    32c8:	b2c9      	uxtb	r1, r1
    32ca:	7361      	strb	r1, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    32cc:	2909      	cmp	r1, #9
    32ce:	d818      	bhi.n	3302 <dhcp_rebind+0xa2>
    32d0:	ebc1 1341 	rsb	r3, r1, r1, lsl #5
    32d4:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    32d8:	00c9      	lsls	r1, r1, #3
    32da:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    32dc:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    32e0:	4a15      	ldr	r2, [pc, #84]	; (3338 <dhcp_rebind+0xd8>)
    32e2:	fb82 0203 	smull	r0, r2, r2, r3
    32e6:	17db      	asrs	r3, r3, #31
    32e8:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    32ec:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    32ee:	4813      	ldr	r0, [pc, #76]	; (333c <dhcp_rebind+0xdc>)
    32f0:	4b13      	ldr	r3, [pc, #76]	; (3340 <dhcp_rebind+0xe0>)
    32f2:	4798      	blx	r3
}
    32f4:	4628      	mov	r0, r5
    32f6:	b002      	add	sp, #8
    32f8:	bd70      	pop	{r4, r5, r6, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    32fa:	4812      	ldr	r0, [pc, #72]	; (3344 <dhcp_rebind+0xe4>)
    32fc:	4b03      	ldr	r3, [pc, #12]	; (330c <dhcp_rebind+0xac>)
    32fe:	4798      	blx	r3
    3300:	e7e0      	b.n	32c4 <dhcp_rebind+0x64>
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    3302:	f242 7110 	movw	r1, #10000	; 0x2710
    3306:	e7e9      	b.n	32dc <dhcp_rebind+0x7c>
    3308:	0000b4f4 	.word	0x0000b4f4
    330c:	0000a1f9 	.word	0x0000a1f9
    3310:	00002f75 	.word	0x00002f75
    3314:	00003079 	.word	0x00003079
    3318:	00002f85 	.word	0x00002f85
    331c:	00002fbd 	.word	0x00002fbd
    3320:	00003029 	.word	0x00003029
    3324:	00005ec5 	.word	0x00005ec5
    3328:	0000c3d8 	.word	0x0000c3d8
    332c:	00008d49 	.word	0x00008d49
    3330:	00003225 	.word	0x00003225
    3334:	0000b504 	.word	0x0000b504
    3338:	10624dd3 	.word	0x10624dd3
    333c:	0000b54c 	.word	0x0000b54c
    3340:	0000a111 	.word	0x0000a111
    3344:	0000b51c 	.word	0x0000b51c

00003348 <dhcp_discover>:
{
    3348:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    334c:	b082      	sub	sp, #8
    334e:	4606      	mov	r6, r0
	struct dhcp *dhcp   = netif->dhcp;
    3350:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
    3352:	4836      	ldr	r0, [pc, #216]	; (342c <dhcp_discover+0xe4>)
    3354:	4b36      	ldr	r3, [pc, #216]	; (3430 <dhcp_discover+0xe8>)
    3356:	4798      	blx	r3
	ip_addr_set_any(&dhcp->offered_ip_addr);
    3358:	2300      	movs	r3, #0
    335a:	6263      	str	r3, [r4, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_SELECTING);
    335c:	2106      	movs	r1, #6
    335e:	4620      	mov	r0, r4
    3360:	4b34      	ldr	r3, [pc, #208]	; (3434 <dhcp_discover+0xec>)
    3362:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
    3364:	2201      	movs	r2, #1
    3366:	4621      	mov	r1, r4
    3368:	4630      	mov	r0, r6
    336a:	4b33      	ldr	r3, [pc, #204]	; (3438 <dhcp_discover+0xf0>)
    336c:	4798      	blx	r3
	if (result == ERR_OK) {
    336e:	4605      	mov	r5, r0
    3370:	2800      	cmp	r0, #0
    3372:	d156      	bne.n	3422 <dhcp_discover+0xda>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    3374:	4831      	ldr	r0, [pc, #196]	; (343c <dhcp_discover+0xf4>)
    3376:	4f2e      	ldr	r7, [pc, #184]	; (3430 <dhcp_discover+0xe8>)
    3378:	47b8      	blx	r7
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    337a:	2202      	movs	r2, #2
    337c:	2139      	movs	r1, #57	; 0x39
    337e:	4620      	mov	r0, r4
    3380:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 3478 <dhcp_discover+0x130>
    3384:	47c0      	blx	r8
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    3386:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
    3388:	4620      	mov	r0, r4
    338a:	4b2d      	ldr	r3, [pc, #180]	; (3440 <dhcp_discover+0xf8>)
    338c:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4 /*num options*/);
    338e:	2204      	movs	r2, #4
    3390:	2137      	movs	r1, #55	; 0x37
    3392:	4620      	mov	r0, r4
    3394:	47c0      	blx	r8
		dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    3396:	2101      	movs	r1, #1
    3398:	4620      	mov	r0, r4
    339a:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 347c <dhcp_discover+0x134>
    339e:	47c0      	blx	r8
		dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    33a0:	2103      	movs	r1, #3
    33a2:	4620      	mov	r0, r4
    33a4:	47c0      	blx	r8
		dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    33a6:	211c      	movs	r1, #28
    33a8:	4620      	mov	r0, r4
    33aa:	47c0      	blx	r8
		dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    33ac:	2106      	movs	r1, #6
    33ae:	4620      	mov	r0, r4
    33b0:	47c0      	blx	r8
		dhcp_option_trailer(dhcp);
    33b2:	4620      	mov	r0, r4
    33b4:	4b23      	ldr	r3, [pc, #140]	; (3444 <dhcp_discover+0xfc>)
    33b6:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    33b8:	4823      	ldr	r0, [pc, #140]	; (3448 <dhcp_discover+0x100>)
    33ba:	47b8      	blx	r7
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    33bc:	8b21      	ldrh	r1, [r4, #24]
    33be:	31f0      	adds	r1, #240	; 0xf0
    33c0:	b289      	uxth	r1, r1
    33c2:	6920      	ldr	r0, [r4, #16]
    33c4:	4b21      	ldr	r3, [pc, #132]	; (344c <dhcp_discover+0x104>)
    33c6:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    33c8:	4821      	ldr	r0, [pc, #132]	; (3450 <dhcp_discover+0x108>)
    33ca:	47b8      	blx	r7
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    33cc:	6921      	ldr	r1, [r4, #16]
    33ce:	6860      	ldr	r0, [r4, #4]
    33d0:	9600      	str	r6, [sp, #0]
    33d2:	2343      	movs	r3, #67	; 0x43
    33d4:	4a1f      	ldr	r2, [pc, #124]	; (3454 <dhcp_discover+0x10c>)
    33d6:	4e20      	ldr	r6, [pc, #128]	; (3458 <dhcp_discover+0x110>)
    33d8:	47b0      	blx	r6
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    33da:	4820      	ldr	r0, [pc, #128]	; (345c <dhcp_discover+0x114>)
    33dc:	47b8      	blx	r7
		dhcp_delete_msg(dhcp);
    33de:	4620      	mov	r0, r4
    33e0:	4b1f      	ldr	r3, [pc, #124]	; (3460 <dhcp_discover+0x118>)
    33e2:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    33e4:	481f      	ldr	r0, [pc, #124]	; (3464 <dhcp_discover+0x11c>)
    33e6:	47b8      	blx	r7
	dhcp->tries++;
    33e8:	7b61      	ldrb	r1, [r4, #13]
    33ea:	3101      	adds	r1, #1
    33ec:	b2c9      	uxtb	r1, r1
    33ee:	7361      	strb	r1, [r4, #13]
	msecs                 = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    33f0:	2905      	cmp	r1, #5
    33f2:	bf9a      	itte	ls
    33f4:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
    33f8:	fa03 f101 	lslls.w	r1, r3, r1
    33fc:	f64e 2160 	movwhi	r1, #60000	; 0xea60
    3400:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3402:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    3406:	4a18      	ldr	r2, [pc, #96]	; (3468 <dhcp_discover+0x120>)
    3408:	fb82 0203 	smull	r0, r2, r2, r3
    340c:	17db      	asrs	r3, r3, #31
    340e:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    3412:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    3414:	4815      	ldr	r0, [pc, #84]	; (346c <dhcp_discover+0x124>)
    3416:	4b16      	ldr	r3, [pc, #88]	; (3470 <dhcp_discover+0x128>)
    3418:	4798      	blx	r3
}
    341a:	4628      	mov	r0, r5
    341c:	b002      	add	sp, #8
    341e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    3422:	4814      	ldr	r0, [pc, #80]	; (3474 <dhcp_discover+0x12c>)
    3424:	4b02      	ldr	r3, [pc, #8]	; (3430 <dhcp_discover+0xe8>)
    3426:	4798      	blx	r3
    3428:	e7de      	b.n	33e8 <dhcp_discover+0xa0>
    342a:	bf00      	nop
    342c:	0000b57c 	.word	0x0000b57c
    3430:	0000a1f9 	.word	0x0000a1f9
    3434:	00002f75 	.word	0x00002f75
    3438:	00003079 	.word	0x00003079
    343c:	0000b58c 	.word	0x0000b58c
    3440:	00002fbd 	.word	0x00002fbd
    3444:	00003029 	.word	0x00003029
    3448:	0000b5ac 	.word	0x0000b5ac
    344c:	00005ec5 	.word	0x00005ec5
    3450:	0000b5c8 	.word	0x0000b5c8
    3454:	0000c3d8 	.word	0x0000c3d8
    3458:	00008d49 	.word	0x00008d49
    345c:	0000b610 	.word	0x0000b610
    3460:	00003225 	.word	0x00003225
    3464:	0000b630 	.word	0x0000b630
    3468:	10624dd3 	.word	0x10624dd3
    346c:	0000b67c 	.word	0x0000b67c
    3470:	0000a111 	.word	0x0000a111
    3474:	0000b64c 	.word	0x0000b64c
    3478:	00002f85 	.word	0x00002f85
    347c:	00002fa7 	.word	0x00002fa7

00003480 <dhcp_select>:
{
    3480:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    3484:	b083      	sub	sp, #12
    3486:	4605      	mov	r5, r0
	struct dhcp *dhcp = netif->dhcp;
    3488:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(
    348a:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
    348e:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
    3492:	f890 1038 	ldrb.w	r1, [r0, #56]	; 0x38
    3496:	9100      	str	r1, [sp, #0]
    3498:	4601      	mov	r1, r0
    349a:	483a      	ldr	r0, [pc, #232]	; (3584 <dhcp_select+0x104>)
    349c:	4e3a      	ldr	r6, [pc, #232]	; (3588 <dhcp_select+0x108>)
    349e:	47b0      	blx	r6
	dhcp_set_state(dhcp, DHCP_REQUESTING);
    34a0:	2101      	movs	r1, #1
    34a2:	4620      	mov	r0, r4
    34a4:	4b39      	ldr	r3, [pc, #228]	; (358c <dhcp_select+0x10c>)
    34a6:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    34a8:	2203      	movs	r2, #3
    34aa:	4621      	mov	r1, r4
    34ac:	4628      	mov	r0, r5
    34ae:	4b38      	ldr	r3, [pc, #224]	; (3590 <dhcp_select+0x110>)
    34b0:	4798      	blx	r3
	if (result == ERR_OK) {
    34b2:	4681      	mov	r9, r0
    34b4:	2800      	cmp	r0, #0
    34b6:	d161      	bne.n	357c <dhcp_select+0xfc>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    34b8:	2202      	movs	r2, #2
    34ba:	2139      	movs	r1, #57	; 0x39
    34bc:	4620      	mov	r0, r4
    34be:	4f35      	ldr	r7, [pc, #212]	; (3594 <dhcp_select+0x114>)
    34c0:	47b8      	blx	r7
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    34c2:	8da9      	ldrh	r1, [r5, #44]	; 0x2c
    34c4:	4620      	mov	r0, r4
    34c6:	4b34      	ldr	r3, [pc, #208]	; (3598 <dhcp_select+0x118>)
    34c8:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    34ca:	2204      	movs	r2, #4
    34cc:	2132      	movs	r1, #50	; 0x32
    34ce:	4620      	mov	r0, r4
    34d0:	47b8      	blx	r7
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    34d2:	6a60      	ldr	r0, [r4, #36]	; 0x24
    34d4:	4e31      	ldr	r6, [pc, #196]	; (359c <dhcp_select+0x11c>)
    34d6:	47b0      	blx	r6
    34d8:	4601      	mov	r1, r0
    34da:	4620      	mov	r0, r4
    34dc:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 35cc <dhcp_select+0x14c>
    34e0:	47c0      	blx	r8
		dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    34e2:	2204      	movs	r2, #4
    34e4:	2136      	movs	r1, #54	; 0x36
    34e6:	4620      	mov	r0, r4
    34e8:	47b8      	blx	r7
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->server_ip_addr)));
    34ea:	6a20      	ldr	r0, [r4, #32]
    34ec:	47b0      	blx	r6
    34ee:	4601      	mov	r1, r0
    34f0:	4620      	mov	r0, r4
    34f2:	47c0      	blx	r8
		dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4 /*num options*/);
    34f4:	2204      	movs	r2, #4
    34f6:	2137      	movs	r1, #55	; 0x37
    34f8:	4620      	mov	r0, r4
    34fa:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    34fc:	2101      	movs	r1, #1
    34fe:	4620      	mov	r0, r4
    3500:	4f27      	ldr	r7, [pc, #156]	; (35a0 <dhcp_select+0x120>)
    3502:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    3504:	2103      	movs	r1, #3
    3506:	4620      	mov	r0, r4
    3508:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    350a:	211c      	movs	r1, #28
    350c:	4620      	mov	r0, r4
    350e:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    3510:	2106      	movs	r1, #6
    3512:	4620      	mov	r0, r4
    3514:	47b8      	blx	r7
		dhcp_option_trailer(dhcp);
    3516:	4620      	mov	r0, r4
    3518:	4b22      	ldr	r3, [pc, #136]	; (35a4 <dhcp_select+0x124>)
    351a:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    351c:	8b21      	ldrh	r1, [r4, #24]
    351e:	31f0      	adds	r1, #240	; 0xf0
    3520:	b289      	uxth	r1, r1
    3522:	6920      	ldr	r0, [r4, #16]
    3524:	4b20      	ldr	r3, [pc, #128]	; (35a8 <dhcp_select+0x128>)
    3526:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    3528:	6921      	ldr	r1, [r4, #16]
    352a:	6860      	ldr	r0, [r4, #4]
    352c:	9500      	str	r5, [sp, #0]
    352e:	2343      	movs	r3, #67	; 0x43
    3530:	4a1e      	ldr	r2, [pc, #120]	; (35ac <dhcp_select+0x12c>)
    3532:	4d1f      	ldr	r5, [pc, #124]	; (35b0 <dhcp_select+0x130>)
    3534:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    3536:	4620      	mov	r0, r4
    3538:	4b1e      	ldr	r3, [pc, #120]	; (35b4 <dhcp_select+0x134>)
    353a:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    353c:	481e      	ldr	r0, [pc, #120]	; (35b8 <dhcp_select+0x138>)
    353e:	4b1f      	ldr	r3, [pc, #124]	; (35bc <dhcp_select+0x13c>)
    3540:	4798      	blx	r3
	dhcp->tries++;
    3542:	7b61      	ldrb	r1, [r4, #13]
    3544:	3101      	adds	r1, #1
    3546:	b2c9      	uxtb	r1, r1
    3548:	7361      	strb	r1, [r4, #13]
	msecs                 = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    354a:	2905      	cmp	r1, #5
    354c:	bf9a      	itte	ls
    354e:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
    3552:	fa03 f101 	lslls.w	r1, r3, r1
    3556:	f64e 2160 	movwhi	r1, #60000	; 0xea60
    355a:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    355c:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    3560:	4a17      	ldr	r2, [pc, #92]	; (35c0 <dhcp_select+0x140>)
    3562:	fb82 0203 	smull	r0, r2, r2, r3
    3566:	17db      	asrs	r3, r3, #31
    3568:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    356c:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %" U16_F " msecs\n", msecs));
    356e:	4815      	ldr	r0, [pc, #84]	; (35c4 <dhcp_select+0x144>)
    3570:	4b05      	ldr	r3, [pc, #20]	; (3588 <dhcp_select+0x108>)
    3572:	4798      	blx	r3
}
    3574:	4648      	mov	r0, r9
    3576:	b003      	add	sp, #12
    3578:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    357c:	4812      	ldr	r0, [pc, #72]	; (35c8 <dhcp_select+0x148>)
    357e:	4b0f      	ldr	r3, [pc, #60]	; (35bc <dhcp_select+0x13c>)
    3580:	4798      	blx	r3
    3582:	e7de      	b.n	3542 <dhcp_select+0xc2>
    3584:	0000b6ac 	.word	0x0000b6ac
    3588:	0000a111 	.word	0x0000a111
    358c:	00002f75 	.word	0x00002f75
    3590:	00003079 	.word	0x00003079
    3594:	00002f85 	.word	0x00002f85
    3598:	00002fbd 	.word	0x00002fbd
    359c:	00002f69 	.word	0x00002f69
    35a0:	00002fa7 	.word	0x00002fa7
    35a4:	00003029 	.word	0x00003029
    35a8:	00005ec5 	.word	0x00005ec5
    35ac:	0000c3d8 	.word	0x0000c3d8
    35b0:	00008d49 	.word	0x00008d49
    35b4:	00003225 	.word	0x00003225
    35b8:	0000b6cc 	.word	0x0000b6cc
    35bc:	0000a1f9 	.word	0x0000a1f9
    35c0:	10624dd3 	.word	0x10624dd3
    35c4:	0000b714 	.word	0x0000b714
    35c8:	0000b6e4 	.word	0x0000b6e4
    35cc:	00002fe3 	.word	0x00002fe3

000035d0 <dhcp_reboot>:
{
    35d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    35d2:	b083      	sub	sp, #12
    35d4:	4606      	mov	r6, r0
	struct dhcp *dhcp = netif->dhcp;
    35d6:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
    35d8:	482d      	ldr	r0, [pc, #180]	; (3690 <dhcp_reboot+0xc0>)
    35da:	4b2e      	ldr	r3, [pc, #184]	; (3694 <dhcp_reboot+0xc4>)
    35dc:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_REBOOTING);
    35de:	2103      	movs	r1, #3
    35e0:	4620      	mov	r0, r4
    35e2:	4b2d      	ldr	r3, [pc, #180]	; (3698 <dhcp_reboot+0xc8>)
    35e4:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    35e6:	2203      	movs	r2, #3
    35e8:	4621      	mov	r1, r4
    35ea:	4630      	mov	r0, r6
    35ec:	4b2b      	ldr	r3, [pc, #172]	; (369c <dhcp_reboot+0xcc>)
    35ee:	4798      	blx	r3
	if (result == ERR_OK) {
    35f0:	4605      	mov	r5, r0
    35f2:	2800      	cmp	r0, #0
    35f4:	d145      	bne.n	3682 <dhcp_reboot+0xb2>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    35f6:	2202      	movs	r2, #2
    35f8:	2139      	movs	r1, #57	; 0x39
    35fa:	4620      	mov	r0, r4
    35fc:	4f28      	ldr	r7, [pc, #160]	; (36a0 <dhcp_reboot+0xd0>)
    35fe:	47b8      	blx	r7
		dhcp_option_short(dhcp, 576);
    3600:	f44f 7110 	mov.w	r1, #576	; 0x240
    3604:	4620      	mov	r0, r4
    3606:	4b27      	ldr	r3, [pc, #156]	; (36a4 <dhcp_reboot+0xd4>)
    3608:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    360a:	2204      	movs	r2, #4
    360c:	2132      	movs	r1, #50	; 0x32
    360e:	4620      	mov	r0, r4
    3610:	47b8      	blx	r7
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    3612:	6a60      	ldr	r0, [r4, #36]	; 0x24
    3614:	4b24      	ldr	r3, [pc, #144]	; (36a8 <dhcp_reboot+0xd8>)
    3616:	4798      	blx	r3
    3618:	4601      	mov	r1, r0
    361a:	4620      	mov	r0, r4
    361c:	4b23      	ldr	r3, [pc, #140]	; (36ac <dhcp_reboot+0xdc>)
    361e:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    3620:	4620      	mov	r0, r4
    3622:	4b23      	ldr	r3, [pc, #140]	; (36b0 <dhcp_reboot+0xe0>)
    3624:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3626:	8b21      	ldrh	r1, [r4, #24]
    3628:	31f0      	adds	r1, #240	; 0xf0
    362a:	b289      	uxth	r1, r1
    362c:	6920      	ldr	r0, [r4, #16]
    362e:	4b21      	ldr	r3, [pc, #132]	; (36b4 <dhcp_reboot+0xe4>)
    3630:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    3632:	6921      	ldr	r1, [r4, #16]
    3634:	6860      	ldr	r0, [r4, #4]
    3636:	9600      	str	r6, [sp, #0]
    3638:	2343      	movs	r3, #67	; 0x43
    363a:	4a1f      	ldr	r2, [pc, #124]	; (36b8 <dhcp_reboot+0xe8>)
    363c:	4e1f      	ldr	r6, [pc, #124]	; (36bc <dhcp_reboot+0xec>)
    363e:	47b0      	blx	r6
		dhcp_delete_msg(dhcp);
    3640:	4620      	mov	r0, r4
    3642:	4b1f      	ldr	r3, [pc, #124]	; (36c0 <dhcp_reboot+0xf0>)
    3644:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
    3646:	481f      	ldr	r0, [pc, #124]	; (36c4 <dhcp_reboot+0xf4>)
    3648:	4b12      	ldr	r3, [pc, #72]	; (3694 <dhcp_reboot+0xc4>)
    364a:	4798      	blx	r3
	dhcp->tries++;
    364c:	7b61      	ldrb	r1, [r4, #13]
    364e:	3101      	adds	r1, #1
    3650:	b2c9      	uxtb	r1, r1
    3652:	7361      	strb	r1, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    3654:	2909      	cmp	r1, #9
    3656:	d818      	bhi.n	368a <dhcp_reboot+0xba>
    3658:	ebc1 1341 	rsb	r3, r1, r1, lsl #5
    365c:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    3660:	00c9      	lsls	r1, r1, #3
    3662:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3664:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    3668:	4a17      	ldr	r2, [pc, #92]	; (36c8 <dhcp_reboot+0xf8>)
    366a:	fb82 0203 	smull	r0, r2, r2, r3
    366e:	17db      	asrs	r3, r3, #31
    3670:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    3674:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    3676:	4815      	ldr	r0, [pc, #84]	; (36cc <dhcp_reboot+0xfc>)
    3678:	4b15      	ldr	r3, [pc, #84]	; (36d0 <dhcp_reboot+0x100>)
    367a:	4798      	blx	r3
}
    367c:	4628      	mov	r0, r5
    367e:	b003      	add	sp, #12
    3680:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    3682:	4814      	ldr	r0, [pc, #80]	; (36d4 <dhcp_reboot+0x104>)
    3684:	4b03      	ldr	r3, [pc, #12]	; (3694 <dhcp_reboot+0xc4>)
    3686:	4798      	blx	r3
    3688:	e7e0      	b.n	364c <dhcp_reboot+0x7c>
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    368a:	f242 7110 	movw	r1, #10000	; 0x2710
    368e:	e7e9      	b.n	3664 <dhcp_reboot+0x94>
    3690:	0000b744 	.word	0x0000b744
    3694:	0000a1f9 	.word	0x0000a1f9
    3698:	00002f75 	.word	0x00002f75
    369c:	00003079 	.word	0x00003079
    36a0:	00002f85 	.word	0x00002f85
    36a4:	00002fbd 	.word	0x00002fbd
    36a8:	00002f69 	.word	0x00002f69
    36ac:	00002fe3 	.word	0x00002fe3
    36b0:	00003029 	.word	0x00003029
    36b4:	00005ec5 	.word	0x00005ec5
    36b8:	0000c3d8 	.word	0x0000c3d8
    36bc:	00008d49 	.word	0x00008d49
    36c0:	00003225 	.word	0x00003225
    36c4:	0000b754 	.word	0x0000b754
    36c8:	10624dd3 	.word	0x10624dd3
    36cc:	0000b79c 	.word	0x0000b79c
    36d0:	0000a111 	.word	0x0000a111
    36d4:	0000b76c 	.word	0x0000b76c

000036d8 <dhcp_check>:
{
    36d8:	b570      	push	{r4, r5, r6, lr}
    36da:	4605      	mov	r5, r0
	struct dhcp *dhcp = netif->dhcp;
    36dc:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    36de:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
    36e2:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
    36e6:	4601      	mov	r1, r0
    36e8:	480e      	ldr	r0, [pc, #56]	; (3724 <dhcp_check+0x4c>)
    36ea:	4e0f      	ldr	r6, [pc, #60]	; (3728 <dhcp_check+0x50>)
    36ec:	47b0      	blx	r6
	dhcp_set_state(dhcp, DHCP_CHECKING);
    36ee:	2108      	movs	r1, #8
    36f0:	4620      	mov	r0, r4
    36f2:	4b0e      	ldr	r3, [pc, #56]	; (372c <dhcp_check+0x54>)
    36f4:	4798      	blx	r3
	result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
    36f6:	2200      	movs	r2, #0
    36f8:	f104 0124 	add.w	r1, r4, #36	; 0x24
    36fc:	4628      	mov	r0, r5
    36fe:	4b0c      	ldr	r3, [pc, #48]	; (3730 <dhcp_check+0x58>)
    3700:	4798      	blx	r3
	if (result != ERR_OK) {
    3702:	b950      	cbnz	r0, 371a <dhcp_check+0x42>
	dhcp->tries++;
    3704:	7b63      	ldrb	r3, [r4, #13]
    3706:	3301      	adds	r3, #1
    3708:	7363      	strb	r3, [r4, #13]
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    370a:	2301      	movs	r3, #1
    370c:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    370e:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    3712:	4808      	ldr	r0, [pc, #32]	; (3734 <dhcp_check+0x5c>)
    3714:	4b04      	ldr	r3, [pc, #16]	; (3728 <dhcp_check+0x50>)
    3716:	4798      	blx	r3
    3718:	bd70      	pop	{r4, r5, r6, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    371a:	4807      	ldr	r0, [pc, #28]	; (3738 <dhcp_check+0x60>)
    371c:	4b07      	ldr	r3, [pc, #28]	; (373c <dhcp_check+0x64>)
    371e:	4798      	blx	r3
    3720:	e7f0      	b.n	3704 <dhcp_check+0x2c>
    3722:	bf00      	nop
    3724:	0000b7cc 	.word	0x0000b7cc
    3728:	0000a111 	.word	0x0000a111
    372c:	00002f75 	.word	0x00002f75
    3730:	00009245 	.word	0x00009245
    3734:	0000b810 	.word	0x0000b810
    3738:	0000b7e8 	.word	0x0000b7e8
    373c:	0000a1f9 	.word	0x0000a1f9

00003740 <dhcp_bind>:
{
    3740:	b5f0      	push	{r4, r5, r6, r7, lr}
    3742:	b085      	sub	sp, #20
	LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
    3744:	2800      	cmp	r0, #0
    3746:	f000 8085 	beq.w	3854 <dhcp_bind+0x114>
    374a:	4605      	mov	r5, r0
	dhcp = netif->dhcp;
    374c:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
    374e:	2c00      	cmp	r4, #0
    3750:	f000 8088 	beq.w	3864 <dhcp_bind+0x124>
	LWIP_DEBUGF(
    3754:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
    3758:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
    375c:	f890 1038 	ldrb.w	r1, [r0, #56]	; 0x38
    3760:	9100      	str	r1, [sp, #0]
    3762:	4601      	mov	r1, r0
    3764:	484e      	ldr	r0, [pc, #312]	; (38a0 <dhcp_bind+0x160>)
    3766:	4e4f      	ldr	r6, [pc, #316]	; (38a4 <dhcp_bind+0x164>)
    3768:	47b0      	blx	r6
	if (dhcp->offered_t1_renew != 0xffffffffUL) {
    376a:	6b61      	ldr	r1, [r4, #52]	; 0x34
    376c:	f1b1 3fff 	cmp.w	r1, #4294967295
    3770:	d018      	beq.n	37a4 <dhcp_bind+0x64>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    3772:	484d      	ldr	r0, [pc, #308]	; (38a8 <dhcp_bind+0x168>)
    3774:	47b0      	blx	r6
		timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    3776:	6b62      	ldr	r2, [r4, #52]	; 0x34
    3778:	f102 031e 	add.w	r3, r2, #30
    377c:	494b      	ldr	r1, [pc, #300]	; (38ac <dhcp_bind+0x16c>)
    377e:	fba1 1303 	umull	r1, r3, r1, r3
    3782:	095b      	lsrs	r3, r3, #5
		dhcp->t1_timeout = (u16_t)timeout;
    3784:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3788:	428b      	cmp	r3, r1
    378a:	bf28      	it	cs
    378c:	460b      	movcs	r3, r1
    378e:	b29b      	uxth	r3, r3
		if (dhcp->t1_timeout == 0) {
    3790:	2b00      	cmp	r3, #0
    3792:	d06f      	beq.n	3874 <dhcp_bind+0x134>
		dhcp->t1_timeout = (u16_t)timeout;
    3794:	83a3      	strh	r3, [r4, #28]
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    3796:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    379a:	fb01 f102 	mul.w	r1, r1, r2
    379e:	4844      	ldr	r0, [pc, #272]	; (38b0 <dhcp_bind+0x170>)
    37a0:	4b40      	ldr	r3, [pc, #256]	; (38a4 <dhcp_bind+0x164>)
    37a2:	4798      	blx	r3
	if (dhcp->offered_t2_rebind != 0xffffffffUL) {
    37a4:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    37a6:	f1b1 3fff 	cmp.w	r1, #4294967295
    37aa:	d019      	beq.n	37e0 <dhcp_bind+0xa0>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    37ac:	4841      	ldr	r0, [pc, #260]	; (38b4 <dhcp_bind+0x174>)
    37ae:	4b3d      	ldr	r3, [pc, #244]	; (38a4 <dhcp_bind+0x164>)
    37b0:	4798      	blx	r3
		timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    37b2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    37b4:	f102 031e 	add.w	r3, r2, #30
    37b8:	493c      	ldr	r1, [pc, #240]	; (38ac <dhcp_bind+0x16c>)
    37ba:	fba1 1303 	umull	r1, r3, r1, r3
    37be:	095b      	lsrs	r3, r3, #5
		dhcp->t2_timeout = (u16_t)timeout;
    37c0:	f64f 71ff 	movw	r1, #65535	; 0xffff
    37c4:	428b      	cmp	r3, r1
    37c6:	bf28      	it	cs
    37c8:	460b      	movcs	r3, r1
    37ca:	b29b      	uxth	r3, r3
		if (dhcp->t2_timeout == 0) {
    37cc:	2b00      	cmp	r3, #0
    37ce:	d054      	beq.n	387a <dhcp_bind+0x13a>
		dhcp->t2_timeout = (u16_t)timeout;
    37d0:	83e3      	strh	r3, [r4, #30]
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    37d2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    37d6:	fb01 f102 	mul.w	r1, r1, r2
    37da:	4835      	ldr	r0, [pc, #212]	; (38b0 <dhcp_bind+0x170>)
    37dc:	4b31      	ldr	r3, [pc, #196]	; (38a4 <dhcp_bind+0x164>)
    37de:	4798      	blx	r3
	if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
    37e0:	8be3      	ldrh	r3, [r4, #30]
    37e2:	8ba2      	ldrh	r2, [r4, #28]
    37e4:	429a      	cmp	r2, r3
    37e6:	d302      	bcc.n	37ee <dhcp_bind+0xae>
    37e8:	b10b      	cbz	r3, 37ee <dhcp_bind+0xae>
		dhcp->t1_timeout = 0;
    37ea:	2300      	movs	r3, #0
    37ec:	83a3      	strh	r3, [r4, #28]
	if (dhcp->subnet_mask_given) {
    37ee:	7ba3      	ldrb	r3, [r4, #14]
    37f0:	2b00      	cmp	r3, #0
    37f2:	d045      	beq.n	3880 <dhcp_bind+0x140>
		ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
    37f4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    37f6:	9303      	str	r3, [sp, #12]
	ip_addr_copy(gw_addr, dhcp->offered_gw_addr);
    37f8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    37fa:	9302      	str	r3, [sp, #8]
	if (ip_addr_isany(&gw_addr)) {
    37fc:	b92b      	cbnz	r3, 380a <dhcp_bind+0xca>
		ip_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
    37fe:	6a63      	ldr	r3, [r4, #36]	; 0x24
    3800:	9a03      	ldr	r2, [sp, #12]
    3802:	4013      	ands	r3, r2
		ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
    3804:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    3808:	9302      	str	r3, [sp, #8]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE,
    380a:	4626      	mov	r6, r4
    380c:	f856 1f24 	ldr.w	r1, [r6, #36]!
    3810:	4829      	ldr	r0, [pc, #164]	; (38b8 <dhcp_bind+0x178>)
    3812:	4f24      	ldr	r7, [pc, #144]	; (38a4 <dhcp_bind+0x164>)
    3814:	47b8      	blx	r7
	netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
    3816:	4631      	mov	r1, r6
    3818:	4628      	mov	r0, r5
    381a:	4b28      	ldr	r3, [pc, #160]	; (38bc <dhcp_bind+0x17c>)
    381c:	4798      	blx	r3
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08" X32_F "\n", ip4_addr_get_u32(&sn_mask)));
    381e:	ae04      	add	r6, sp, #16
    3820:	f856 1d04 	ldr.w	r1, [r6, #-4]!
    3824:	4826      	ldr	r0, [pc, #152]	; (38c0 <dhcp_bind+0x180>)
    3826:	47b8      	blx	r7
	netif_set_netmask(netif, &sn_mask);
    3828:	4631      	mov	r1, r6
    382a:	4628      	mov	r0, r5
    382c:	4b25      	ldr	r3, [pc, #148]	; (38c4 <dhcp_bind+0x184>)
    382e:	4798      	blx	r3
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08" X32_F "\n", ip4_addr_get_u32(&gw_addr)));
    3830:	ae04      	add	r6, sp, #16
    3832:	f856 1d08 	ldr.w	r1, [r6, #-8]!
    3836:	4824      	ldr	r0, [pc, #144]	; (38c8 <dhcp_bind+0x188>)
    3838:	47b8      	blx	r7
	netif_set_gw(netif, &gw_addr);
    383a:	4631      	mov	r1, r6
    383c:	4628      	mov	r0, r5
    383e:	4b23      	ldr	r3, [pc, #140]	; (38cc <dhcp_bind+0x18c>)
    3840:	4798      	blx	r3
	netif_set_up(netif);
    3842:	4628      	mov	r0, r5
    3844:	4b22      	ldr	r3, [pc, #136]	; (38d0 <dhcp_bind+0x190>)
    3846:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_BOUND);
    3848:	210a      	movs	r1, #10
    384a:	4620      	mov	r0, r4
    384c:	4b21      	ldr	r3, [pc, #132]	; (38d4 <dhcp_bind+0x194>)
    384e:	4798      	blx	r3
}
    3850:	b005      	add	sp, #20
    3852:	bdf0      	pop	{r4, r5, r6, r7, pc}
	LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
    3854:	4b20      	ldr	r3, [pc, #128]	; (38d8 <dhcp_bind+0x198>)
    3856:	f240 32a3 	movw	r2, #931	; 0x3a3
    385a:	4920      	ldr	r1, [pc, #128]	; (38dc <dhcp_bind+0x19c>)
    385c:	4820      	ldr	r0, [pc, #128]	; (38e0 <dhcp_bind+0x1a0>)
    385e:	4c11      	ldr	r4, [pc, #68]	; (38a4 <dhcp_bind+0x164>)
    3860:	47a0      	blx	r4
    3862:	e7fe      	b.n	3862 <dhcp_bind+0x122>
	LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
    3864:	4b1c      	ldr	r3, [pc, #112]	; (38d8 <dhcp_bind+0x198>)
    3866:	f240 32a5 	movw	r2, #933	; 0x3a5
    386a:	491e      	ldr	r1, [pc, #120]	; (38e4 <dhcp_bind+0x1a4>)
    386c:	481c      	ldr	r0, [pc, #112]	; (38e0 <dhcp_bind+0x1a0>)
    386e:	4c0d      	ldr	r4, [pc, #52]	; (38a4 <dhcp_bind+0x164>)
    3870:	47a0      	blx	r4
    3872:	e7fe      	b.n	3872 <dhcp_bind+0x132>
			dhcp->t1_timeout = 1;
    3874:	2301      	movs	r3, #1
    3876:	83a3      	strh	r3, [r4, #28]
    3878:	e78d      	b.n	3796 <dhcp_bind+0x56>
			dhcp->t2_timeout = 1;
    387a:	2301      	movs	r3, #1
    387c:	83e3      	strh	r3, [r4, #30]
    387e:	e7a8      	b.n	37d2 <dhcp_bind+0x92>
		u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
    3880:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
		if (first_octet <= 127) {
    3884:	f013 0f80 	tst.w	r3, #128	; 0x80
    3888:	d102      	bne.n	3890 <dhcp_bind+0x150>
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
    388a:	23ff      	movs	r3, #255	; 0xff
    388c:	9303      	str	r3, [sp, #12]
    388e:	e7b3      	b.n	37f8 <dhcp_bind+0xb8>
		} else if (first_octet >= 192) {
    3890:	2bbf      	cmp	r3, #191	; 0xbf
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
    3892:	bf8c      	ite	hi
    3894:	f06f 437f 	mvnhi.w	r3, #4278190080	; 0xff000000
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
    3898:	f64f 73ff 	movwls	r3, #65535	; 0xffff
    389c:	9303      	str	r3, [sp, #12]
    389e:	e7ab      	b.n	37f8 <dhcp_bind+0xb8>
    38a0:	0000b874 	.word	0x0000b874
    38a4:	0000a111 	.word	0x0000a111
    38a8:	0000b894 	.word	0x0000b894
    38ac:	88888889 	.word	0x88888889
    38b0:	0000b8bc 	.word	0x0000b8bc
    38b4:	0000b8e8 	.word	0x0000b8e8
    38b8:	0000b910 	.word	0x0000b910
    38bc:	00005a75 	.word	0x00005a75
    38c0:	0000b92c 	.word	0x0000b92c
    38c4:	00005b65 	.word	0x00005b65
    38c8:	0000b948 	.word	0x0000b948
    38cc:	00005b59 	.word	0x00005b59
    38d0:	00005b7d 	.word	0x00005b7d
    38d4:	00002f75 	.word	0x00002f75
    38d8:	0000b3e0 	.word	0x0000b3e0
    38dc:	0000b840 	.word	0x0000b840
    38e0:	0000b428 	.word	0x0000b428
    38e4:	0000b85c 	.word	0x0000b85c

000038e8 <dhcp_recv>:
{
    38e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    38ec:	b08d      	sub	sp, #52	; 0x34
    38ee:	4681      	mov	r9, r0
    38f0:	4693      	mov	fp, r2
	struct dhcp *    dhcp      = netif->dhcp;
    38f2:	6a82      	ldr	r2, [r0, #40]	; 0x28
    38f4:	9204      	str	r2, [sp, #16]
	struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
    38f6:	f8db 5004 	ldr.w	r5, [fp, #4]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    38fa:	7859      	ldrb	r1, [r3, #1]
    38fc:	781a      	ldrb	r2, [r3, #0]
    38fe:	f8bd 0058 	ldrh.w	r0, [sp, #88]	; 0x58
    3902:	9002      	str	r0, [sp, #8]
    3904:	78d8      	ldrb	r0, [r3, #3]
    3906:	9001      	str	r0, [sp, #4]
    3908:	789b      	ldrb	r3, [r3, #2]
    390a:	9300      	str	r3, [sp, #0]
    390c:	460b      	mov	r3, r1
    390e:	4659      	mov	r1, fp
    3910:	4859      	ldr	r0, [pc, #356]	; (3a78 <dhcp_recv+0x190>)
    3912:	4c5a      	ldr	r4, [pc, #360]	; (3a7c <dhcp_recv+0x194>)
    3914:	47a0      	blx	r4
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->len = %" U16_F "\n", p->len));
    3916:	f8bb 100a 	ldrh.w	r1, [fp, #10]
    391a:	4859      	ldr	r0, [pc, #356]	; (3a80 <dhcp_recv+0x198>)
    391c:	47a0      	blx	r4
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %" U16_F "\n", p->tot_len));
    391e:	f8bb 1008 	ldrh.w	r1, [fp, #8]
    3922:	4858      	ldr	r0, [pc, #352]	; (3a84 <dhcp_recv+0x19c>)
    3924:	47a0      	blx	r4
	if (p->len < DHCP_MIN_REPLY_LEN) {
    3926:	f8bb 300a 	ldrh.w	r3, [fp, #10]
    392a:	2b2b      	cmp	r3, #43	; 0x2b
    392c:	d920      	bls.n	3970 <dhcp_recv+0x88>
	if (reply_msg->op != DHCP_BOOTREPLY) {
    392e:	7829      	ldrb	r1, [r5, #0]
    3930:	2902      	cmp	r1, #2
    3932:	d121      	bne.n	3978 <dhcp_recv+0x90>
	for (i = 0; i < netif->hwaddr_len; i++) {
    3934:	f899 702e 	ldrb.w	r7, [r9, #46]	; 0x2e
    3938:	b367      	cbz	r7, 3994 <dhcp_recv+0xac>
		if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    393a:	f899 202f 	ldrb.w	r2, [r9, #47]	; 0x2f
    393e:	7f28      	ldrb	r0, [r5, #28]
    3940:	4282      	cmp	r2, r0
    3942:	d125      	bne.n	3990 <dhcp_recv+0xa8>
    3944:	f109 0630 	add.w	r6, r9, #48	; 0x30
    3948:	f105 041d 	add.w	r4, r5, #29
    394c:	2301      	movs	r3, #1
	for (i = 0; i < netif->hwaddr_len; i++) {
    394e:	b2da      	uxtb	r2, r3
    3950:	42ba      	cmp	r2, r7
    3952:	d21f      	bcs.n	3994 <dhcp_recv+0xac>
		if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    3954:	4619      	mov	r1, r3
    3956:	f816 2b01 	ldrb.w	r2, [r6], #1
    395a:	f814 0b01 	ldrb.w	r0, [r4], #1
    395e:	3301      	adds	r3, #1
    3960:	4282      	cmp	r2, r0
    3962:	d0f4      	beq.n	394e <dhcp_recv+0x66>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    3964:	9000      	str	r0, [sp, #0]
    3966:	460b      	mov	r3, r1
    3968:	4847      	ldr	r0, [pc, #284]	; (3a88 <dhcp_recv+0x1a0>)
    396a:	4c44      	ldr	r4, [pc, #272]	; (3a7c <dhcp_recv+0x194>)
    396c:	47a0      	blx	r4
			goto free_pbuf_and_return;
    396e:	e006      	b.n	397e <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    3970:	4846      	ldr	r0, [pc, #280]	; (3a8c <dhcp_recv+0x1a4>)
    3972:	4b47      	ldr	r3, [pc, #284]	; (3a90 <dhcp_recv+0x1a8>)
    3974:	4798      	blx	r3
		goto free_pbuf_and_return;
    3976:	e002      	b.n	397e <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    3978:	4846      	ldr	r0, [pc, #280]	; (3a94 <dhcp_recv+0x1ac>)
    397a:	4b40      	ldr	r3, [pc, #256]	; (3a7c <dhcp_recv+0x194>)
    397c:	4798      	blx	r3
	dhcp->msg_in = NULL;
    397e:	2300      	movs	r3, #0
    3980:	9a04      	ldr	r2, [sp, #16]
    3982:	6093      	str	r3, [r2, #8]
	pbuf_free(p);
    3984:	4658      	mov	r0, fp
    3986:	4b44      	ldr	r3, [pc, #272]	; (3a98 <dhcp_recv+0x1b0>)
    3988:	4798      	blx	r3
}
    398a:	b00d      	add	sp, #52	; 0x34
    398c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    3990:	2100      	movs	r1, #0
    3992:	e7e7      	b.n	3964 <dhcp_recv+0x7c>
	if (ntohl(reply_msg->xid) != dhcp->xid) {
    3994:	6868      	ldr	r0, [r5, #4]
    3996:	4b41      	ldr	r3, [pc, #260]	; (3a9c <dhcp_recv+0x1b4>)
    3998:	4798      	blx	r3
    399a:	9c04      	ldr	r4, [sp, #16]
    399c:	6823      	ldr	r3, [r4, #0]
    399e:	4298      	cmp	r0, r3
    39a0:	d008      	beq.n	39b4 <dhcp_recv+0xcc>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    39a2:	6868      	ldr	r0, [r5, #4]
    39a4:	4b3d      	ldr	r3, [pc, #244]	; (3a9c <dhcp_recv+0x1b4>)
    39a6:	4798      	blx	r3
    39a8:	6822      	ldr	r2, [r4, #0]
    39aa:	4601      	mov	r1, r0
    39ac:	483c      	ldr	r0, [pc, #240]	; (3aa0 <dhcp_recv+0x1b8>)
    39ae:	4b33      	ldr	r3, [pc, #204]	; (3a7c <dhcp_recv+0x194>)
    39b0:	4798      	blx	r3
		goto free_pbuf_and_return;
    39b2:	e7e4      	b.n	397e <dhcp_recv+0x96>
	dhcp_clear_all_options(dhcp);
    39b4:	4b3b      	ldr	r3, [pc, #236]	; (3aa4 <dhcp_recv+0x1bc>)
    39b6:	2200      	movs	r2, #0
    39b8:	601a      	str	r2, [r3, #0]
    39ba:	605a      	str	r2, [r3, #4]
    39bc:	811a      	strh	r2, [r3, #8]
	if (p->len < DHCP_SNAME_OFS) {
    39be:	f8bb 300a 	ldrh.w	r3, [fp, #10]
    39c2:	2b2b      	cmp	r3, #43	; 0x2b
    39c4:	f240 8259 	bls.w	3e7a <dhcp_recv+0x592>
	dhcp->msg_in = (struct dhcp_msg *)p->payload;
    39c8:	f8db 3004 	ldr.w	r3, [fp, #4]
    39cc:	9a04      	ldr	r2, [sp, #16]
    39ce:	6093      	str	r3, [r2, #8]
	options_idx_max = p->tot_len;
    39d0:	f8bb a008 	ldrh.w	sl, [fp, #8]
	int          parse_sname_as_options = 0;
    39d4:	2300      	movs	r3, #0
    39d6:	9306      	str	r3, [sp, #24]
	options_idx = DHCP_OPTIONS_OFS;
    39d8:	24f0      	movs	r4, #240	; 0xf0
    39da:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
    39de:	f8cd b014 	str.w	fp, [sp, #20]
	while ((q != NULL) && (options_idx >= q->len)) {
    39e2:	9a05      	ldr	r2, [sp, #20]
    39e4:	2a00      	cmp	r2, #0
    39e6:	f000 8243 	beq.w	3e70 <dhcp_recv+0x588>
    39ea:	8953      	ldrh	r3, [r2, #10]
    39ec:	429c      	cmp	r4, r3
    39ee:	f0c0 82fd 	bcc.w	3fec <dhcp_recv+0x704>
		options_idx -= q->len;
    39f2:	1ae4      	subs	r4, r4, r3
    39f4:	b2a4      	uxth	r4, r4
		options_idx_max -= q->len;
    39f6:	ebaa 0a03 	sub.w	sl, sl, r3
    39fa:	fa1f fa8a 	uxth.w	sl, sl
		q = q->next;
    39fe:	6812      	ldr	r2, [r2, #0]
	while ((q != NULL) && (options_idx >= q->len)) {
    3a00:	2a00      	cmp	r2, #0
    3a02:	f000 8238 	beq.w	3e76 <dhcp_recv+0x58e>
    3a06:	8953      	ldrh	r3, [r2, #10]
    3a08:	42a3      	cmp	r3, r4
    3a0a:	d9f2      	bls.n	39f2 <dhcp_recv+0x10a>
    3a0c:	4693      	mov	fp, r2
	options    = (u8_t *)q->payload;
    3a0e:	f8db 3004 	ldr.w	r3, [fp, #4]
    3a12:	9307      	str	r3, [sp, #28]
	while ((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    3a14:	4622      	mov	r2, r4
    3a16:	5d1b      	ldrb	r3, [r3, r4]
    3a18:	2bff      	cmp	r3, #255	; 0xff
    3a1a:	d002      	beq.n	3a22 <dhcp_recv+0x13a>
    3a1c:	45a2      	cmp	sl, r4
    3a1e:	f200 80a3 	bhi.w	3b68 <dhcp_recv+0x280>
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
    3a22:	4b20      	ldr	r3, [pc, #128]	; (3aa4 <dhcp_recv+0x1bc>)
    3a24:	781b      	ldrb	r3, [r3, #0]
    3a26:	2b00      	cmp	r3, #0
    3a28:	f000 8210 	beq.w	3e4c <dhcp_recv+0x564>
		u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    3a2c:	4b1e      	ldr	r3, [pc, #120]	; (3aa8 <dhcp_recv+0x1c0>)
    3a2e:	6819      	ldr	r1, [r3, #0]
		dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    3a30:	2200      	movs	r2, #0
    3a32:	4b1c      	ldr	r3, [pc, #112]	; (3aa4 <dhcp_recv+0x1bc>)
    3a34:	701a      	strb	r2, [r3, #0]
		if (overload == DHCP_OVERLOAD_FILE) {
    3a36:	2901      	cmp	r1, #1
    3a38:	f040 81f2 	bne.w	3e20 <dhcp_recv+0x538>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    3a3c:	481b      	ldr	r0, [pc, #108]	; (3aac <dhcp_recv+0x1c4>)
    3a3e:	4b14      	ldr	r3, [pc, #80]	; (3a90 <dhcp_recv+0x1a8>)
    3a40:	4798      	blx	r3
		options_idx_max       = DHCP_FILE_OFS + DHCP_FILE_LEN;
    3a42:	f04f 0aec 	mov.w	sl, #236	; 0xec
		options_idx           = DHCP_FILE_OFS;
    3a46:	246c      	movs	r4, #108	; 0x6c
    3a48:	e7cb      	b.n	39e2 <dhcp_recv+0xfa>
		parse_sname_as_options = 0;
    3a4a:	2300      	movs	r3, #0
    3a4c:	9306      	str	r3, [sp, #24]
		options_idx_max        = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
    3a4e:	f04f 0a6c 	mov.w	sl, #108	; 0x6c
		options_idx            = DHCP_SNAME_OFS;
    3a52:	242c      	movs	r4, #44	; 0x2c
    3a54:	e7c5      	b.n	39e2 <dhcp_recv+0xfa>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3a56:	f8db 2000 	ldr.w	r2, [fp]
    3a5a:	2a00      	cmp	r2, #0
    3a5c:	f000 830c 	beq.w	4078 <dhcp_recv+0x790>
    3a60:	6852      	ldr	r2, [r2, #4]
    3a62:	7817      	ldrb	r7, [r2, #0]
    3a64:	e089      	b.n	3b7a <dhcp_recv+0x292>
			offset--;
    3a66:	3c01      	subs	r4, #1
    3a68:	b2a4      	uxth	r4, r4
			decode_len = len = 0;
    3a6a:	2700      	movs	r7, #0
    3a6c:	3402      	adds	r4, #2
		offset += len + 2;
    3a6e:	fa17 f484 	uxtah	r4, r7, r4
    3a72:	b2a4      	uxth	r4, r4
    3a74:	e055      	b.n	3b22 <dhcp_recv+0x23a>
    3a76:	bf00      	nop
    3a78:	0000b964 	.word	0x0000b964
    3a7c:	0000a111 	.word	0x0000a111
    3a80:	0000b9a4 	.word	0x0000b9a4
    3a84:	0000b9b8 	.word	0x0000b9b8
    3a88:	0000ba20 	.word	0x0000ba20
    3a8c:	0000b9d0 	.word	0x0000b9d0
    3a90:	0000a1f9 	.word	0x0000a1f9
    3a94:	0000b9f8 	.word	0x0000b9f8
    3a98:	00005d21 	.word	0x00005d21
    3a9c:	00002f69 	.word	0x00002f69
    3aa0:	0000ba5c 	.word	0x0000ba5c
    3aa4:	200082f8 	.word	0x200082f8
    3aa8:	20008304 	.word	0x20008304
    3aac:	0000bb1c 	.word	0x0000bb1c
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3ab0:	2f04      	cmp	r7, #4
    3ab2:	f040 80e1 	bne.w	3c78 <dhcp_recv+0x390>
		decode_len = len;
    3ab6:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
    3ab8:	2606      	movs	r6, #6
    3aba:	1ca3      	adds	r3, r4, #2
		offset += len + 2;
    3abc:	fa17 f783 	uxtah	r7, r7, r3
    3ac0:	b2bb      	uxth	r3, r7
    3ac2:	9308      	str	r3, [sp, #32]
			u32_t value = 0;
    3ac4:	2300      	movs	r3, #0
    3ac6:	930b      	str	r3, [sp, #44]	; 0x2c
			if (!dhcp_option_given(dhcp, decode_idx)) {
    3ac8:	4bb9      	ldr	r3, [pc, #740]	; (3db0 <dhcp_recv+0x4c8>)
    3aca:	5d9b      	ldrb	r3, [r3, r6]
    3acc:	bb43      	cbnz	r3, 3b20 <dhcp_recv+0x238>
		u16_t val_offset = offset + 2;
    3ace:	3402      	adds	r4, #2
    3ad0:	b2a4      	uxth	r4, r4
    3ad2:	4fb7      	ldr	r7, [pc, #732]	; (3db0 <dhcp_recv+0x4c8>)
    3ad4:	4437      	add	r7, r6
    3ad6:	4bb7      	ldr	r3, [pc, #732]	; (3db4 <dhcp_recv+0x4cc>)
    3ad8:	eb03 0886 	add.w	r8, r3, r6, lsl #2
				pbuf_copy_partial(q, &value, copy_len, val_offset);
    3adc:	f8df 9300 	ldr.w	r9, [pc, #768]	; 3de0 <dhcp_recv+0x4f8>
				copy_len = LWIP_MIN(decode_len, 4);
    3ae0:	2d03      	cmp	r5, #3
    3ae2:	bf94      	ite	ls
    3ae4:	462a      	movls	r2, r5
    3ae6:	2204      	movhi	r2, #4
				pbuf_copy_partial(q, &value, copy_len, val_offset);
    3ae8:	4623      	mov	r3, r4
    3aea:	b292      	uxth	r2, r2
    3aec:	a90b      	add	r1, sp, #44	; 0x2c
    3aee:	4658      	mov	r0, fp
    3af0:	47c8      	blx	r9
				if (decode_len > 4) {
    3af2:	2d04      	cmp	r5, #4
    3af4:	f240 8176 	bls.w	3de4 <dhcp_recv+0x4fc>
					LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
    3af8:	f015 0f03 	tst.w	r5, #3
    3afc:	f040 8150 	bne.w	3da0 <dhcp_recv+0x4b8>
					dhcp_got_option(dhcp, decode_idx);
    3b00:	2301      	movs	r3, #1
    3b02:	703b      	strb	r3, [r7, #0]
					dhcp_set_option_value(dhcp, decode_idx, htonl(value));
    3b04:	980b      	ldr	r0, [sp, #44]	; 0x2c
    3b06:	4bac      	ldr	r3, [pc, #688]	; (3db8 <dhcp_recv+0x4d0>)
    3b08:	4798      	blx	r3
    3b0a:	f848 0f04 	str.w	r0, [r8, #4]!
					decode_len -= 4;
    3b0e:	3d04      	subs	r5, #4
    3b10:	b2ed      	uxtb	r5, r5
					val_offset += 4;
    3b12:	3404      	adds	r4, #4
    3b14:	b2a4      	uxth	r4, r4
					decode_idx++;
    3b16:	3601      	adds	r6, #1
			if (!dhcp_option_given(dhcp, decode_idx)) {
    3b18:	f817 3f01 	ldrb.w	r3, [r7, #1]!
    3b1c:	2b00      	cmp	r3, #0
    3b1e:	d0df      	beq.n	3ae0 <dhcp_recv+0x1f8>
    3b20:	9c08      	ldr	r4, [sp, #32]
		if (offset >= q->len) {
    3b22:	f8bb 300a 	ldrh.w	r3, [fp, #10]
    3b26:	42a3      	cmp	r3, r4
    3b28:	d811      	bhi.n	3b4e <dhcp_recv+0x266>
			offset -= q->len;
    3b2a:	1ae4      	subs	r4, r4, r3
    3b2c:	b2a4      	uxth	r4, r4
			offset_max -= q->len;
    3b2e:	ebaa 0a03 	sub.w	sl, sl, r3
    3b32:	fa1f fa8a 	uxth.w	sl, sl
			if ((offset < offset_max) && offset_max) {
    3b36:	4554      	cmp	r4, sl
    3b38:	f4bf af73 	bcs.w	3a22 <dhcp_recv+0x13a>
    3b3c:	f1ba 0f00 	cmp.w	sl, #0
    3b40:	f43f af6f 	beq.w	3a22 <dhcp_recv+0x13a>
				q = q->next;
    3b44:	f8db b000 	ldr.w	fp, [fp]
				options = (u8_t *)q->payload;
    3b48:	f8db 3004 	ldr.w	r3, [fp, #4]
    3b4c:	9307      	str	r3, [sp, #28]
	while ((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    3b4e:	f1bb 0f00 	cmp.w	fp, #0
    3b52:	f43f af66 	beq.w	3a22 <dhcp_recv+0x13a>
    3b56:	4622      	mov	r2, r4
    3b58:	9b07      	ldr	r3, [sp, #28]
    3b5a:	5d1b      	ldrb	r3, [r3, r4]
    3b5c:	2bff      	cmp	r3, #255	; 0xff
    3b5e:	f43f af60 	beq.w	3a22 <dhcp_recv+0x13a>
    3b62:	45a2      	cmp	sl, r4
    3b64:	f67f af5d 	bls.w	3a22 <dhcp_recv+0x13a>
		if (offset + 1 < q->len) {
    3b68:	1c61      	adds	r1, r4, #1
    3b6a:	f8bb 000a 	ldrh.w	r0, [fp, #10]
    3b6e:	4281      	cmp	r1, r0
    3b70:	f6bf af71 	bge.w	3a56 <dhcp_recv+0x16e>
			len = options[offset + 1];
    3b74:	9907      	ldr	r1, [sp, #28]
    3b76:	440a      	add	r2, r1
    3b78:	7857      	ldrb	r7, [r2, #1]
		switch (op) {
    3b7a:	2b3b      	cmp	r3, #59	; 0x3b
    3b7c:	f200 810b 	bhi.w	3d96 <dhcp_recv+0x4ae>
    3b80:	a201      	add	r2, pc, #4	; (adr r2, 3b88 <dhcp_recv+0x2a0>)
    3b82:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    3b86:	bf00      	nop
    3b88:	00003a67 	.word	0x00003a67
    3b8c:	00003ab1 	.word	0x00003ab1
    3b90:	00003d97 	.word	0x00003d97
    3b94:	00003c8b 	.word	0x00003c8b
    3b98:	00003d97 	.word	0x00003d97
    3b9c:	00003d97 	.word	0x00003d97
    3ba0:	00003ca7 	.word	0x00003ca7
    3ba4:	00003d97 	.word	0x00003d97
    3ba8:	00003d97 	.word	0x00003d97
    3bac:	00003d97 	.word	0x00003d97
    3bb0:	00003d97 	.word	0x00003d97
    3bb4:	00003d97 	.word	0x00003d97
    3bb8:	00003d97 	.word	0x00003d97
    3bbc:	00003d97 	.word	0x00003d97
    3bc0:	00003d97 	.word	0x00003d97
    3bc4:	00003d97 	.word	0x00003d97
    3bc8:	00003d97 	.word	0x00003d97
    3bcc:	00003d97 	.word	0x00003d97
    3bd0:	00003d97 	.word	0x00003d97
    3bd4:	00003d97 	.word	0x00003d97
    3bd8:	00003d97 	.word	0x00003d97
    3bdc:	00003d97 	.word	0x00003d97
    3be0:	00003d97 	.word	0x00003d97
    3be4:	00003d97 	.word	0x00003d97
    3be8:	00003d97 	.word	0x00003d97
    3bec:	00003d97 	.word	0x00003d97
    3bf0:	00003d97 	.word	0x00003d97
    3bf4:	00003d97 	.word	0x00003d97
    3bf8:	00003d97 	.word	0x00003d97
    3bfc:	00003d97 	.word	0x00003d97
    3c00:	00003d97 	.word	0x00003d97
    3c04:	00003d97 	.word	0x00003d97
    3c08:	00003d97 	.word	0x00003d97
    3c0c:	00003d97 	.word	0x00003d97
    3c10:	00003d97 	.word	0x00003d97
    3c14:	00003d97 	.word	0x00003d97
    3c18:	00003d97 	.word	0x00003d97
    3c1c:	00003d97 	.word	0x00003d97
    3c20:	00003d97 	.word	0x00003d97
    3c24:	00003d97 	.word	0x00003d97
    3c28:	00003d97 	.word	0x00003d97
    3c2c:	00003d97 	.word	0x00003d97
    3c30:	00003d97 	.word	0x00003d97
    3c34:	00003d97 	.word	0x00003d97
    3c38:	00003d97 	.word	0x00003d97
    3c3c:	00003d97 	.word	0x00003d97
    3c40:	00003d97 	.word	0x00003d97
    3c44:	00003d97 	.word	0x00003d97
    3c48:	00003d97 	.word	0x00003d97
    3c4c:	00003d97 	.word	0x00003d97
    3c50:	00003d97 	.word	0x00003d97
    3c54:	00003cef 	.word	0x00003cef
    3c58:	00003d0b 	.word	0x00003d0b
    3c5c:	00003d27 	.word	0x00003d27
    3c60:	00003d43 	.word	0x00003d43
    3c64:	00003d97 	.word	0x00003d97
    3c68:	00003d97 	.word	0x00003d97
    3c6c:	00003d97 	.word	0x00003d97
    3c70:	00003d5f 	.word	0x00003d5f
    3c74:	00003d7b 	.word	0x00003d7b
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3c78:	4b50      	ldr	r3, [pc, #320]	; (3dbc <dhcp_recv+0x4d4>)
    3c7a:	f240 527c 	movw	r2, #1404	; 0x57c
    3c7e:	4950      	ldr	r1, [pc, #320]	; (3dc0 <dhcp_recv+0x4d8>)
    3c80:	4850      	ldr	r0, [pc, #320]	; (3dc4 <dhcp_recv+0x4dc>)
    3c82:	4c51      	ldr	r4, [pc, #324]	; (3dc8 <dhcp_recv+0x4e0>)
    3c84:	47a0      	blx	r4
    3c86:	e7fe      	b.n	3c86 <dhcp_recv+0x39e>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3c88:	2700      	movs	r7, #0
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    3c8a:	2f03      	cmp	r7, #3
    3c8c:	d902      	bls.n	3c94 <dhcp_recv+0x3ac>
			decode_idx = DHCP_OPTION_IDX_ROUTER;
    3c8e:	2607      	movs	r6, #7
			decode_len = 4; /* only copy the first given router */
    3c90:	2504      	movs	r5, #4
    3c92:	e712      	b.n	3aba <dhcp_recv+0x1d2>
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    3c94:	4b49      	ldr	r3, [pc, #292]	; (3dbc <dhcp_recv+0x4d4>)
    3c96:	f240 5281 	movw	r2, #1409	; 0x581
    3c9a:	494c      	ldr	r1, [pc, #304]	; (3dcc <dhcp_recv+0x4e4>)
    3c9c:	4849      	ldr	r0, [pc, #292]	; (3dc4 <dhcp_recv+0x4dc>)
    3c9e:	4c4a      	ldr	r4, [pc, #296]	; (3dc8 <dhcp_recv+0x4e0>)
    3ca0:	47a0      	blx	r4
    3ca2:	e7fe      	b.n	3ca2 <dhcp_recv+0x3ba>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3ca4:	2700      	movs	r7, #0
			LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
    3ca6:	f017 0f03 	tst.w	r7, #3
    3caa:	d10f      	bne.n	3ccc <dhcp_recv+0x3e4>
			decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
    3cac:	463d      	mov	r5, r7
    3cae:	2f08      	cmp	r7, #8
    3cb0:	bf28      	it	cs
    3cb2:	2508      	movcs	r5, #8
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    3cb4:	42bd      	cmp	r5, r7
    3cb6:	d811      	bhi.n	3cdc <dhcp_recv+0x3f4>
    3cb8:	1ca3      	adds	r3, r4, #2
		offset += len + 2;
    3cba:	fa17 f783 	uxtah	r7, r7, r3
    3cbe:	b2bb      	uxth	r3, r7
    3cc0:	9308      	str	r3, [sp, #32]
		if (decode_len > 0) {
    3cc2:	2d00      	cmp	r5, #0
    3cc4:	f000 80aa 	beq.w	3e1c <dhcp_recv+0x534>
			decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
    3cc8:	2608      	movs	r6, #8
    3cca:	e6fb      	b.n	3ac4 <dhcp_recv+0x1dc>
			LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
    3ccc:	4b3b      	ldr	r3, [pc, #236]	; (3dbc <dhcp_recv+0x4d4>)
    3cce:	f240 5286 	movw	r2, #1414	; 0x586
    3cd2:	493f      	ldr	r1, [pc, #252]	; (3dd0 <dhcp_recv+0x4e8>)
    3cd4:	483b      	ldr	r0, [pc, #236]	; (3dc4 <dhcp_recv+0x4dc>)
    3cd6:	4c3c      	ldr	r4, [pc, #240]	; (3dc8 <dhcp_recv+0x4e0>)
    3cd8:	47a0      	blx	r4
    3cda:	e7fe      	b.n	3cda <dhcp_recv+0x3f2>
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    3cdc:	4b37      	ldr	r3, [pc, #220]	; (3dbc <dhcp_recv+0x4d4>)
    3cde:	f240 5289 	movw	r2, #1417	; 0x589
    3ce2:	493a      	ldr	r1, [pc, #232]	; (3dcc <dhcp_recv+0x4e4>)
    3ce4:	4837      	ldr	r0, [pc, #220]	; (3dc4 <dhcp_recv+0x4dc>)
    3ce6:	4c38      	ldr	r4, [pc, #224]	; (3dc8 <dhcp_recv+0x4e0>)
    3ce8:	47a0      	blx	r4
    3cea:	e7fe      	b.n	3cea <dhcp_recv+0x402>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3cec:	2700      	movs	r7, #0
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3cee:	2f04      	cmp	r7, #4
    3cf0:	d102      	bne.n	3cf8 <dhcp_recv+0x410>
		decode_len = len;
    3cf2:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
    3cf4:	2603      	movs	r6, #3
    3cf6:	e6e0      	b.n	3aba <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3cf8:	4b30      	ldr	r3, [pc, #192]	; (3dbc <dhcp_recv+0x4d4>)
    3cfa:	f240 528d 	movw	r2, #1421	; 0x58d
    3cfe:	4930      	ldr	r1, [pc, #192]	; (3dc0 <dhcp_recv+0x4d8>)
    3d00:	4830      	ldr	r0, [pc, #192]	; (3dc4 <dhcp_recv+0x4dc>)
    3d02:	4c31      	ldr	r4, [pc, #196]	; (3dc8 <dhcp_recv+0x4e0>)
    3d04:	47a0      	blx	r4
    3d06:	e7fe      	b.n	3d06 <dhcp_recv+0x41e>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3d08:	2700      	movs	r7, #0
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    3d0a:	2f01      	cmp	r7, #1
    3d0c:	d102      	bne.n	3d14 <dhcp_recv+0x42c>
		decode_len = len;
    3d0e:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_OVERLOAD;
    3d10:	2600      	movs	r6, #0
    3d12:	e6d2      	b.n	3aba <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    3d14:	4b29      	ldr	r3, [pc, #164]	; (3dbc <dhcp_recv+0x4d4>)
    3d16:	f240 5291 	movw	r2, #1425	; 0x591
    3d1a:	492e      	ldr	r1, [pc, #184]	; (3dd4 <dhcp_recv+0x4ec>)
    3d1c:	4829      	ldr	r0, [pc, #164]	; (3dc4 <dhcp_recv+0x4dc>)
    3d1e:	4c2a      	ldr	r4, [pc, #168]	; (3dc8 <dhcp_recv+0x4e0>)
    3d20:	47a0      	blx	r4
    3d22:	e7fe      	b.n	3d22 <dhcp_recv+0x43a>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3d24:	2700      	movs	r7, #0
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    3d26:	2f01      	cmp	r7, #1
    3d28:	d102      	bne.n	3d30 <dhcp_recv+0x448>
		decode_len = len;
    3d2a:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
    3d2c:	2601      	movs	r6, #1
    3d2e:	e6c4      	b.n	3aba <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    3d30:	4b22      	ldr	r3, [pc, #136]	; (3dbc <dhcp_recv+0x4d4>)
    3d32:	f240 5295 	movw	r2, #1429	; 0x595
    3d36:	4927      	ldr	r1, [pc, #156]	; (3dd4 <dhcp_recv+0x4ec>)
    3d38:	4822      	ldr	r0, [pc, #136]	; (3dc4 <dhcp_recv+0x4dc>)
    3d3a:	4c23      	ldr	r4, [pc, #140]	; (3dc8 <dhcp_recv+0x4e0>)
    3d3c:	47a0      	blx	r4
    3d3e:	e7fe      	b.n	3d3e <dhcp_recv+0x456>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3d40:	2700      	movs	r7, #0
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3d42:	2f04      	cmp	r7, #4
    3d44:	d102      	bne.n	3d4c <dhcp_recv+0x464>
		decode_len = len;
    3d46:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_SERVER_ID;
    3d48:	2602      	movs	r6, #2
    3d4a:	e6b6      	b.n	3aba <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3d4c:	4b1b      	ldr	r3, [pc, #108]	; (3dbc <dhcp_recv+0x4d4>)
    3d4e:	f240 5299 	movw	r2, #1433	; 0x599
    3d52:	491b      	ldr	r1, [pc, #108]	; (3dc0 <dhcp_recv+0x4d8>)
    3d54:	481b      	ldr	r0, [pc, #108]	; (3dc4 <dhcp_recv+0x4dc>)
    3d56:	4c1c      	ldr	r4, [pc, #112]	; (3dc8 <dhcp_recv+0x4e0>)
    3d58:	47a0      	blx	r4
    3d5a:	e7fe      	b.n	3d5a <dhcp_recv+0x472>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3d5c:	2700      	movs	r7, #0
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3d5e:	2f04      	cmp	r7, #4
    3d60:	d102      	bne.n	3d68 <dhcp_recv+0x480>
		decode_len = len;
    3d62:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_T1;
    3d64:	2604      	movs	r6, #4
    3d66:	e6a8      	b.n	3aba <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3d68:	4b14      	ldr	r3, [pc, #80]	; (3dbc <dhcp_recv+0x4d4>)
    3d6a:	f240 529d 	movw	r2, #1437	; 0x59d
    3d6e:	4914      	ldr	r1, [pc, #80]	; (3dc0 <dhcp_recv+0x4d8>)
    3d70:	4814      	ldr	r0, [pc, #80]	; (3dc4 <dhcp_recv+0x4dc>)
    3d72:	4c15      	ldr	r4, [pc, #84]	; (3dc8 <dhcp_recv+0x4e0>)
    3d74:	47a0      	blx	r4
    3d76:	e7fe      	b.n	3d76 <dhcp_recv+0x48e>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3d78:	2700      	movs	r7, #0
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3d7a:	2f04      	cmp	r7, #4
    3d7c:	d102      	bne.n	3d84 <dhcp_recv+0x49c>
		decode_len = len;
    3d7e:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_T2;
    3d80:	2605      	movs	r6, #5
    3d82:	e69a      	b.n	3aba <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3d84:	4b0d      	ldr	r3, [pc, #52]	; (3dbc <dhcp_recv+0x4d4>)
    3d86:	f240 52a1 	movw	r2, #1441	; 0x5a1
    3d8a:	490d      	ldr	r1, [pc, #52]	; (3dc0 <dhcp_recv+0x4d8>)
    3d8c:	480d      	ldr	r0, [pc, #52]	; (3dc4 <dhcp_recv+0x4dc>)
    3d8e:	4c0e      	ldr	r4, [pc, #56]	; (3dc8 <dhcp_recv+0x4e0>)
    3d90:	47a0      	blx	r4
    3d92:	e7fe      	b.n	3d92 <dhcp_recv+0x4aa>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3d94:	2700      	movs	r7, #0
			LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %" U16_F " in options\n", op));
    3d96:	4619      	mov	r1, r3
    3d98:	480f      	ldr	r0, [pc, #60]	; (3dd8 <dhcp_recv+0x4f0>)
    3d9a:	4b0b      	ldr	r3, [pc, #44]	; (3dc8 <dhcp_recv+0x4e0>)
    3d9c:	4798      	blx	r3
    3d9e:	e665      	b.n	3a6c <dhcp_recv+0x184>
					LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
    3da0:	4b06      	ldr	r3, [pc, #24]	; (3dbc <dhcp_recv+0x4d4>)
    3da2:	f240 52b4 	movw	r2, #1460	; 0x5b4
    3da6:	490d      	ldr	r1, [pc, #52]	; (3ddc <dhcp_recv+0x4f4>)
    3da8:	4806      	ldr	r0, [pc, #24]	; (3dc4 <dhcp_recv+0x4dc>)
    3daa:	4c07      	ldr	r4, [pc, #28]	; (3dc8 <dhcp_recv+0x4e0>)
    3dac:	47a0      	blx	r4
    3dae:	e7fe      	b.n	3dae <dhcp_recv+0x4c6>
    3db0:	200082f8 	.word	0x200082f8
    3db4:	20008300 	.word	0x20008300
    3db8:	00002f51 	.word	0x00002f51
    3dbc:	0000b3e0 	.word	0x0000b3e0
    3dc0:	0000ba98 	.word	0x0000ba98
    3dc4:	0000b428 	.word	0x0000b428
    3dc8:	0000a111 	.word	0x0000a111
    3dcc:	0000baa4 	.word	0x0000baa4
    3dd0:	0000bab8 	.word	0x0000bab8
    3dd4:	0000bac8 	.word	0x0000bac8
    3dd8:	0000bad4 	.word	0x0000bad4
    3ddc:	0000baf4 	.word	0x0000baf4
    3de0:	000060ad 	.word	0x000060ad
				} else if (decode_len == 4) {
    3de4:	2d04      	cmp	r5, #4
    3de6:	d00c      	beq.n	3e02 <dhcp_recv+0x51a>
					LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
    3de8:	2d01      	cmp	r5, #1
    3dea:	d10f      	bne.n	3e0c <dhcp_recv+0x524>
					value = ((u8_t *)&value)[0];
    3dec:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    3df0:	930b      	str	r3, [sp, #44]	; 0x2c
				dhcp_got_option(dhcp, decode_idx);
    3df2:	2201      	movs	r2, #1
    3df4:	4b7f      	ldr	r3, [pc, #508]	; (3ff4 <dhcp_recv+0x70c>)
    3df6:	559a      	strb	r2, [r3, r6]
				dhcp_set_option_value(dhcp, decode_idx, value);
    3df8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    3dfa:	4b7f      	ldr	r3, [pc, #508]	; (3ff8 <dhcp_recv+0x710>)
    3dfc:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
    3e00:	e68e      	b.n	3b20 <dhcp_recv+0x238>
					value = ntohl(value);
    3e02:	980b      	ldr	r0, [sp, #44]	; 0x2c
    3e04:	4b7d      	ldr	r3, [pc, #500]	; (3ffc <dhcp_recv+0x714>)
    3e06:	4798      	blx	r3
    3e08:	900b      	str	r0, [sp, #44]	; 0x2c
    3e0a:	e7f2      	b.n	3df2 <dhcp_recv+0x50a>
					LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
    3e0c:	4b7c      	ldr	r3, [pc, #496]	; (4000 <dhcp_recv+0x718>)
    3e0e:	f240 52be 	movw	r2, #1470	; 0x5be
    3e12:	497c      	ldr	r1, [pc, #496]	; (4004 <dhcp_recv+0x71c>)
    3e14:	487c      	ldr	r0, [pc, #496]	; (4008 <dhcp_recv+0x720>)
    3e16:	4c7d      	ldr	r4, [pc, #500]	; (400c <dhcp_recv+0x724>)
    3e18:	47a0      	blx	r4
    3e1a:	e7fe      	b.n	3e1a <dhcp_recv+0x532>
		offset += len + 2;
    3e1c:	9c08      	ldr	r4, [sp, #32]
    3e1e:	e680      	b.n	3b22 <dhcp_recv+0x23a>
		} else if (overload == DHCP_OVERLOAD_SNAME) {
    3e20:	2902      	cmp	r1, #2
    3e22:	d108      	bne.n	3e36 <dhcp_recv+0x54e>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    3e24:	487a      	ldr	r0, [pc, #488]	; (4010 <dhcp_recv+0x728>)
    3e26:	4b7b      	ldr	r3, [pc, #492]	; (4014 <dhcp_recv+0x72c>)
    3e28:	4798      	blx	r3
		parse_sname_as_options = 0;
    3e2a:	2300      	movs	r3, #0
    3e2c:	9306      	str	r3, [sp, #24]
		options_idx_max        = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
    3e2e:	f04f 0a6c 	mov.w	sl, #108	; 0x6c
		options_idx            = DHCP_SNAME_OFS;
    3e32:	242c      	movs	r4, #44	; 0x2c
    3e34:	e5d5      	b.n	39e2 <dhcp_recv+0xfa>
		} else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
    3e36:	2903      	cmp	r1, #3
    3e38:	d105      	bne.n	3e46 <dhcp_recv+0x55e>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname and file field\n"));
    3e3a:	4877      	ldr	r0, [pc, #476]	; (4018 <dhcp_recv+0x730>)
    3e3c:	4b75      	ldr	r3, [pc, #468]	; (4014 <dhcp_recv+0x72c>)
    3e3e:	4798      	blx	r3
			parse_sname_as_options = 1;
    3e40:	2301      	movs	r3, #1
    3e42:	9306      	str	r3, [sp, #24]
    3e44:	e5fd      	b.n	3a42 <dhcp_recv+0x15a>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("invalid overload option: %d\n", (int)overload));
    3e46:	4875      	ldr	r0, [pc, #468]	; (401c <dhcp_recv+0x734>)
    3e48:	4b70      	ldr	r3, [pc, #448]	; (400c <dhcp_recv+0x724>)
    3e4a:	4798      	blx	r3
	} else if (parse_sname_as_options) {
    3e4c:	9b06      	ldr	r3, [sp, #24]
    3e4e:	2b00      	cmp	r3, #0
    3e50:	f47f adfb 	bne.w	3a4a <dhcp_recv+0x162>
    3e54:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    3e58:	f8dd b014 	ldr.w	fp, [sp, #20]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
    3e5c:	4870      	ldr	r0, [pc, #448]	; (4020 <dhcp_recv+0x738>)
    3e5e:	4b6d      	ldr	r3, [pc, #436]	; (4014 <dhcp_recv+0x72c>)
    3e60:	4798      	blx	r3
	if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    3e62:	4b64      	ldr	r3, [pc, #400]	; (3ff4 <dhcp_recv+0x70c>)
    3e64:	785b      	ldrb	r3, [r3, #1]
    3e66:	b963      	cbnz	r3, 3e82 <dhcp_recv+0x59a>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    3e68:	486e      	ldr	r0, [pc, #440]	; (4024 <dhcp_recv+0x73c>)
    3e6a:	4b6a      	ldr	r3, [pc, #424]	; (4014 <dhcp_recv+0x72c>)
    3e6c:	4798      	blx	r3
		goto free_pbuf_and_return;
    3e6e:	e586      	b.n	397e <dhcp_recv+0x96>
    3e70:	f8dd b014 	ldr.w	fp, [sp, #20]
    3e74:	e001      	b.n	3e7a <dhcp_recv+0x592>
    3e76:	f8dd b014 	ldr.w	fp, [sp, #20]
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    3e7a:	486b      	ldr	r0, [pc, #428]	; (4028 <dhcp_recv+0x740>)
    3e7c:	4b65      	ldr	r3, [pc, #404]	; (4014 <dhcp_recv+0x72c>)
    3e7e:	4798      	blx	r3
		goto free_pbuf_and_return;
    3e80:	e57d      	b.n	397e <dhcp_recv+0x96>
	msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
    3e82:	4b5d      	ldr	r3, [pc, #372]	; (3ff8 <dhcp_recv+0x710>)
    3e84:	791b      	ldrb	r3, [r3, #4]
	if (msg_type == DHCP_ACK) {
    3e86:	2b05      	cmp	r3, #5
    3e88:	d149      	bne.n	3f1e <dhcp_recv+0x636>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    3e8a:	4868      	ldr	r0, [pc, #416]	; (402c <dhcp_recv+0x744>)
    3e8c:	4b61      	ldr	r3, [pc, #388]	; (4014 <dhcp_recv+0x72c>)
    3e8e:	4798      	blx	r3
		if (dhcp->state == DHCP_REQUESTING) {
    3e90:	9b04      	ldr	r3, [sp, #16]
    3e92:	7b1b      	ldrb	r3, [r3, #12]
    3e94:	2b01      	cmp	r3, #1
    3e96:	d139      	bne.n	3f0c <dhcp_recv+0x624>
	struct dhcp *dhcp = netif->dhcp;
    3e98:	f8d9 4028 	ldr.w	r4, [r9, #40]	; 0x28
	ip_addr_set_zero(&dhcp->offered_sn_mask);
    3e9c:	2300      	movs	r3, #0
    3e9e:	62a3      	str	r3, [r4, #40]	; 0x28
	ip_addr_set_zero(&dhcp->offered_gw_addr);
    3ea0:	62e3      	str	r3, [r4, #44]	; 0x2c
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
    3ea2:	4b54      	ldr	r3, [pc, #336]	; (3ff4 <dhcp_recv+0x70c>)
    3ea4:	78db      	ldrb	r3, [r3, #3]
    3ea6:	b113      	cbz	r3, 3eae <dhcp_recv+0x5c6>
		dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
    3ea8:	4b53      	ldr	r3, [pc, #332]	; (3ff8 <dhcp_recv+0x710>)
    3eaa:	68db      	ldr	r3, [r3, #12]
    3eac:	6323      	str	r3, [r4, #48]	; 0x30
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
    3eae:	4b51      	ldr	r3, [pc, #324]	; (3ff4 <dhcp_recv+0x70c>)
    3eb0:	791b      	ldrb	r3, [r3, #4]
    3eb2:	b30b      	cbz	r3, 3ef8 <dhcp_recv+0x610>
		dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
    3eb4:	4b50      	ldr	r3, [pc, #320]	; (3ff8 <dhcp_recv+0x710>)
    3eb6:	691b      	ldr	r3, [r3, #16]
    3eb8:	6363      	str	r3, [r4, #52]	; 0x34
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
    3eba:	4b4e      	ldr	r3, [pc, #312]	; (3ff4 <dhcp_recv+0x70c>)
    3ebc:	795b      	ldrb	r3, [r3, #5]
    3ebe:	b1fb      	cbz	r3, 3f00 <dhcp_recv+0x618>
		dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
    3ec0:	4b4d      	ldr	r3, [pc, #308]	; (3ff8 <dhcp_recv+0x710>)
    3ec2:	695b      	ldr	r3, [r3, #20]
    3ec4:	63a3      	str	r3, [r4, #56]	; 0x38
	ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    3ec6:	68a3      	ldr	r3, [r4, #8]
    3ec8:	691b      	ldr	r3, [r3, #16]
    3eca:	6263      	str	r3, [r4, #36]	; 0x24
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
    3ecc:	4b49      	ldr	r3, [pc, #292]	; (3ff4 <dhcp_recv+0x70c>)
    3ece:	799b      	ldrb	r3, [r3, #6]
    3ed0:	b1cb      	cbz	r3, 3f06 <dhcp_recv+0x61e>
		ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
    3ed2:	4b49      	ldr	r3, [pc, #292]	; (3ff8 <dhcp_recv+0x710>)
    3ed4:	6998      	ldr	r0, [r3, #24]
    3ed6:	4b56      	ldr	r3, [pc, #344]	; (4030 <dhcp_recv+0x748>)
    3ed8:	4798      	blx	r3
    3eda:	62a0      	str	r0, [r4, #40]	; 0x28
		dhcp->subnet_mask_given = 1;
    3edc:	2301      	movs	r3, #1
    3ede:	73a3      	strb	r3, [r4, #14]
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
    3ee0:	4b44      	ldr	r3, [pc, #272]	; (3ff4 <dhcp_recv+0x70c>)
    3ee2:	79db      	ldrb	r3, [r3, #7]
    3ee4:	b123      	cbz	r3, 3ef0 <dhcp_recv+0x608>
		ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
    3ee6:	4b44      	ldr	r3, [pc, #272]	; (3ff8 <dhcp_recv+0x710>)
    3ee8:	69d8      	ldr	r0, [r3, #28]
    3eea:	4b51      	ldr	r3, [pc, #324]	; (4030 <dhcp_recv+0x748>)
    3eec:	4798      	blx	r3
    3eee:	62e0      	str	r0, [r4, #44]	; 0x2c
			dhcp_check(netif);
    3ef0:	4648      	mov	r0, r9
    3ef2:	4b50      	ldr	r3, [pc, #320]	; (4034 <dhcp_recv+0x74c>)
    3ef4:	4798      	blx	r3
    3ef6:	e542      	b.n	397e <dhcp_recv+0x96>
		dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
    3ef8:	6b23      	ldr	r3, [r4, #48]	; 0x30
    3efa:	085b      	lsrs	r3, r3, #1
    3efc:	6363      	str	r3, [r4, #52]	; 0x34
    3efe:	e7dc      	b.n	3eba <dhcp_recv+0x5d2>
		dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
    3f00:	6b23      	ldr	r3, [r4, #48]	; 0x30
    3f02:	63a3      	str	r3, [r4, #56]	; 0x38
    3f04:	e7df      	b.n	3ec6 <dhcp_recv+0x5de>
		dhcp->subnet_mask_given = 0;
    3f06:	2300      	movs	r3, #0
    3f08:	73a3      	strb	r3, [r4, #14]
    3f0a:	e7e9      	b.n	3ee0 <dhcp_recv+0x5f8>
		else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
    3f0c:	3b03      	subs	r3, #3
    3f0e:	b2db      	uxtb	r3, r3
    3f10:	2b02      	cmp	r3, #2
    3f12:	f63f ad34 	bhi.w	397e <dhcp_recv+0x96>
			dhcp_bind(netif);
    3f16:	4648      	mov	r0, r9
    3f18:	4b47      	ldr	r3, [pc, #284]	; (4038 <dhcp_recv+0x750>)
    3f1a:	4798      	blx	r3
    3f1c:	e52f      	b.n	397e <dhcp_recv+0x96>
	else if ((msg_type == DHCP_NAK)
    3f1e:	2b06      	cmp	r3, #6
    3f20:	d130      	bne.n	3f84 <dhcp_recv+0x69c>
	         && ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_REBINDING)
    3f22:	9b04      	ldr	r3, [sp, #16]
    3f24:	7b1a      	ldrb	r2, [r3, #12]
    3f26:	1ed3      	subs	r3, r2, #3
    3f28:	b2db      	uxtb	r3, r3
    3f2a:	2b02      	cmp	r3, #2
    3f2c:	d902      	bls.n	3f34 <dhcp_recv+0x64c>
    3f2e:	2a01      	cmp	r2, #1
    3f30:	f47f ad25 	bne.w	397e <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    3f34:	4841      	ldr	r0, [pc, #260]	; (403c <dhcp_recv+0x754>)
    3f36:	4b37      	ldr	r3, [pc, #220]	; (4014 <dhcp_recv+0x72c>)
    3f38:	4798      	blx	r3
	struct dhcp *dhcp = netif->dhcp;
    3f3a:	f8d9 5028 	ldr.w	r5, [r9, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    3f3e:	f899 3037 	ldrb.w	r3, [r9, #55]	; 0x37
    3f42:	f899 2036 	ldrb.w	r2, [r9, #54]	; 0x36
    3f46:	f899 1038 	ldrb.w	r1, [r9, #56]	; 0x38
    3f4a:	9100      	str	r1, [sp, #0]
    3f4c:	4649      	mov	r1, r9
    3f4e:	483c      	ldr	r0, [pc, #240]	; (4040 <dhcp_recv+0x758>)
    3f50:	4c2e      	ldr	r4, [pc, #184]	; (400c <dhcp_recv+0x724>)
    3f52:	47a0      	blx	r4
	netif_set_down(netif);
    3f54:	4648      	mov	r0, r9
    3f56:	4b3b      	ldr	r3, [pc, #236]	; (4044 <dhcp_recv+0x75c>)
    3f58:	4798      	blx	r3
	netif_set_ipaddr(netif, IP_ADDR_ANY);
    3f5a:	4c3b      	ldr	r4, [pc, #236]	; (4048 <dhcp_recv+0x760>)
    3f5c:	4621      	mov	r1, r4
    3f5e:	4648      	mov	r0, r9
    3f60:	4b3a      	ldr	r3, [pc, #232]	; (404c <dhcp_recv+0x764>)
    3f62:	4798      	blx	r3
	netif_set_gw(netif, IP_ADDR_ANY);
    3f64:	4621      	mov	r1, r4
    3f66:	4648      	mov	r0, r9
    3f68:	4b39      	ldr	r3, [pc, #228]	; (4050 <dhcp_recv+0x768>)
    3f6a:	4798      	blx	r3
	netif_set_netmask(netif, IP_ADDR_ANY);
    3f6c:	4621      	mov	r1, r4
    3f6e:	4648      	mov	r0, r9
    3f70:	4b38      	ldr	r3, [pc, #224]	; (4054 <dhcp_recv+0x76c>)
    3f72:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    3f74:	210c      	movs	r1, #12
    3f76:	4628      	mov	r0, r5
    3f78:	4b37      	ldr	r3, [pc, #220]	; (4058 <dhcp_recv+0x770>)
    3f7a:	4798      	blx	r3
	dhcp_discover(netif);
    3f7c:	4648      	mov	r0, r9
    3f7e:	4b37      	ldr	r3, [pc, #220]	; (405c <dhcp_recv+0x774>)
    3f80:	4798      	blx	r3
    3f82:	e4fc      	b.n	397e <dhcp_recv+0x96>
	else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
    3f84:	2b02      	cmp	r3, #2
    3f86:	f47f acfa 	bne.w	397e <dhcp_recv+0x96>
    3f8a:	9b04      	ldr	r3, [sp, #16]
    3f8c:	7b1b      	ldrb	r3, [r3, #12]
    3f8e:	2b06      	cmp	r3, #6
    3f90:	f47f acf5 	bne.w	397e <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    3f94:	4832      	ldr	r0, [pc, #200]	; (4060 <dhcp_recv+0x778>)
    3f96:	4b1f      	ldr	r3, [pc, #124]	; (4014 <dhcp_recv+0x72c>)
    3f98:	4798      	blx	r3
		dhcp->request_timeout = 0;
    3f9a:	2300      	movs	r3, #0
    3f9c:	9a04      	ldr	r2, [sp, #16]
    3f9e:	8353      	strh	r3, [r2, #26]
	struct dhcp *dhcp = netif->dhcp;
    3fa0:	f8d9 4028 	ldr.w	r4, [r9, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    3fa4:	f899 3037 	ldrb.w	r3, [r9, #55]	; 0x37
    3fa8:	f899 2036 	ldrb.w	r2, [r9, #54]	; 0x36
    3fac:	f899 1038 	ldrb.w	r1, [r9, #56]	; 0x38
    3fb0:	9100      	str	r1, [sp, #0]
    3fb2:	4649      	mov	r1, r9
    3fb4:	482b      	ldr	r0, [pc, #172]	; (4064 <dhcp_recv+0x77c>)
    3fb6:	4d15      	ldr	r5, [pc, #84]	; (400c <dhcp_recv+0x724>)
    3fb8:	47a8      	blx	r5
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
    3fba:	4b0e      	ldr	r3, [pc, #56]	; (3ff4 <dhcp_recv+0x70c>)
    3fbc:	789b      	ldrb	r3, [r3, #2]
    3fbe:	b183      	cbz	r3, 3fe2 <dhcp_recv+0x6fa>
		ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
    3fc0:	4b0d      	ldr	r3, [pc, #52]	; (3ff8 <dhcp_recv+0x710>)
    3fc2:	6898      	ldr	r0, [r3, #8]
    3fc4:	4b1a      	ldr	r3, [pc, #104]	; (4030 <dhcp_recv+0x748>)
    3fc6:	4798      	blx	r3
    3fc8:	4601      	mov	r1, r0
    3fca:	6220      	str	r0, [r4, #32]
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE,
    3fcc:	4826      	ldr	r0, [pc, #152]	; (4068 <dhcp_recv+0x780>)
    3fce:	47a8      	blx	r5
		ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    3fd0:	68a3      	ldr	r3, [r4, #8]
    3fd2:	6919      	ldr	r1, [r3, #16]
    3fd4:	6261      	str	r1, [r4, #36]	; 0x24
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE,
    3fd6:	4825      	ldr	r0, [pc, #148]	; (406c <dhcp_recv+0x784>)
    3fd8:	47a8      	blx	r5
		dhcp_select(netif);
    3fda:	4648      	mov	r0, r9
    3fdc:	4b24      	ldr	r3, [pc, #144]	; (4070 <dhcp_recv+0x788>)
    3fde:	4798      	blx	r3
    3fe0:	e4cd      	b.n	397e <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    3fe2:	4649      	mov	r1, r9
    3fe4:	4823      	ldr	r0, [pc, #140]	; (4074 <dhcp_recv+0x78c>)
    3fe6:	4b09      	ldr	r3, [pc, #36]	; (400c <dhcp_recv+0x724>)
    3fe8:	4798      	blx	r3
    3fea:	e4c8      	b.n	397e <dhcp_recv+0x96>
	q = p;
    3fec:	f8dd b014 	ldr.w	fp, [sp, #20]
    3ff0:	e50d      	b.n	3a0e <dhcp_recv+0x126>
    3ff2:	bf00      	nop
    3ff4:	200082f8 	.word	0x200082f8
    3ff8:	20008304 	.word	0x20008304
    3ffc:	00002f69 	.word	0x00002f69
    4000:	0000b3e0 	.word	0x0000b3e0
    4004:	0000bb08 	.word	0x0000bb08
    4008:	0000b428 	.word	0x0000b428
    400c:	0000a111 	.word	0x0000a111
    4010:	0000bb34 	.word	0x0000bb34
    4014:	0000a1f9 	.word	0x0000a1f9
    4018:	0000bb4c 	.word	0x0000bb4c
    401c:	0000bb6c 	.word	0x0000bb6c
    4020:	0000bbc4 	.word	0x0000bbc4
    4024:	0000bbe8 	.word	0x0000bbe8
    4028:	0000bb8c 	.word	0x0000bb8c
    402c:	0000bc14 	.word	0x0000bc14
    4030:	00002f51 	.word	0x00002f51
    4034:	000036d9 	.word	0x000036d9
    4038:	00003741 	.word	0x00003741
    403c:	0000bc28 	.word	0x0000bc28
    4040:	0000bc3c 	.word	0x0000bc3c
    4044:	00005bb9 	.word	0x00005bb9
    4048:	0000c3dc 	.word	0x0000c3dc
    404c:	00005a75 	.word	0x00005a75
    4050:	00005b59 	.word	0x00005b59
    4054:	00005b65 	.word	0x00005b65
    4058:	00002f75 	.word	0x00002f75
    405c:	00003349 	.word	0x00003349
    4060:	0000bc60 	.word	0x0000bc60
    4064:	0000bc8c 	.word	0x0000bc8c
    4068:	0000bcb4 	.word	0x0000bcb4
    406c:	0000bcd8 	.word	0x0000bcd8
    4070:	00003481 	.word	0x00003481
    4074:	0000bd00 	.word	0x0000bd00
		switch (op) {
    4078:	2b3b      	cmp	r3, #59	; 0x3b
    407a:	f63f ae8b 	bhi.w	3d94 <dhcp_recv+0x4ac>
    407e:	a201      	add	r2, pc, #4	; (adr r2, 4084 <dhcp_recv+0x79c>)
    4080:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    4084:	00003a67 	.word	0x00003a67
    4088:	00003c79 	.word	0x00003c79
    408c:	00003d95 	.word	0x00003d95
    4090:	00003c89 	.word	0x00003c89
    4094:	00003d95 	.word	0x00003d95
    4098:	00003d95 	.word	0x00003d95
    409c:	00003ca5 	.word	0x00003ca5
    40a0:	00003d95 	.word	0x00003d95
    40a4:	00003d95 	.word	0x00003d95
    40a8:	00003d95 	.word	0x00003d95
    40ac:	00003d95 	.word	0x00003d95
    40b0:	00003d95 	.word	0x00003d95
    40b4:	00003d95 	.word	0x00003d95
    40b8:	00003d95 	.word	0x00003d95
    40bc:	00003d95 	.word	0x00003d95
    40c0:	00003d95 	.word	0x00003d95
    40c4:	00003d95 	.word	0x00003d95
    40c8:	00003d95 	.word	0x00003d95
    40cc:	00003d95 	.word	0x00003d95
    40d0:	00003d95 	.word	0x00003d95
    40d4:	00003d95 	.word	0x00003d95
    40d8:	00003d95 	.word	0x00003d95
    40dc:	00003d95 	.word	0x00003d95
    40e0:	00003d95 	.word	0x00003d95
    40e4:	00003d95 	.word	0x00003d95
    40e8:	00003d95 	.word	0x00003d95
    40ec:	00003d95 	.word	0x00003d95
    40f0:	00003d95 	.word	0x00003d95
    40f4:	00003d95 	.word	0x00003d95
    40f8:	00003d95 	.word	0x00003d95
    40fc:	00003d95 	.word	0x00003d95
    4100:	00003d95 	.word	0x00003d95
    4104:	00003d95 	.word	0x00003d95
    4108:	00003d95 	.word	0x00003d95
    410c:	00003d95 	.word	0x00003d95
    4110:	00003d95 	.word	0x00003d95
    4114:	00003d95 	.word	0x00003d95
    4118:	00003d95 	.word	0x00003d95
    411c:	00003d95 	.word	0x00003d95
    4120:	00003d95 	.word	0x00003d95
    4124:	00003d95 	.word	0x00003d95
    4128:	00003d95 	.word	0x00003d95
    412c:	00003d95 	.word	0x00003d95
    4130:	00003d95 	.word	0x00003d95
    4134:	00003d95 	.word	0x00003d95
    4138:	00003d95 	.word	0x00003d95
    413c:	00003d95 	.word	0x00003d95
    4140:	00003d95 	.word	0x00003d95
    4144:	00003d95 	.word	0x00003d95
    4148:	00003d95 	.word	0x00003d95
    414c:	00003d95 	.word	0x00003d95
    4150:	00003ced 	.word	0x00003ced
    4154:	00003d09 	.word	0x00003d09
    4158:	00003d25 	.word	0x00003d25
    415c:	00003d41 	.word	0x00003d41
    4160:	00003d95 	.word	0x00003d95
    4164:	00003d95 	.word	0x00003d95
    4168:	00003d95 	.word	0x00003d95
    416c:	00003d5d 	.word	0x00003d5d
    4170:	00003d79 	.word	0x00003d79

00004174 <dhcp_arp_reply>:
{
    4174:	b570      	push	{r4, r5, r6, lr}
    4176:	b082      	sub	sp, #8
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    4178:	b158      	cbz	r0, 4192 <dhcp_arp_reply+0x1e>
    417a:	460c      	mov	r4, r1
    417c:	4605      	mov	r5, r0
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
    417e:	482e      	ldr	r0, [pc, #184]	; (4238 <dhcp_arp_reply+0xc4>)
    4180:	4b2e      	ldr	r3, [pc, #184]	; (423c <dhcp_arp_reply+0xc8>)
    4182:	4798      	blx	r3
	if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
    4184:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4186:	b113      	cbz	r3, 418e <dhcp_arp_reply+0x1a>
    4188:	7b1b      	ldrb	r3, [r3, #12]
    418a:	2b08      	cmp	r3, #8
    418c:	d009      	beq.n	41a2 <dhcp_arp_reply+0x2e>
}
    418e:	b002      	add	sp, #8
    4190:	bd70      	pop	{r4, r5, r6, pc}
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    4192:	4b2b      	ldr	r3, [pc, #172]	; (4240 <dhcp_arp_reply+0xcc>)
    4194:	f240 3226 	movw	r2, #806	; 0x326
    4198:	492a      	ldr	r1, [pc, #168]	; (4244 <dhcp_arp_reply+0xd0>)
    419a:	482b      	ldr	r0, [pc, #172]	; (4248 <dhcp_arp_reply+0xd4>)
    419c:	4c2b      	ldr	r4, [pc, #172]	; (424c <dhcp_arp_reply+0xd8>)
    419e:	47a0      	blx	r4
    41a0:	e7fe      	b.n	41a0 <dhcp_arp_reply+0x2c>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    41a2:	6821      	ldr	r1, [r4, #0]
    41a4:	482a      	ldr	r0, [pc, #168]	; (4250 <dhcp_arp_reply+0xdc>)
    41a6:	4b29      	ldr	r3, [pc, #164]	; (424c <dhcp_arp_reply+0xd8>)
    41a8:	4798      	blx	r3
		if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
    41aa:	6aab      	ldr	r3, [r5, #40]	; 0x28
    41ac:	6822      	ldr	r2, [r4, #0]
    41ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    41b0:	429a      	cmp	r2, r3
    41b2:	d1ec      	bne.n	418e <dhcp_arp_reply+0x1a>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
    41b4:	4827      	ldr	r0, [pc, #156]	; (4254 <dhcp_arp_reply+0xe0>)
    41b6:	4e21      	ldr	r6, [pc, #132]	; (423c <dhcp_arp_reply+0xc8>)
    41b8:	47b0      	blx	r6
	struct dhcp *dhcp   = netif->dhcp;
    41ba:	6aac      	ldr	r4, [r5, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
    41bc:	4826      	ldr	r0, [pc, #152]	; (4258 <dhcp_arp_reply+0xe4>)
    41be:	47b0      	blx	r6
	dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    41c0:	210c      	movs	r1, #12
    41c2:	4620      	mov	r0, r4
    41c4:	4b25      	ldr	r3, [pc, #148]	; (425c <dhcp_arp_reply+0xe8>)
    41c6:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
    41c8:	2204      	movs	r2, #4
    41ca:	4621      	mov	r1, r4
    41cc:	4628      	mov	r0, r5
    41ce:	4b24      	ldr	r3, [pc, #144]	; (4260 <dhcp_arp_reply+0xec>)
    41d0:	4798      	blx	r3
	if (result == ERR_OK) {
    41d2:	2800      	cmp	r0, #0
    41d4:	d12b      	bne.n	422e <dhcp_arp_reply+0xba>
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    41d6:	2204      	movs	r2, #4
    41d8:	2132      	movs	r1, #50	; 0x32
    41da:	4620      	mov	r0, r4
    41dc:	4b21      	ldr	r3, [pc, #132]	; (4264 <dhcp_arp_reply+0xf0>)
    41de:	4798      	blx	r3
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    41e0:	6a60      	ldr	r0, [r4, #36]	; 0x24
    41e2:	4b21      	ldr	r3, [pc, #132]	; (4268 <dhcp_arp_reply+0xf4>)
    41e4:	4798      	blx	r3
    41e6:	4601      	mov	r1, r0
    41e8:	4620      	mov	r0, r4
    41ea:	4b20      	ldr	r3, [pc, #128]	; (426c <dhcp_arp_reply+0xf8>)
    41ec:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    41ee:	4620      	mov	r0, r4
    41f0:	4b1f      	ldr	r3, [pc, #124]	; (4270 <dhcp_arp_reply+0xfc>)
    41f2:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    41f4:	8b21      	ldrh	r1, [r4, #24]
    41f6:	31f0      	adds	r1, #240	; 0xf0
    41f8:	b289      	uxth	r1, r1
    41fa:	6920      	ldr	r0, [r4, #16]
    41fc:	4b1d      	ldr	r3, [pc, #116]	; (4274 <dhcp_arp_reply+0x100>)
    41fe:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    4200:	6921      	ldr	r1, [r4, #16]
    4202:	6860      	ldr	r0, [r4, #4]
    4204:	9500      	str	r5, [sp, #0]
    4206:	2343      	movs	r3, #67	; 0x43
    4208:	4a1b      	ldr	r2, [pc, #108]	; (4278 <dhcp_arp_reply+0x104>)
    420a:	4d1c      	ldr	r5, [pc, #112]	; (427c <dhcp_arp_reply+0x108>)
    420c:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    420e:	4620      	mov	r0, r4
    4210:	4b1b      	ldr	r3, [pc, #108]	; (4280 <dhcp_arp_reply+0x10c>)
    4212:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
    4214:	481b      	ldr	r0, [pc, #108]	; (4284 <dhcp_arp_reply+0x110>)
    4216:	47b0      	blx	r6
	dhcp->tries++;
    4218:	7b63      	ldrb	r3, [r4, #13]
    421a:	3301      	adds	r3, #1
    421c:	7363      	strb	r3, [r4, #13]
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    421e:	2314      	movs	r3, #20
    4220:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %" U16_F " msecs\n", msecs));
    4222:	f242 7110 	movw	r1, #10000	; 0x2710
    4226:	4818      	ldr	r0, [pc, #96]	; (4288 <dhcp_arp_reply+0x114>)
    4228:	4b08      	ldr	r3, [pc, #32]	; (424c <dhcp_arp_reply+0xd8>)
    422a:	4798      	blx	r3
}
    422c:	e7af      	b.n	418e <dhcp_arp_reply+0x1a>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    422e:	4817      	ldr	r0, [pc, #92]	; (428c <dhcp_arp_reply+0x118>)
    4230:	4b02      	ldr	r3, [pc, #8]	; (423c <dhcp_arp_reply+0xc8>)
    4232:	4798      	blx	r3
    4234:	e7f0      	b.n	4218 <dhcp_arp_reply+0xa4>
    4236:	bf00      	nop
    4238:	0000bdd4 	.word	0x0000bdd4
    423c:	0000a1f9 	.word	0x0000a1f9
    4240:	0000b3e0 	.word	0x0000b3e0
    4244:	0000bd34 	.word	0x0000bd34
    4248:	0000b428 	.word	0x0000b428
    424c:	0000a111 	.word	0x0000a111
    4250:	0000bde8 	.word	0x0000bde8
    4254:	0000be1c 	.word	0x0000be1c
    4258:	0000be60 	.word	0x0000be60
    425c:	00002f75 	.word	0x00002f75
    4260:	00003079 	.word	0x00003079
    4264:	00002f85 	.word	0x00002f85
    4268:	00002f69 	.word	0x00002f69
    426c:	00002fe3 	.word	0x00002fe3
    4270:	00003029 	.word	0x00003029
    4274:	00005ec5 	.word	0x00005ec5
    4278:	0000c3d8 	.word	0x0000c3d8
    427c:	00008d49 	.word	0x00008d49
    4280:	00003225 	.word	0x00003225
    4284:	0000be70 	.word	0x0000be70
    4288:	0000bebc 	.word	0x0000bebc
    428c:	0000be8c 	.word	0x0000be8c

00004290 <dhcp_renew>:
{
    4290:	b570      	push	{r4, r5, r6, lr}
    4292:	b082      	sub	sp, #8
    4294:	4606      	mov	r6, r0
	struct dhcp *dhcp = netif->dhcp;
    4296:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
    4298:	4828      	ldr	r0, [pc, #160]	; (433c <dhcp_renew+0xac>)
    429a:	4b29      	ldr	r3, [pc, #164]	; (4340 <dhcp_renew+0xb0>)
    429c:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_RENEWING);
    429e:	2105      	movs	r1, #5
    42a0:	4620      	mov	r0, r4
    42a2:	4b28      	ldr	r3, [pc, #160]	; (4344 <dhcp_renew+0xb4>)
    42a4:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    42a6:	2203      	movs	r2, #3
    42a8:	4621      	mov	r1, r4
    42aa:	4630      	mov	r0, r6
    42ac:	4b26      	ldr	r3, [pc, #152]	; (4348 <dhcp_renew+0xb8>)
    42ae:	4798      	blx	r3
	if (result == ERR_OK) {
    42b0:	4605      	mov	r5, r0
    42b2:	2800      	cmp	r0, #0
    42b4:	d13a      	bne.n	432c <dhcp_renew+0x9c>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    42b6:	2202      	movs	r2, #2
    42b8:	2139      	movs	r1, #57	; 0x39
    42ba:	4620      	mov	r0, r4
    42bc:	4b23      	ldr	r3, [pc, #140]	; (434c <dhcp_renew+0xbc>)
    42be:	4798      	blx	r3
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    42c0:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
    42c2:	4620      	mov	r0, r4
    42c4:	4b22      	ldr	r3, [pc, #136]	; (4350 <dhcp_renew+0xc0>)
    42c6:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    42c8:	4620      	mov	r0, r4
    42ca:	4b22      	ldr	r3, [pc, #136]	; (4354 <dhcp_renew+0xc4>)
    42cc:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    42ce:	8b21      	ldrh	r1, [r4, #24]
    42d0:	31f0      	adds	r1, #240	; 0xf0
    42d2:	b289      	uxth	r1, r1
    42d4:	6920      	ldr	r0, [r4, #16]
    42d6:	4b20      	ldr	r3, [pc, #128]	; (4358 <dhcp_renew+0xc8>)
    42d8:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    42da:	6921      	ldr	r1, [r4, #16]
    42dc:	6860      	ldr	r0, [r4, #4]
    42de:	9600      	str	r6, [sp, #0]
    42e0:	2343      	movs	r3, #67	; 0x43
    42e2:	f104 0220 	add.w	r2, r4, #32
    42e6:	4e1d      	ldr	r6, [pc, #116]	; (435c <dhcp_renew+0xcc>)
    42e8:	47b0      	blx	r6
		dhcp_delete_msg(dhcp);
    42ea:	4620      	mov	r0, r4
    42ec:	4b1c      	ldr	r3, [pc, #112]	; (4360 <dhcp_renew+0xd0>)
    42ee:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
    42f0:	481c      	ldr	r0, [pc, #112]	; (4364 <dhcp_renew+0xd4>)
    42f2:	4b13      	ldr	r3, [pc, #76]	; (4340 <dhcp_renew+0xb0>)
    42f4:	4798      	blx	r3
	dhcp->tries++;
    42f6:	7b61      	ldrb	r1, [r4, #13]
    42f8:	3101      	adds	r1, #1
    42fa:	b2c9      	uxtb	r1, r1
    42fc:	7361      	strb	r1, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    42fe:	2909      	cmp	r1, #9
    4300:	d818      	bhi.n	4334 <dhcp_renew+0xa4>
    4302:	ebc1 1341 	rsb	r3, r1, r1, lsl #5
    4306:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    430a:	0109      	lsls	r1, r1, #4
    430c:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    430e:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    4312:	4a15      	ldr	r2, [pc, #84]	; (4368 <dhcp_renew+0xd8>)
    4314:	fb82 0203 	smull	r0, r2, r2, r3
    4318:	17db      	asrs	r3, r3, #31
    431a:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    431e:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    4320:	4812      	ldr	r0, [pc, #72]	; (436c <dhcp_renew+0xdc>)
    4322:	4b13      	ldr	r3, [pc, #76]	; (4370 <dhcp_renew+0xe0>)
    4324:	4798      	blx	r3
}
    4326:	4628      	mov	r0, r5
    4328:	b002      	add	sp, #8
    432a:	bd70      	pop	{r4, r5, r6, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    432c:	4811      	ldr	r0, [pc, #68]	; (4374 <dhcp_renew+0xe4>)
    432e:	4b04      	ldr	r3, [pc, #16]	; (4340 <dhcp_renew+0xb0>)
    4330:	4798      	blx	r3
    4332:	e7e0      	b.n	42f6 <dhcp_renew+0x66>
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    4334:	f644 6120 	movw	r1, #20000	; 0x4e20
    4338:	e7e9      	b.n	430e <dhcp_renew+0x7e>
    433a:	bf00      	nop
    433c:	0000beec 	.word	0x0000beec
    4340:	0000a1f9 	.word	0x0000a1f9
    4344:	00002f75 	.word	0x00002f75
    4348:	00003079 	.word	0x00003079
    434c:	00002f85 	.word	0x00002f85
    4350:	00002fbd 	.word	0x00002fbd
    4354:	00003029 	.word	0x00003029
    4358:	00005ec5 	.word	0x00005ec5
    435c:	00008d49 	.word	0x00008d49
    4360:	00003225 	.word	0x00003225
    4364:	0000befc 	.word	0x0000befc
    4368:	10624dd3 	.word	0x10624dd3
    436c:	0000bf40 	.word	0x0000bf40
    4370:	0000a111 	.word	0x0000a111
    4374:	0000bf14 	.word	0x0000bf14

00004378 <dhcp_coarse_tmr>:
{
    4378:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct netif *netif = netif_list;
    437c:	4b22      	ldr	r3, [pc, #136]	; (4408 <dhcp_coarse_tmr+0x90>)
    437e:	681c      	ldr	r4, [r3, #0]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
    4380:	4822      	ldr	r0, [pc, #136]	; (440c <dhcp_coarse_tmr+0x94>)
    4382:	4b23      	ldr	r3, [pc, #140]	; (4410 <dhcp_coarse_tmr+0x98>)
    4384:	4798      	blx	r3
	while (netif != NULL) {
    4386:	2c00      	cmp	r4, #0
    4388:	d03b      	beq.n	4402 <dhcp_coarse_tmr+0x8a>
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
    438a:	4f22      	ldr	r7, [pc, #136]	; (4414 <dhcp_coarse_tmr+0x9c>)
    438c:	4d20      	ldr	r5, [pc, #128]	; (4410 <dhcp_coarse_tmr+0x98>)
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
    438e:	4e22      	ldr	r6, [pc, #136]	; (4418 <dhcp_coarse_tmr+0xa0>)
    4390:	e00f      	b.n	43b2 <dhcp_coarse_tmr+0x3a>
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
    4392:	4822      	ldr	r0, [pc, #136]	; (441c <dhcp_coarse_tmr+0xa4>)
    4394:	47a8      	blx	r5
	struct dhcp *dhcp = netif->dhcp;
    4396:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
    439a:	4821      	ldr	r0, [pc, #132]	; (4420 <dhcp_coarse_tmr+0xa8>)
    439c:	47a8      	blx	r5
	if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    439e:	f898 300c 	ldrb.w	r3, [r8, #12]
    43a2:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
    43a6:	2a01      	cmp	r2, #1
    43a8:	d025      	beq.n	43f6 <dhcp_coarse_tmr+0x7e>
    43aa:	2b0a      	cmp	r3, #10
    43ac:	d023      	beq.n	43f6 <dhcp_coarse_tmr+0x7e>
		netif = netif->next;
    43ae:	6824      	ldr	r4, [r4, #0]
	while (netif != NULL) {
    43b0:	b33c      	cbz	r4, 4402 <dhcp_coarse_tmr+0x8a>
		if (netif->dhcp != NULL) {
    43b2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    43b4:	2b00      	cmp	r3, #0
    43b6:	d0fa      	beq.n	43ae <dhcp_coarse_tmr+0x36>
			if (netif->dhcp->t2_timeout-- == 1) {
    43b8:	8bda      	ldrh	r2, [r3, #30]
    43ba:	1e51      	subs	r1, r2, #1
    43bc:	83d9      	strh	r1, [r3, #30]
    43be:	2a01      	cmp	r2, #1
    43c0:	d0e7      	beq.n	4392 <dhcp_coarse_tmr+0x1a>
			} else if (netif->dhcp->t1_timeout-- == 1) {
    43c2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    43c4:	8b93      	ldrh	r3, [r2, #28]
    43c6:	1e59      	subs	r1, r3, #1
    43c8:	8391      	strh	r1, [r2, #28]
    43ca:	2b01      	cmp	r3, #1
    43cc:	d1ef      	bne.n	43ae <dhcp_coarse_tmr+0x36>
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
    43ce:	4638      	mov	r0, r7
    43d0:	47a8      	blx	r5
	struct dhcp *dhcp = netif->dhcp;
    43d2:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
    43d6:	4630      	mov	r0, r6
    43d8:	47a8      	blx	r5
	if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    43da:	f898 300c 	ldrb.w	r3, [r8, #12]
    43de:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
    43e2:	2a01      	cmp	r2, #1
    43e4:	d001      	beq.n	43ea <dhcp_coarse_tmr+0x72>
    43e6:	2b0a      	cmp	r3, #10
    43e8:	d1e1      	bne.n	43ae <dhcp_coarse_tmr+0x36>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    43ea:	480e      	ldr	r0, [pc, #56]	; (4424 <dhcp_coarse_tmr+0xac>)
    43ec:	47a8      	blx	r5
		dhcp_renew(netif);
    43ee:	4620      	mov	r0, r4
    43f0:	4b0d      	ldr	r3, [pc, #52]	; (4428 <dhcp_coarse_tmr+0xb0>)
    43f2:	4798      	blx	r3
    43f4:	e7db      	b.n	43ae <dhcp_coarse_tmr+0x36>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    43f6:	480d      	ldr	r0, [pc, #52]	; (442c <dhcp_coarse_tmr+0xb4>)
    43f8:	47a8      	blx	r5
		dhcp_rebind(netif);
    43fa:	4620      	mov	r0, r4
    43fc:	4b0c      	ldr	r3, [pc, #48]	; (4430 <dhcp_coarse_tmr+0xb8>)
    43fe:	4798      	blx	r3
    4400:	e7d5      	b.n	43ae <dhcp_coarse_tmr+0x36>
    4402:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4406:	bf00      	nop
    4408:	200092f0 	.word	0x200092f0
    440c:	0000bf70 	.word	0x0000bf70
    4410:	0000a1f9 	.word	0x0000a1f9
    4414:	0000bfd8 	.word	0x0000bfd8
    4418:	0000bff8 	.word	0x0000bff8
    441c:	0000bf84 	.word	0x0000bf84
    4420:	0000bfa4 	.word	0x0000bfa4
    4424:	0000c00c 	.word	0x0000c00c
    4428:	00004291 	.word	0x00004291
    442c:	0000bfb8 	.word	0x0000bfb8
    4430:	00003261 	.word	0x00003261

00004434 <dhcp_release>:
{
    4434:	b5f0      	push	{r4, r5, r6, r7, lr}
    4436:	b083      	sub	sp, #12
    4438:	4605      	mov	r5, r0
	struct dhcp *dhcp = netif->dhcp;
    443a:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));
    443c:	482f      	ldr	r0, [pc, #188]	; (44fc <dhcp_release+0xc8>)
    443e:	4b30      	ldr	r3, [pc, #192]	; (4500 <dhcp_release+0xcc>)
    4440:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_OFF);
    4442:	2100      	movs	r1, #0
    4444:	4620      	mov	r0, r4
    4446:	4b2f      	ldr	r3, [pc, #188]	; (4504 <dhcp_release+0xd0>)
    4448:	4798      	blx	r3
	ip_addr_set_zero(&dhcp->server_ip_addr);
    444a:	2300      	movs	r3, #0
    444c:	6223      	str	r3, [r4, #32]
	ip_addr_set_zero(&dhcp->offered_ip_addr);
    444e:	6263      	str	r3, [r4, #36]	; 0x24
	ip_addr_set_zero(&dhcp->offered_sn_mask);
    4450:	62a3      	str	r3, [r4, #40]	; 0x28
	ip_addr_set_zero(&dhcp->offered_gw_addr);
    4452:	62e3      	str	r3, [r4, #44]	; 0x2c
	dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
    4454:	63a3      	str	r3, [r4, #56]	; 0x38
    4456:	6363      	str	r3, [r4, #52]	; 0x34
    4458:	6323      	str	r3, [r4, #48]	; 0x30
	result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
    445a:	2207      	movs	r2, #7
    445c:	4621      	mov	r1, r4
    445e:	4628      	mov	r0, r5
    4460:	4b29      	ldr	r3, [pc, #164]	; (4508 <dhcp_release+0xd4>)
    4462:	4798      	blx	r3
	if (result == ERR_OK) {
    4464:	4606      	mov	r6, r0
    4466:	2800      	cmp	r0, #0
    4468:	d141      	bne.n	44ee <dhcp_release+0xba>
		dhcp_option_trailer(dhcp);
    446a:	4620      	mov	r0, r4
    446c:	4b27      	ldr	r3, [pc, #156]	; (450c <dhcp_release+0xd8>)
    446e:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    4470:	8b21      	ldrh	r1, [r4, #24]
    4472:	31f0      	adds	r1, #240	; 0xf0
    4474:	b289      	uxth	r1, r1
    4476:	6920      	ldr	r0, [r4, #16]
    4478:	4b25      	ldr	r3, [pc, #148]	; (4510 <dhcp_release+0xdc>)
    447a:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    447c:	6921      	ldr	r1, [r4, #16]
    447e:	6860      	ldr	r0, [r4, #4]
    4480:	9500      	str	r5, [sp, #0]
    4482:	2343      	movs	r3, #67	; 0x43
    4484:	f104 0220 	add.w	r2, r4, #32
    4488:	4f22      	ldr	r7, [pc, #136]	; (4514 <dhcp_release+0xe0>)
    448a:	47b8      	blx	r7
		dhcp_delete_msg(dhcp);
    448c:	4620      	mov	r0, r4
    448e:	4b22      	ldr	r3, [pc, #136]	; (4518 <dhcp_release+0xe4>)
    4490:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
    4492:	4822      	ldr	r0, [pc, #136]	; (451c <dhcp_release+0xe8>)
    4494:	4b1a      	ldr	r3, [pc, #104]	; (4500 <dhcp_release+0xcc>)
    4496:	4798      	blx	r3
	dhcp->tries++;
    4498:	7b61      	ldrb	r1, [r4, #13]
    449a:	3101      	adds	r1, #1
    449c:	b2c9      	uxtb	r1, r1
    449e:	7361      	strb	r1, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    44a0:	2909      	cmp	r1, #9
    44a2:	d828      	bhi.n	44f6 <dhcp_release+0xc2>
    44a4:	ebc1 1341 	rsb	r3, r1, r1, lsl #5
    44a8:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    44ac:	00c9      	lsls	r1, r1, #3
    44ae:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    44b0:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    44b4:	4a1a      	ldr	r2, [pc, #104]	; (4520 <dhcp_release+0xec>)
    44b6:	fb82 0203 	smull	r0, r2, r2, r3
    44ba:	17db      	asrs	r3, r3, #31
    44bc:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    44c0:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    44c2:	4818      	ldr	r0, [pc, #96]	; (4524 <dhcp_release+0xf0>)
    44c4:	4b18      	ldr	r3, [pc, #96]	; (4528 <dhcp_release+0xf4>)
    44c6:	4798      	blx	r3
	netif_set_down(netif);
    44c8:	4628      	mov	r0, r5
    44ca:	4b18      	ldr	r3, [pc, #96]	; (452c <dhcp_release+0xf8>)
    44cc:	4798      	blx	r3
	netif_set_ipaddr(netif, IP_ADDR_ANY);
    44ce:	4c18      	ldr	r4, [pc, #96]	; (4530 <dhcp_release+0xfc>)
    44d0:	4621      	mov	r1, r4
    44d2:	4628      	mov	r0, r5
    44d4:	4b17      	ldr	r3, [pc, #92]	; (4534 <dhcp_release+0x100>)
    44d6:	4798      	blx	r3
	netif_set_gw(netif, IP_ADDR_ANY);
    44d8:	4621      	mov	r1, r4
    44da:	4628      	mov	r0, r5
    44dc:	4b16      	ldr	r3, [pc, #88]	; (4538 <dhcp_release+0x104>)
    44de:	4798      	blx	r3
	netif_set_netmask(netif, IP_ADDR_ANY);
    44e0:	4621      	mov	r1, r4
    44e2:	4628      	mov	r0, r5
    44e4:	4b15      	ldr	r3, [pc, #84]	; (453c <dhcp_release+0x108>)
    44e6:	4798      	blx	r3
}
    44e8:	4630      	mov	r0, r6
    44ea:	b003      	add	sp, #12
    44ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    44ee:	4814      	ldr	r0, [pc, #80]	; (4540 <dhcp_release+0x10c>)
    44f0:	4b03      	ldr	r3, [pc, #12]	; (4500 <dhcp_release+0xcc>)
    44f2:	4798      	blx	r3
    44f4:	e7d0      	b.n	4498 <dhcp_release+0x64>
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    44f6:	f242 7110 	movw	r1, #10000	; 0x2710
    44fa:	e7d9      	b.n	44b0 <dhcp_release+0x7c>
    44fc:	0000c02c 	.word	0x0000c02c
    4500:	0000a1f9 	.word	0x0000a1f9
    4504:	00002f75 	.word	0x00002f75
    4508:	00003079 	.word	0x00003079
    450c:	00003029 	.word	0x00003029
    4510:	00005ec5 	.word	0x00005ec5
    4514:	00008d49 	.word	0x00008d49
    4518:	00003225 	.word	0x00003225
    451c:	0000c03c 	.word	0x0000c03c
    4520:	10624dd3 	.word	0x10624dd3
    4524:	0000c090 	.word	0x0000c090
    4528:	0000a111 	.word	0x0000a111
    452c:	00005bb9 	.word	0x00005bb9
    4530:	0000c3dc 	.word	0x0000c3dc
    4534:	00005a75 	.word	0x00005a75
    4538:	00005b59 	.word	0x00005b59
    453c:	00005b65 	.word	0x00005b65
    4540:	0000c060 	.word	0x0000c060

00004544 <dhcp_fine_tmr>:
{
    4544:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct netif *netif = netif_list;
    4548:	4b3a      	ldr	r3, [pc, #232]	; (4634 <dhcp_fine_tmr+0xf0>)
    454a:	681c      	ldr	r4, [r3, #0]
	while (netif != NULL) {
    454c:	2c00      	cmp	r4, #0
    454e:	d06f      	beq.n	4630 <dhcp_fine_tmr+0xec>
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
    4550:	4f39      	ldr	r7, [pc, #228]	; (4638 <dhcp_fine_tmr+0xf4>)
    4552:	4d3a      	ldr	r5, [pc, #232]	; (463c <dhcp_fine_tmr+0xf8>)
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
    4554:	4e3a      	ldr	r6, [pc, #232]	; (4640 <dhcp_fine_tmr+0xfc>)
    4556:	e004      	b.n	4562 <dhcp_fine_tmr+0x1e>
			} else if (netif->dhcp->request_timeout == 1) {
    4558:	2b01      	cmp	r3, #1
    455a:	d00b      	beq.n	4574 <dhcp_fine_tmr+0x30>
		netif = netif->next;
    455c:	6824      	ldr	r4, [r4, #0]
	while (netif != NULL) {
    455e:	2c00      	cmp	r4, #0
    4560:	d066      	beq.n	4630 <dhcp_fine_tmr+0xec>
		if (netif->dhcp != NULL) {
    4562:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    4564:	2a00      	cmp	r2, #0
    4566:	d0f9      	beq.n	455c <dhcp_fine_tmr+0x18>
			if (netif->dhcp->request_timeout > 1) {
    4568:	8b53      	ldrh	r3, [r2, #26]
    456a:	2b01      	cmp	r3, #1
    456c:	d9f4      	bls.n	4558 <dhcp_fine_tmr+0x14>
				netif->dhcp->request_timeout--;
    456e:	3b01      	subs	r3, #1
    4570:	8353      	strh	r3, [r2, #26]
    4572:	e7f3      	b.n	455c <dhcp_fine_tmr+0x18>
				netif->dhcp->request_timeout--;
    4574:	2300      	movs	r3, #0
    4576:	8353      	strh	r3, [r2, #26]
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
    4578:	4638      	mov	r0, r7
    457a:	47a8      	blx	r5
	struct dhcp *dhcp = netif->dhcp;
    457c:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
    4580:	4630      	mov	r0, r6
    4582:	47a8      	blx	r5
	if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    4584:	f898 300c 	ldrb.w	r3, [r8, #12]
    4588:	2b0c      	cmp	r3, #12
    458a:	d014      	beq.n	45b6 <dhcp_fine_tmr+0x72>
    458c:	2b06      	cmp	r3, #6
    458e:	d012      	beq.n	45b6 <dhcp_fine_tmr+0x72>
	} else if (dhcp->state == DHCP_REQUESTING) {
    4590:	2b01      	cmp	r3, #1
    4592:	d016      	beq.n	45c2 <dhcp_fine_tmr+0x7e>
	} else if (dhcp->state == DHCP_CHECKING) {
    4594:	2b08      	cmp	r3, #8
    4596:	d027      	beq.n	45e8 <dhcp_fine_tmr+0xa4>
	else if (dhcp->state == DHCP_RENEWING) {
    4598:	2b05      	cmp	r3, #5
    459a:	d030      	beq.n	45fe <dhcp_fine_tmr+0xba>
	} else if (dhcp->state == DHCP_REBINDING) {
    459c:	2b04      	cmp	r3, #4
    459e:	d034      	beq.n	460a <dhcp_fine_tmr+0xc6>
	} else if (dhcp->state == DHCP_REBOOTING) {
    45a0:	2b03      	cmp	r3, #3
    45a2:	d1db      	bne.n	455c <dhcp_fine_tmr+0x18>
		if (dhcp->tries < REBOOT_TRIES) {
    45a4:	f898 300d 	ldrb.w	r3, [r8, #13]
    45a8:	2b01      	cmp	r3, #1
			dhcp_reboot(netif);
    45aa:	4620      	mov	r0, r4
    45ac:	bf94      	ite	ls
    45ae:	4b25      	ldrls	r3, [pc, #148]	; (4644 <dhcp_fine_tmr+0x100>)
			dhcp_discover(netif);
    45b0:	4b25      	ldrhi	r3, [pc, #148]	; (4648 <dhcp_fine_tmr+0x104>)
    45b2:	4798      	blx	r3
    45b4:	e7d2      	b.n	455c <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    45b6:	4825      	ldr	r0, [pc, #148]	; (464c <dhcp_fine_tmr+0x108>)
    45b8:	47a8      	blx	r5
		dhcp_discover(netif);
    45ba:	4620      	mov	r0, r4
    45bc:	4b22      	ldr	r3, [pc, #136]	; (4648 <dhcp_fine_tmr+0x104>)
    45be:	4798      	blx	r3
    45c0:	e7cc      	b.n	455c <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    45c2:	4823      	ldr	r0, [pc, #140]	; (4650 <dhcp_fine_tmr+0x10c>)
    45c4:	47a8      	blx	r5
		if (dhcp->tries <= 5) {
    45c6:	f898 300d 	ldrb.w	r3, [r8, #13]
    45ca:	2b05      	cmp	r3, #5
    45cc:	d803      	bhi.n	45d6 <dhcp_fine_tmr+0x92>
			dhcp_select(netif);
    45ce:	4620      	mov	r0, r4
    45d0:	4b20      	ldr	r3, [pc, #128]	; (4654 <dhcp_fine_tmr+0x110>)
    45d2:	4798      	blx	r3
    45d4:	e7c2      	b.n	455c <dhcp_fine_tmr+0x18>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    45d6:	4820      	ldr	r0, [pc, #128]	; (4658 <dhcp_fine_tmr+0x114>)
    45d8:	47a8      	blx	r5
			dhcp_release(netif);
    45da:	4620      	mov	r0, r4
    45dc:	4b1f      	ldr	r3, [pc, #124]	; (465c <dhcp_fine_tmr+0x118>)
    45de:	4798      	blx	r3
			dhcp_discover(netif);
    45e0:	4620      	mov	r0, r4
    45e2:	4b19      	ldr	r3, [pc, #100]	; (4648 <dhcp_fine_tmr+0x104>)
    45e4:	4798      	blx	r3
    45e6:	e7b9      	b.n	455c <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    45e8:	481d      	ldr	r0, [pc, #116]	; (4660 <dhcp_fine_tmr+0x11c>)
    45ea:	47a8      	blx	r5
		if (dhcp->tries <= 1) {
    45ec:	f898 300d 	ldrb.w	r3, [r8, #13]
    45f0:	2b01      	cmp	r3, #1
			dhcp_check(netif);
    45f2:	4620      	mov	r0, r4
    45f4:	bf94      	ite	ls
    45f6:	4b1b      	ldrls	r3, [pc, #108]	; (4664 <dhcp_fine_tmr+0x120>)
			dhcp_bind(netif);
    45f8:	4b1b      	ldrhi	r3, [pc, #108]	; (4668 <dhcp_fine_tmr+0x124>)
    45fa:	4798      	blx	r3
    45fc:	e7ae      	b.n	455c <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    45fe:	481b      	ldr	r0, [pc, #108]	; (466c <dhcp_fine_tmr+0x128>)
    4600:	47a8      	blx	r5
		dhcp_renew(netif);
    4602:	4620      	mov	r0, r4
    4604:	4b1a      	ldr	r3, [pc, #104]	; (4670 <dhcp_fine_tmr+0x12c>)
    4606:	4798      	blx	r3
    4608:	e7a8      	b.n	455c <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    460a:	481a      	ldr	r0, [pc, #104]	; (4674 <dhcp_fine_tmr+0x130>)
    460c:	47a8      	blx	r5
		if (dhcp->tries <= 8) {
    460e:	f898 300d 	ldrb.w	r3, [r8, #13]
    4612:	2b08      	cmp	r3, #8
    4614:	d803      	bhi.n	461e <dhcp_fine_tmr+0xda>
			dhcp_rebind(netif);
    4616:	4620      	mov	r0, r4
    4618:	4b17      	ldr	r3, [pc, #92]	; (4678 <dhcp_fine_tmr+0x134>)
    461a:	4798      	blx	r3
    461c:	e79e      	b.n	455c <dhcp_fine_tmr+0x18>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
    461e:	4817      	ldr	r0, [pc, #92]	; (467c <dhcp_fine_tmr+0x138>)
    4620:	47a8      	blx	r5
			dhcp_release(netif);
    4622:	4620      	mov	r0, r4
    4624:	4b0d      	ldr	r3, [pc, #52]	; (465c <dhcp_fine_tmr+0x118>)
    4626:	4798      	blx	r3
			dhcp_discover(netif);
    4628:	4620      	mov	r0, r4
    462a:	4b07      	ldr	r3, [pc, #28]	; (4648 <dhcp_fine_tmr+0x104>)
    462c:	4798      	blx	r3
    462e:	e795      	b.n	455c <dhcp_fine_tmr+0x18>
    4630:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4634:	200092f0 	.word	0x200092f0
    4638:	0000c0c0 	.word	0x0000c0c0
    463c:	0000a1f9 	.word	0x0000a1f9
    4640:	0000c0e4 	.word	0x0000c0e4
    4644:	000035d1 	.word	0x000035d1
    4648:	00003349 	.word	0x00003349
    464c:	0000c0f4 	.word	0x0000c0f4
    4650:	0000c11c 	.word	0x0000c11c
    4654:	00003481 	.word	0x00003481
    4658:	0000c150 	.word	0x0000c150
    465c:	00004435 	.word	0x00004435
    4660:	0000c184 	.word	0x0000c184
    4664:	000036d9 	.word	0x000036d9
    4668:	00003741 	.word	0x00003741
    466c:	0000c1b4 	.word	0x0000c1b4
    4670:	00004291 	.word	0x00004291
    4674:	0000c1e8 	.word	0x0000c1e8
    4678:	00003261 	.word	0x00003261
    467c:	0000c21c 	.word	0x0000c21c

00004680 <dhcp_stop>:
{
    4680:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    4682:	b1a8      	cbz	r0, 46b0 <dhcp_stop+0x30>
	dhcp = netif->dhcp;
    4684:	6a84      	ldr	r4, [r0, #40]	; 0x28
	netif->flags &= ~NETIF_FLAG_DHCP;
    4686:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
    468a:	f022 0208 	bic.w	r2, r2, #8
    468e:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
    4692:	480b      	ldr	r0, [pc, #44]	; (46c0 <dhcp_stop+0x40>)
    4694:	4b0b      	ldr	r3, [pc, #44]	; (46c4 <dhcp_stop+0x44>)
    4696:	4798      	blx	r3
	if (dhcp != NULL) {
    4698:	b14c      	cbz	r4, 46ae <dhcp_stop+0x2e>
		if (dhcp->pcb != NULL) {
    469a:	6860      	ldr	r0, [r4, #4]
    469c:	b118      	cbz	r0, 46a6 <dhcp_stop+0x26>
			udp_remove(dhcp->pcb);
    469e:	4b0a      	ldr	r3, [pc, #40]	; (46c8 <dhcp_stop+0x48>)
    46a0:	4798      	blx	r3
			dhcp->pcb = NULL;
    46a2:	2300      	movs	r3, #0
    46a4:	6063      	str	r3, [r4, #4]
		dhcp_set_state(dhcp, DHCP_OFF);
    46a6:	2100      	movs	r1, #0
    46a8:	4620      	mov	r0, r4
    46aa:	4b08      	ldr	r3, [pc, #32]	; (46cc <dhcp_stop+0x4c>)
    46ac:	4798      	blx	r3
    46ae:	bd10      	pop	{r4, pc}
	LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    46b0:	4b07      	ldr	r3, [pc, #28]	; (46d0 <dhcp_stop+0x50>)
    46b2:	f240 42cc 	movw	r2, #1228	; 0x4cc
    46b6:	4907      	ldr	r1, [pc, #28]	; (46d4 <dhcp_stop+0x54>)
    46b8:	4807      	ldr	r0, [pc, #28]	; (46d8 <dhcp_stop+0x58>)
    46ba:	4c08      	ldr	r4, [pc, #32]	; (46dc <dhcp_stop+0x5c>)
    46bc:	47a0      	blx	r4
    46be:	e7fe      	b.n	46be <dhcp_stop+0x3e>
    46c0:	0000c260 	.word	0x0000c260
    46c4:	0000a1f9 	.word	0x0000a1f9
    46c8:	00008ef5 	.word	0x00008ef5
    46cc:	00002f75 	.word	0x00002f75
    46d0:	0000b3e0 	.word	0x0000b3e0
    46d4:	0000c244 	.word	0x0000c244
    46d8:	0000b428 	.word	0x0000b428
    46dc:	0000a111 	.word	0x0000a111

000046e0 <dhcp_start>:
{
    46e0:	b570      	push	{r4, r5, r6, lr}
    46e2:	b082      	sub	sp, #8
	LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
    46e4:	2800      	cmp	r0, #0
    46e6:	d052      	beq.n	478e <dhcp_start+0xae>
    46e8:	4604      	mov	r4, r0
	dhcp = netif->dhcp;
    46ea:	6a85      	ldr	r5, [r0, #40]	; 0x28
	LWIP_DEBUGF(
    46ec:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
    46f0:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
    46f4:	f890 1038 	ldrb.w	r1, [r0, #56]	; 0x38
    46f8:	9100      	str	r1, [sp, #0]
    46fa:	4601      	mov	r1, r0
    46fc:	483d      	ldr	r0, [pc, #244]	; (47f4 <dhcp_start+0x114>)
    46fe:	4e3e      	ldr	r6, [pc, #248]	; (47f8 <dhcp_start+0x118>)
    4700:	47b0      	blx	r6
	netif->flags &= ~NETIF_FLAG_DHCP;
    4702:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    4706:	f023 0208 	bic.w	r2, r3, #8
    470a:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
	if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
    470e:	f013 0f20 	tst.w	r3, #32
    4712:	d044      	beq.n	479e <dhcp_start+0xbe>
	if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
    4714:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    4716:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
    471a:	d346      	bcc.n	47aa <dhcp_start+0xca>
	if (dhcp == NULL) {
    471c:	2d00      	cmp	r5, #0
    471e:	d04a      	beq.n	47b6 <dhcp_start+0xd6>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    4720:	4836      	ldr	r0, [pc, #216]	; (47fc <dhcp_start+0x11c>)
    4722:	4b37      	ldr	r3, [pc, #220]	; (4800 <dhcp_start+0x120>)
    4724:	4798      	blx	r3
		if (dhcp->pcb != NULL) {
    4726:	6868      	ldr	r0, [r5, #4]
    4728:	b108      	cbz	r0, 472e <dhcp_start+0x4e>
			udp_remove(dhcp->pcb);
    472a:	4b36      	ldr	r3, [pc, #216]	; (4804 <dhcp_start+0x124>)
    472c:	4798      	blx	r3
	memset(dhcp, 0, sizeof(struct dhcp));
    472e:	223c      	movs	r2, #60	; 0x3c
    4730:	2100      	movs	r1, #0
    4732:	4628      	mov	r0, r5
    4734:	4b34      	ldr	r3, [pc, #208]	; (4808 <dhcp_start+0x128>)
    4736:	4798      	blx	r3
	dhcp->pcb = udp_new();
    4738:	4b34      	ldr	r3, [pc, #208]	; (480c <dhcp_start+0x12c>)
    473a:	4798      	blx	r3
    473c:	6068      	str	r0, [r5, #4]
	if (dhcp->pcb == NULL) {
    473e:	2800      	cmp	r0, #0
    4740:	d04c      	beq.n	47dc <dhcp_start+0xfc>
	ip_set_option(dhcp->pcb, SOF_BROADCAST);
    4742:	7a03      	ldrb	r3, [r0, #8]
    4744:	f043 0320 	orr.w	r3, r3, #32
    4748:	7203      	strb	r3, [r0, #8]
	udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    474a:	4e31      	ldr	r6, [pc, #196]	; (4810 <dhcp_start+0x130>)
    474c:	2244      	movs	r2, #68	; 0x44
    474e:	4631      	mov	r1, r6
    4750:	6868      	ldr	r0, [r5, #4]
    4752:	4b30      	ldr	r3, [pc, #192]	; (4814 <dhcp_start+0x134>)
    4754:	4798      	blx	r3
	udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
    4756:	2243      	movs	r2, #67	; 0x43
    4758:	4631      	mov	r1, r6
    475a:	6868      	ldr	r0, [r5, #4]
    475c:	4b2e      	ldr	r3, [pc, #184]	; (4818 <dhcp_start+0x138>)
    475e:	4798      	blx	r3
	udp_recv(dhcp->pcb, dhcp_recv, netif);
    4760:	4622      	mov	r2, r4
    4762:	492e      	ldr	r1, [pc, #184]	; (481c <dhcp_start+0x13c>)
    4764:	6868      	ldr	r0, [r5, #4]
    4766:	4b2e      	ldr	r3, [pc, #184]	; (4820 <dhcp_start+0x140>)
    4768:	4798      	blx	r3
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
    476a:	482e      	ldr	r0, [pc, #184]	; (4824 <dhcp_start+0x144>)
    476c:	4b24      	ldr	r3, [pc, #144]	; (4800 <dhcp_start+0x120>)
    476e:	4798      	blx	r3
	result = dhcp_discover(netif);
    4770:	4620      	mov	r0, r4
    4772:	4b2d      	ldr	r3, [pc, #180]	; (4828 <dhcp_start+0x148>)
    4774:	4798      	blx	r3
	if (result != ERR_OK) {
    4776:	4603      	mov	r3, r0
    4778:	2800      	cmp	r0, #0
    477a:	d135      	bne.n	47e8 <dhcp_start+0x108>
	netif->flags |= NETIF_FLAG_DHCP;
    477c:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
    4780:	f042 0208 	orr.w	r2, r2, #8
    4784:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
}
    4788:	4618      	mov	r0, r3
    478a:	b002      	add	sp, #8
    478c:	bd70      	pop	{r4, r5, r6, pc}
	LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
    478e:	4b27      	ldr	r3, [pc, #156]	; (482c <dhcp_start+0x14c>)
    4790:	f240 227a 	movw	r2, #634	; 0x27a
    4794:	4926      	ldr	r1, [pc, #152]	; (4830 <dhcp_start+0x150>)
    4796:	4827      	ldr	r0, [pc, #156]	; (4834 <dhcp_start+0x154>)
    4798:	4c17      	ldr	r4, [pc, #92]	; (47f8 <dhcp_start+0x118>)
    479a:	47a0      	blx	r4
    479c:	e7fe      	b.n	479c <dhcp_start+0xbc>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): No ETHARP netif\n"));
    479e:	4826      	ldr	r0, [pc, #152]	; (4838 <dhcp_start+0x158>)
    47a0:	4b17      	ldr	r3, [pc, #92]	; (4800 <dhcp_start+0x120>)
    47a2:	4798      	blx	r3
		return ERR_ARG;
    47a4:	f06f 030d 	mvn.w	r3, #13
    47a8:	e7ee      	b.n	4788 <dhcp_start+0xa8>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    47aa:	4824      	ldr	r0, [pc, #144]	; (483c <dhcp_start+0x15c>)
    47ac:	4b14      	ldr	r3, [pc, #80]	; (4800 <dhcp_start+0x120>)
    47ae:	4798      	blx	r3
		return ERR_MEM;
    47b0:	f04f 33ff 	mov.w	r3, #4294967295
    47b4:	e7e8      	b.n	4788 <dhcp_start+0xa8>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    47b6:	4822      	ldr	r0, [pc, #136]	; (4840 <dhcp_start+0x160>)
    47b8:	4b11      	ldr	r3, [pc, #68]	; (4800 <dhcp_start+0x120>)
    47ba:	4798      	blx	r3
		dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
    47bc:	203c      	movs	r0, #60	; 0x3c
    47be:	4b21      	ldr	r3, [pc, #132]	; (4844 <dhcp_start+0x164>)
    47c0:	4798      	blx	r3
		if (dhcp == NULL) {
    47c2:	4605      	mov	r5, r0
    47c4:	b120      	cbz	r0, 47d0 <dhcp_start+0xf0>
		netif->dhcp = dhcp;
    47c6:	62a0      	str	r0, [r4, #40]	; 0x28
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
    47c8:	481f      	ldr	r0, [pc, #124]	; (4848 <dhcp_start+0x168>)
    47ca:	4b0b      	ldr	r3, [pc, #44]	; (47f8 <dhcp_start+0x118>)
    47cc:	4798      	blx	r3
    47ce:	e7ae      	b.n	472e <dhcp_start+0x4e>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
    47d0:	481e      	ldr	r0, [pc, #120]	; (484c <dhcp_start+0x16c>)
    47d2:	4b0b      	ldr	r3, [pc, #44]	; (4800 <dhcp_start+0x120>)
    47d4:	4798      	blx	r3
			return ERR_MEM;
    47d6:	f04f 33ff 	mov.w	r3, #4294967295
    47da:	e7d5      	b.n	4788 <dhcp_start+0xa8>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    47dc:	481c      	ldr	r0, [pc, #112]	; (4850 <dhcp_start+0x170>)
    47de:	4b08      	ldr	r3, [pc, #32]	; (4800 <dhcp_start+0x120>)
    47e0:	4798      	blx	r3
		return ERR_MEM;
    47e2:	f04f 33ff 	mov.w	r3, #4294967295
    47e6:	e7cf      	b.n	4788 <dhcp_start+0xa8>
		dhcp_stop(netif);
    47e8:	4620      	mov	r0, r4
    47ea:	4b1a      	ldr	r3, [pc, #104]	; (4854 <dhcp_start+0x174>)
    47ec:	4798      	blx	r3
		return ERR_MEM;
    47ee:	f04f 33ff 	mov.w	r3, #4294967295
    47f2:	e7c9      	b.n	4788 <dhcp_start+0xa8>
    47f4:	0000c26c 	.word	0x0000c26c
    47f8:	0000a111 	.word	0x0000a111
    47fc:	0000c35c 	.word	0x0000c35c
    4800:	0000a1f9 	.word	0x0000a1f9
    4804:	00008ef5 	.word	0x00008ef5
    4808:	0000a101 	.word	0x0000a101
    480c:	00008f31 	.word	0x00008f31
    4810:	0000c3dc 	.word	0x0000c3dc
    4814:	00008c6d 	.word	0x00008c6d
    4818:	00008e8d 	.word	0x00008e8d
    481c:	000038e9 	.word	0x000038e9
    4820:	00008eed 	.word	0x00008eed
    4824:	0000c3ac 	.word	0x0000c3ac
    4828:	00003349 	.word	0x00003349
    482c:	0000b3e0 	.word	0x0000b3e0
    4830:	0000bd34 	.word	0x0000bd34
    4834:	0000b428 	.word	0x0000b428
    4838:	0000c28c 	.word	0x0000c28c
    483c:	0000c2ac 	.word	0x0000c2ac
    4840:	0000c2ec 	.word	0x0000c2ec
    4844:	000058c5 	.word	0x000058c5
    4848:	0000c33c 	.word	0x0000c33c
    484c:	0000c314 	.word	0x0000c314
    4850:	0000c388 	.word	0x0000c388
    4854:	00004681 	.word	0x00004681

00004858 <lwip_init>:

/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void lwip_init(void)
{
    4858:	b508      	push	{r3, lr}
	/* Modules initialization */
	stats_init();
#if !NO_SYS
	sys_init();
#endif /* !NO_SYS */
	mem_init();
    485a:	4b06      	ldr	r3, [pc, #24]	; (4874 <lwip_init+0x1c>)
    485c:	4798      	blx	r3
	memp_init();
    485e:	4b06      	ldr	r3, [pc, #24]	; (4878 <lwip_init+0x20>)
    4860:	4798      	blx	r3
	pbuf_init();
	netif_init();
    4862:	4b06      	ldr	r3, [pc, #24]	; (487c <lwip_init+0x24>)
    4864:	4798      	blx	r3
#endif /* LWIP_ARP */
#if LWIP_RAW
	raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
	udp_init();
    4866:	4b06      	ldr	r3, [pc, #24]	; (4880 <lwip_init+0x28>)
    4868:	4798      	blx	r3
#endif /* LWIP_UDP */
#if LWIP_TCP
	tcp_init();
    486a:	4b06      	ldr	r3, [pc, #24]	; (4884 <lwip_init+0x2c>)
    486c:	4798      	blx	r3
#if LWIP_DNS
	dns_init();
#endif /* LWIP_DNS */

#if LWIP_TIMERS
	sys_timeouts_init();
    486e:	4b06      	ldr	r3, [pc, #24]	; (4888 <lwip_init+0x30>)
    4870:	4798      	blx	r3
    4872:	bd08      	pop	{r3, pc}
    4874:	0000573d 	.word	0x0000573d
    4878:	00005999 	.word	0x00005999
    487c:	00005a71 	.word	0x00005a71
    4880:	00008a79 	.word	0x00008a79
    4884:	000061c1 	.word	0x000061c1
    4888:	00008939 	.word	0x00008939

0000488c <icmp_send_response>:
 *          p->payload pointing to the IP header
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
    488c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    4890:	b085      	sub	sp, #20
    4892:	4680      	mov	r8, r0
    4894:	4689      	mov	r9, r1
    4896:	4615      	mov	r5, r2
	/* we can use the echo header here */
	struct icmp_echo_hdr *icmphdr;
	ip_addr_t             iphdr_src;

	/* ICMP header + IP header + 8 bytes of data */
	q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE, PBUF_RAM);
    4898:	2200      	movs	r2, #0
    489a:	2124      	movs	r1, #36	; 0x24
    489c:	2001      	movs	r0, #1
    489e:	4b22      	ldr	r3, [pc, #136]	; (4928 <icmp_send_response+0x9c>)
    48a0:	4798      	blx	r3
	if (q == NULL) {
    48a2:	2800      	cmp	r0, #0
    48a4:	d03d      	beq.n	4922 <icmp_send_response+0x96>
    48a6:	4606      	mov	r6, r0
		return;
	}
	LWIP_ASSERT("check that first pbuf can hold icmp message",
	            (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

	iphdr = (struct ip_hdr *)p->payload;
    48a8:	f8d8 7004 	ldr.w	r7, [r8, #4]
	ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
	LWIP_DEBUGF(ICMP_DEBUG, (" to "));
	ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
	LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

	icmphdr        = (struct icmp_echo_hdr *)q->payload;
    48ac:	6844      	ldr	r4, [r0, #4]
	icmphdr->type  = type;
    48ae:	f884 9000 	strb.w	r9, [r4]
	icmphdr->code  = code;
    48b2:	7065      	strb	r5, [r4, #1]
	icmphdr->id    = 0;
    48b4:	2500      	movs	r5, #0
    48b6:	7125      	strb	r5, [r4, #4]
    48b8:	7165      	strb	r5, [r4, #5]
	icmphdr->seqno = 0;
    48ba:	71a5      	strb	r5, [r4, #6]
    48bc:	71e5      	strb	r5, [r4, #7]

	/* copy fields from original packet */
	SMEMCPY(
    48be:	f8d0 c004 	ldr.w	ip, [r0, #4]
    48c2:	f8d8 3004 	ldr.w	r3, [r8, #4]
    48c6:	f8d3 e000 	ldr.w	lr, [r3]
    48ca:	6858      	ldr	r0, [r3, #4]
    48cc:	6899      	ldr	r1, [r3, #8]
    48ce:	f8d3 800c 	ldr.w	r8, [r3, #12]
    48d2:	f8cc e008 	str.w	lr, [ip, #8]
    48d6:	f8cc 000c 	str.w	r0, [ip, #12]
    48da:	f8cc 1010 	str.w	r1, [ip, #16]
    48de:	f8cc 8014 	str.w	r8, [ip, #20]
    48e2:	f8d3 e010 	ldr.w	lr, [r3, #16]
    48e6:	6958      	ldr	r0, [r3, #20]
    48e8:	6999      	ldr	r1, [r3, #24]
    48ea:	f8cc e018 	str.w	lr, [ip, #24]
    48ee:	f8cc 001c 	str.w	r0, [ip, #28]
    48f2:	f8cc 1020 	str.w	r1, [ip, #32]
	    (u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload, IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

	/* calculate checksum */
	icmphdr->chksum = 0;
    48f6:	70a5      	strb	r5, [r4, #2]
    48f8:	70e5      	strb	r5, [r4, #3]
	icmphdr->chksum = inet_chksum(icmphdr, q->len);
    48fa:	8971      	ldrh	r1, [r6, #10]
    48fc:	4620      	mov	r0, r4
    48fe:	4b0b      	ldr	r3, [pc, #44]	; (492c <icmp_send_response+0xa0>)
    4900:	4798      	blx	r3
    4902:	8060      	strh	r0, [r4, #2]
	ICMP_STATS_INC(icmp.xmit);
	/* increase number of messages attempted to send */
	snmp_inc_icmpoutmsgs();
	/* increase number of destination unreachable messages attempted to send */
	snmp_inc_icmpouttimeexcds();
	ip_addr_copy(iphdr_src, iphdr->src);
    4904:	68fb      	ldr	r3, [r7, #12]
    4906:	aa04      	add	r2, sp, #16
    4908:	f842 3d04 	str.w	r3, [r2, #-4]!
	ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
    490c:	2301      	movs	r3, #1
    490e:	9301      	str	r3, [sp, #4]
    4910:	9500      	str	r5, [sp, #0]
    4912:	23ff      	movs	r3, #255	; 0xff
    4914:	4629      	mov	r1, r5
    4916:	4630      	mov	r0, r6
    4918:	4c05      	ldr	r4, [pc, #20]	; (4930 <icmp_send_response+0xa4>)
    491a:	47a0      	blx	r4
	pbuf_free(q);
    491c:	4630      	mov	r0, r6
    491e:	4b05      	ldr	r3, [pc, #20]	; (4934 <icmp_send_response+0xa8>)
    4920:	4798      	blx	r3
}
    4922:	b005      	add	sp, #20
    4924:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4928:	00005d89 	.word	0x00005d89
    492c:	00004bc1 	.word	0x00004bc1
    4930:	00004f51 	.word	0x00004f51
    4934:	00005d21 	.word	0x00005d21

00004938 <icmp_input>:
{
    4938:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    493c:	b085      	sub	sp, #20
    493e:	4606      	mov	r6, r0
    4940:	4688      	mov	r8, r1
	iphdr = (struct ip_hdr *)p->payload;
    4942:	6847      	ldr	r7, [r0, #4]
	hlen  = IPH_HL(iphdr) * 4;
    4944:	783c      	ldrb	r4, [r7, #0]
    4946:	f004 040f 	and.w	r4, r4, #15
    494a:	00a4      	lsls	r4, r4, #2
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
    494c:	4265      	negs	r5, r4
    494e:	b22d      	sxth	r5, r5
    4950:	4629      	mov	r1, r5
    4952:	4b45      	ldr	r3, [pc, #276]	; (4a68 <icmp_input+0x130>)
    4954:	4798      	blx	r3
    4956:	b9a0      	cbnz	r0, 4982 <icmp_input+0x4a>
    4958:	8933      	ldrh	r3, [r6, #8]
    495a:	2b03      	cmp	r3, #3
    495c:	d911      	bls.n	4982 <icmp_input+0x4a>
	type = *((u8_t *)p->payload);
    495e:	6873      	ldr	r3, [r6, #4]
	switch (type) {
    4960:	781b      	ldrb	r3, [r3, #0]
    4962:	2b08      	cmp	r3, #8
    4964:	d16f      	bne.n	4a46 <icmp_input+0x10e>
		if (ip_addr_ismulticast(&current_iphdr_dest)) {
    4966:	4b41      	ldr	r3, [pc, #260]	; (4a6c <icmp_input+0x134>)
    4968:	6818      	ldr	r0, [r3, #0]
    496a:	f000 09f0 	and.w	r9, r0, #240	; 0xf0
		if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
    496e:	4641      	mov	r1, r8
    4970:	4b3f      	ldr	r3, [pc, #252]	; (4a70 <icmp_input+0x138>)
    4972:	4798      	blx	r3
    4974:	b958      	cbnz	r0, 498e <icmp_input+0x56>
		if (!accepted) {
    4976:	f1b9 0fe0 	cmp.w	r9, #224	; 0xe0
    497a:	d008      	beq.n	498e <icmp_input+0x56>
		if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
    497c:	8933      	ldrh	r3, [r6, #8]
    497e:	2b07      	cmp	r3, #7
    4980:	d809      	bhi.n	4996 <icmp_input+0x5e>
	pbuf_free(p);
    4982:	4630      	mov	r0, r6
    4984:	4b3b      	ldr	r3, [pc, #236]	; (4a74 <icmp_input+0x13c>)
    4986:	4798      	blx	r3
}
    4988:	b005      	add	sp, #20
    498a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			pbuf_free(p);
    498e:	4630      	mov	r0, r6
    4990:	4b38      	ldr	r3, [pc, #224]	; (4a74 <icmp_input+0x13c>)
    4992:	4798      	blx	r3
			return;
    4994:	e7f8      	b.n	4988 <icmp_input+0x50>
		if (inet_chksum_pbuf(p) != 0) {
    4996:	4630      	mov	r0, r6
    4998:	4b37      	ldr	r3, [pc, #220]	; (4a78 <icmp_input+0x140>)
    499a:	4798      	blx	r3
    499c:	b970      	cbnz	r0, 49bc <icmp_input+0x84>
	hlen  = IPH_HL(iphdr) * 4;
    499e:	b224      	sxth	r4, r4
		if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    49a0:	2122      	movs	r1, #34	; 0x22
    49a2:	4630      	mov	r0, r6
    49a4:	4b30      	ldr	r3, [pc, #192]	; (4a68 <icmp_input+0x130>)
    49a6:	4798      	blx	r3
    49a8:	b330      	cbz	r0, 49f8 <icmp_input+0xc0>
			if (pbuf_header(p, hlen)) {
    49aa:	4621      	mov	r1, r4
    49ac:	4630      	mov	r0, r6
    49ae:	4b2e      	ldr	r3, [pc, #184]	; (4a68 <icmp_input+0x130>)
    49b0:	4798      	blx	r3
    49b2:	b138      	cbz	r0, 49c4 <icmp_input+0x8c>
	pbuf_free(p);
    49b4:	4630      	mov	r0, r6
    49b6:	4b2f      	ldr	r3, [pc, #188]	; (4a74 <icmp_input+0x13c>)
    49b8:	4798      	blx	r3
	return;
    49ba:	e7e5      	b.n	4988 <icmp_input+0x50>
			pbuf_free(p);
    49bc:	4630      	mov	r0, r6
    49be:	4b2d      	ldr	r3, [pc, #180]	; (4a74 <icmp_input+0x13c>)
    49c0:	4798      	blx	r3
			return;
    49c2:	e7e1      	b.n	4988 <icmp_input+0x50>
			r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
    49c4:	2200      	movs	r2, #0
    49c6:	8931      	ldrh	r1, [r6, #8]
    49c8:	2002      	movs	r0, #2
    49ca:	4b2c      	ldr	r3, [pc, #176]	; (4a7c <icmp_input+0x144>)
    49cc:	4798      	blx	r3
			if (r == NULL) {
    49ce:	4681      	mov	r9, r0
    49d0:	2800      	cmp	r0, #0
    49d2:	d0ef      	beq.n	49b4 <icmp_input+0x7c>
			if (pbuf_copy(r, p) != ERR_OK) {
    49d4:	4631      	mov	r1, r6
    49d6:	4b2a      	ldr	r3, [pc, #168]	; (4a80 <icmp_input+0x148>)
    49d8:	4798      	blx	r3
    49da:	2800      	cmp	r0, #0
    49dc:	d1ea      	bne.n	49b4 <icmp_input+0x7c>
			iphdr = (struct ip_hdr *)r->payload;
    49de:	f8d9 7004 	ldr.w	r7, [r9, #4]
			if (pbuf_header(r, -hlen)) {
    49e2:	4629      	mov	r1, r5
    49e4:	4648      	mov	r0, r9
    49e6:	4b20      	ldr	r3, [pc, #128]	; (4a68 <icmp_input+0x130>)
    49e8:	4798      	blx	r3
    49ea:	2800      	cmp	r0, #0
    49ec:	d1e2      	bne.n	49b4 <icmp_input+0x7c>
			pbuf_free(p);
    49ee:	4630      	mov	r0, r6
    49f0:	4b20      	ldr	r3, [pc, #128]	; (4a74 <icmp_input+0x13c>)
    49f2:	4798      	blx	r3
			p = r;
    49f4:	464e      	mov	r6, r9
    49f6:	e006      	b.n	4a06 <icmp_input+0xce>
			if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    49f8:	f06f 0121 	mvn.w	r1, #33	; 0x21
    49fc:	4630      	mov	r0, r6
    49fe:	4b1a      	ldr	r3, [pc, #104]	; (4a68 <icmp_input+0x130>)
    4a00:	4798      	blx	r3
    4a02:	2800      	cmp	r0, #0
    4a04:	d1d6      	bne.n	49b4 <icmp_input+0x7c>
		iecho = (struct icmp_echo_hdr *)p->payload;
    4a06:	6872      	ldr	r2, [r6, #4]
		ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    4a08:	4b18      	ldr	r3, [pc, #96]	; (4a6c <icmp_input+0x134>)
    4a0a:	681b      	ldr	r3, [r3, #0]
    4a0c:	60fb      	str	r3, [r7, #12]
		ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    4a0e:	4b1d      	ldr	r3, [pc, #116]	; (4a84 <icmp_input+0x14c>)
    4a10:	681b      	ldr	r3, [r3, #0]
    4a12:	613b      	str	r3, [r7, #16]
		ICMPH_TYPE_SET(iecho, ICMP_ER);
    4a14:	2300      	movs	r3, #0
    4a16:	7013      	strb	r3, [r2, #0]
		if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
    4a18:	8853      	ldrh	r3, [r2, #2]
    4a1a:	f64f 71f6 	movw	r1, #65526	; 0xfff6
    4a1e:	428b      	cmp	r3, r1
			iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
    4a20:	bf8c      	ite	hi
    4a22:	3309      	addhi	r3, #9
			iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
    4a24:	3308      	addls	r3, #8
    4a26:	8053      	strh	r3, [r2, #2]
		IPH_TTL_SET(iphdr, ICMP_TTL);
    4a28:	23ff      	movs	r3, #255	; 0xff
    4a2a:	723b      	strb	r3, [r7, #8]
		IPH_CHKSUM_SET(iphdr, 0);
    4a2c:	2300      	movs	r3, #0
    4a2e:	72bb      	strb	r3, [r7, #10]
    4a30:	72fb      	strb	r3, [r7, #11]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    4a32:	2114      	movs	r1, #20
    4a34:	4638      	mov	r0, r7
    4a36:	4b14      	ldr	r3, [pc, #80]	; (4a88 <icmp_input+0x150>)
    4a38:	4798      	blx	r3
    4a3a:	8178      	strh	r0, [r7, #10]
		if (pbuf_header(p, hlen)) {
    4a3c:	4621      	mov	r1, r4
    4a3e:	4630      	mov	r0, r6
    4a40:	4b09      	ldr	r3, [pc, #36]	; (4a68 <icmp_input+0x130>)
    4a42:	4798      	blx	r3
    4a44:	b118      	cbz	r0, 4a4e <icmp_input+0x116>
	pbuf_free(p);
    4a46:	4630      	mov	r0, r6
    4a48:	4b0a      	ldr	r3, [pc, #40]	; (4a74 <icmp_input+0x13c>)
    4a4a:	4798      	blx	r3
	return;
    4a4c:	e79c      	b.n	4988 <icmp_input+0x50>
			ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL, ICMP_TTL, 0, IP_PROTO_ICMP, inp);
    4a4e:	f8cd 8008 	str.w	r8, [sp, #8]
    4a52:	2301      	movs	r3, #1
    4a54:	9301      	str	r3, [sp, #4]
    4a56:	2200      	movs	r2, #0
    4a58:	9200      	str	r2, [sp, #0]
    4a5a:	23ff      	movs	r3, #255	; 0xff
    4a5c:	4903      	ldr	r1, [pc, #12]	; (4a6c <icmp_input+0x134>)
    4a5e:	4630      	mov	r0, r6
    4a60:	4c0a      	ldr	r4, [pc, #40]	; (4a8c <icmp_input+0x154>)
    4a62:	47a0      	blx	r4
    4a64:	e7ef      	b.n	4a46 <icmp_input+0x10e>
    4a66:	bf00      	nop
    4a68:	00005c8d 	.word	0x00005c8d
    4a6c:	20008334 	.word	0x20008334
    4a70:	00004f91 	.word	0x00004f91
    4a74:	00005d21 	.word	0x00005d21
    4a78:	00004bd1 	.word	0x00004bd1
    4a7c:	00005d89 	.word	0x00005d89
    4a80:	00005fad 	.word	0x00005fad
    4a84:	2000832c 	.word	0x2000832c
    4a88:	00004bc1 	.word	0x00004bc1
    4a8c:	00004e55 	.word	0x00004e55

00004a90 <icmp_dest_unreach>:
{
    4a90:	b508      	push	{r3, lr}
	icmp_send_response(p, ICMP_DUR, t);
    4a92:	460a      	mov	r2, r1
    4a94:	2103      	movs	r1, #3
    4a96:	4b01      	ldr	r3, [pc, #4]	; (4a9c <icmp_dest_unreach+0xc>)
    4a98:	4798      	blx	r3
    4a9a:	bd08      	pop	{r3, pc}
    4a9c:	0000488d 	.word	0x0000488d

00004aa0 <icmp_time_exceeded>:
{
    4aa0:	b508      	push	{r3, lr}
	icmp_send_response(p, ICMP_TE, t);
    4aa2:	460a      	mov	r2, r1
    4aa4:	210b      	movs	r1, #11
    4aa6:	4b01      	ldr	r3, [pc, #4]	; (4aac <icmp_time_exceeded+0xc>)
    4aa8:	4798      	blx	r3
    4aaa:	bd08      	pop	{r3, pc}
    4aac:	0000488d 	.word	0x0000488d

00004ab0 <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */

static u16_t lwip_standard_chksum(void *dataptr, int len)
{
    4ab0:	b410      	push	{r4}
    4ab2:	b083      	sub	sp, #12
	u8_t * pb = (u8_t *)dataptr;
	u16_t *ps, t = 0;
    4ab4:	2300      	movs	r3, #0
    4ab6:	f8ad 3006 	strh.w	r3, [sp, #6]
	u32_t  sum = 0;
	int    odd = ((mem_ptr_t)pb & 1);

	/* Get aligned to u16_t */
	if (odd && len > 0) {
    4aba:	f010 0401 	ands.w	r4, r0, #1
    4abe:	d007      	beq.n	4ad0 <lwip_standard_chksum+0x20>
    4ac0:	4299      	cmp	r1, r3
    4ac2:	dd2a      	ble.n	4b1a <lwip_standard_chksum+0x6a>
		((u8_t *)&t)[1] = *pb++;
    4ac4:	1c43      	adds	r3, r0, #1
    4ac6:	7802      	ldrb	r2, [r0, #0]
    4ac8:	f88d 2007 	strb.w	r2, [sp, #7]
		len--;
    4acc:	3901      	subs	r1, #1
    4ace:	e000      	b.n	4ad2 <lwip_standard_chksum+0x22>
	u8_t * pb = (u8_t *)dataptr;
    4ad0:	4603      	mov	r3, r0
	}

	/* Add the bulk of the data */
	ps = (u16_t *)(void *)pb;
	while (len > 1) {
    4ad2:	2901      	cmp	r1, #1
    4ad4:	dd1f      	ble.n	4b16 <lwip_standard_chksum+0x66>
	u8_t * pb = (u8_t *)dataptr;
    4ad6:	2200      	movs	r2, #0
		sum += *ps++;
    4ad8:	f833 0b02 	ldrh.w	r0, [r3], #2
    4adc:	4402      	add	r2, r0
		len -= 2;
    4ade:	3902      	subs	r1, #2
	while (len > 1) {
    4ae0:	2901      	cmp	r1, #1
    4ae2:	dcf9      	bgt.n	4ad8 <lwip_standard_chksum+0x28>
	}

	/* Consume left-over byte, if any */
	if (len > 0) {
    4ae4:	2900      	cmp	r1, #0
		((u8_t *)&t)[0] = *(u8_t *)ps;
    4ae6:	bfc4      	itt	gt
    4ae8:	781b      	ldrbgt	r3, [r3, #0]
    4aea:	f88d 3006 	strbgt.w	r3, [sp, #6]
	}

	/* Add end bytes */
	sum += t;
    4aee:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    4af2:	4402      	add	r2, r0

	/* Fold 32-bit sum to 16 bits
	   calling this twice is propably faster than if statements... */
	sum = FOLD_U32T(sum);
    4af4:	b290      	uxth	r0, r2
    4af6:	eb00 4212 	add.w	r2, r0, r2, lsr #16
	sum = FOLD_U32T(sum);
    4afa:	b290      	uxth	r0, r2
    4afc:	eb00 4012 	add.w	r0, r0, r2, lsr #16

	/* Swap if alignment was odd */
	if (odd) {
    4b00:	b124      	cbz	r4, 4b0c <lwip_standard_chksum+0x5c>
		sum = SWAP_BYTES_IN_WORD(sum);
    4b02:	0203      	lsls	r3, r0, #8
    4b04:	b29b      	uxth	r3, r3
    4b06:	f3c0 2007 	ubfx	r0, r0, #8, #8
    4b0a:	4318      	orrs	r0, r3
	}

	return (u16_t)sum;
    4b0c:	b280      	uxth	r0, r0
}
    4b0e:	b003      	add	sp, #12
    4b10:	f85d 4b04 	ldr.w	r4, [sp], #4
    4b14:	4770      	bx	lr
	u32_t  sum = 0;
    4b16:	2200      	movs	r2, #0
    4b18:	e7e4      	b.n	4ae4 <lwip_standard_chksum+0x34>
	while (len > 1) {
    4b1a:	2901      	cmp	r1, #1
	u8_t * pb = (u8_t *)dataptr;
    4b1c:	bfc8      	it	gt
    4b1e:	4603      	movgt	r3, r0
	while (len > 1) {
    4b20:	dcd9      	bgt.n	4ad6 <lwip_standard_chksum+0x26>
	sum = FOLD_U32T(sum);
    4b22:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    4b26:	e7ec      	b.n	4b02 <lwip_standard_chksum+0x52>

00004b28 <inet_chksum_pseudo>:
 * @param proto ip protocol (used for checksum of pseudo header)
 * @param proto_len length of the ip data part (used for checksum of pseudo header)
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t inet_chksum_pseudo(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t proto, u16_t proto_len)
{
    4b28:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    4b2c:	468a      	mov	sl, r1
    4b2e:	4691      	mov	r9, r2
    4b30:	4698      	mov	r8, r3
	u8_t         swapped;

	acc     = 0;
	swapped = 0;
	/* iterate through all pbuf in chain */
	for (q = p; q != NULL; q = q->next) {
    4b32:	2800      	cmp	r0, #0
    4b34:	d03e      	beq.n	4bb4 <inet_chksum_pseudo+0x8c>
    4b36:	4605      	mov	r5, r0
    4b38:	2600      	movs	r6, #0
    4b3a:	4634      	mov	r4, r6
		LWIP_DEBUGF(INET_DEBUG,
		            ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n", (void *)q, (void *)q->next));
		acc += LWIP_CHKSUM(q->payload, q->len);
    4b3c:	4f1e      	ldr	r7, [pc, #120]	; (4bb8 <inet_chksum_pseudo+0x90>)
    4b3e:	e001      	b.n	4b44 <inet_chksum_pseudo+0x1c>
	for (q = p; q != NULL; q = q->next) {
    4b40:	682d      	ldr	r5, [r5, #0]
    4b42:	b19d      	cbz	r5, 4b6c <inet_chksum_pseudo+0x44>
		acc += LWIP_CHKSUM(q->payload, q->len);
    4b44:	8969      	ldrh	r1, [r5, #10]
    4b46:	6868      	ldr	r0, [r5, #4]
    4b48:	47b8      	blx	r7
    4b4a:	4404      	add	r4, r0
		/*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
		/* just executing this next line is probably faster that the if statement needed
		   to check whether we really need to execute it, and does no harm */
		acc = FOLD_U32T(acc);
    4b4c:	b2a0      	uxth	r0, r4
    4b4e:	eb00 4414 	add.w	r4, r0, r4, lsr #16
		if (q->len % 2 != 0) {
    4b52:	896b      	ldrh	r3, [r5, #10]
    4b54:	f013 0f01 	tst.w	r3, #1
    4b58:	d0f2      	beq.n	4b40 <inet_chksum_pseudo+0x18>
			swapped = 1 - swapped;
    4b5a:	f1c6 0601 	rsb	r6, r6, #1
    4b5e:	b2f6      	uxtb	r6, r6
			acc     = SWAP_BYTES_IN_WORD(acc);
    4b60:	0223      	lsls	r3, r4, #8
    4b62:	b29b      	uxth	r3, r3
    4b64:	f3c4 2407 	ubfx	r4, r4, #8, #8
    4b68:	431c      	orrs	r4, r3
    4b6a:	e7e9      	b.n	4b40 <inet_chksum_pseudo+0x18>
		}
		/*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
	}

	if (swapped) {
    4b6c:	b126      	cbz	r6, 4b78 <inet_chksum_pseudo+0x50>
		acc = SWAP_BYTES_IN_WORD(acc);
    4b6e:	0223      	lsls	r3, r4, #8
    4b70:	b29b      	uxth	r3, r3
    4b72:	f3c4 2407 	ubfx	r4, r4, #8, #8
    4b76:	431c      	orrs	r4, r3
	}
	addr = ip4_addr_get_u32(src);
    4b78:	f8da 2000 	ldr.w	r2, [sl]
	acc += (addr & 0xffffUL);
	acc += ((addr >> 16) & 0xffffUL);
	addr = ip4_addr_get_u32(dest);
    4b7c:	f8d9 3000 	ldr.w	r3, [r9]
	acc += (addr & 0xffffUL);
	acc += ((addr >> 16) & 0xffffUL);
    4b80:	0c18      	lsrs	r0, r3, #16
    4b82:	fa10 f083 	uxtah	r0, r0, r3
    4b86:	fa10 f082 	uxtah	r0, r0, r2
    4b8a:	eb00 4012 	add.w	r0, r0, r2, lsr #16
    4b8e:	4404      	add	r4, r0
	acc += (u32_t)htons((u16_t)proto);
    4b90:	4640      	mov	r0, r8
    4b92:	4d0a      	ldr	r5, [pc, #40]	; (4bbc <inet_chksum_pseudo+0x94>)
    4b94:	47a8      	blx	r5
    4b96:	4404      	add	r4, r0
	acc += (u32_t)htons(proto_len);
    4b98:	f8bd 0020 	ldrh.w	r0, [sp, #32]
    4b9c:	47a8      	blx	r5
    4b9e:	4420      	add	r0, r4

	/* Fold 32-bit sum to 16 bits
	   calling this twice is propably faster than if statements... */
	acc = FOLD_U32T(acc);
    4ba0:	b284      	uxth	r4, r0
    4ba2:	eb04 4410 	add.w	r4, r4, r0, lsr #16
	acc = FOLD_U32T(acc);
    4ba6:	b2a0      	uxth	r0, r4
    4ba8:	eb00 4014 	add.w	r0, r0, r4, lsr #16
	LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%" X32_F "\n", acc));
	return (u16_t) ~(acc & 0xffffUL);
    4bac:	43c0      	mvns	r0, r0
}
    4bae:	b280      	uxth	r0, r0
    4bb0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	acc     = 0;
    4bb4:	2400      	movs	r4, #0
    4bb6:	e7df      	b.n	4b78 <inet_chksum_pseudo+0x50>
    4bb8:	00004ab1 	.word	0x00004ab1
    4bbc:	00002f3d 	.word	0x00002f3d

00004bc0 <inet_chksum>:
 * @param len length of the buffer to calculate the checksum
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t inet_chksum(void *dataptr, u16_t len)
{
    4bc0:	b508      	push	{r3, lr}
	return ~LWIP_CHKSUM(dataptr, len);
    4bc2:	4b02      	ldr	r3, [pc, #8]	; (4bcc <inet_chksum+0xc>)
    4bc4:	4798      	blx	r3
    4bc6:	43c0      	mvns	r0, r0
}
    4bc8:	b280      	uxth	r0, r0
    4bca:	bd08      	pop	{r3, pc}
    4bcc:	00004ab1 	.word	0x00004ab1

00004bd0 <inet_chksum_pbuf>:
 *
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t inet_chksum_pbuf(struct pbuf *p)
{
    4bd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct pbuf *q;
	u8_t         swapped;

	acc     = 0;
	swapped = 0;
	for (q = p; q != NULL; q = q->next) {
    4bd2:	b318      	cbz	r0, 4c1c <inet_chksum_pbuf+0x4c>
    4bd4:	4605      	mov	r5, r0
    4bd6:	2600      	movs	r6, #0
    4bd8:	4634      	mov	r4, r6
		acc += LWIP_CHKSUM(q->payload, q->len);
    4bda:	4f11      	ldr	r7, [pc, #68]	; (4c20 <inet_chksum_pbuf+0x50>)
    4bdc:	e001      	b.n	4be2 <inet_chksum_pbuf+0x12>
	for (q = p; q != NULL; q = q->next) {
    4bde:	682d      	ldr	r5, [r5, #0]
    4be0:	b19d      	cbz	r5, 4c0a <inet_chksum_pbuf+0x3a>
		acc += LWIP_CHKSUM(q->payload, q->len);
    4be2:	8969      	ldrh	r1, [r5, #10]
    4be4:	6868      	ldr	r0, [r5, #4]
    4be6:	47b8      	blx	r7
    4be8:	4420      	add	r0, r4
		acc = FOLD_U32T(acc);
    4bea:	b284      	uxth	r4, r0
    4bec:	eb04 4410 	add.w	r4, r4, r0, lsr #16
		if (q->len % 2 != 0) {
    4bf0:	896b      	ldrh	r3, [r5, #10]
    4bf2:	f013 0f01 	tst.w	r3, #1
    4bf6:	d0f2      	beq.n	4bde <inet_chksum_pbuf+0xe>
			swapped = 1 - swapped;
    4bf8:	f1c6 0601 	rsb	r6, r6, #1
    4bfc:	b2f6      	uxtb	r6, r6
			acc     = SWAP_BYTES_IN_WORD(acc);
    4bfe:	0223      	lsls	r3, r4, #8
    4c00:	b29b      	uxth	r3, r3
    4c02:	f3c4 2407 	ubfx	r4, r4, #8, #8
    4c06:	431c      	orrs	r4, r3
    4c08:	e7e9      	b.n	4bde <inet_chksum_pbuf+0xe>
		}
	}

	if (swapped) {
    4c0a:	b126      	cbz	r6, 4c16 <inet_chksum_pbuf+0x46>
		acc = SWAP_BYTES_IN_WORD(acc);
    4c0c:	0223      	lsls	r3, r4, #8
    4c0e:	b29b      	uxth	r3, r3
    4c10:	f3c4 2407 	ubfx	r4, r4, #8, #8
    4c14:	431c      	orrs	r4, r3
	}
	return (u16_t) ~(acc & 0xffffUL);
    4c16:	43e0      	mvns	r0, r4
}
    4c18:	b280      	uxth	r0, r0
    4c1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	acc     = 0;
    4c1c:	2400      	movs	r4, #0
    4c1e:	e7fa      	b.n	4c16 <inet_chksum_pbuf+0x46>
    4c20:	00004ab1 	.word	0x00004ab1

00004c24 <ip_route>:
		return netif;
	}
#endif

	/* iterate through netifs */
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    4c24:	4b0e      	ldr	r3, [pc, #56]	; (4c60 <ip_route+0x3c>)
    4c26:	681b      	ldr	r3, [r3, #0]
    4c28:	b973      	cbnz	r3, 4c48 <ip_route+0x24>
				/* return netif on which to forward IP packet */
				return netif;
			}
		}
	}
	if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    4c2a:	4b0e      	ldr	r3, [pc, #56]	; (4c64 <ip_route+0x40>)
    4c2c:	681b      	ldr	r3, [r3, #0]
    4c2e:	b133      	cbz	r3, 4c3e <ip_route+0x1a>
    4c30:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
    4c34:	f002 0201 	and.w	r2, r2, #1
		             ip4_addr2_16(dest),
		             ip4_addr3_16(dest),
		             ip4_addr4_16(dest)));
		IP_STATS_INC(ip.rterr);
		snmp_inc_ipoutnoroutes();
		return NULL;
    4c38:	2a00      	cmp	r2, #0
    4c3a:	bf08      	it	eq
    4c3c:	2300      	moveq	r3, #0
	}
	/* no matching netif found, use default netif */
	return netif_default;
}
    4c3e:	4618      	mov	r0, r3
    4c40:	4770      	bx	lr
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    4c42:	681b      	ldr	r3, [r3, #0]
    4c44:	2b00      	cmp	r3, #0
    4c46:	d0f0      	beq.n	4c2a <ip_route+0x6>
		if (netif_is_up(netif)) {
    4c48:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
    4c4c:	f012 0f01 	tst.w	r2, #1
    4c50:	d0f7      	beq.n	4c42 <ip_route+0x1e>
			if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
    4c52:	6802      	ldr	r2, [r0, #0]
    4c54:	6859      	ldr	r1, [r3, #4]
    4c56:	404a      	eors	r2, r1
    4c58:	6899      	ldr	r1, [r3, #8]
    4c5a:	420a      	tst	r2, r1
    4c5c:	d1f1      	bne.n	4c42 <ip_route+0x1e>
    4c5e:	e7ee      	b.n	4c3e <ip_route+0x1a>
    4c60:	200092f0 	.word	0x200092f0
    4c64:	200092f4 	.word	0x200092f4

00004c68 <ip_input>:
 * @param inp the netif on which this packet was received
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t ip_input(struct pbuf *p, struct netif *inp)
{
    4c68:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4c6c:	4606      	mov	r6, r0

	IP_STATS_INC(ip.recv);
	snmp_inc_ipinreceives();

	/* identify the IP header */
	iphdr = (struct ip_hdr *)p->payload;
    4c6e:	f8d0 9004 	ldr.w	r9, [r0, #4]
	if (IPH_V(iphdr) != 4) {
    4c72:	f899 5000 	ldrb.w	r5, [r9]
    4c76:	092b      	lsrs	r3, r5, #4
    4c78:	2b04      	cmp	r3, #4
    4c7a:	d004      	beq.n	4c86 <ip_input+0x1e>
		LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING,
		            ("IP packet dropped due to bad version number %" U16_F "\n", IPH_V(iphdr)));
		ip_debug_print(p);
		pbuf_free(p);
    4c7c:	4b65      	ldr	r3, [pc, #404]	; (4e14 <ip_input+0x1ac>)
    4c7e:	4798      	blx	r3
	current_header = NULL;
	ip_addr_set_any(&current_iphdr_src);
	ip_addr_set_any(&current_iphdr_dest);

	return ERR_OK;
}
    4c80:	2000      	movs	r0, #0
    4c82:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4c86:	4688      	mov	r8, r1
	iphdr_hlen = IPH_HL(iphdr);
    4c88:	f005 050f 	and.w	r5, r5, #15
	iphdr_hlen *= 4;
    4c8c:	00ad      	lsls	r5, r5, #2
	iphdr_len = ntohs(IPH_LEN(iphdr));
    4c8e:	f8b9 0002 	ldrh.w	r0, [r9, #2]
    4c92:	4b61      	ldr	r3, [pc, #388]	; (4e18 <ip_input+0x1b0>)
    4c94:	4798      	blx	r3
    4c96:	4604      	mov	r4, r0
	if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    4c98:	8973      	ldrh	r3, [r6, #10]
    4c9a:	42ab      	cmp	r3, r5
    4c9c:	d302      	bcc.n	4ca4 <ip_input+0x3c>
    4c9e:	8933      	ldrh	r3, [r6, #8]
    4ca0:	4283      	cmp	r3, r0
    4ca2:	d203      	bcs.n	4cac <ip_input+0x44>
		pbuf_free(p);
    4ca4:	4630      	mov	r0, r6
    4ca6:	4b5b      	ldr	r3, [pc, #364]	; (4e14 <ip_input+0x1ac>)
    4ca8:	4798      	blx	r3
		return ERR_OK;
    4caa:	e7e9      	b.n	4c80 <ip_input+0x18>
	if (inet_chksum(iphdr, iphdr_hlen) != 0) {
    4cac:	4629      	mov	r1, r5
    4cae:	4648      	mov	r0, r9
    4cb0:	4b5a      	ldr	r3, [pc, #360]	; (4e1c <ip_input+0x1b4>)
    4cb2:	4798      	blx	r3
    4cb4:	b990      	cbnz	r0, 4cdc <ip_input+0x74>
	pbuf_realloc(p, iphdr_len);
    4cb6:	4621      	mov	r1, r4
    4cb8:	4630      	mov	r0, r6
    4cba:	4b59      	ldr	r3, [pc, #356]	; (4e20 <ip_input+0x1b8>)
    4cbc:	4798      	blx	r3
	ip_addr_copy(current_iphdr_dest, iphdr->dest);
    4cbe:	f8d9 2010 	ldr.w	r2, [r9, #16]
    4cc2:	4b58      	ldr	r3, [pc, #352]	; (4e24 <ip_input+0x1bc>)
    4cc4:	601a      	str	r2, [r3, #0]
	ip_addr_copy(current_iphdr_src, iphdr->src);
    4cc6:	f8d9 200c 	ldr.w	r2, [r9, #12]
    4cca:	4b57      	ldr	r3, [pc, #348]	; (4e28 <ip_input+0x1c0>)
    4ccc:	601a      	str	r2, [r3, #0]
		netif     = inp;
    4cce:	4644      	mov	r4, r8
		int first = 1;
    4cd0:	2701      	movs	r7, #1
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    4cd2:	f8df b150 	ldr.w	fp, [pc, #336]	; 4e24 <ip_input+0x1bc>
				netif = netif_list;
    4cd6:	f8df a178 	ldr.w	sl, [pc, #376]	; 4e50 <ip_input+0x1e8>
    4cda:	e00b      	b.n	4cf4 <ip_input+0x8c>
		pbuf_free(p);
    4cdc:	4630      	mov	r0, r6
    4cde:	4b4d      	ldr	r3, [pc, #308]	; (4e14 <ip_input+0x1ac>)
    4ce0:	4798      	blx	r3
		return ERR_OK;
    4ce2:	e7cd      	b.n	4c80 <ip_input+0x18>
			if (first) {
    4ce4:	b1ff      	cbz	r7, 4d26 <ip_input+0xbe>
				netif = netif_list;
    4ce6:	f8da 4000 	ldr.w	r4, [sl]
			if (netif == inp) {
    4cea:	4544      	cmp	r4, r8
				netif = netif->next;
    4cec:	bf08      	it	eq
    4cee:	6824      	ldreq	r4, [r4, #0]
    4cf0:	2700      	movs	r7, #0
		} while (netif != NULL);
    4cf2:	b1d4      	cbz	r4, 4d2a <ip_input+0xc2>
			if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    4cf4:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    4cf8:	f013 0f01 	tst.w	r3, #1
    4cfc:	d0f2      	beq.n	4ce4 <ip_input+0x7c>
    4cfe:	f114 0f04 	cmn.w	r4, #4
    4d02:	d0ef      	beq.n	4ce4 <ip_input+0x7c>
    4d04:	6863      	ldr	r3, [r4, #4]
    4d06:	2b00      	cmp	r3, #0
    4d08:	d0ec      	beq.n	4ce4 <ip_input+0x7c>
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    4d0a:	f8db 0000 	ldr.w	r0, [fp]
    4d0e:	4283      	cmp	r3, r0
    4d10:	d004      	beq.n	4d1c <ip_input+0xb4>
				    ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
    4d12:	4621      	mov	r1, r4
    4d14:	4b45      	ldr	r3, [pc, #276]	; (4e2c <ip_input+0x1c4>)
    4d16:	4798      	blx	r3
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    4d18:	2800      	cmp	r0, #0
    4d1a:	d0e3      	beq.n	4ce4 <ip_input+0x7c>
	if (netif == NULL) {
    4d1c:	b12c      	cbz	r4, 4d2a <ip_input+0xc2>
	if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
    4d1e:	4b42      	ldr	r3, [pc, #264]	; (4e28 <ip_input+0x1c0>)
    4d20:	6818      	ldr	r0, [r3, #0]
    4d22:	b1c0      	cbz	r0, 4d56 <ip_input+0xee>
    4d24:	e00a      	b.n	4d3c <ip_input+0xd4>
				netif = netif->next;
    4d26:	6824      	ldr	r4, [r4, #0]
    4d28:	e7df      	b.n	4cea <ip_input+0x82>
		if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
    4d2a:	f899 3009 	ldrb.w	r3, [r9, #9]
    4d2e:	2b11      	cmp	r3, #17
    4d30:	d049      	beq.n	4dc6 <ip_input+0x15e>
	if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
    4d32:	4b3d      	ldr	r3, [pc, #244]	; (4e28 <ip_input+0x1c0>)
    4d34:	6818      	ldr	r0, [r3, #0]
    4d36:	2800      	cmp	r0, #0
    4d38:	d050      	beq.n	4ddc <ip_input+0x174>
    4d3a:	2400      	movs	r4, #0
		if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) || (ip_addr_ismulticast(&current_iphdr_src))) {
    4d3c:	4641      	mov	r1, r8
    4d3e:	4b3b      	ldr	r3, [pc, #236]	; (4e2c <ip_input+0x1c4>)
    4d40:	4798      	blx	r3
    4d42:	2800      	cmp	r0, #0
    4d44:	d146      	bne.n	4dd4 <ip_input+0x16c>
    4d46:	4b38      	ldr	r3, [pc, #224]	; (4e28 <ip_input+0x1c0>)
    4d48:	681b      	ldr	r3, [r3, #0]
    4d4a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    4d4e:	2be0      	cmp	r3, #224	; 0xe0
    4d50:	d040      	beq.n	4dd4 <ip_input+0x16c>
	if (netif == NULL) {
    4d52:	2c00      	cmp	r4, #0
    4d54:	d042      	beq.n	4ddc <ip_input+0x174>
	if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
    4d56:	f8b9 3006 	ldrh.w	r3, [r9, #6]
    4d5a:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    4d5e:	b29b      	uxth	r3, r3
    4d60:	b13b      	cbz	r3, 4d72 <ip_input+0x10a>
		p = ip_reass(p);
    4d62:	4630      	mov	r0, r6
    4d64:	4b32      	ldr	r3, [pc, #200]	; (4e30 <ip_input+0x1c8>)
    4d66:	4798      	blx	r3
		if (p == NULL) {
    4d68:	4606      	mov	r6, r0
    4d6a:	2800      	cmp	r0, #0
    4d6c:	d088      	beq.n	4c80 <ip_input+0x18>
		iphdr = (struct ip_hdr *)p->payload;
    4d6e:	f8d0 9004 	ldr.w	r9, [r0, #4]
	current_netif  = inp;
    4d72:	4b30      	ldr	r3, [pc, #192]	; (4e34 <ip_input+0x1cc>)
    4d74:	f8c3 8000 	str.w	r8, [r3]
	current_header = iphdr;
    4d78:	4b2f      	ldr	r3, [pc, #188]	; (4e38 <ip_input+0x1d0>)
    4d7a:	f8c3 9000 	str.w	r9, [r3]
	if (raw_input(p, inp) == 0)
    4d7e:	4641      	mov	r1, r8
    4d80:	4630      	mov	r0, r6
    4d82:	4b2e      	ldr	r3, [pc, #184]	; (4e3c <ip_input+0x1d4>)
    4d84:	4798      	blx	r3
    4d86:	2800      	cmp	r0, #0
    4d88:	d130      	bne.n	4dec <ip_input+0x184>
		switch (IPH_PROTO(iphdr)) {
    4d8a:	f899 3009 	ldrb.w	r3, [r9, #9]
    4d8e:	2b06      	cmp	r3, #6
    4d90:	d036      	beq.n	4e00 <ip_input+0x198>
    4d92:	2b11      	cmp	r3, #17
    4d94:	d026      	beq.n	4de4 <ip_input+0x17c>
    4d96:	2b01      	cmp	r3, #1
    4d98:	d037      	beq.n	4e0a <ip_input+0x1a2>
			if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) && !ip_addr_ismulticast(&current_iphdr_dest)) {
    4d9a:	4641      	mov	r1, r8
    4d9c:	4b21      	ldr	r3, [pc, #132]	; (4e24 <ip_input+0x1bc>)
    4d9e:	6818      	ldr	r0, [r3, #0]
    4da0:	4b22      	ldr	r3, [pc, #136]	; (4e2c <ip_input+0x1c4>)
    4da2:	4798      	blx	r3
    4da4:	b958      	cbnz	r0, 4dbe <ip_input+0x156>
    4da6:	4b1f      	ldr	r3, [pc, #124]	; (4e24 <ip_input+0x1bc>)
    4da8:	681b      	ldr	r3, [r3, #0]
    4daa:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    4dae:	2be0      	cmp	r3, #224	; 0xe0
    4db0:	d005      	beq.n	4dbe <ip_input+0x156>
				p->payload = iphdr;
    4db2:	f8c6 9004 	str.w	r9, [r6, #4]
				icmp_dest_unreach(p, ICMP_DUR_PROTO);
    4db6:	2102      	movs	r1, #2
    4db8:	4630      	mov	r0, r6
    4dba:	4b21      	ldr	r3, [pc, #132]	; (4e40 <ip_input+0x1d8>)
    4dbc:	4798      	blx	r3
			pbuf_free(p);
    4dbe:	4630      	mov	r0, r6
    4dc0:	4b14      	ldr	r3, [pc, #80]	; (4e14 <ip_input+0x1ac>)
    4dc2:	4798      	blx	r3
    4dc4:	e012      	b.n	4dec <ip_input+0x184>
			if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
    4dc6:	444d      	add	r5, r9
    4dc8:	886b      	ldrh	r3, [r5, #2]
    4dca:	f5b3 4f88 	cmp.w	r3, #17408	; 0x4400
    4dce:	d1b0      	bne.n	4d32 <ip_input+0xca>
				netif        = inp;
    4dd0:	4644      	mov	r4, r8
    4dd2:	e7be      	b.n	4d52 <ip_input+0xea>
			pbuf_free(p);
    4dd4:	4630      	mov	r0, r6
    4dd6:	4b0f      	ldr	r3, [pc, #60]	; (4e14 <ip_input+0x1ac>)
    4dd8:	4798      	blx	r3
			return ERR_OK;
    4dda:	e751      	b.n	4c80 <ip_input+0x18>
		pbuf_free(p);
    4ddc:	4630      	mov	r0, r6
    4dde:	4b0d      	ldr	r3, [pc, #52]	; (4e14 <ip_input+0x1ac>)
    4de0:	4798      	blx	r3
		return ERR_OK;
    4de2:	e74d      	b.n	4c80 <ip_input+0x18>
			udp_input(p, inp);
    4de4:	4641      	mov	r1, r8
    4de6:	4630      	mov	r0, r6
    4de8:	4b16      	ldr	r3, [pc, #88]	; (4e44 <ip_input+0x1dc>)
    4dea:	4798      	blx	r3
	current_netif  = NULL;
    4dec:	2300      	movs	r3, #0
    4dee:	4a11      	ldr	r2, [pc, #68]	; (4e34 <ip_input+0x1cc>)
    4df0:	6013      	str	r3, [r2, #0]
	current_header = NULL;
    4df2:	4a11      	ldr	r2, [pc, #68]	; (4e38 <ip_input+0x1d0>)
    4df4:	6013      	str	r3, [r2, #0]
	ip_addr_set_any(&current_iphdr_src);
    4df6:	4a0c      	ldr	r2, [pc, #48]	; (4e28 <ip_input+0x1c0>)
    4df8:	6013      	str	r3, [r2, #0]
	ip_addr_set_any(&current_iphdr_dest);
    4dfa:	4a0a      	ldr	r2, [pc, #40]	; (4e24 <ip_input+0x1bc>)
    4dfc:	6013      	str	r3, [r2, #0]
	return ERR_OK;
    4dfe:	e73f      	b.n	4c80 <ip_input+0x18>
			tcp_input(p, inp);
    4e00:	4641      	mov	r1, r8
    4e02:	4630      	mov	r0, r6
    4e04:	4b10      	ldr	r3, [pc, #64]	; (4e48 <ip_input+0x1e0>)
    4e06:	4798      	blx	r3
			break;
    4e08:	e7f0      	b.n	4dec <ip_input+0x184>
			icmp_input(p, inp);
    4e0a:	4641      	mov	r1, r8
    4e0c:	4630      	mov	r0, r6
    4e0e:	4b0f      	ldr	r3, [pc, #60]	; (4e4c <ip_input+0x1e4>)
    4e10:	4798      	blx	r3
			break;
    4e12:	e7eb      	b.n	4dec <ip_input+0x184>
    4e14:	00005d21 	.word	0x00005d21
    4e18:	00002f47 	.word	0x00002f47
    4e1c:	00004bc1 	.word	0x00004bc1
    4e20:	00005ec5 	.word	0x00005ec5
    4e24:	20008334 	.word	0x20008334
    4e28:	2000832c 	.word	0x2000832c
    4e2c:	00004f91 	.word	0x00004f91
    4e30:	00005209 	.word	0x00005209
    4e34:	20008330 	.word	0x20008330
    4e38:	20008338 	.word	0x20008338
    4e3c:	00006149 	.word	0x00006149
    4e40:	00004a91 	.word	0x00004a91
    4e44:	00008a7d 	.word	0x00008a7d
    4e48:	0000760d 	.word	0x0000760d
    4e4c:	00004939 	.word	0x00004939
    4e50:	200092f0 	.word	0x200092f0

00004e54 <ip_output_if>:
 *
 * @note ip_id: RFC791 "some host may be able to simply use
 *  unique identifiers independent of destination"
 */
err_t ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t ttl, u8_t tos, u8_t proto, struct netif *netif)
{
    4e54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4e58:	b087      	sub	sp, #28
    4e5a:	4605      	mov	r5, r0
    4e5c:	9102      	str	r1, [sp, #8]
    4e5e:	f89d 8040 	ldrb.w	r8, [sp, #64]	; 0x40
    4e62:	f89d b044 	ldrb.w	fp, [sp, #68]	; 0x44
    4e66:	9e12      	ldr	r6, [sp, #72]	; 0x48
	LWIP_ASSERT("p->ref == 1", p->ref == 1);

	snmp_inc_ipoutrequests();

	/* Should the IP header be generated or is it already included in p? */
	if (dest != IP_HDRINCL) {
    4e68:	9201      	str	r2, [sp, #4]
    4e6a:	2a00      	cmp	r2, #0
    4e6c:	d057      	beq.n	4f1e <ip_output_if+0xca>
    4e6e:	469a      	mov	sl, r3
    4e70:	4617      	mov	r7, r2
			}
#endif /* CHECKSUM_GEN_IP_INLINE */
		}
#endif /* IP_OPTIONS_SEND */
		/* generate IP header */
		if (pbuf_header(p, IP_HLEN)) {
    4e72:	2114      	movs	r1, #20
    4e74:	4b32      	ldr	r3, [pc, #200]	; (4f40 <ip_output_if+0xec>)
    4e76:	4798      	blx	r3
    4e78:	2800      	cmp	r0, #0
    4e7a:	d15d      	bne.n	4f38 <ip_output_if+0xe4>
			IP_STATS_INC(ip.err);
			snmp_inc_ipoutdiscards();
			return ERR_BUF;
		}

		iphdr = (struct ip_hdr *)p->payload;
    4e7c:	686c      	ldr	r4, [r5, #4]
		LWIP_ASSERT("check that first pbuf can hold struct ip_hdr", (p->len >= sizeof(struct ip_hdr)));

		IPH_TTL_SET(iphdr, ttl);
    4e7e:	f884 a008 	strb.w	sl, [r4, #8]
		IPH_PROTO_SET(iphdr, proto);
    4e82:	f884 b009 	strb.w	fp, [r4, #9]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

		/* dest cannot be NULL here */
		ip_addr_copy(iphdr->dest, *dest);
    4e86:	683b      	ldr	r3, [r7, #0]
    4e88:	6123      	str	r3, [r4, #16]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    4e8a:	b29a      	uxth	r2, r3
    4e8c:	9203      	str	r2, [sp, #12]
		chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
    4e8e:	ea4f 4913 	mov.w	r9, r3, lsr #16
#endif /* CHECKSUM_GEN_IP_INLINE */

		IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    4e92:	2345      	movs	r3, #69	; 0x45
    4e94:	7023      	strb	r3, [r4, #0]
		IPH_TOS_SET(iphdr, tos);
    4e96:	f884 8001 	strb.w	r8, [r4, #1]
		chk_sum += LWIP_MAKE_U16(proto, ttl);
    4e9a:	ea4a 2a0b 	orr.w	sl, sl, fp, lsl #8
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    4e9e:	ea4f 2808 	mov.w	r8, r8, lsl #8
    4ea2:	ea48 0803 	orr.w	r8, r8, r3
    4ea6:	eb0a 0b08 	add.w	fp, sl, r8
#endif /* CHECKSUM_GEN_IP_INLINE */
		IPH_LEN_SET(iphdr, htons(p->tot_len));
    4eaa:	8928      	ldrh	r0, [r5, #8]
    4eac:	4f25      	ldr	r7, [pc, #148]	; (4f44 <ip_output_if+0xf0>)
    4eae:	47b8      	blx	r7
    4eb0:	4682      	mov	sl, r0
    4eb2:	8060      	strh	r0, [r4, #2]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
		IPH_OFFSET_SET(iphdr, 0);
    4eb4:	2300      	movs	r3, #0
    4eb6:	71a3      	strb	r3, [r4, #6]
    4eb8:	71e3      	strb	r3, [r4, #7]
		IPH_ID_SET(iphdr, htons(ip_id));
    4eba:	f8df 8090 	ldr.w	r8, [pc, #144]	; 4f4c <ip_output_if+0xf8>
    4ebe:	f8b8 0000 	ldrh.w	r0, [r8]
    4ec2:	47b8      	blx	r7
    4ec4:	80a0      	strh	r0, [r4, #4]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
		++ip_id;
    4ec6:	f8b8 3000 	ldrh.w	r3, [r8]
    4eca:	3301      	adds	r3, #1
    4ecc:	f8a8 3000 	strh.w	r3, [r8]

		if (ip_addr_isany(src)) {
    4ed0:	9b02      	ldr	r3, [sp, #8]
    4ed2:	b10b      	cbz	r3, 4ed8 <ip_output_if+0x84>
    4ed4:	681b      	ldr	r3, [r3, #0]
    4ed6:	bb03      	cbnz	r3, 4f1a <ip_output_if+0xc6>
			ip_addr_copy(iphdr->src, netif->ip_addr);
    4ed8:	6873      	ldr	r3, [r6, #4]
    4eda:	60e3      	str	r3, [r4, #12]
			/* src cannot be NULL here */
			ip_addr_copy(iphdr->src, *src);
		}

#if CHECKSUM_GEN_IP_INLINE
		chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
    4edc:	68e2      	ldr	r2, [r4, #12]
		chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
    4ede:	fa1b f382 	uxtah	r3, fp, r2
    4ee2:	eb03 4312 	add.w	r3, r3, r2, lsr #16
    4ee6:	9a03      	ldr	r2, [sp, #12]
    4ee8:	4413      	add	r3, r2
    4eea:	444b      	add	r3, r9
    4eec:	449a      	add	sl, r3
    4eee:	4450      	add	r0, sl
		chk_sum        = (chk_sum >> 16) + (chk_sum & 0xFFFF);
    4ef0:	fa1f fa80 	uxth.w	sl, r0
    4ef4:	eb0a 4010 	add.w	r0, sl, r0, lsr #16
		chk_sum        = (chk_sum >> 16) + chk_sum;
    4ef8:	eb00 4010 	add.w	r0, r0, r0, lsr #16
		chk_sum        = ~chk_sum;
		iphdr->_chksum = chk_sum; /* network order */
    4efc:	43c0      	mvns	r0, r0
    4efe:	8160      	strh	r0, [r4, #10]
	}
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
	/* don't fragment if interface has mtu set to 0 [loopif] */
	if (netif->mtu && (p->tot_len > netif->mtu)) {
    4f00:	8db3      	ldrh	r3, [r6, #44]	; 0x2c
    4f02:	b113      	cbz	r3, 4f0a <ip_output_if+0xb6>
    4f04:	892a      	ldrh	r2, [r5, #8]
    4f06:	429a      	cmp	r2, r3
    4f08:	d810      	bhi.n	4f2c <ip_output_if+0xd8>
		return ip_frag(p, netif, dest);
	}
#endif /* IP_FRAG */

	LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
	return netif->output(netif, p, dest);
    4f0a:	6973      	ldr	r3, [r6, #20]
    4f0c:	9a01      	ldr	r2, [sp, #4]
    4f0e:	4629      	mov	r1, r5
    4f10:	4630      	mov	r0, r6
    4f12:	4798      	blx	r3
}
    4f14:	b007      	add	sp, #28
    4f16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ip_addr_copy(iphdr->src, *src);
    4f1a:	60e3      	str	r3, [r4, #12]
    4f1c:	e7de      	b.n	4edc <ip_output_if+0x88>
		ip_addr_copy(dest_addr, iphdr->dest);
    4f1e:	6843      	ldr	r3, [r0, #4]
    4f20:	691b      	ldr	r3, [r3, #16]
    4f22:	aa06      	add	r2, sp, #24
    4f24:	f842 3d04 	str.w	r3, [r2, #-4]!
    4f28:	9201      	str	r2, [sp, #4]
    4f2a:	e7e9      	b.n	4f00 <ip_output_if+0xac>
		return ip_frag(p, netif, dest);
    4f2c:	9a01      	ldr	r2, [sp, #4]
    4f2e:	4631      	mov	r1, r6
    4f30:	4628      	mov	r0, r5
    4f32:	4b05      	ldr	r3, [pc, #20]	; (4f48 <ip_output_if+0xf4>)
    4f34:	4798      	blx	r3
    4f36:	e7ed      	b.n	4f14 <ip_output_if+0xc0>
			return ERR_BUF;
    4f38:	f06f 0001 	mvn.w	r0, #1
    4f3c:	e7ea      	b.n	4f14 <ip_output_if+0xc0>
    4f3e:	bf00      	nop
    4f40:	00005c8d 	.word	0x00005c8d
    4f44:	00002f3d 	.word	0x00002f3d
    4f48:	00005565 	.word	0x00005565
    4f4c:	2000162c 	.word	0x2000162c

00004f50 <ip_output>:
 *
 * @return ERR_RTE if no route is found
 *         see ip_output_if() for more return values
 */
err_t ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t ttl, u8_t tos, u8_t proto)
{
    4f50:	b5f0      	push	{r4, r5, r6, r7, lr}
    4f52:	b085      	sub	sp, #20
    4f54:	4605      	mov	r5, r0
    4f56:	460e      	mov	r6, r1
    4f58:	4614      	mov	r4, r2
    4f5a:	461f      	mov	r7, r3

	/* pbufs passed to IP must have a ref-count of 1 as their payload pointer
	   gets altered as the packet is passed down the stack */
	LWIP_ASSERT("p->ref == 1", p->ref == 1);

	if ((netif = ip_route(dest)) == NULL) {
    4f5c:	4610      	mov	r0, r2
    4f5e:	4b0a      	ldr	r3, [pc, #40]	; (4f88 <ip_output+0x38>)
    4f60:	4798      	blx	r3
    4f62:	b170      	cbz	r0, 4f82 <ip_output+0x32>
		             ip4_addr4_16(dest)));
		IP_STATS_INC(ip.rterr);
		return ERR_RTE;
	}

	return ip_output_if(p, src, dest, ttl, tos, proto, netif);
    4f64:	9002      	str	r0, [sp, #8]
    4f66:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    4f6a:	9301      	str	r3, [sp, #4]
    4f6c:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
    4f70:	9300      	str	r3, [sp, #0]
    4f72:	463b      	mov	r3, r7
    4f74:	4622      	mov	r2, r4
    4f76:	4631      	mov	r1, r6
    4f78:	4628      	mov	r0, r5
    4f7a:	4c04      	ldr	r4, [pc, #16]	; (4f8c <ip_output+0x3c>)
    4f7c:	47a0      	blx	r4
}
    4f7e:	b005      	add	sp, #20
    4f80:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_RTE;
    4f82:	f06f 0003 	mvn.w	r0, #3
    4f86:	e7fa      	b.n	4f7e <ip_output+0x2e>
    4f88:	00004c25 	.word	0x00004c25
    4f8c:	00004e55 	.word	0x00004e55

00004f90 <ip4_addr_isbroadcast>:
{
	ip_addr_t ipaddr;
	ip4_addr_set_u32(&ipaddr, addr);

	/* all ones (broadcast) or all zeroes (old skool broadcast) */
	if ((~addr == IPADDR_ANY) || (addr == IPADDR_ANY)) {
    4f90:	1e43      	subs	r3, r0, #1
    4f92:	f113 0f03 	cmn.w	r3, #3
    4f96:	d812      	bhi.n	4fbe <ip4_addr_isbroadcast+0x2e>
		return 1;
		/* no broadcast support on this network interface? */
	} else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
    4f98:	f891 3035 	ldrb.w	r3, [r1, #53]	; 0x35
    4f9c:	f013 0f02 	tst.w	r3, #2
    4fa0:	d00f      	beq.n	4fc2 <ip4_addr_isbroadcast+0x32>
		/* the given address cannot be a broadcast address
		 * nor can we check against any broadcast addresses */
		return 0;
		/* address matches network interface address exactly? => no broadcast */
	} else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    4fa2:	684b      	ldr	r3, [r1, #4]
    4fa4:	4298      	cmp	r0, r3
    4fa6:	d00e      	beq.n	4fc6 <ip4_addr_isbroadcast+0x36>
		return 0;
		/*  on the same (sub) network... */
	} else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
    4fa8:	688a      	ldr	r2, [r1, #8]
    4faa:	4043      	eors	r3, r0
    4fac:	4213      	tst	r3, r2
    4fae:	d10c      	bne.n	4fca <ip4_addr_isbroadcast+0x3a>
	           /* ...and host identifier bits are all ones? =>... */
	           && ((addr & ~ip4_addr_get_u32(&netif->netmask))
    4fb0:	43d2      	mvns	r2, r2
    4fb2:	ea32 0300 	bics.w	r3, r2, r0
		return 1;
    4fb6:	bf0c      	ite	eq
    4fb8:	2001      	moveq	r0, #1
    4fba:	2000      	movne	r0, #0
    4fbc:	4770      	bx	lr
    4fbe:	2001      	movs	r0, #1
    4fc0:	4770      	bx	lr
		return 0;
    4fc2:	2000      	movs	r0, #0
    4fc4:	4770      	bx	lr
		return 0;
    4fc6:	2000      	movs	r0, #0
    4fc8:	4770      	bx	lr
	               == (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
		/* => network broadcast address */
		return 1;
	} else {
		return 0;
    4fca:	2000      	movs	r0, #0
	}
}
    4fcc:	4770      	bx	lr
	...

00004fd0 <ipaddr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
    4fd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4fd4:	b085      	sub	sp, #20
    4fd6:	9101      	str	r1, [sp, #4]
	u8_t  rem;
	u8_t  n;
	u8_t  i;
	int   len = 0;

	s_addr = ip4_addr_get_u32(addr);
    4fd8:	6803      	ldr	r3, [r0, #0]
    4fda:	f10d 0c10 	add.w	ip, sp, #16
    4fde:	f84c 3d04 	str.w	r3, [ip, #-4]!

	rp = buf;
    4fe2:	460c      	mov	r4, r1
	int   len = 0;
    4fe4:	f04f 0800 	mov.w	r8, #0
    4fe8:	46c1      	mov	r9, r8
	ap = (u8_t *)&s_addr;
	for (n = 0; n < 4; n++) {
		i = 0;
		do {
			rem = *ap % (u8_t)10;
    4fea:	4f27      	ldr	r7, [pc, #156]	; (5088 <ipaddr_ntoa_r+0xb8>)
    4fec:	f102 0e01 	add.w	lr, r2, #1
			*rp++ = inv[i];
		}
		if (len++ >= buflen) {
			return NULL;
		}
		*rp++ = '.';
    4ff0:	f04f 0b2e 	mov.w	fp, #46	; 0x2e
    4ff4:	4666      	mov	r6, ip
    4ff6:	f89c 3000 	ldrb.w	r3, [ip]
	int   len = 0;
    4ffa:	4648      	mov	r0, r9
    4ffc:	469a      	mov	sl, r3
    4ffe:	e000      	b.n	5002 <ipaddr_ntoa_r+0x32>
			inv[i++] = '0' + rem;
    5000:	4628      	mov	r0, r5
			rem = *ap % (u8_t)10;
    5002:	fba7 310a 	umull	r3, r1, r7, sl
    5006:	08c9      	lsrs	r1, r1, #3
    5008:	eb01 0381 	add.w	r3, r1, r1, lsl #2
    500c:	ebaa 0343 	sub.w	r3, sl, r3, lsl #1
			inv[i++] = '0' + rem;
    5010:	1c45      	adds	r5, r0, #1
    5012:	b2ed      	uxtb	r5, r5
    5014:	3330      	adds	r3, #48	; 0x30
    5016:	f10d 0a10 	add.w	sl, sp, #16
    501a:	4482      	add	sl, r0
    501c:	f80a 3c08 	strb.w	r3, [sl, #-8]
		} while (*ap);
    5020:	f001 0aff 	and.w	sl, r1, #255	; 0xff
    5024:	2900      	cmp	r1, #0
    5026:	d1eb      	bne.n	5000 <ipaddr_ntoa_r+0x30>
    5028:	f886 9000 	strb.w	r9, [r6]
    502c:	f10c 0c01 	add.w	ip, ip, #1
		while (i--) {
    5030:	b1ad      	cbz	r5, 505e <ipaddr_ntoa_r+0x8e>
			if (len++ >= buflen) {
    5032:	f108 0101 	add.w	r1, r8, #1
    5036:	4542      	cmp	r2, r8
    5038:	dd21      	ble.n	507e <ipaddr_ntoa_r+0xae>
    503a:	ab02      	add	r3, sp, #8
    503c:	181d      	adds	r5, r3, r0
    503e:	1e63      	subs	r3, r4, #1
    5040:	4420      	add	r0, r4
    5042:	1c9e      	adds	r6, r3, #2
			*rp++ = inv[i];
    5044:	f815 4901 	ldrb.w	r4, [r5], #-1
    5048:	f803 4f01 	strb.w	r4, [r3, #1]!
		while (i--) {
    504c:	4298      	cmp	r0, r3
    504e:	d008      	beq.n	5062 <ipaddr_ntoa_r+0x92>
			if (len++ >= buflen) {
    5050:	3101      	adds	r1, #1
    5052:	4571      	cmp	r1, lr
    5054:	d1f5      	bne.n	5042 <ipaddr_ntoa_r+0x72>
				return NULL;
    5056:	2000      	movs	r0, #0
		ap++;
	}
	*--rp = 0;
	return buf;
}
    5058:	b005      	add	sp, #20
    505a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		while (i--) {
    505e:	4641      	mov	r1, r8
    5060:	4626      	mov	r6, r4
		if (len++ >= buflen) {
    5062:	f101 0801 	add.w	r8, r1, #1
    5066:	428a      	cmp	r2, r1
    5068:	dd0b      	ble.n	5082 <ipaddr_ntoa_r+0xb2>
		*rp++ = '.';
    506a:	1c74      	adds	r4, r6, #1
    506c:	f886 b000 	strb.w	fp, [r6]
	for (n = 0; n < 4; n++) {
    5070:	ab04      	add	r3, sp, #16
    5072:	459c      	cmp	ip, r3
    5074:	d1be      	bne.n	4ff4 <ipaddr_ntoa_r+0x24>
	*--rp = 0;
    5076:	2300      	movs	r3, #0
    5078:	7033      	strb	r3, [r6, #0]
	return buf;
    507a:	9801      	ldr	r0, [sp, #4]
    507c:	e7ec      	b.n	5058 <ipaddr_ntoa_r+0x88>
				return NULL;
    507e:	2000      	movs	r0, #0
    5080:	e7ea      	b.n	5058 <ipaddr_ntoa_r+0x88>
			return NULL;
    5082:	2000      	movs	r0, #0
    5084:	e7e8      	b.n	5058 <ipaddr_ntoa_r+0x88>
    5086:	bf00      	nop
    5088:	cccccccd 	.word	0xcccccccd

0000508c <ip_reass_free_complete_datagram>:
 * @param ipr datagram to free
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    508c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5090:	4681      	mov	r9, r0
    5092:	468a      	mov	sl, r1
		LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
	}

	snmp_inc_ipreasmfails();
#if LWIP_ICMP
	iprh = (struct ip_reass_helper *)ipr->p->payload;
    5094:	6845      	ldr	r5, [r0, #4]
    5096:	686b      	ldr	r3, [r5, #4]
	if (iprh->start == 0) {
    5098:	889a      	ldrh	r2, [r3, #4]
    509a:	b322      	cbz	r2, 50e6 <ip_reass_free_complete_datagram+0x5a>
	u16_t                   pbufs_freed = 0;
    509c:	2400      	movs	r4, #0
	}
#endif /* LWIP_ICMP */

	/* First, free all received pbufs.  The individual pbufs need to be released
	   separately as they have not yet been chained */
	p = ipr->p;
    509e:	f8d9 6004 	ldr.w	r6, [r9, #4]
	while (p != NULL) {
    50a2:	b16e      	cbz	r6, 50c0 <ip_reass_free_complete_datagram+0x34>
		struct pbuf *pcur;
		iprh = (struct ip_reass_helper *)p->payload;
		pcur = p;
		/* get the next pointer before freeing */
		p    = iprh->next_pbuf;
		clen = pbuf_clen(pcur);
    50a4:	f8df 8090 	ldr.w	r8, [pc, #144]	; 5138 <ip_reass_free_complete_datagram+0xac>
		LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
		pbufs_freed += clen;
		pbuf_free(pcur);
    50a8:	4f1f      	ldr	r7, [pc, #124]	; (5128 <ip_reass_free_complete_datagram+0x9c>)
		iprh = (struct ip_reass_helper *)p->payload;
    50aa:	6873      	ldr	r3, [r6, #4]
		p    = iprh->next_pbuf;
    50ac:	681d      	ldr	r5, [r3, #0]
		clen = pbuf_clen(pcur);
    50ae:	4630      	mov	r0, r6
    50b0:	47c0      	blx	r8
		pbufs_freed += clen;
    50b2:	4404      	add	r4, r0
    50b4:	b2a4      	uxth	r4, r4
		pbuf_free(pcur);
    50b6:	4630      	mov	r0, r6
    50b8:	47b8      	blx	r7
		p    = iprh->next_pbuf;
    50ba:	462e      	mov	r6, r5
	while (p != NULL) {
    50bc:	2d00      	cmp	r5, #0
    50be:	d1f4      	bne.n	50aa <ip_reass_free_complete_datagram+0x1e>
 */
static void ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{

	/* dequeue the reass struct  */
	if (reassdatagrams == ipr) {
    50c0:	4b1a      	ldr	r3, [pc, #104]	; (512c <ip_reass_free_complete_datagram+0xa0>)
    50c2:	681b      	ldr	r3, [r3, #0]
    50c4:	4599      	cmp	r9, r3
    50c6:	d029      	beq.n	511c <ip_reass_free_complete_datagram+0x90>
		/* it was the first in the list */
		reassdatagrams = ipr->next;
	} else {
		/* it wasn't the first, so it must have a valid 'prev' */
		LWIP_ASSERT("sanity check linked list", prev != NULL);
		prev->next = ipr->next;
    50c8:	f8d9 3000 	ldr.w	r3, [r9]
    50cc:	f8ca 3000 	str.w	r3, [sl]
	}

	/* now we can free the ip_reass struct */
	memp_free(MEMP_REASSDATA, ipr);
    50d0:	4649      	mov	r1, r9
    50d2:	2005      	movs	r0, #5
    50d4:	4b16      	ldr	r3, [pc, #88]	; (5130 <ip_reass_free_complete_datagram+0xa4>)
    50d6:	4798      	blx	r3
	ip_reass_pbufcount -= pbufs_freed;
    50d8:	4a14      	ldr	r2, [pc, #80]	; (512c <ip_reass_free_complete_datagram+0xa0>)
    50da:	8893      	ldrh	r3, [r2, #4]
    50dc:	1b1b      	subs	r3, r3, r4
    50de:	8093      	strh	r3, [r2, #4]
}
    50e0:	4620      	mov	r0, r4
    50e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		ipr->p = iprh->next_pbuf;
    50e6:	681b      	ldr	r3, [r3, #0]
    50e8:	6043      	str	r3, [r0, #4]
		SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    50ea:	686a      	ldr	r2, [r5, #4]
    50ec:	4603      	mov	r3, r0
    50ee:	f853 1f08 	ldr.w	r1, [r3, #8]!
    50f2:	685e      	ldr	r6, [r3, #4]
    50f4:	689c      	ldr	r4, [r3, #8]
    50f6:	68d8      	ldr	r0, [r3, #12]
    50f8:	6011      	str	r1, [r2, #0]
    50fa:	6056      	str	r6, [r2, #4]
    50fc:	6094      	str	r4, [r2, #8]
    50fe:	60d0      	str	r0, [r2, #12]
    5100:	6919      	ldr	r1, [r3, #16]
    5102:	6111      	str	r1, [r2, #16]
		icmp_time_exceeded(p, ICMP_TE_FRAG);
    5104:	2101      	movs	r1, #1
    5106:	4628      	mov	r0, r5
    5108:	4b0a      	ldr	r3, [pc, #40]	; (5134 <ip_reass_free_complete_datagram+0xa8>)
    510a:	4798      	blx	r3
		clen = pbuf_clen(p);
    510c:	4628      	mov	r0, r5
    510e:	4b0a      	ldr	r3, [pc, #40]	; (5138 <ip_reass_free_complete_datagram+0xac>)
    5110:	4798      	blx	r3
		pbufs_freed += clen;
    5112:	b284      	uxth	r4, r0
		pbuf_free(p);
    5114:	4628      	mov	r0, r5
    5116:	4b04      	ldr	r3, [pc, #16]	; (5128 <ip_reass_free_complete_datagram+0x9c>)
    5118:	4798      	blx	r3
    511a:	e7c0      	b.n	509e <ip_reass_free_complete_datagram+0x12>
		reassdatagrams = ipr->next;
    511c:	f8d9 2000 	ldr.w	r2, [r9]
    5120:	4b02      	ldr	r3, [pc, #8]	; (512c <ip_reass_free_complete_datagram+0xa0>)
    5122:	601a      	str	r2, [r3, #0]
    5124:	e7d4      	b.n	50d0 <ip_reass_free_complete_datagram+0x44>
    5126:	bf00      	nop
    5128:	00005d21 	.word	0x00005d21
    512c:	20001630 	.word	0x20001630
    5130:	00005a59 	.word	0x00005a59
    5134:	00004aa1 	.word	0x00004aa1
    5138:	00005f25 	.word	0x00005f25

0000513c <ip_reass_remove_oldest_datagram>:
{
    513c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    5140:	4605      	mov	r5, r0
    5142:	4688      	mov	r8, r1
	int                  pbufs_freed = 0, pbufs_freed_current;
    5144:	2600      	movs	r6, #0
		r               = reassdatagrams;
    5146:	4f19      	ldr	r7, [pc, #100]	; (51ac <ip_reass_remove_oldest_datagram+0x70>)
			pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    5148:	f8df 9064 	ldr.w	r9, [pc, #100]	; 51b0 <ip_reass_remove_oldest_datagram+0x74>
    514c:	e022      	b.n	5194 <ip_reass_remove_oldest_datagram+0x58>
				other_datagrams++;
    514e:	3401      	adds	r4, #1
				if (oldest == NULL) {
    5150:	b1b8      	cbz	r0, 5182 <ip_reass_remove_oldest_datagram+0x46>
				} else if (r->timer <= oldest->timer) {
    5152:	f893 c01f 	ldrb.w	ip, [r3, #31]
    5156:	7fc2      	ldrb	r2, [r0, #31]
    5158:	4594      	cmp	ip, r2
    515a:	bf98      	it	ls
    515c:	4618      	movls	r0, r3
			if (r->next != NULL) {
    515e:	681a      	ldr	r2, [r3, #0]
    5160:	b18a      	cbz	r2, 5186 <ip_reass_remove_oldest_datagram+0x4a>
    5162:	4619      	mov	r1, r3
    5164:	4613      	mov	r3, r2
			if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    5166:	695a      	ldr	r2, [r3, #20]
    5168:	4572      	cmp	r2, lr
    516a:	d1f0      	bne.n	514e <ip_reass_remove_oldest_datagram+0x12>
    516c:	f8d5 c010 	ldr.w	ip, [r5, #16]
    5170:	699a      	ldr	r2, [r3, #24]
    5172:	4562      	cmp	r2, ip
    5174:	d1eb      	bne.n	514e <ip_reass_remove_oldest_datagram+0x12>
    5176:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
    517a:	88aa      	ldrh	r2, [r5, #4]
    517c:	4594      	cmp	ip, r2
    517e:	d1e6      	bne.n	514e <ip_reass_remove_oldest_datagram+0x12>
    5180:	e7ed      	b.n	515e <ip_reass_remove_oldest_datagram+0x22>
    5182:	4618      	mov	r0, r3
    5184:	e7eb      	b.n	515e <ip_reass_remove_oldest_datagram+0x22>
		if (oldest != NULL) {
    5186:	b108      	cbz	r0, 518c <ip_reass_remove_oldest_datagram+0x50>
			pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    5188:	47c8      	blx	r9
			pbufs_freed += pbufs_freed_current;
    518a:	4406      	add	r6, r0
	} while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
    518c:	4546      	cmp	r6, r8
    518e:	da09      	bge.n	51a4 <ip_reass_remove_oldest_datagram+0x68>
    5190:	2c01      	cmp	r4, #1
    5192:	dd07      	ble.n	51a4 <ip_reass_remove_oldest_datagram+0x68>
		r               = reassdatagrams;
    5194:	683b      	ldr	r3, [r7, #0]
		while (r != NULL) {
    5196:	b12b      	cbz	r3, 51a4 <ip_reass_remove_oldest_datagram+0x68>
			if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    5198:	f8d5 e00c 	ldr.w	lr, [r5, #12]
    519c:	2400      	movs	r4, #0
    519e:	4621      	mov	r1, r4
    51a0:	4620      	mov	r0, r4
    51a2:	e7e0      	b.n	5166 <ip_reass_remove_oldest_datagram+0x2a>
}
    51a4:	4630      	mov	r0, r6
    51a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    51aa:	bf00      	nop
    51ac:	20001630 	.word	0x20001630
    51b0:	0000508d 	.word	0x0000508d

000051b4 <ipfrag_free_pbuf_custom>:
}

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void ipfrag_free_pbuf_custom(struct pbuf *p)
{
    51b4:	b510      	push	{r4, lr}
    51b6:	4604      	mov	r4, r0
	struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref *)p;
	LWIP_ASSERT("pcr != NULL", pcr != NULL);
	LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
	if (pcr->original != NULL) {
    51b8:	6940      	ldr	r0, [r0, #20]
    51ba:	b108      	cbz	r0, 51c0 <ipfrag_free_pbuf_custom+0xc>
		pbuf_free(pcr->original);
    51bc:	4b03      	ldr	r3, [pc, #12]	; (51cc <ipfrag_free_pbuf_custom+0x18>)
    51be:	4798      	blx	r3
	memp_free(MEMP_FRAG_PBUF, p);
    51c0:	4621      	mov	r1, r4
    51c2:	2006      	movs	r0, #6
    51c4:	4b02      	ldr	r3, [pc, #8]	; (51d0 <ipfrag_free_pbuf_custom+0x1c>)
    51c6:	4798      	blx	r3
    51c8:	bd10      	pop	{r4, pc}
    51ca:	bf00      	nop
    51cc:	00005d21 	.word	0x00005d21
    51d0:	00005a59 	.word	0x00005a59

000051d4 <ip_reass_tmr>:
	r = reassdatagrams;
    51d4:	4b0a      	ldr	r3, [pc, #40]	; (5200 <ip_reass_tmr+0x2c>)
    51d6:	6818      	ldr	r0, [r3, #0]
	while (r != NULL) {
    51d8:	b188      	cbz	r0, 51fe <ip_reass_tmr+0x2a>
{
    51da:	b570      	push	{r4, r5, r6, lr}
	while (r != NULL) {
    51dc:	2400      	movs	r4, #0
			ip_reass_free_complete_datagram(tmp, prev);
    51de:	4e09      	ldr	r6, [pc, #36]	; (5204 <ip_reass_tmr+0x30>)
    51e0:	e004      	b.n	51ec <ip_reass_tmr+0x18>
			r = r->next;
    51e2:	6805      	ldr	r5, [r0, #0]
			ip_reass_free_complete_datagram(tmp, prev);
    51e4:	4621      	mov	r1, r4
    51e6:	47b0      	blx	r6
			r = r->next;
    51e8:	4628      	mov	r0, r5
	while (r != NULL) {
    51ea:	b138      	cbz	r0, 51fc <ip_reass_tmr+0x28>
		if (r->timer > 0) {
    51ec:	7fc3      	ldrb	r3, [r0, #31]
    51ee:	2b00      	cmp	r3, #0
    51f0:	d0f7      	beq.n	51e2 <ip_reass_tmr+0xe>
			r->timer--;
    51f2:	3b01      	subs	r3, #1
    51f4:	77c3      	strb	r3, [r0, #31]
    51f6:	4604      	mov	r4, r0
			r    = r->next;
    51f8:	6800      	ldr	r0, [r0, #0]
    51fa:	e7f6      	b.n	51ea <ip_reass_tmr+0x16>
    51fc:	bd70      	pop	{r4, r5, r6, pc}
    51fe:	4770      	bx	lr
    5200:	20001630 	.word	0x20001630
    5204:	0000508d 	.word	0x0000508d

00005208 <ip_reass>:
{
    5208:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    520c:	b083      	sub	sp, #12
    520e:	4607      	mov	r7, r0
	fraghdr = (struct ip_hdr *)p->payload;
    5210:	6846      	ldr	r6, [r0, #4]
	if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    5212:	7833      	ldrb	r3, [r6, #0]
    5214:	f003 030f 	and.w	r3, r3, #15
    5218:	2b05      	cmp	r3, #5
    521a:	d122      	bne.n	5262 <ip_reass+0x5a>
	offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    521c:	88f0      	ldrh	r0, [r6, #6]
    521e:	4ca0      	ldr	r4, [pc, #640]	; (54a0 <ip_reass+0x298>)
    5220:	47a0      	blx	r4
    5222:	4683      	mov	fp, r0
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    5224:	8870      	ldrh	r0, [r6, #2]
    5226:	47a0      	blx	r4
    5228:	9001      	str	r0, [sp, #4]
    522a:	f896 a000 	ldrb.w	sl, [r6]
	clen = pbuf_clen(p);
    522e:	4638      	mov	r0, r7
    5230:	4b9c      	ldr	r3, [pc, #624]	; (54a4 <ip_reass+0x29c>)
    5232:	4798      	blx	r3
    5234:	4680      	mov	r8, r0
	if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    5236:	4b9c      	ldr	r3, [pc, #624]	; (54a8 <ip_reass+0x2a0>)
    5238:	889b      	ldrh	r3, [r3, #4]
    523a:	4403      	add	r3, r0
    523c:	2b0a      	cmp	r3, #10
    523e:	dc06      	bgt.n	524e <ip_reass+0x46>
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    5240:	4b99      	ldr	r3, [pc, #612]	; (54a8 <ip_reass+0x2a0>)
    5242:	681c      	ldr	r4, [r3, #0]
    5244:	2c00      	cmp	r4, #0
    5246:	d079      	beq.n	533c <ip_reass+0x134>
		if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    5248:	68f2      	ldr	r2, [r6, #12]
    524a:	2500      	movs	r5, #0
    524c:	e014      	b.n	5278 <ip_reass+0x70>
		if (!ip_reass_remove_oldest_datagram(fraghdr, clen) || ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
    524e:	4601      	mov	r1, r0
    5250:	4630      	mov	r0, r6
    5252:	4b96      	ldr	r3, [pc, #600]	; (54ac <ip_reass+0x2a4>)
    5254:	4798      	blx	r3
    5256:	b120      	cbz	r0, 5262 <ip_reass+0x5a>
    5258:	4b93      	ldr	r3, [pc, #588]	; (54a8 <ip_reass+0x2a0>)
    525a:	889b      	ldrh	r3, [r3, #4]
    525c:	4443      	add	r3, r8
    525e:	2b0a      	cmp	r3, #10
    5260:	ddee      	ble.n	5240 <ip_reass+0x38>
	pbuf_free(p);
    5262:	4638      	mov	r0, r7
    5264:	4b92      	ldr	r3, [pc, #584]	; (54b0 <ip_reass+0x2a8>)
    5266:	4798      	blx	r3
	return NULL;
    5268:	f04f 0800 	mov.w	r8, #0
    526c:	e101      	b.n	5472 <ip_reass+0x26a>
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    526e:	6823      	ldr	r3, [r4, #0]
    5270:	4625      	mov	r5, r4
    5272:	2b00      	cmp	r3, #0
    5274:	d062      	beq.n	533c <ip_reass+0x134>
    5276:	461c      	mov	r4, r3
		if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    5278:	6963      	ldr	r3, [r4, #20]
    527a:	4293      	cmp	r3, r2
    527c:	d1f7      	bne.n	526e <ip_reass+0x66>
    527e:	6933      	ldr	r3, [r6, #16]
    5280:	69a1      	ldr	r1, [r4, #24]
    5282:	4299      	cmp	r1, r3
    5284:	d1f3      	bne.n	526e <ip_reass+0x66>
    5286:	89a1      	ldrh	r1, [r4, #12]
    5288:	88b3      	ldrh	r3, [r6, #4]
    528a:	4299      	cmp	r1, r3
    528c:	d1ef      	bne.n	526e <ip_reass+0x66>
	if (ipr == NULL) {
    528e:	2c00      	cmp	r4, #0
    5290:	d053      	beq.n	533a <ip_reass+0x132>
		if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    5292:	88f0      	ldrh	r0, [r6, #6]
    5294:	4b82      	ldr	r3, [pc, #520]	; (54a0 <ip_reass+0x298>)
    5296:	4798      	blx	r3
    5298:	f3c0 000c 	ubfx	r0, r0, #0, #13
    529c:	2800      	cmp	r0, #0
    529e:	f000 8084 	beq.w	53aa <ip_reass+0x1a2>
	ip_reass_pbufcount += clen;
    52a2:	4b81      	ldr	r3, [pc, #516]	; (54a8 <ip_reass+0x2a0>)
    52a4:	889a      	ldrh	r2, [r3, #4]
    52a6:	4490      	add	r8, r2
    52a8:	f8a3 8004 	strh.w	r8, [r3, #4]
	if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    52ac:	88f3      	ldrh	r3, [r6, #6]
    52ae:	f013 0f20 	tst.w	r3, #32
    52b2:	d10c      	bne.n	52ce <ip_reass+0xc6>
		ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    52b4:	7fa3      	ldrb	r3, [r4, #30]
    52b6:	f043 0301 	orr.w	r3, r3, #1
    52ba:	77a3      	strb	r3, [r4, #30]
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    52bc:	f00a 0a0f 	and.w	sl, sl, #15
    52c0:	9b01      	ldr	r3, [sp, #4]
    52c2:	eba3 098a 	sub.w	r9, r3, sl, lsl #2
		ipr->datagram_len = offset + len;
    52c6:	eb09 0bcb 	add.w	fp, r9, fp, lsl #3
    52ca:	f8a4 b01c 	strh.w	fp, [r4, #28]
	fraghdr = (struct ip_hdr *)new_p->payload;
    52ce:	687e      	ldr	r6, [r7, #4]
	len     = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    52d0:	8870      	ldrh	r0, [r6, #2]
    52d2:	f8df 91cc 	ldr.w	r9, [pc, #460]	; 54a0 <ip_reass+0x298>
    52d6:	47c8      	blx	r9
    52d8:	f896 8000 	ldrb.w	r8, [r6]
    52dc:	f008 080f 	and.w	r8, r8, #15
    52e0:	eba0 0888 	sub.w	r8, r0, r8, lsl #2
    52e4:	fa1f f888 	uxth.w	r8, r8
	offset  = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    52e8:	88f0      	ldrh	r0, [r6, #6]
    52ea:	47c8      	blx	r9
    52ec:	f3c0 000c 	ubfx	r0, r0, #0, #13
    52f0:	00c0      	lsls	r0, r0, #3
	iprh            = (struct ip_reass_helper *)new_p->payload;
    52f2:	f8d7 c004 	ldr.w	ip, [r7, #4]
	iprh->next_pbuf = NULL;
    52f6:	2300      	movs	r3, #0
    52f8:	f88c 3000 	strb.w	r3, [ip]
    52fc:	f88c 3001 	strb.w	r3, [ip, #1]
    5300:	f88c 3002 	strb.w	r3, [ip, #2]
    5304:	f88c 3003 	strb.w	r3, [ip, #3]
	iprh->start     = offset;
    5308:	f8ac 0004 	strh.w	r0, [ip, #4]
	iprh->end       = offset + len;
    530c:	4480      	add	r8, r0
    530e:	fa1f f888 	uxth.w	r8, r8
    5312:	f8ac 8006 	strh.w	r8, [ip, #6]
	for (q = ipr->p; q != NULL;) {
    5316:	6862      	ldr	r2, [r4, #4]
    5318:	2a00      	cmp	r2, #0
    531a:	f000 809a 	beq.w	5452 <ip_reass+0x24a>
		iprh_tmp = (struct ip_reass_helper *)q->payload;
    531e:	6853      	ldr	r3, [r2, #4]
		if (iprh->start < iprh_tmp->start) {
    5320:	8899      	ldrh	r1, [r3, #4]
    5322:	4288      	cmp	r0, r1
    5324:	f0c0 80ad 	bcc.w	5482 <ip_reass+0x27a>
		} else if (iprh->start == iprh_tmp->start) {
    5328:	f000 8097 	beq.w	545a <ip_reass+0x252>
		} else if (iprh->start < iprh_tmp->end) {
    532c:	88da      	ldrh	r2, [r3, #6]
    532e:	4282      	cmp	r2, r0
    5330:	f200 8093 	bhi.w	545a <ip_reass+0x252>
    5334:	f04f 0e01 	mov.w	lr, #1
    5338:	e078      	b.n	542c <ip_reass+0x224>
    533a:	462c      	mov	r4, r5
	ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    533c:	2005      	movs	r0, #5
    533e:	4b5d      	ldr	r3, [pc, #372]	; (54b4 <ip_reass+0x2ac>)
    5340:	4798      	blx	r3
	if (ipr == NULL) {
    5342:	4681      	mov	r9, r0
    5344:	b318      	cbz	r0, 538e <ip_reass+0x186>
	memset(ipr, 0, sizeof(struct ip_reassdata));
    5346:	2220      	movs	r2, #32
    5348:	2100      	movs	r1, #0
    534a:	4648      	mov	r0, r9
    534c:	4b5a      	ldr	r3, [pc, #360]	; (54b8 <ip_reass+0x2b0>)
    534e:	4798      	blx	r3
	ipr->timer = IP_REASS_MAXAGE;
    5350:	2303      	movs	r3, #3
    5352:	f889 301f 	strb.w	r3, [r9, #31]
	ipr->next      = reassdatagrams;
    5356:	4b54      	ldr	r3, [pc, #336]	; (54a8 <ip_reass+0x2a0>)
    5358:	681a      	ldr	r2, [r3, #0]
    535a:	f8c9 2000 	str.w	r2, [r9]
	reassdatagrams = ipr;
    535e:	f8c3 9000 	str.w	r9, [r3]
	SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    5362:	6832      	ldr	r2, [r6, #0]
    5364:	6875      	ldr	r5, [r6, #4]
    5366:	68b0      	ldr	r0, [r6, #8]
    5368:	68f1      	ldr	r1, [r6, #12]
    536a:	f8c9 2008 	str.w	r2, [r9, #8]
    536e:	f8c9 500c 	str.w	r5, [r9, #12]
    5372:	f8c9 0010 	str.w	r0, [r9, #16]
    5376:	f8c9 1014 	str.w	r1, [r9, #20]
    537a:	6932      	ldr	r2, [r6, #16]
    537c:	f8c9 2018 	str.w	r2, [r9, #24]
		if (ipr == NULL) {
    5380:	f1b9 0f00 	cmp.w	r9, #0
    5384:	f43f af6d 	beq.w	5262 <ip_reass+0x5a>
    5388:	4625      	mov	r5, r4
	return ipr;
    538a:	464c      	mov	r4, r9
    538c:	e789      	b.n	52a2 <ip_reass+0x9a>
		if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
    538e:	4641      	mov	r1, r8
    5390:	4630      	mov	r0, r6
    5392:	4b46      	ldr	r3, [pc, #280]	; (54ac <ip_reass+0x2a4>)
    5394:	4798      	blx	r3
    5396:	4580      	cmp	r8, r0
    5398:	f73f af63 	bgt.w	5262 <ip_reass+0x5a>
			ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    539c:	2005      	movs	r0, #5
    539e:	4b45      	ldr	r3, [pc, #276]	; (54b4 <ip_reass+0x2ac>)
    53a0:	4798      	blx	r3
		if (ipr == NULL)
    53a2:	4681      	mov	r9, r0
    53a4:	2800      	cmp	r0, #0
    53a6:	d1ce      	bne.n	5346 <ip_reass+0x13e>
    53a8:	e75b      	b.n	5262 <ip_reass+0x5a>
		if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    53aa:	89e0      	ldrh	r0, [r4, #14]
    53ac:	4b3c      	ldr	r3, [pc, #240]	; (54a0 <ip_reass+0x298>)
    53ae:	4798      	blx	r3
    53b0:	f3c0 000c 	ubfx	r0, r0, #0, #13
    53b4:	2800      	cmp	r0, #0
    53b6:	f43f af74 	beq.w	52a2 <ip_reass+0x9a>
			SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    53ba:	6832      	ldr	r2, [r6, #0]
    53bc:	f8d6 e004 	ldr.w	lr, [r6, #4]
    53c0:	68b0      	ldr	r0, [r6, #8]
    53c2:	68f1      	ldr	r1, [r6, #12]
    53c4:	60a2      	str	r2, [r4, #8]
    53c6:	f8c4 e00c 	str.w	lr, [r4, #12]
    53ca:	6120      	str	r0, [r4, #16]
    53cc:	6161      	str	r1, [r4, #20]
    53ce:	6932      	ldr	r2, [r6, #16]
    53d0:	61a2      	str	r2, [r4, #24]
    53d2:	e766      	b.n	52a2 <ip_reass+0x9a>
			iprh->next_pbuf = q;
    53d4:	f8cc 6000 	str.w	r6, [ip]
			if (iprh_prev != NULL) {
    53d8:	2b00      	cmp	r3, #0
    53da:	d056      	beq.n	548a <ip_reass+0x282>
				if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
    53dc:	88d9      	ldrh	r1, [r3, #6]
    53de:	4281      	cmp	r1, r0
    53e0:	d83b      	bhi.n	545a <ip_reass+0x252>
    53e2:	8892      	ldrh	r2, [r2, #4]
    53e4:	4542      	cmp	r2, r8
    53e6:	d338      	bcc.n	545a <ip_reass+0x252>
				iprh_prev->next_pbuf = new_p;
    53e8:	601f      	str	r7, [r3, #0]
	if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    53ea:	7fa3      	ldrb	r3, [r4, #30]
    53ec:	f013 0f01 	tst.w	r3, #1
    53f0:	d03d      	beq.n	546e <ip_reass+0x266>
		if (valid) {
    53f2:	f1be 0f00 	cmp.w	lr, #0
    53f6:	d03a      	beq.n	546e <ip_reass+0x266>
			if (((struct ip_reass_helper *)ipr->p->payload)->start != 0) {
    53f8:	6860      	ldr	r0, [r4, #4]
    53fa:	6843      	ldr	r3, [r0, #4]
    53fc:	889b      	ldrh	r3, [r3, #4]
    53fe:	2b00      	cmp	r3, #0
    5400:	d135      	bne.n	546e <ip_reass+0x266>
				q         = iprh->next_pbuf;
    5402:	f8dc 3000 	ldr.w	r3, [ip]
				while (q != NULL) {
    5406:	2b00      	cmp	r3, #0
    5408:	d058      	beq.n	54bc <ip_reass+0x2b4>
					iprh = (struct ip_reass_helper *)q->payload;
    540a:	685b      	ldr	r3, [r3, #4]
					if (iprh_prev->end != iprh->start) {
    540c:	8899      	ldrh	r1, [r3, #4]
    540e:	f8bc 2006 	ldrh.w	r2, [ip, #6]
    5412:	4291      	cmp	r1, r2
    5414:	d12b      	bne.n	546e <ip_reass+0x266>
					q         = iprh->next_pbuf;
    5416:	681a      	ldr	r2, [r3, #0]
				while (q != NULL) {
    5418:	2a00      	cmp	r2, #0
    541a:	d04f      	beq.n	54bc <ip_reass+0x2b4>
					iprh = (struct ip_reass_helper *)q->payload;
    541c:	6852      	ldr	r2, [r2, #4]
					if (iprh_prev->end != iprh->start) {
    541e:	88d9      	ldrh	r1, [r3, #6]
    5420:	8893      	ldrh	r3, [r2, #4]
    5422:	4299      	cmp	r1, r3
    5424:	d123      	bne.n	546e <ip_reass+0x266>
					iprh = (struct ip_reass_helper *)q->payload;
    5426:	4613      	mov	r3, r2
    5428:	e7f5      	b.n	5416 <ip_reass+0x20e>
		iprh_tmp = (struct ip_reass_helper *)q->payload;
    542a:	4613      	mov	r3, r2
		q         = iprh_tmp->next_pbuf;
    542c:	681e      	ldr	r6, [r3, #0]
	for (q = ipr->p; q != NULL;) {
    542e:	b376      	cbz	r6, 548e <ip_reass+0x286>
		iprh_tmp = (struct ip_reass_helper *)q->payload;
    5430:	6872      	ldr	r2, [r6, #4]
		if (iprh->start < iprh_tmp->start) {
    5432:	8891      	ldrh	r1, [r2, #4]
    5434:	4288      	cmp	r0, r1
    5436:	d3cd      	bcc.n	53d4 <ip_reass+0x1cc>
		} else if (iprh->start == iprh_tmp->start) {
    5438:	4288      	cmp	r0, r1
    543a:	d00e      	beq.n	545a <ip_reass+0x252>
		} else if (iprh->start < iprh_tmp->end) {
    543c:	88d6      	ldrh	r6, [r2, #6]
    543e:	4286      	cmp	r6, r0
    5440:	d80b      	bhi.n	545a <ip_reass+0x252>
			if (iprh_prev != NULL) {
    5442:	2b00      	cmp	r3, #0
    5444:	d0f1      	beq.n	542a <ip_reass+0x222>
				if (iprh_prev->end != iprh_tmp->start) {
    5446:	88db      	ldrh	r3, [r3, #6]
					valid = 0;
    5448:	428b      	cmp	r3, r1
    544a:	bf18      	it	ne
    544c:	f04f 0e00 	movne.w	lr, #0
    5450:	e7eb      	b.n	542a <ip_reass+0x222>
	int                     valid = 1;
    5452:	f04f 0e01 	mov.w	lr, #1
			ipr->p = new_p;
    5456:	6067      	str	r7, [r4, #4]
    5458:	e7c7      	b.n	53ea <ip_reass+0x1e2>
	ip_reass_pbufcount -= pbuf_clen(new_p);
    545a:	4638      	mov	r0, r7
    545c:	4b11      	ldr	r3, [pc, #68]	; (54a4 <ip_reass+0x29c>)
    545e:	4798      	blx	r3
    5460:	4a11      	ldr	r2, [pc, #68]	; (54a8 <ip_reass+0x2a0>)
    5462:	8893      	ldrh	r3, [r2, #4]
    5464:	1a18      	subs	r0, r3, r0
    5466:	8090      	strh	r0, [r2, #4]
	pbuf_free(new_p);
    5468:	4638      	mov	r0, r7
    546a:	4b11      	ldr	r3, [pc, #68]	; (54b0 <ip_reass+0x2a8>)
    546c:	4798      	blx	r3
	return NULL;
    546e:	f04f 0800 	mov.w	r8, #0
}
    5472:	4640      	mov	r0, r8
    5474:	b003      	add	sp, #12
    5476:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		reassdatagrams = ipr->next;
    547a:	6822      	ldr	r2, [r4, #0]
    547c:	4b0a      	ldr	r3, [pc, #40]	; (54a8 <ip_reass+0x2a0>)
    547e:	601a      	str	r2, [r3, #0]
    5480:	e056      	b.n	5530 <ip_reass+0x328>
			iprh->next_pbuf = q;
    5482:	f8cc 2000 	str.w	r2, [ip]
	int                     valid = 1;
    5486:	f04f 0e01 	mov.w	lr, #1
				ipr->p = new_p;
    548a:	6067      	str	r7, [r4, #4]
    548c:	e7ad      	b.n	53ea <ip_reass+0x1e2>
		if (iprh_prev != NULL) {
    548e:	2b00      	cmp	r3, #0
    5490:	d0e1      	beq.n	5456 <ip_reass+0x24e>
			iprh_prev->next_pbuf = new_p;
    5492:	601f      	str	r7, [r3, #0]
			if (iprh_prev->end != iprh->start) {
    5494:	88da      	ldrh	r2, [r3, #6]
    5496:	f8bc 3004 	ldrh.w	r3, [ip, #4]
    549a:	429a      	cmp	r2, r3
    549c:	d1e7      	bne.n	546e <ip_reass+0x266>
    549e:	e7a4      	b.n	53ea <ip_reass+0x1e2>
    54a0:	00002f47 	.word	0x00002f47
    54a4:	00005f25 	.word	0x00005f25
    54a8:	20001630 	.word	0x20001630
    54ac:	0000513d 	.word	0x0000513d
    54b0:	00005d21 	.word	0x00005d21
    54b4:	00005a11 	.word	0x00005a11
    54b8:	0000a101 	.word	0x0000a101
		ipr->datagram_len += IP_HLEN;
    54bc:	8ba3      	ldrh	r3, [r4, #28]
    54be:	3314      	adds	r3, #20
    54c0:	83a3      	strh	r3, [r4, #28]
		r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
    54c2:	6847      	ldr	r7, [r0, #4]
    54c4:	683e      	ldr	r6, [r7, #0]
		SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    54c6:	4623      	mov	r3, r4
    54c8:	f853 2f08 	ldr.w	r2, [r3, #8]!
    54cc:	f8d3 e004 	ldr.w	lr, [r3, #4]
    54d0:	6898      	ldr	r0, [r3, #8]
    54d2:	68d9      	ldr	r1, [r3, #12]
    54d4:	603a      	str	r2, [r7, #0]
    54d6:	f8c7 e004 	str.w	lr, [r7, #4]
    54da:	60b8      	str	r0, [r7, #8]
    54dc:	60f9      	str	r1, [r7, #12]
    54de:	691a      	ldr	r2, [r3, #16]
    54e0:	613a      	str	r2, [r7, #16]
		IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    54e2:	8ba0      	ldrh	r0, [r4, #28]
    54e4:	4b18      	ldr	r3, [pc, #96]	; (5548 <ip_reass+0x340>)
    54e6:	4798      	blx	r3
    54e8:	8078      	strh	r0, [r7, #2]
		IPH_OFFSET_SET(fraghdr, 0);
    54ea:	2300      	movs	r3, #0
    54ec:	71bb      	strb	r3, [r7, #6]
    54ee:	71fb      	strb	r3, [r7, #7]
		IPH_CHKSUM_SET(fraghdr, 0);
    54f0:	72bb      	strb	r3, [r7, #10]
    54f2:	72fb      	strb	r3, [r7, #11]
		IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    54f4:	2114      	movs	r1, #20
    54f6:	4638      	mov	r0, r7
    54f8:	4b14      	ldr	r3, [pc, #80]	; (554c <ip_reass+0x344>)
    54fa:	4798      	blx	r3
    54fc:	8178      	strh	r0, [r7, #10]
		p = ipr->p;
    54fe:	f8d4 8004 	ldr.w	r8, [r4, #4]
		while (r != NULL) {
    5502:	b17e      	cbz	r6, 5524 <ip_reass+0x31c>
			pbuf_header(r, -IP_HLEN);
    5504:	f06f 0b13 	mvn.w	fp, #19
    5508:	f8df a050 	ldr.w	sl, [pc, #80]	; 555c <ip_reass+0x354>
			pbuf_cat(p, r);
    550c:	f8df 9050 	ldr.w	r9, [pc, #80]	; 5560 <ip_reass+0x358>
			iprh = (struct ip_reass_helper *)r->payload;
    5510:	6877      	ldr	r7, [r6, #4]
			pbuf_header(r, -IP_HLEN);
    5512:	4659      	mov	r1, fp
    5514:	4630      	mov	r0, r6
    5516:	47d0      	blx	sl
			pbuf_cat(p, r);
    5518:	4631      	mov	r1, r6
    551a:	4640      	mov	r0, r8
    551c:	47c8      	blx	r9
			r = iprh->next_pbuf;
    551e:	683e      	ldr	r6, [r7, #0]
		while (r != NULL) {
    5520:	2e00      	cmp	r6, #0
    5522:	d1f5      	bne.n	5510 <ip_reass+0x308>
	if (reassdatagrams == ipr) {
    5524:	4b0a      	ldr	r3, [pc, #40]	; (5550 <ip_reass+0x348>)
    5526:	681b      	ldr	r3, [r3, #0]
    5528:	429c      	cmp	r4, r3
    552a:	d0a6      	beq.n	547a <ip_reass+0x272>
		prev->next = ipr->next;
    552c:	6823      	ldr	r3, [r4, #0]
    552e:	602b      	str	r3, [r5, #0]
	memp_free(MEMP_REASSDATA, ipr);
    5530:	4621      	mov	r1, r4
    5532:	2005      	movs	r0, #5
    5534:	4b07      	ldr	r3, [pc, #28]	; (5554 <ip_reass+0x34c>)
    5536:	4798      	blx	r3
		ip_reass_pbufcount -= pbuf_clen(p);
    5538:	4640      	mov	r0, r8
    553a:	4b07      	ldr	r3, [pc, #28]	; (5558 <ip_reass+0x350>)
    553c:	4798      	blx	r3
    553e:	4a04      	ldr	r2, [pc, #16]	; (5550 <ip_reass+0x348>)
    5540:	8893      	ldrh	r3, [r2, #4]
    5542:	1a18      	subs	r0, r3, r0
    5544:	8090      	strh	r0, [r2, #4]
		return p;
    5546:	e794      	b.n	5472 <ip_reass+0x26a>
    5548:	00002f3d 	.word	0x00002f3d
    554c:	00004bc1 	.word	0x00004bc1
    5550:	20001630 	.word	0x20001630
    5554:	00005a59 	.word	0x00005a59
    5558:	00005f25 	.word	0x00005f25
    555c:	00005c8d 	.word	0x00005c8d
    5560:	00005f45 	.word	0x00005f45

00005564 <ip_frag>:
 * @param dest destination ip address to which to send
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
    5564:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5568:	b091      	sub	sp, #68	; 0x44
    556a:	4605      	mov	r5, r0
    556c:	910d      	str	r1, [sp, #52]	; 0x34
    556e:	920e      	str	r2, [sp, #56]	; 0x38
	struct ip_hdr *original_iphdr;
#endif
	struct ip_hdr *iphdr;
	u16_t          nfb;
	u16_t          left, cop;
	u16_t          mtu = netif->mtu;
    5570:	8d8c      	ldrh	r4, [r1, #44]	; 0x2c

	/* Copy the IP header in it */
	iphdr = (struct ip_hdr *)rambuf->payload;
	SMEMCPY(iphdr, p->payload, IP_HLEN);
#else  /* IP_FRAG_USES_STATIC_BUF */
	original_iphdr = (struct ip_hdr *)p->payload;
    5572:	f8d0 b004 	ldr.w	fp, [r0, #4]
	iphdr          = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

	/* Save original offset */
	tmp = ntohs(IPH_OFFSET(iphdr));
    5576:	f8bb 0006 	ldrh.w	r0, [fp, #6]
    557a:	4b65      	ldr	r3, [pc, #404]	; (5710 <ip_frag+0x1ac>)
    557c:	4798      	blx	r3
	ofo = tmp & IP_OFFMASK;
    557e:	f3c0 030c 	ubfx	r3, r0, #0, #13
    5582:	9307      	str	r3, [sp, #28]
	omf = tmp & IP_MF;
    5584:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
    5588:	930b      	str	r3, [sp, #44]	; 0x2c

	left = p->tot_len - IP_HLEN;
    558a:	f8b5 9008 	ldrh.w	r9, [r5, #8]
    558e:	f1a9 0914 	sub.w	r9, r9, #20
    5592:	fa1f f389 	uxth.w	r3, r9
    5596:	9305      	str	r3, [sp, #20]

	nfb = (mtu - IP_HLEN) / 8;
    5598:	f1a4 0314 	sub.w	r3, r4, #20
    559c:	930a      	str	r3, [sp, #40]	; 0x28
    559e:	2b00      	cmp	r3, #0
    55a0:	bfb8      	it	lt
    55a2:	3307      	addlt	r3, #7
    55a4:	f3c3 03cf 	ubfx	r3, r3, #3, #16
    55a8:	930c      	str	r3, [sp, #48]	; 0x30

	while (left) {
    55aa:	9a05      	ldr	r2, [sp, #20]
    55ac:	2a00      	cmp	r2, #0
    55ae:	f000 80a9 	beq.w	5704 <ip_frag+0x1a0>
		if (!last) {
			tmp = tmp | IP_MF;
		}

		/* Fill this fragment */
		cop = last ? left : nfb * 8;
    55b2:	00db      	lsls	r3, r3, #3
    55b4:	b29b      	uxth	r3, r3
    55b6:	930f      	str	r3, [sp, #60]	; 0x3c
    55b8:	2400      	movs	r4, #0
    55ba:	2614      	movs	r6, #20
	return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
    55bc:	f8df a170 	ldr.w	sl, [pc, #368]	; 5730 <ip_frag+0x1cc>
			if (pcr == NULL) {
				pbuf_free(rambuf);
				return ERR_MEM;
			}
			/* Mirror this pbuf, although we might not need all of it. */
			newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
    55c0:	f8df 9170 	ldr.w	r9, [pc, #368]	; 5734 <ip_frag+0x1d0>
			if (newpbuf == NULL) {
				ip_frag_free_pbuf_custom_ref(pcr);
				pbuf_free(rambuf);
				return ERR_MEM;
			}
			pbuf_ref(p);
    55c4:	f8df 8170 	ldr.w	r8, [pc, #368]	; 5738 <ip_frag+0x1d4>
    55c8:	e052      	b.n	5670 <ip_frag+0x10c>
	return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
    55ca:	2006      	movs	r0, #6
    55cc:	47d0      	blx	sl
			if (pcr == NULL) {
    55ce:	4607      	mov	r7, r0
    55d0:	2800      	cmp	r0, #0
    55d2:	f000 8083 	beq.w	56dc <ip_frag+0x178>
			newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
    55d6:	9401      	str	r4, [sp, #4]
    55d8:	686b      	ldr	r3, [r5, #4]
    55da:	9300      	str	r3, [sp, #0]
    55dc:	4603      	mov	r3, r0
    55de:	2202      	movs	r2, #2
    55e0:	4621      	mov	r1, r4
    55e2:	2003      	movs	r0, #3
    55e4:	47c8      	blx	r9
			if (newpbuf == NULL) {
    55e6:	9003      	str	r0, [sp, #12]
    55e8:	2800      	cmp	r0, #0
    55ea:	d07f      	beq.n	56ec <ip_frag+0x188>
			pbuf_ref(p);
    55ec:	4628      	mov	r0, r5
    55ee:	47c0      	blx	r8
			pcr->original                = p;
    55f0:	617d      	str	r5, [r7, #20]
			pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
    55f2:	4b48      	ldr	r3, [pc, #288]	; (5714 <ip_frag+0x1b0>)
    55f4:	613b      	str	r3, [r7, #16]

			/* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
			 * so that it is removed when pbuf_dechain is later called on rambuf.
			 */
			pbuf_cat(rambuf, newpbuf);
    55f6:	9903      	ldr	r1, [sp, #12]
    55f8:	9804      	ldr	r0, [sp, #16]
    55fa:	4b47      	ldr	r3, [pc, #284]	; (5718 <ip_frag+0x1b4>)
    55fc:	4798      	blx	r3
			left_to_copy -= newpbuflen;
    55fe:	1b36      	subs	r6, r6, r4
    5600:	b2b6      	uxth	r6, r6
			if (left_to_copy) {
    5602:	b15e      	cbz	r6, 561c <ip_frag+0xb8>
				p = p->next;
    5604:	682d      	ldr	r5, [r5, #0]
			newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
    5606:	896c      	ldrh	r4, [r5, #10]
    5608:	42b4      	cmp	r4, r6
    560a:	bf28      	it	cs
    560c:	4634      	movcs	r4, r6
    560e:	b2a4      	uxth	r4, r4
			if (!newpbuflen) {
    5610:	2c00      	cmp	r4, #0
    5612:	d1da      	bne.n	55ca <ip_frag+0x66>
				p = p->next;
    5614:	682d      	ldr	r5, [r5, #0]
		while (left_to_copy) {
    5616:	2e00      	cmp	r6, #0
    5618:	d1f5      	bne.n	5606 <ip_frag+0xa2>
    561a:	4634      	mov	r4, r6
		poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

		/* Correct header */
		IPH_OFFSET_SET(iphdr, htons(tmp));
    561c:	9808      	ldr	r0, [sp, #32]
    561e:	4e3f      	ldr	r6, [pc, #252]	; (571c <ip_frag+0x1b8>)
    5620:	47b0      	blx	r6
    5622:	9f09      	ldr	r7, [sp, #36]	; 0x24
    5624:	80f8      	strh	r0, [r7, #6]
		IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    5626:	9b06      	ldr	r3, [sp, #24]
    5628:	f103 0014 	add.w	r0, r3, #20
    562c:	b280      	uxth	r0, r0
    562e:	47b0      	blx	r6
    5630:	8078      	strh	r0, [r7, #2]
		IPH_CHKSUM_SET(iphdr, 0);
    5632:	2300      	movs	r3, #0
    5634:	72bb      	strb	r3, [r7, #10]
    5636:	4638      	mov	r0, r7
    5638:	72fb      	strb	r3, [r7, #11]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    563a:	2114      	movs	r1, #20
    563c:	4b38      	ldr	r3, [pc, #224]	; (5720 <ip_frag+0x1bc>)
    563e:	4798      	blx	r3
    5640:	8178      	strh	r0, [r7, #10]
		}
#else  /* IP_FRAG_USES_STATIC_BUF */
        /* No need for separate header pbuf - we allowed room for it in rambuf
         * when allocated.
         */
        netif->output(netif, rambuf, dest);
    5642:	980d      	ldr	r0, [sp, #52]	; 0x34
    5644:	6943      	ldr	r3, [r0, #20]
    5646:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    5648:	9e04      	ldr	r6, [sp, #16]
    564a:	4631      	mov	r1, r6
    564c:	4798      	blx	r3
         * recreate it next time round the loop. If we're lucky the hardware
         * will have already sent the packet, the free will really free, and
         * there will be zero memory penalty.
         */

        pbuf_free(rambuf);
    564e:	4630      	mov	r0, r6
    5650:	4b34      	ldr	r3, [pc, #208]	; (5724 <ip_frag+0x1c0>)
    5652:	4798      	blx	r3
#endif /* IP_FRAG_USES_STATIC_BUF */
		left -= cop;
    5654:	9a05      	ldr	r2, [sp, #20]
    5656:	9b06      	ldr	r3, [sp, #24]
    5658:	1ad3      	subs	r3, r2, r3
    565a:	b29b      	uxth	r3, r3
    565c:	461a      	mov	r2, r3
    565e:	9305      	str	r3, [sp, #20]
		ofo += nfb;
    5660:	9b07      	ldr	r3, [sp, #28]
    5662:	990c      	ldr	r1, [sp, #48]	; 0x30
    5664:	440b      	add	r3, r1
    5666:	b29b      	uxth	r3, r3
    5668:	9307      	str	r3, [sp, #28]
    566a:	4626      	mov	r6, r4
	while (left) {
    566c:	2a00      	cmp	r2, #0
    566e:	d047      	beq.n	5700 <ip_frag+0x19c>
		tmp = omf | (IP_OFFMASK & (ofo));
    5670:	9b07      	ldr	r3, [sp, #28]
    5672:	f3c3 030c 	ubfx	r3, r3, #0, #13
    5676:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    5678:	4313      	orrs	r3, r2
    567a:	9308      	str	r3, [sp, #32]
		if (!last) {
    567c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    567e:	9905      	ldr	r1, [sp, #20]
    5680:	428a      	cmp	r2, r1
			tmp = tmp | IP_MF;
    5682:	bfbd      	ittte	lt
    5684:	f443 5300 	orrlt.w	r3, r3, #8192	; 0x2000
    5688:	9308      	strlt	r3, [sp, #32]
		cop = last ? left : nfb * 8;
    568a:	9b0f      	ldrlt	r3, [sp, #60]	; 0x3c
    568c:	9b05      	ldrge	r3, [sp, #20]
    568e:	9306      	str	r3, [sp, #24]
		rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    5690:	2200      	movs	r2, #0
    5692:	2114      	movs	r1, #20
    5694:	2002      	movs	r0, #2
    5696:	4b24      	ldr	r3, [pc, #144]	; (5728 <ip_frag+0x1c4>)
    5698:	4798      	blx	r3
		if (rambuf == NULL) {
    569a:	9004      	str	r0, [sp, #16]
    569c:	2800      	cmp	r0, #0
    569e:	d033      	beq.n	5708 <ip_frag+0x1a4>
		SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    56a0:	6843      	ldr	r3, [r0, #4]
    56a2:	f8db 2000 	ldr.w	r2, [fp]
    56a6:	f8db 7004 	ldr.w	r7, [fp, #4]
    56aa:	f8db 0008 	ldr.w	r0, [fp, #8]
    56ae:	f8db 100c 	ldr.w	r1, [fp, #12]
    56b2:	601a      	str	r2, [r3, #0]
    56b4:	605f      	str	r7, [r3, #4]
    56b6:	6098      	str	r0, [r3, #8]
    56b8:	60d9      	str	r1, [r3, #12]
    56ba:	f8db 2010 	ldr.w	r2, [fp, #16]
    56be:	611a      	str	r2, [r3, #16]
		iphdr = (struct ip_hdr *)rambuf->payload;
    56c0:	9b04      	ldr	r3, [sp, #16]
    56c2:	685b      	ldr	r3, [r3, #4]
    56c4:	9309      	str	r3, [sp, #36]	; 0x24
		p->payload = (u8_t *)p->payload + poff;
    56c6:	686b      	ldr	r3, [r5, #4]
    56c8:	4433      	add	r3, r6
    56ca:	606b      	str	r3, [r5, #4]
		p->len -= poff;
    56cc:	896b      	ldrh	r3, [r5, #10]
    56ce:	1b9e      	subs	r6, r3, r6
    56d0:	816e      	strh	r6, [r5, #10]
		while (left_to_copy) {
    56d2:	9b06      	ldr	r3, [sp, #24]
    56d4:	2b00      	cmp	r3, #0
    56d6:	d0a1      	beq.n	561c <ip_frag+0xb8>
    56d8:	461e      	mov	r6, r3
    56da:	e794      	b.n	5606 <ip_frag+0xa2>
				pbuf_free(rambuf);
    56dc:	9804      	ldr	r0, [sp, #16]
    56de:	4b11      	ldr	r3, [pc, #68]	; (5724 <ip_frag+0x1c0>)
    56e0:	4798      	blx	r3
				return ERR_MEM;
    56e2:	f04f 30ff 	mov.w	r0, #4294967295
#if IP_FRAG_USES_STATIC_BUF
	pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
	snmp_inc_ipfragoks();
	return ERR_OK;
}
    56e6:	b011      	add	sp, #68	; 0x44
    56e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	memp_free(MEMP_FRAG_PBUF, p);
    56ec:	4639      	mov	r1, r7
    56ee:	2006      	movs	r0, #6
    56f0:	4b0e      	ldr	r3, [pc, #56]	; (572c <ip_frag+0x1c8>)
    56f2:	4798      	blx	r3
				pbuf_free(rambuf);
    56f4:	9804      	ldr	r0, [sp, #16]
    56f6:	4b0b      	ldr	r3, [pc, #44]	; (5724 <ip_frag+0x1c0>)
    56f8:	4798      	blx	r3
				return ERR_MEM;
    56fa:	f04f 30ff 	mov.w	r0, #4294967295
    56fe:	e7f2      	b.n	56e6 <ip_frag+0x182>
	return ERR_OK;
    5700:	2000      	movs	r0, #0
    5702:	e7f0      	b.n	56e6 <ip_frag+0x182>
    5704:	2000      	movs	r0, #0
    5706:	e7ee      	b.n	56e6 <ip_frag+0x182>
			return ERR_MEM;
    5708:	f04f 30ff 	mov.w	r0, #4294967295
    570c:	e7eb      	b.n	56e6 <ip_frag+0x182>
    570e:	bf00      	nop
    5710:	00002f47 	.word	0x00002f47
    5714:	000051b5 	.word	0x000051b5
    5718:	00005f45 	.word	0x00005f45
    571c:	00002f3d 	.word	0x00002f3d
    5720:	00004bc1 	.word	0x00004bc1
    5724:	00005d21 	.word	0x00005d21
    5728:	00005d89 	.word	0x00005d89
    572c:	00005a59 	.word	0x00005a59
    5730:	00005a11 	.word	0x00005a11
    5734:	00005c2d 	.word	0x00005c2d
    5738:	00005f3b 	.word	0x00005f3b

0000573c <mem_init>:
	struct mem *mem;

	LWIP_ASSERT("Sanity check alignment", (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

	/* align the heap */
	ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    573c:	4b0a      	ldr	r3, [pc, #40]	; (5768 <mem_init+0x2c>)
    573e:	f023 0303 	bic.w	r3, r3, #3
    5742:	4a0a      	ldr	r2, [pc, #40]	; (576c <mem_init+0x30>)
    5744:	6013      	str	r3, [r2, #0]
	/* initialize the start of the heap */
	mem       = (struct mem *)(void *)ram;
	mem->next = MEM_SIZE_ALIGNED;
    5746:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
    574a:	8019      	strh	r1, [r3, #0]
	mem->prev = 0;
    574c:	2000      	movs	r0, #0
    574e:	8058      	strh	r0, [r3, #2]
	mem->used = 0;
    5750:	7118      	strb	r0, [r3, #4]
	/* initialize the end of the heap */
	ram_end       = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
    5752:	1858      	adds	r0, r3, r1
    5754:	6050      	str	r0, [r2, #4]
	ram_end->used = 1;
    5756:	2001      	movs	r0, #1
    5758:	f883 0fa4 	strb.w	r0, [r3, #4004]	; 0xfa4
	ram_end->next = MEM_SIZE_ALIGNED;
    575c:	f8a3 1fa0 	strh.w	r1, [r3, #4000]	; 0xfa0
	ram_end->prev = MEM_SIZE_ALIGNED;
    5760:	f8a3 1fa2 	strh.w	r1, [r3, #4002]	; 0xfa2

	/* initialize the lowest-free pointer to the start of the heap */
	lfree = (struct mem *)(void *)ram;
    5764:	6093      	str	r3, [r2, #8]
    5766:	4770      	bx	lr
    5768:	2000833f 	.word	0x2000833f
    576c:	20001638 	.word	0x20001638

00005770 <mem_free>:
void mem_free(void *rmem)
{
	struct mem *mem;
	LWIP_MEM_FREE_DECL_PROTECT();

	if (rmem == NULL) {
    5770:	2800      	cmp	r0, #0
    5772:	d03f      	beq.n	57f4 <mem_free+0x84>
    5774:	4603      	mov	r3, r0
	}
	LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) == 0);

	LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram && (u8_t *)rmem < (u8_t *)ram_end);

	if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    5776:	4a20      	ldr	r2, [pc, #128]	; (57f8 <mem_free+0x88>)
    5778:	6812      	ldr	r2, [r2, #0]
    577a:	4290      	cmp	r0, r2
    577c:	d33a      	bcc.n	57f4 <mem_free+0x84>
    577e:	491e      	ldr	r1, [pc, #120]	; (57f8 <mem_free+0x88>)
    5780:	6848      	ldr	r0, [r1, #4]
    5782:	4283      	cmp	r3, r0
    5784:	d236      	bcs.n	57f4 <mem_free+0x84>
{
    5786:	b470      	push	{r4, r5, r6}
		return;
	}
	/* protect the heap from concurrent access */
	LWIP_MEM_FREE_PROTECT();
	/* Get the corresponding struct mem ... */
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    5788:	f1a3 0108 	sub.w	r1, r3, #8
	/* ... which has to be in a used state ... */
	LWIP_ASSERT("mem_free: mem->used", mem->used);
	/* ... and is now unused. */
	mem->used = 0;
    578c:	2400      	movs	r4, #0
    578e:	f803 4c04 	strb.w	r4, [r3, #-4]

	if (mem < lfree) {
    5792:	4c19      	ldr	r4, [pc, #100]	; (57f8 <mem_free+0x88>)
    5794:	68a4      	ldr	r4, [r4, #8]
    5796:	42a1      	cmp	r1, r4
		/* the newly freed struct is now the lowest */
		lfree = mem;
    5798:	bf3c      	itt	cc
    579a:	4c17      	ldrcc	r4, [pc, #92]	; (57f8 <mem_free+0x88>)
    579c:	60a1      	strcc	r1, [r4, #8]
	nmem = (struct mem *)(void *)&ram[mem->next];
    579e:	f833 5c08 	ldrh.w	r5, [r3, #-8]
    57a2:	1954      	adds	r4, r2, r5
	if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    57a4:	42a1      	cmp	r1, r4
    57a6:	d010      	beq.n	57ca <mem_free+0x5a>
    57a8:	7926      	ldrb	r6, [r4, #4]
    57aa:	b976      	cbnz	r6, 57ca <mem_free+0x5a>
    57ac:	42a0      	cmp	r0, r4
    57ae:	d00c      	beq.n	57ca <mem_free+0x5a>
		if (lfree == nmem) {
    57b0:	4811      	ldr	r0, [pc, #68]	; (57f8 <mem_free+0x88>)
    57b2:	6880      	ldr	r0, [r0, #8]
    57b4:	4284      	cmp	r4, r0
			lfree = mem;
    57b6:	bf04      	itt	eq
    57b8:	480f      	ldreq	r0, [pc, #60]	; (57f8 <mem_free+0x88>)
    57ba:	6081      	streq	r1, [r0, #8]
		mem->next                                      = nmem->next;
    57bc:	5b50      	ldrh	r0, [r2, r5]
    57be:	f823 0c08 	strh.w	r0, [r3, #-8]
		((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    57c2:	5b50      	ldrh	r0, [r2, r5]
    57c4:	4410      	add	r0, r2
    57c6:	1a8c      	subs	r4, r1, r2
    57c8:	8044      	strh	r4, [r0, #2]
	pmem = (struct mem *)(void *)&ram[mem->prev];
    57ca:	f833 0c06 	ldrh.w	r0, [r3, #-6]
    57ce:	1814      	adds	r4, r2, r0
	if (pmem != mem && pmem->used == 0) {
    57d0:	42a1      	cmp	r1, r4
    57d2:	d00e      	beq.n	57f2 <mem_free+0x82>
    57d4:	7925      	ldrb	r5, [r4, #4]
    57d6:	b965      	cbnz	r5, 57f2 <mem_free+0x82>
		if (lfree == mem) {
    57d8:	4d07      	ldr	r5, [pc, #28]	; (57f8 <mem_free+0x88>)
    57da:	68ad      	ldr	r5, [r5, #8]
    57dc:	42a9      	cmp	r1, r5
			lfree = pmem;
    57de:	bf04      	itt	eq
    57e0:	4905      	ldreq	r1, [pc, #20]	; (57f8 <mem_free+0x88>)
    57e2:	608c      	streq	r4, [r1, #8]
		pmem->next                                    = mem->next;
    57e4:	f833 1c08 	ldrh.w	r1, [r3, #-8]
    57e8:	5211      	strh	r1, [r2, r0]
		((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    57ea:	f833 3c08 	ldrh.w	r3, [r3, #-8]
    57ee:	441a      	add	r2, r3
    57f0:	8050      	strh	r0, [r2, #2]
	plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_FREE_UNPROTECT();
}
    57f2:	bc70      	pop	{r4, r5, r6}
    57f4:	4770      	bx	lr
    57f6:	bf00      	nop
    57f8:	20001638 	.word	0x20001638

000057fc <mem_trim>:
	/* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
	LWIP_MEM_FREE_DECL_PROTECT();

	/* Expand the size of the allocated memory region so that we can
	   adjust for alignment. */
	newsize = LWIP_MEM_ALIGN_SIZE(newsize);
    57fc:	3103      	adds	r1, #3
    57fe:	f64f 73fc 	movw	r3, #65532	; 0xfffc
    5802:	400b      	ands	r3, r1
    5804:	2b0c      	cmp	r3, #12
    5806:	bf38      	it	cc
    5808:	230c      	movcc	r3, #12
	if (newsize < MIN_SIZE_ALIGNED) {
		/* every data block must be at least MIN_SIZE_ALIGNED long */
		newsize = MIN_SIZE_ALIGNED;
	}

	if (newsize > MEM_SIZE_ALIGNED) {
    580a:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
    580e:	d852      	bhi.n	58b6 <mem_trim+0xba>
		return NULL;
	}

	LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram && (u8_t *)rmem < (u8_t *)ram_end);

	if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    5810:	4a2b      	ldr	r2, [pc, #172]	; (58c0 <mem_trim+0xc4>)
    5812:	6812      	ldr	r2, [r2, #0]
    5814:	4282      	cmp	r2, r0
    5816:	d82b      	bhi.n	5870 <mem_trim+0x74>
    5818:	4929      	ldr	r1, [pc, #164]	; (58c0 <mem_trim+0xc4>)
    581a:	6849      	ldr	r1, [r1, #4]
    581c:	4288      	cmp	r0, r1
    581e:	d227      	bcs.n	5870 <mem_trim+0x74>
{
    5820:	b4f0      	push	{r4, r5, r6, r7}
		MEM_STATS_INC(illegal);
		SYS_ARCH_UNPROTECT(lev);
		return rmem;
	}
	/* Get the corresponding struct mem ... */
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    5822:	f1a0 0408 	sub.w	r4, r0, #8
	/* ... and its offset pointer */
	ptr = (mem_size_t)((u8_t *)mem - ram);
    5826:	1aa4      	subs	r4, r4, r2
    5828:	b2a4      	uxth	r4, r4

	size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    582a:	f830 5c08 	ldrh.w	r5, [r0, #-8]
    582e:	f1a5 0108 	sub.w	r1, r5, #8
    5832:	1b09      	subs	r1, r1, r4
    5834:	b289      	uxth	r1, r1
	LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
	if (newsize > size) {
    5836:	4299      	cmp	r1, r3
    5838:	d33f      	bcc.n	58ba <mem_trim+0xbe>
		/* not supported */
		return NULL;
	}
	if (newsize == size) {
    583a:	d018      	beq.n	586e <mem_trim+0x72>
	}

	/* protect the heap from concurrent access */
	LWIP_MEM_FREE_PROTECT();

	mem2 = (struct mem *)(void *)&ram[mem->next];
    583c:	1956      	adds	r6, r2, r5
	if (mem2->used == 0) {
    583e:	7937      	ldrb	r7, [r6, #4]
    5840:	b9df      	cbnz	r7, 587a <mem_trim+0x7e>
		/* The next struct is unused, we can simply move it at little */
		mem_size_t next;
		/* remember the old next pointer */
		next = mem2->next;
    5842:	5b55      	ldrh	r5, [r2, r5]
		/* create new struct mem which is moved directly after the shrinked mem */
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    5844:	f104 0108 	add.w	r1, r4, #8
    5848:	440b      	add	r3, r1
    584a:	b29b      	uxth	r3, r3
		if (lfree == mem2) {
    584c:	491c      	ldr	r1, [pc, #112]	; (58c0 <mem_trim+0xc4>)
    584e:	6889      	ldr	r1, [r1, #8]
    5850:	428e      	cmp	r6, r1
    5852:	d00e      	beq.n	5872 <mem_trim+0x76>
			lfree = (struct mem *)(void *)&ram[ptr2];
		}
		mem2       = (struct mem *)(void *)&ram[ptr2];
    5854:	18d1      	adds	r1, r2, r3
		mem2->used = 0;
    5856:	2600      	movs	r6, #0
    5858:	710e      	strb	r6, [r1, #4]
		/* restore the next pointer */
		mem2->next = next;
    585a:	52d5      	strh	r5, [r2, r3]
		/* link it back to mem */
		mem2->prev = ptr;
    585c:	804c      	strh	r4, [r1, #2]
		/* link mem to it */
		mem->next = ptr2;
    585e:	f820 3c08 	strh.w	r3, [r0, #-8]
		/* last thing to restore linked list: as we have moved mem2,
		 * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
		 * the end of the heap */
		if (mem2->next != MEM_SIZE_ALIGNED) {
    5862:	5ad1      	ldrh	r1, [r2, r3]
    5864:	f5b1 6f7a 	cmp.w	r1, #4000	; 0xfa0
    5868:	d001      	beq.n	586e <mem_trim+0x72>
			((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    586a:	440a      	add	r2, r1
    586c:	8053      	strh	r3, [r2, #2]
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_FREE_UNPROTECT();
	return rmem;
}
    586e:	bcf0      	pop	{r4, r5, r6, r7}
    5870:	4770      	bx	lr
			lfree = (struct mem *)(void *)&ram[ptr2];
    5872:	18d1      	adds	r1, r2, r3
    5874:	4e12      	ldr	r6, [pc, #72]	; (58c0 <mem_trim+0xc4>)
    5876:	60b1      	str	r1, [r6, #8]
    5878:	e7ec      	b.n	5854 <mem_trim+0x58>
	} else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
    587a:	f103 0514 	add.w	r5, r3, #20
    587e:	428d      	cmp	r5, r1
    5880:	d8f5      	bhi.n	586e <mem_trim+0x72>
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    5882:	f104 0108 	add.w	r1, r4, #8
    5886:	440b      	add	r3, r1
    5888:	b29b      	uxth	r3, r3
		mem2 = (struct mem *)(void *)&ram[ptr2];
    588a:	18d1      	adds	r1, r2, r3
		if (mem2 < lfree) {
    588c:	4d0c      	ldr	r5, [pc, #48]	; (58c0 <mem_trim+0xc4>)
    588e:	68ad      	ldr	r5, [r5, #8]
    5890:	42a9      	cmp	r1, r5
			lfree = mem2;
    5892:	bf3c      	itt	cc
    5894:	4d0a      	ldrcc	r5, [pc, #40]	; (58c0 <mem_trim+0xc4>)
    5896:	60a9      	strcc	r1, [r5, #8]
		mem2->used = 0;
    5898:	2500      	movs	r5, #0
    589a:	710d      	strb	r5, [r1, #4]
		mem2->next = mem->next;
    589c:	f830 5c08 	ldrh.w	r5, [r0, #-8]
    58a0:	52d5      	strh	r5, [r2, r3]
		mem2->prev = ptr;
    58a2:	804c      	strh	r4, [r1, #2]
		mem->next  = ptr2;
    58a4:	f820 3c08 	strh.w	r3, [r0, #-8]
		if (mem2->next != MEM_SIZE_ALIGNED) {
    58a8:	5ad1      	ldrh	r1, [r2, r3]
    58aa:	f5b1 6f7a 	cmp.w	r1, #4000	; 0xfa0
    58ae:	d0de      	beq.n	586e <mem_trim+0x72>
			((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    58b0:	440a      	add	r2, r1
    58b2:	8053      	strh	r3, [r2, #2]
    58b4:	e7db      	b.n	586e <mem_trim+0x72>
		return NULL;
    58b6:	2000      	movs	r0, #0
    58b8:	4770      	bx	lr
		return NULL;
    58ba:	2000      	movs	r0, #0
    58bc:	e7d7      	b.n	586e <mem_trim+0x72>
    58be:	bf00      	nop
    58c0:	20001638 	.word	0x20001638

000058c4 <mem_malloc>:
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	u8_t        local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_ALLOC_DECL_PROTECT();

	if (size == 0) {
    58c4:	2800      	cmp	r0, #0
    58c6:	d05f      	beq.n	5988 <mem_malloc+0xc4>
{
    58c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    58ca:	4603      	mov	r3, r0
		return NULL;
	}

	/* Expand the size of the allocated memory region so that we can
	   adjust for alignment. */
	size = LWIP_MEM_ALIGN_SIZE(size);
    58cc:	3303      	adds	r3, #3
    58ce:	f64f 74fc 	movw	r4, #65532	; 0xfffc
    58d2:	401c      	ands	r4, r3
    58d4:	2c0c      	cmp	r4, #12
    58d6:	bf38      	it	cc
    58d8:	240c      	movcc	r4, #12
	if (size < MIN_SIZE_ALIGNED) {
		/* every data block must be at least MIN_SIZE_ALIGNED long */
		size = MIN_SIZE_ALIGNED;
	}

	if (size > MEM_SIZE_ALIGNED) {
    58da:	f5b4 6f7a 	cmp.w	r4, #4000	; 0xfa0
    58de:	d855      	bhi.n	598c <mem_malloc+0xc8>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

		/* Scan through the heap searching for a free block that is big enough,
		 * beginning with the lowest free block.
		 */
		for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    58e0:	4b2c      	ldr	r3, [pc, #176]	; (5994 <mem_malloc+0xd0>)
    58e2:	689f      	ldr	r7, [r3, #8]
    58e4:	6819      	ldr	r1, [r3, #0]
    58e6:	1a7b      	subs	r3, r7, r1
    58e8:	b29b      	uxth	r3, r3
    58ea:	f5c4 657a 	rsb	r5, r4, #4000	; 0xfa0
    58ee:	42ab      	cmp	r3, r5
    58f0:	da4e      	bge.n	5990 <mem_malloc+0xcc>
				local_mem_free_count = 1;
				break;
			}
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

			if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    58f2:	f06f 0c07 	mvn.w	ip, #7
    58f6:	46a6      	mov	lr, r4
    58f8:	e00e      	b.n	5918 <mem_malloc+0x54>
					 * take care of this).
					 * -> near fit or excact fit: do not split, no mem2 creation
					 * also can't move mem->next directly behind mem, since mem->next
					 * will always be used at this point!
					 */
					mem->used = 1;
    58fa:	2301      	movs	r3, #1
    58fc:	7103      	strb	r3, [r0, #4]
					MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
				}
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
			mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
				if (mem == lfree) {
    58fe:	4b25      	ldr	r3, [pc, #148]	; (5994 <mem_malloc+0xd0>)
    5900:	689b      	ldr	r3, [r3, #8]
    5902:	4298      	cmp	r0, r3
    5904:	d02f      	beq.n	5966 <mem_malloc+0xa2>
				            (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
				LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
				            ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
				LWIP_ASSERT("mem_malloc: sanity check alignment", (((mem_ptr_t)mem) & (MEM_ALIGNMENT - 1)) == 0);

				return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    5906:	3008      	adds	r0, #8
    5908:	bdf0      	pop	{r4, r5, r6, r7, pc}
			mem            = (struct mem *)(void *)&ram[ptr];
    590a:	4603      	mov	r3, r0
    590c:	e037      	b.n	597e <mem_malloc+0xba>
    590e:	4603      	mov	r3, r0
    5910:	e035      	b.n	597e <mem_malloc+0xba>
		     ptr = ((struct mem *)(void *)&ram[ptr])->next) {
    5912:	8803      	ldrh	r3, [r0, #0]
		for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    5914:	42ab      	cmp	r3, r5
    5916:	da35      	bge.n	5984 <mem_malloc+0xc0>
			mem            = (struct mem *)(void *)&ram[ptr];
    5918:	18c8      	adds	r0, r1, r3
			if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    591a:	7902      	ldrb	r2, [r0, #4]
    591c:	2a00      	cmp	r2, #0
    591e:	d1f8      	bne.n	5912 <mem_malloc+0x4e>
    5920:	ebac 0203 	sub.w	r2, ip, r3
    5924:	5ace      	ldrh	r6, [r1, r3]
    5926:	4432      	add	r2, r6
    5928:	4676      	mov	r6, lr
    592a:	42a2      	cmp	r2, r4
    592c:	d3f1      	bcc.n	5912 <mem_malloc+0x4e>
				if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
    592e:	3614      	adds	r6, #20
    5930:	42b2      	cmp	r2, r6
    5932:	d3e2      	bcc.n	58fa <mem_malloc+0x36>
					ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
    5934:	f104 0208 	add.w	r2, r4, #8
    5938:	441a      	add	r2, r3
    593a:	b292      	uxth	r2, r2
					mem2       = (struct mem *)(void *)&ram[ptr2];
    593c:	188c      	adds	r4, r1, r2
					mem2->used = 0;
    593e:	2500      	movs	r5, #0
    5940:	7125      	strb	r5, [r4, #4]
					mem2->next = mem->next;
    5942:	8805      	ldrh	r5, [r0, #0]
    5944:	528d      	strh	r5, [r1, r2]
					mem2->prev = ptr;
    5946:	8063      	strh	r3, [r4, #2]
					mem->next = ptr2;
    5948:	8002      	strh	r2, [r0, #0]
					mem->used = 1;
    594a:	2301      	movs	r3, #1
    594c:	7103      	strb	r3, [r0, #4]
					if (mem2->next != MEM_SIZE_ALIGNED) {
    594e:	5a8b      	ldrh	r3, [r1, r2]
    5950:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
    5954:	d0d3      	beq.n	58fe <mem_malloc+0x3a>
						((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    5956:	4419      	add	r1, r3
    5958:	804a      	strh	r2, [r1, #2]
				if (mem == lfree) {
    595a:	4287      	cmp	r7, r0
    595c:	d1d3      	bne.n	5906 <mem_malloc+0x42>
					while (cur->used && cur != ram_end) {
    595e:	7903      	ldrb	r3, [r0, #4]
    5960:	2b00      	cmp	r3, #0
    5962:	d0d2      	beq.n	590a <mem_malloc+0x46>
				if (mem == lfree) {
    5964:	4603      	mov	r3, r0
					while (cur->used && cur != ram_end) {
    5966:	4a0b      	ldr	r2, [pc, #44]	; (5994 <mem_malloc+0xd0>)
    5968:	6851      	ldr	r1, [r2, #4]
    596a:	4288      	cmp	r0, r1
    596c:	d0cf      	beq.n	590e <mem_malloc+0x4a>
						cur = (struct mem *)(void *)&ram[cur->next];
    596e:	6814      	ldr	r4, [r2, #0]
    5970:	881b      	ldrh	r3, [r3, #0]
    5972:	4423      	add	r3, r4
					while (cur->used && cur != ram_end) {
    5974:	791a      	ldrb	r2, [r3, #4]
    5976:	b112      	cbz	r2, 597e <mem_malloc+0xba>
    5978:	428b      	cmp	r3, r1
    597a:	d1f9      	bne.n	5970 <mem_malloc+0xac>
						cur = (struct mem *)(void *)&ram[cur->next];
    597c:	460b      	mov	r3, r1
					lfree = cur;
    597e:	4a05      	ldr	r2, [pc, #20]	; (5994 <mem_malloc+0xd0>)
    5980:	6093      	str	r3, [r2, #8]
    5982:	e7c0      	b.n	5906 <mem_malloc+0x42>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %" S16_F " bytes\n", (s16_t)size));
	MEM_STATS_INC(err);
	LWIP_MEM_ALLOC_UNPROTECT();
	sys_mutex_unlock(&mem_mutex);
	return NULL;
    5984:	2000      	movs	r0, #0
    5986:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return NULL;
    5988:	2000      	movs	r0, #0
    598a:	4770      	bx	lr
		return NULL;
    598c:	2000      	movs	r0, #0
    598e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return NULL;
    5990:	2000      	movs	r0, #0
    5992:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5994:	20001638 	.word	0x20001638

00005998 <memp_init>:
 * Initialize this module.
 *
 * Carves out memp_memory into linked lists for each pool-type.
 */
void memp_init(void)
{
    5998:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		MEMP_STATS_AVAIL(err, i, 0);
		MEMP_STATS_AVAIL(avail, i, memp_num[i]);
	}

#if !MEMP_SEPARATE_POOLS
	memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
    599c:	4f19      	ldr	r7, [pc, #100]	; (5a04 <memp_init+0x6c>)
    599e:	f027 0703 	bic.w	r7, r7, #3
    59a2:	4b19      	ldr	r3, [pc, #100]	; (5a08 <memp_init+0x70>)
    59a4:	f503 7655 	add.w	r6, r3, #852	; 0x354
    59a8:	f8df c060 	ldr.w	ip, [pc, #96]	; 5a0c <memp_init+0x74>
    59ac:	f10c 0e14 	add.w	lr, ip, #20
    59b0:	f503 795f 	add.w	r9, r3, #892	; 0x37c
#endif /* !MEMP_SEPARATE_POOLS */
	/* for every pool: */
	for (i = 0; i < MEMP_MAX; ++i) {
		memp_tab[i] = NULL;
    59b4:	f04f 0a00 	mov.w	sl, #0
    59b8:	e015      	b.n	59e6 <memp_init+0x4e>
#endif /* MEMP_SEPARATE_POOLS */
		/* create a linked list of memp elements */
		for (j = 0; j < memp_num[i]; ++j) {
			memp->next  = memp_tab[i];
			memp_tab[i] = memp;
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    59ba:	4603      	mov	r3, r0
			memp->next  = memp_tab[i];
    59bc:	6019      	str	r1, [r3, #0]
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    59be:	1958      	adds	r0, r3, r5
    59c0:	3201      	adds	r2, #1
			memp_tab[i] = memp;
    59c2:	4619      	mov	r1, r3
		for (j = 0; j < memp_num[i]; ++j) {
    59c4:	b293      	uxth	r3, r2
    59c6:	429c      	cmp	r4, r3
    59c8:	d8f7      	bhi.n	59ba <memp_init+0x22>
    59ca:	3c01      	subs	r4, #1
    59cc:	b2a4      	uxth	r4, r4
    59ce:	fb04 5305 	mla	r3, r4, r5, r5
    59d2:	fb04 7405 	mla	r4, r4, r5, r7
    59d6:	f8c8 4000 	str.w	r4, [r8]
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    59da:	441f      	add	r7, r3
    59dc:	3604      	adds	r6, #4
    59de:	f10e 0e02 	add.w	lr, lr, #2
	for (i = 0; i < MEMP_MAX; ++i) {
    59e2:	45b1      	cmp	r9, r6
    59e4:	d00c      	beq.n	5a00 <memp_init+0x68>
    59e6:	46b0      	mov	r8, r6
		memp_tab[i] = NULL;
    59e8:	f8c6 a000 	str.w	sl, [r6]
		for (j = 0; j < memp_num[i]; ++j) {
    59ec:	f83c 4b02 	ldrh.w	r4, [ip], #2
    59f0:	2c00      	cmp	r4, #0
    59f2:	d0f3      	beq.n	59dc <memp_init+0x44>
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    59f4:	f8be 5000 	ldrh.w	r5, [lr]
    59f8:	463b      	mov	r3, r7
    59fa:	2200      	movs	r2, #0
    59fc:	4611      	mov	r1, r2
    59fe:	e7dd      	b.n	59bc <memp_init+0x24>
#if MEMP_OVERFLOW_CHECK
	memp_overflow_init();
	/* check everything a first time to see if it worked */
	memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
    5a00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5a04:	20001647 	.word	0x20001647
    5a08:	20007c14 	.word	0x20007c14
    5a0c:	0000c3e0 	.word	0x0000c3e0

00005a10 <memp_malloc>:
#endif
{
	struct memp *memp;
	SYS_ARCH_DECL_PROTECT(old_level);

	LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    5a10:	2809      	cmp	r0, #9
    5a12:	d80d      	bhi.n	5a30 <memp_malloc+0x20>
	SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
	memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

	memp = memp_tab[type];
    5a14:	4b0b      	ldr	r3, [pc, #44]	; (5a44 <memp_malloc+0x34>)
    5a16:	eb03 0380 	add.w	r3, r3, r0, lsl #2
    5a1a:	f8d3 3354 	ldr.w	r3, [r3, #852]	; 0x354

	if (memp != NULL) {
    5a1e:	b12b      	cbz	r3, 5a2c <memp_malloc+0x1c>
		memp_tab[type] = memp->next;
    5a20:	6819      	ldr	r1, [r3, #0]
    5a22:	4a08      	ldr	r2, [pc, #32]	; (5a44 <memp_malloc+0x34>)
    5a24:	eb02 0280 	add.w	r2, r2, r0, lsl #2
    5a28:	f8c2 1354 	str.w	r1, [r2, #852]	; 0x354
	}

	SYS_ARCH_UNPROTECT(old_level);

	return memp;
}
    5a2c:	4618      	mov	r0, r3
    5a2e:	4770      	bx	lr
{
    5a30:	b510      	push	{r4, lr}
	LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    5a32:	4b05      	ldr	r3, [pc, #20]	; (5a48 <memp_malloc+0x38>)
    5a34:	f240 1289 	movw	r2, #393	; 0x189
    5a38:	4904      	ldr	r1, [pc, #16]	; (5a4c <memp_malloc+0x3c>)
    5a3a:	4805      	ldr	r0, [pc, #20]	; (5a50 <memp_malloc+0x40>)
    5a3c:	4c05      	ldr	r4, [pc, #20]	; (5a54 <memp_malloc+0x44>)
    5a3e:	47a0      	blx	r4
    5a40:	e7fe      	b.n	5a40 <memp_malloc+0x30>
    5a42:	bf00      	nop
    5a44:	20007c14 	.word	0x20007c14
    5a48:	0000c408 	.word	0x0000c408
    5a4c:	0000c42c 	.word	0x0000c42c
    5a50:	0000b428 	.word	0x0000b428
    5a54:	0000a111 	.word	0x0000a111

00005a58 <memp_free>:
void memp_free(memp_t type, void *mem)
{
	struct memp *memp;
	SYS_ARCH_DECL_PROTECT(old_level);

	if (mem == NULL) {
    5a58:	b139      	cbz	r1, 5a6a <memp_free+0x12>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

	MEMP_STATS_DEC(used, type);

	memp->next     = memp_tab[type];
    5a5a:	4b04      	ldr	r3, [pc, #16]	; (5a6c <memp_free+0x14>)
    5a5c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    5a60:	f8d0 3354 	ldr.w	r3, [r0, #852]	; 0x354
    5a64:	600b      	str	r3, [r1, #0]
	memp_tab[type] = memp;
    5a66:	f8c0 1354 	str.w	r1, [r0, #852]	; 0x354
    5a6a:	4770      	bx	lr
    5a6c:	20007c14 	.word	0x20007c14

00005a70 <netif_init>:
	return ERR_OK;
}
#endif /* LWIP_HAVE_LOOPIF */

void netif_init(void)
{
    5a70:	4770      	bx	lr
	...

00005a74 <netif_set_ipaddr>:
 *
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
    5a74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5a76:	4604      	mov	r4, r0
#if LWIP_TCP
	struct tcp_pcb *       pcb;
	struct tcp_pcb_listen *lpcb;

	/* address is actually being changed? */
	if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    5a78:	2900      	cmp	r1, #0
    5a7a:	d027      	beq.n	5acc <netif_set_ipaddr+0x58>
    5a7c:	460d      	mov	r5, r1
    5a7e:	680a      	ldr	r2, [r1, #0]
    5a80:	6843      	ldr	r3, [r0, #4]
    5a82:	429a      	cmp	r2, r3
    5a84:	d011      	beq.n	5aaa <netif_set_ipaddr+0x36>
		/* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
		pcb = tcp_active_pcbs;
    5a86:	4b12      	ldr	r3, [pc, #72]	; (5ad0 <netif_set_ipaddr+0x5c>)
    5a88:	6818      	ldr	r0, [r3, #0]
		while (pcb != NULL) {
    5a8a:	b158      	cbz	r0, 5aa4 <netif_set_ipaddr+0x30>
#endif /* LWIP_AUTOIP */
			) {
				/* this connection must be aborted */
				struct tcp_pcb *next = pcb->next;
				LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
				tcp_abort(pcb);
    5a8c:	4f11      	ldr	r7, [pc, #68]	; (5ad4 <netif_set_ipaddr+0x60>)
    5a8e:	e003      	b.n	5a98 <netif_set_ipaddr+0x24>
				struct tcp_pcb *next = pcb->next;
    5a90:	68c6      	ldr	r6, [r0, #12]
				tcp_abort(pcb);
    5a92:	47b8      	blx	r7
				pcb = next;
    5a94:	4630      	mov	r0, r6
		while (pcb != NULL) {
    5a96:	b128      	cbz	r0, 5aa4 <netif_set_ipaddr+0x30>
			if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
    5a98:	6802      	ldr	r2, [r0, #0]
    5a9a:	6863      	ldr	r3, [r4, #4]
    5a9c:	429a      	cmp	r2, r3
    5a9e:	d0f7      	beq.n	5a90 <netif_set_ipaddr+0x1c>
			} else {
				pcb = pcb->next;
    5aa0:	68c0      	ldr	r0, [r0, #12]
    5aa2:	e7f8      	b.n	5a96 <netif_set_ipaddr+0x22>
			}
		}
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    5aa4:	4b0c      	ldr	r3, [pc, #48]	; (5ad8 <netif_set_ipaddr+0x64>)
    5aa6:	681b      	ldr	r3, [r3, #0]
    5aa8:	b92b      	cbnz	r3, 5ab6 <netif_set_ipaddr+0x42>
	}
#endif
	snmp_delete_ipaddridx_tree(netif);
	snmp_delete_iprteidx_tree(0, netif);
	/* set new IP address to netif */
	ip_addr_set(&(netif->ip_addr), ipaddr);
    5aaa:	682b      	ldr	r3, [r5, #0]
    5aac:	6063      	str	r3, [r4, #4]
	             netif->name[1],
	             ip4_addr1_16(&netif->ip_addr),
	             ip4_addr2_16(&netif->ip_addr),
	             ip4_addr3_16(&netif->ip_addr),
	             ip4_addr4_16(&netif->ip_addr)));
}
    5aae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    5ab0:	68db      	ldr	r3, [r3, #12]
    5ab2:	2b00      	cmp	r3, #0
    5ab4:	d0f9      	beq.n	5aaa <netif_set_ipaddr+0x36>
			if ((!(ip_addr_isany(&(lpcb->local_ip)))) && (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
    5ab6:	2b00      	cmp	r3, #0
    5ab8:	d0fa      	beq.n	5ab0 <netif_set_ipaddr+0x3c>
    5aba:	681a      	ldr	r2, [r3, #0]
    5abc:	2a00      	cmp	r2, #0
    5abe:	d0f7      	beq.n	5ab0 <netif_set_ipaddr+0x3c>
    5ac0:	6861      	ldr	r1, [r4, #4]
    5ac2:	428a      	cmp	r2, r1
				ip_addr_set(&(lpcb->local_ip), ipaddr);
    5ac4:	bf04      	itt	eq
    5ac6:	682a      	ldreq	r2, [r5, #0]
    5ac8:	601a      	streq	r2, [r3, #0]
    5aca:	e7f1      	b.n	5ab0 <netif_set_ipaddr+0x3c>
	ip_addr_set(&(netif->ip_addr), ipaddr);
    5acc:	2300      	movs	r3, #0
    5ace:	e7ed      	b.n	5aac <netif_set_ipaddr+0x38>
    5ad0:	20009300 	.word	0x20009300
    5ad4:	00006ab5 	.word	0x00006ab5
    5ad8:	20009308 	.word	0x20009308

00005adc <netif_set_addr>:
{
    5adc:	b570      	push	{r4, r5, r6, lr}
    5ade:	4604      	mov	r4, r0
    5ae0:	4616      	mov	r6, r2
    5ae2:	461d      	mov	r5, r3
	netif_set_ipaddr(netif, ipaddr);
    5ae4:	4b06      	ldr	r3, [pc, #24]	; (5b00 <netif_set_addr+0x24>)
    5ae6:	4798      	blx	r3
 */
void netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
	snmp_delete_iprteidx_tree(0, netif);
	/* set new netmask to netif */
	ip_addr_set(&(netif->netmask), netmask);
    5ae8:	b12e      	cbz	r6, 5af6 <netif_set_addr+0x1a>
    5aea:	6833      	ldr	r3, [r6, #0]
    5aec:	60a3      	str	r3, [r4, #8]
	ip_addr_set(&(netif->gw), gw);
    5aee:	b125      	cbz	r5, 5afa <netif_set_addr+0x1e>
    5af0:	682b      	ldr	r3, [r5, #0]
    5af2:	60e3      	str	r3, [r4, #12]
    5af4:	bd70      	pop	{r4, r5, r6, pc}
	ip_addr_set(&(netif->netmask), netmask);
    5af6:	2300      	movs	r3, #0
    5af8:	e7f8      	b.n	5aec <netif_set_addr+0x10>
	ip_addr_set(&(netif->gw), gw);
    5afa:	2300      	movs	r3, #0
    5afc:	e7f9      	b.n	5af2 <netif_set_addr+0x16>
    5afe:	bf00      	nop
    5b00:	00005a75 	.word	0x00005a75

00005b04 <netif_add>:
{
    5b04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5b06:	4604      	mov	r4, r0
	ip_addr_set_zero(&netif->ip_addr);
    5b08:	2500      	movs	r5, #0
    5b0a:	6045      	str	r5, [r0, #4]
	ip_addr_set_zero(&netif->netmask);
    5b0c:	6085      	str	r5, [r0, #8]
	ip_addr_set_zero(&netif->gw);
    5b0e:	60c5      	str	r5, [r0, #12]
	netif->flags = 0;
    5b10:	f880 5035 	strb.w	r5, [r0, #53]	; 0x35
	netif->dhcp = NULL;
    5b14:	6285      	str	r5, [r0, #40]	; 0x28
	netif->status_callback = NULL;
    5b16:	61c5      	str	r5, [r0, #28]
	netif->link_callback = NULL;
    5b18:	6205      	str	r5, [r0, #32]
	netif->state = state;
    5b1a:	9d06      	ldr	r5, [sp, #24]
    5b1c:	6245      	str	r5, [r0, #36]	; 0x24
	netif->num   = netif_num++;
    5b1e:	4e0b      	ldr	r6, [pc, #44]	; (5b4c <netif_add+0x48>)
    5b20:	7835      	ldrb	r5, [r6, #0]
    5b22:	1c6f      	adds	r7, r5, #1
    5b24:	7037      	strb	r7, [r6, #0]
    5b26:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
	netif->input = input;
    5b2a:	9d08      	ldr	r5, [sp, #32]
    5b2c:	6105      	str	r5, [r0, #16]
	netif_set_addr(netif, ipaddr, netmask, gw);
    5b2e:	4d08      	ldr	r5, [pc, #32]	; (5b50 <netif_add+0x4c>)
    5b30:	47a8      	blx	r5
	if (init(netif) != ERR_OK) {
    5b32:	4620      	mov	r0, r4
    5b34:	9b07      	ldr	r3, [sp, #28]
    5b36:	4798      	blx	r3
    5b38:	b928      	cbnz	r0, 5b46 <netif_add+0x42>
	netif->next = netif_list;
    5b3a:	4b06      	ldr	r3, [pc, #24]	; (5b54 <netif_add+0x50>)
    5b3c:	681a      	ldr	r2, [r3, #0]
    5b3e:	6022      	str	r2, [r4, #0]
	netif_list  = netif;
    5b40:	601c      	str	r4, [r3, #0]
	return netif;
    5b42:	4620      	mov	r0, r4
    5b44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return NULL;
    5b46:	2000      	movs	r0, #0
}
    5b48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5b4a:	bf00      	nop
    5b4c:	20007f90 	.word	0x20007f90
    5b50:	00005add 	.word	0x00005add
    5b54:	200092f0 	.word	0x200092f0

00005b58 <netif_set_gw>:
	ip_addr_set(&(netif->gw), gw);
    5b58:	b111      	cbz	r1, 5b60 <netif_set_gw+0x8>
    5b5a:	680b      	ldr	r3, [r1, #0]
    5b5c:	60c3      	str	r3, [r0, #12]
    5b5e:	4770      	bx	lr
    5b60:	2300      	movs	r3, #0
    5b62:	e7fb      	b.n	5b5c <netif_set_gw+0x4>

00005b64 <netif_set_netmask>:
	ip_addr_set(&(netif->netmask), netmask);
    5b64:	b111      	cbz	r1, 5b6c <netif_set_netmask+0x8>
    5b66:	680b      	ldr	r3, [r1, #0]
    5b68:	6083      	str	r3, [r0, #8]
    5b6a:	4770      	bx	lr
    5b6c:	2300      	movs	r3, #0
    5b6e:	e7fb      	b.n	5b68 <netif_set_netmask+0x4>

00005b70 <netif_set_default>:
		snmp_delete_iprteidx_tree(1, netif);
	} else {
		/* install default route */
		snmp_insert_iprteidx_tree(1, netif);
	}
	netif_default = netif;
    5b70:	4b01      	ldr	r3, [pc, #4]	; (5b78 <netif_set_default+0x8>)
    5b72:	6018      	str	r0, [r3, #0]
    5b74:	4770      	bx	lr
    5b76:	bf00      	nop
    5b78:	200092f4 	.word	0x200092f4

00005b7c <netif_set_up>:
 *
 * @see dhcp_start()
 */
void netif_set_up(struct netif *netif)
{
	if (!(netif->flags & NETIF_FLAG_UP)) {
    5b7c:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
    5b80:	f013 0f01 	tst.w	r3, #1
    5b84:	d114      	bne.n	5bb0 <netif_set_up+0x34>
{
    5b86:	b510      	push	{r4, lr}
    5b88:	4604      	mov	r4, r0
		netif->flags |= NETIF_FLAG_UP;
    5b8a:	f043 0301 	orr.w	r3, r3, #1
    5b8e:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35

#if LWIP_SNMP
		snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

		NETIF_STATUS_CALLBACK(netif);
    5b92:	69c3      	ldr	r3, [r0, #28]
    5b94:	b103      	cbz	r3, 5b98 <netif_set_up+0x1c>
    5b96:	4798      	blx	r3

		if (netif->flags & NETIF_FLAG_LINK_UP) {
#if LWIP_ARP
			/* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
			if (netif->flags & (NETIF_FLAG_ETHARP)) {
    5b98:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    5b9c:	f003 0330 	and.w	r3, r3, #48	; 0x30
    5ba0:	2b30      	cmp	r3, #48	; 0x30
    5ba2:	d000      	beq.n	5ba6 <netif_set_up+0x2a>
    5ba4:	bd10      	pop	{r4, pc}
				etharp_gratuitous(netif);
    5ba6:	1d21      	adds	r1, r4, #4
    5ba8:	4620      	mov	r0, r4
    5baa:	4b02      	ldr	r3, [pc, #8]	; (5bb4 <netif_set_up+0x38>)
    5bac:	4798      	blx	r3
				igmp_report_groups(netif);
			}
#endif /* LWIP_IGMP */
		}
	}
}
    5bae:	e7f9      	b.n	5ba4 <netif_set_up+0x28>
    5bb0:	4770      	bx	lr
    5bb2:	bf00      	nop
    5bb4:	00009131 	.word	0x00009131

00005bb8 <netif_set_down>:
 *
 * @see dhcp_start()
 */
void netif_set_down(struct netif *netif)
{
	if (netif->flags & NETIF_FLAG_UP) {
    5bb8:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
    5bbc:	f013 0f01 	tst.w	r3, #1
    5bc0:	d010      	beq.n	5be4 <netif_set_down+0x2c>
{
    5bc2:	b510      	push	{r4, lr}
    5bc4:	4604      	mov	r4, r0
		netif->flags &= ~NETIF_FLAG_UP;
    5bc6:	f023 0201 	bic.w	r2, r3, #1
    5bca:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
#if LWIP_SNMP
		snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
		if (netif->flags & NETIF_FLAG_ETHARP) {
    5bce:	f013 0f20 	tst.w	r3, #32
    5bd2:	d104      	bne.n	5bde <netif_set_down+0x26>
			etharp_cleanup_netif(netif);
		}
#endif /* LWIP_ARP */
		NETIF_STATUS_CALLBACK(netif);
    5bd4:	69e3      	ldr	r3, [r4, #28]
    5bd6:	b10b      	cbz	r3, 5bdc <netif_set_down+0x24>
    5bd8:	4620      	mov	r0, r4
    5bda:	4798      	blx	r3
    5bdc:	bd10      	pop	{r4, pc}
			etharp_cleanup_netif(netif);
    5bde:	4b02      	ldr	r3, [pc, #8]	; (5be8 <netif_set_down+0x30>)
    5be0:	4798      	blx	r3
    5be2:	e7f7      	b.n	5bd4 <netif_set_down+0x1c>
    5be4:	4770      	bx	lr
    5be6:	bf00      	nop
    5be8:	00009101 	.word	0x00009101

00005bec <netif_set_status_callback>:
/**
 * Set callback to be called when interface is brought up/down
 */
void netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback)
{
	if (netif) {
    5bec:	b100      	cbz	r0, 5bf0 <netif_set_status_callback+0x4>
		netif->status_callback = status_callback;
    5bee:	61c1      	str	r1, [r0, #28]
    5bf0:	4770      	bx	lr

00005bf2 <netif_set_link_callback>:
/**
 * Set callback to be called when link is brought up/down
 */
void netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback)
{
	if (netif) {
    5bf2:	b100      	cbz	r0, 5bf6 <netif_set_link_callback+0x4>
		netif->link_callback = link_callback;
    5bf4:	6201      	str	r1, [r0, #32]
    5bf6:	4770      	bx	lr

00005bf8 <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
    void
    pbuf_free_ooseq(void)
{
    5bf8:	b510      	push	{r4, lr}
	struct tcp_pcb *pcb;
	SYS_ARCH_DECL_PROTECT(old_level);

	SYS_ARCH_PROTECT(old_level);
	pbuf_free_ooseq_pending = 0;
    5bfa:	2200      	movs	r2, #0
    5bfc:	4b08      	ldr	r3, [pc, #32]	; (5c20 <pbuf_free_ooseq+0x28>)
    5bfe:	701a      	strb	r2, [r3, #0]
	SYS_ARCH_UNPROTECT(old_level);

	for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    5c00:	4b08      	ldr	r3, [pc, #32]	; (5c24 <pbuf_free_ooseq+0x2c>)
    5c02:	681c      	ldr	r4, [r3, #0]
    5c04:	b15c      	cbz	r4, 5c1e <pbuf_free_ooseq+0x26>
		if (NULL != pcb->ooseq) {
    5c06:	6f60      	ldr	r0, [r4, #116]	; 0x74
    5c08:	b920      	cbnz	r0, 5c14 <pbuf_free_ooseq+0x1c>
	for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    5c0a:	68e4      	ldr	r4, [r4, #12]
    5c0c:	b13c      	cbz	r4, 5c1e <pbuf_free_ooseq+0x26>
		if (NULL != pcb->ooseq) {
    5c0e:	6f60      	ldr	r0, [r4, #116]	; 0x74
    5c10:	2800      	cmp	r0, #0
    5c12:	d0fa      	beq.n	5c0a <pbuf_free_ooseq+0x12>
			/** Free the ooseq pbufs of one PCB only */
			LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
			tcp_segs_free(pcb->ooseq);
    5c14:	4b04      	ldr	r3, [pc, #16]	; (5c28 <pbuf_free_ooseq+0x30>)
    5c16:	4798      	blx	r3
			pcb->ooseq = NULL;
    5c18:	2300      	movs	r3, #0
    5c1a:	6763      	str	r3, [r4, #116]	; 0x74
			return;
    5c1c:	bd10      	pop	{r4, pc}
    5c1e:	bd10      	pop	{r4, pc}
    5c20:	200092f8 	.word	0x200092f8
    5c24:	20009300 	.word	0x20009300
    5c28:	00006265 	.word	0x00006265

00005c2c <pbuf_alloced_custom>:
 * @param payload_mem_len the size of the 'payload_mem' buffer, must be at least
 *        big enough to hold 'length' plus the header size
 */
struct pbuf *pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p, void *payload_mem,
                                 u16_t payload_mem_len)
{
    5c2c:	b470      	push	{r4, r5, r6}
    5c2e:	9c03      	ldr	r4, [sp, #12]
	u16_t offset;
	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%" U16_F ")\n", length));

	/* determine header offset */
	switch (l) {
    5c30:	2803      	cmp	r0, #3
    5c32:	d826      	bhi.n	5c82 <pbuf_alloced_custom+0x56>
    5c34:	e8df f000 	tbb	[pc, r0]
    5c38:	06040208 	.word	0x06040208
		/* add room for transport (often TCP) layer header */
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
		break;
	case PBUF_IP:
		/* add room for IP layer header */
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    5c3c:	2022      	movs	r0, #34	; 0x22
    5c3e:	e004      	b.n	5c4a <pbuf_alloced_custom+0x1e>
		break;
	case PBUF_LINK:
		/* add room for link layer header */
		offset = PBUF_LINK_HLEN;
    5c40:	200e      	movs	r0, #14
		break;
    5c42:	e002      	b.n	5c4a <pbuf_alloced_custom+0x1e>
	case PBUF_RAW:
		offset = 0;
    5c44:	2000      	movs	r0, #0
		break;
    5c46:	e000      	b.n	5c4a <pbuf_alloced_custom+0x1e>
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    5c48:	2036      	movs	r0, #54	; 0x36
	default:
		LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
		return NULL;
	}

	if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
    5c4a:	3003      	adds	r0, #3
    5c4c:	f020 0503 	bic.w	r5, r0, #3
    5c50:	440d      	add	r5, r1
    5c52:	f8bd 6010 	ldrh.w	r6, [sp, #16]
    5c56:	42b5      	cmp	r5, r6
    5c58:	dc15      	bgt.n	5c86 <pbuf_alloced_custom+0x5a>
		LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING,
		            ("pbuf_alloced_custom(length=%" U16_F ") buffer too short\n", length));
		return NULL;
	}

	p->pbuf.next = NULL;
    5c5a:	2500      	movs	r5, #0
    5c5c:	601d      	str	r5, [r3, #0]
	if (payload_mem != NULL) {
    5c5e:	b16c      	cbz	r4, 5c7c <pbuf_alloced_custom+0x50>
		p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
    5c60:	f020 0003 	bic.w	r0, r0, #3
    5c64:	4420      	add	r0, r4
    5c66:	6058      	str	r0, [r3, #4]
	} else {
		p->pbuf.payload = NULL;
	}
	p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
    5c68:	2002      	movs	r0, #2
    5c6a:	7358      	strb	r0, [r3, #13]
	p->pbuf.len = p->pbuf.tot_len = length;
    5c6c:	8119      	strh	r1, [r3, #8]
    5c6e:	8159      	strh	r1, [r3, #10]
	p->pbuf.type                  = type;
    5c70:	731a      	strb	r2, [r3, #12]
	p->pbuf.ref                   = 1;
    5c72:	2201      	movs	r2, #1
    5c74:	81da      	strh	r2, [r3, #14]
	return &p->pbuf;
    5c76:	4618      	mov	r0, r3
}
    5c78:	bc70      	pop	{r4, r5, r6}
    5c7a:	4770      	bx	lr
		p->pbuf.payload = NULL;
    5c7c:	2000      	movs	r0, #0
    5c7e:	6058      	str	r0, [r3, #4]
    5c80:	e7f2      	b.n	5c68 <pbuf_alloced_custom+0x3c>
		return NULL;
    5c82:	2000      	movs	r0, #0
    5c84:	e7f8      	b.n	5c78 <pbuf_alloced_custom+0x4c>
		return NULL;
    5c86:	2000      	movs	r0, #0
    5c88:	e7f6      	b.n	5c78 <pbuf_alloced_custom+0x4c>
	...

00005c8c <pbuf_header>:
	u16_t type;
	void *payload;
	u16_t increment_magnitude;

	LWIP_ASSERT("p != NULL", p != NULL);
	if ((header_size_increment == 0) || (p == NULL)) {
    5c8c:	2900      	cmp	r1, #0
    5c8e:	d035      	beq.n	5cfc <pbuf_header+0x70>
    5c90:	460b      	mov	r3, r1
    5c92:	2800      	cmp	r0, #0
    5c94:	d034      	beq.n	5d00 <pbuf_header+0x74>
{
    5c96:	b510      	push	{r4, lr}
		return 0;
	}

	if (header_size_increment < 0) {
    5c98:	2900      	cmp	r1, #0
    5c9a:	db0b      	blt.n	5cb4 <pbuf_header+0x28>
		increment_magnitude = -header_size_increment;
		/* Check that we aren't going to move off the end of the pbuf */
		LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
	} else {
		increment_magnitude = header_size_increment;
    5c9c:	b28c      	uxth	r4, r1
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
	}

	type = p->type;
    5c9e:	7b01      	ldrb	r1, [r0, #12]
	/* remember current payload pointer */
	payload = p->payload;
    5ca0:	6842      	ldr	r2, [r0, #4]

	/* pbuf types containing payloads? */
	if (type == PBUF_RAM || type == PBUF_POOL) {
    5ca2:	b1a1      	cbz	r1, 5cce <pbuf_header+0x42>
    5ca4:	2903      	cmp	r1, #3
    5ca6:	d012      	beq.n	5cce <pbuf_header+0x42>
			p->payload = payload;
			/* bail out unsuccesfully */
			return 1;
		}
		/* pbuf types refering to external payloads? */
	} else if (type == PBUF_REF || type == PBUF_ROM) {
    5ca8:	3901      	subs	r1, #1
    5caa:	b289      	uxth	r1, r1
    5cac:	2901      	cmp	r1, #1
    5cae:	d91d      	bls.n	5cec <pbuf_header+0x60>
			return 1;
		}
	} else {
		/* Unknown type */
		LWIP_ASSERT("bad pbuf type", 0);
		return 1;
    5cb0:	2001      	movs	r0, #1
    5cb2:	bd10      	pop	{r4, pc}
		increment_magnitude = -header_size_increment;
    5cb4:	424c      	negs	r4, r1
    5cb6:	b2a4      	uxth	r4, r4
		LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    5cb8:	8942      	ldrh	r2, [r0, #10]
    5cba:	42a2      	cmp	r2, r4
    5cbc:	d2ef      	bcs.n	5c9e <pbuf_header+0x12>
    5cbe:	4b14      	ldr	r3, [pc, #80]	; (5d10 <pbuf_header+0x84>)
    5cc0:	f240 2202 	movw	r2, #514	; 0x202
    5cc4:	4913      	ldr	r1, [pc, #76]	; (5d14 <pbuf_header+0x88>)
    5cc6:	4814      	ldr	r0, [pc, #80]	; (5d18 <pbuf_header+0x8c>)
    5cc8:	4c14      	ldr	r4, [pc, #80]	; (5d1c <pbuf_header+0x90>)
    5cca:	47a0      	blx	r4
    5ccc:	e7fe      	b.n	5ccc <pbuf_header+0x40>
		p->payload = (u8_t *)p->payload - header_size_increment;
    5cce:	1ad2      	subs	r2, r2, r3
		if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
    5cd0:	f100 0110 	add.w	r1, r0, #16
    5cd4:	428a      	cmp	r2, r1
    5cd6:	d315      	bcc.n	5d04 <pbuf_header+0x78>
		p->payload = (u8_t *)p->payload - header_size_increment;
    5cd8:	6042      	str	r2, [r0, #4]
	}
	/* modify pbuf length fields */
	p->len += header_size_increment;
    5cda:	b29b      	uxth	r3, r3
    5cdc:	8942      	ldrh	r2, [r0, #10]
    5cde:	441a      	add	r2, r3
    5ce0:	8142      	strh	r2, [r0, #10]
	p->tot_len += header_size_increment;
    5ce2:	8902      	ldrh	r2, [r0, #8]
    5ce4:	4413      	add	r3, r2
    5ce6:	8103      	strh	r3, [r0, #8]

	LWIP_DEBUGF(
	    PBUF_DEBUG | LWIP_DBG_TRACE,
	    ("pbuf_header: old %p new %p (%" S16_F ")\n", (void *)payload, (void *)p->payload, header_size_increment));

	return 0;
    5ce8:	2000      	movs	r0, #0
    5cea:	bd10      	pop	{r4, pc}
		if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    5cec:	2b00      	cmp	r3, #0
    5cee:	da0b      	bge.n	5d08 <pbuf_header+0x7c>
    5cf0:	8941      	ldrh	r1, [r0, #10]
    5cf2:	42a1      	cmp	r1, r4
    5cf4:	d30a      	bcc.n	5d0c <pbuf_header+0x80>
			p->payload = (u8_t *)p->payload - header_size_increment;
    5cf6:	1ad2      	subs	r2, r2, r3
    5cf8:	6042      	str	r2, [r0, #4]
    5cfa:	e7ee      	b.n	5cda <pbuf_header+0x4e>
		return 0;
    5cfc:	2000      	movs	r0, #0
    5cfe:	4770      	bx	lr
    5d00:	2000      	movs	r0, #0
    5d02:	4770      	bx	lr
			return 1;
    5d04:	2001      	movs	r0, #1
    5d06:	bd10      	pop	{r4, pc}
			return 1;
    5d08:	2001      	movs	r0, #1
    5d0a:	bd10      	pop	{r4, pc}
    5d0c:	2001      	movs	r0, #1
}
    5d0e:	bd10      	pop	{r4, pc}
    5d10:	0000c44c 	.word	0x0000c44c
    5d14:	0000c470 	.word	0x0000c470
    5d18:	0000b428 	.word	0x0000b428
    5d1c:	0000a111 	.word	0x0000a111

00005d20 <pbuf_free>:
 * 2->1->1 becomes 1->1->1
 * 1->1->1 becomes .......
 *
 */
u8_t pbuf_free(struct pbuf *p)
{
    5d20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u16_t        type;
	struct pbuf *q;
	u8_t         count;

	if (p == NULL) {
    5d24:	b338      	cbz	r0, 5d76 <pbuf_free+0x56>
    5d26:	4601      	mov	r1, r0
    5d28:	2400      	movs	r4, #0
					/* is this a ROM or RAM referencing pbuf? */
				} else if (type == PBUF_ROM || type == PBUF_REF) {
					memp_free(MEMP_PBUF, p);
					/* type == PBUF_RAM */
				} else {
					mem_free(p);
    5d2a:	4d15      	ldr	r5, [pc, #84]	; (5d80 <pbuf_free+0x60>)
					memp_free(MEMP_PBUF, p);
    5d2c:	f04f 0808 	mov.w	r8, #8
    5d30:	4e14      	ldr	r6, [pc, #80]	; (5d84 <pbuf_free+0x64>)
    5d32:	e006      	b.n	5d42 <pbuf_free+0x22>
				pc->custom_free_function(p);
    5d34:	690b      	ldr	r3, [r1, #16]
    5d36:	4608      	mov	r0, r1
    5d38:	4798      	blx	r3
				}
			}
			count++;
    5d3a:	3401      	adds	r4, #1
    5d3c:	b2e4      	uxtb	r4, r4
			/* proceed to next pbuf */
			p = q;
    5d3e:	4639      	mov	r1, r7
	while (p != NULL) {
    5d40:	b1d7      	cbz	r7, 5d78 <pbuf_free+0x58>
		ref = --(p->ref);
    5d42:	89cb      	ldrh	r3, [r1, #14]
    5d44:	3b01      	subs	r3, #1
    5d46:	b29b      	uxth	r3, r3
    5d48:	81cb      	strh	r3, [r1, #14]
		if (ref == 0) {
    5d4a:	b9ab      	cbnz	r3, 5d78 <pbuf_free+0x58>
			q = p->next;
    5d4c:	680f      	ldr	r7, [r1, #0]
			if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
    5d4e:	7b4b      	ldrb	r3, [r1, #13]
    5d50:	f013 0f02 	tst.w	r3, #2
    5d54:	d1ee      	bne.n	5d34 <pbuf_free+0x14>
			type = p->type;
    5d56:	7b0b      	ldrb	r3, [r1, #12]
				if (type == PBUF_POOL) {
    5d58:	2b03      	cmp	r3, #3
    5d5a:	d006      	beq.n	5d6a <pbuf_free+0x4a>
				} else if (type == PBUF_ROM || type == PBUF_REF) {
    5d5c:	3b01      	subs	r3, #1
    5d5e:	b29b      	uxth	r3, r3
    5d60:	2b01      	cmp	r3, #1
    5d62:	d905      	bls.n	5d70 <pbuf_free+0x50>
					mem_free(p);
    5d64:	4608      	mov	r0, r1
    5d66:	47a8      	blx	r5
    5d68:	e7e7      	b.n	5d3a <pbuf_free+0x1a>
					memp_free(MEMP_PBUF_POOL, p);
    5d6a:	2009      	movs	r0, #9
    5d6c:	47b0      	blx	r6
    5d6e:	e7e4      	b.n	5d3a <pbuf_free+0x1a>
					memp_free(MEMP_PBUF, p);
    5d70:	4640      	mov	r0, r8
    5d72:	47b0      	blx	r6
    5d74:	e7e1      	b.n	5d3a <pbuf_free+0x1a>
		return 0;
    5d76:	2400      	movs	r4, #0
		}
	}
	PERF_STOP("pbuf_free");
	/* return number of de-allocated pbufs */
	return count;
}
    5d78:	4620      	mov	r0, r4
    5d7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5d7e:	bf00      	nop
    5d80:	00005771 	.word	0x00005771
    5d84:	00005a59 	.word	0x00005a59

00005d88 <pbuf_alloc>:
{
    5d88:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	switch (layer) {
    5d8c:	2803      	cmp	r0, #3
    5d8e:	f200 808d 	bhi.w	5eac <pbuf_alloc+0x124>
    5d92:	e8df f000 	tbb	[pc, r0]
    5d96:	0208      	.short	0x0208
    5d98:	0604      	.short	0x0604
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    5d9a:	2422      	movs	r4, #34	; 0x22
    5d9c:	e004      	b.n	5da8 <pbuf_alloc+0x20>
		offset = PBUF_LINK_HLEN;
    5d9e:	240e      	movs	r4, #14
		break;
    5da0:	e002      	b.n	5da8 <pbuf_alloc+0x20>
		offset = 0;
    5da2:	2400      	movs	r4, #0
		break;
    5da4:	e000      	b.n	5da8 <pbuf_alloc+0x20>
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    5da6:	2436      	movs	r4, #54	; 0x36
    5da8:	4617      	mov	r7, r2
    5daa:	460d      	mov	r5, r1
	switch (type) {
    5dac:	2a03      	cmp	r2, #3
    5dae:	d87f      	bhi.n	5eb0 <pbuf_alloc+0x128>
    5db0:	e8df f002 	tbb	[pc, r2]
    5db4:	026f6f51 	.word	0x026f6f51
		p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    5db8:	2009      	movs	r0, #9
    5dba:	4b3e      	ldr	r3, [pc, #248]	; (5eb4 <pbuf_alloc+0x12c>)
    5dbc:	4798      	blx	r3
		if (p == NULL) {
    5dbe:	4606      	mov	r6, r0
    5dc0:	2800      	cmp	r0, #0
    5dc2:	d03c      	beq.n	5e3e <pbuf_alloc+0xb6>
		p->type = type;
    5dc4:	2303      	movs	r3, #3
    5dc6:	7303      	strb	r3, [r0, #12]
		p->next = NULL;
    5dc8:	2300      	movs	r3, #0
    5dca:	6003      	str	r3, [r0, #0]
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    5dcc:	1903      	adds	r3, r0, r4
    5dce:	3313      	adds	r3, #19
    5dd0:	f023 0303 	bic.w	r3, r3, #3
    5dd4:	6043      	str	r3, [r0, #4]
		p->tot_len = length;
    5dd6:	8105      	strh	r5, [r0, #8]
		p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    5dd8:	3403      	adds	r4, #3
    5dda:	f024 0403 	bic.w	r4, r4, #3
    5dde:	f5c4 64bd 	rsb	r4, r4, #1512	; 0x5e8
    5de2:	3404      	adds	r4, #4
    5de4:	42ac      	cmp	r4, r5
    5de6:	bfa8      	it	ge
    5de8:	462c      	movge	r4, r5
    5dea:	8144      	strh	r4, [r0, #10]
		p->ref = 1;
    5dec:	2301      	movs	r3, #1
    5dee:	81c3      	strh	r3, [r0, #14]
		rem_len = length - p->len;
    5df0:	b2a4      	uxth	r4, r4
    5df2:	1b2d      	subs	r5, r5, r4
		while (rem_len > 0) {
    5df4:	2d00      	cmp	r5, #0
    5df6:	dd45      	ble.n	5e84 <pbuf_alloc+0xfc>
    5df8:	4682      	mov	sl, r0
			q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    5dfa:	f04f 0809 	mov.w	r8, #9
    5dfe:	4f2d      	ldr	r7, [pc, #180]	; (5eb4 <pbuf_alloc+0x12c>)
			q->type  = type;
    5e00:	f04f 0903 	mov.w	r9, #3
			q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    5e04:	4640      	mov	r0, r8
    5e06:	47b8      	blx	r7
			if (q == NULL) {
    5e08:	4604      	mov	r4, r0
    5e0a:	b1e0      	cbz	r0, 5e46 <pbuf_alloc+0xbe>
			q->type  = type;
    5e0c:	f880 900c 	strb.w	r9, [r0, #12]
			q->flags = 0;
    5e10:	2300      	movs	r3, #0
    5e12:	7343      	strb	r3, [r0, #13]
			q->next  = NULL;
    5e14:	6003      	str	r3, [r0, #0]
			r->next = q;
    5e16:	f8ca 0000 	str.w	r0, [sl]
			q->tot_len = (u16_t)rem_len;
    5e1a:	b2ab      	uxth	r3, r5
    5e1c:	8103      	strh	r3, [r0, #8]
			q->len     = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    5e1e:	f240 52ec 	movw	r2, #1516	; 0x5ec
    5e22:	4293      	cmp	r3, r2
    5e24:	bf28      	it	cs
    5e26:	4613      	movcs	r3, r2
    5e28:	8143      	strh	r3, [r0, #10]
			q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    5e2a:	f100 0210 	add.w	r2, r0, #16
    5e2e:	6042      	str	r2, [r0, #4]
			q->ref = 1;
    5e30:	2201      	movs	r2, #1
    5e32:	81c2      	strh	r2, [r0, #14]
			rem_len -= q->len;
    5e34:	1aed      	subs	r5, r5, r3
			r = q;
    5e36:	4682      	mov	sl, r0
		while (rem_len > 0) {
    5e38:	2d00      	cmp	r5, #0
    5e3a:	dce3      	bgt.n	5e04 <pbuf_alloc+0x7c>
    5e3c:	e022      	b.n	5e84 <pbuf_alloc+0xfc>
	pbuf_free_ooseq_pending = 1;
    5e3e:	2201      	movs	r2, #1
    5e40:	4b1d      	ldr	r3, [pc, #116]	; (5eb8 <pbuf_alloc+0x130>)
    5e42:	701a      	strb	r2, [r3, #0]
    5e44:	e022      	b.n	5e8c <pbuf_alloc+0x104>
    5e46:	2201      	movs	r2, #1
    5e48:	4b1b      	ldr	r3, [pc, #108]	; (5eb8 <pbuf_alloc+0x130>)
    5e4a:	701a      	strb	r2, [r3, #0]
				pbuf_free(p);
    5e4c:	4630      	mov	r0, r6
    5e4e:	4b1b      	ldr	r3, [pc, #108]	; (5ebc <pbuf_alloc+0x134>)
    5e50:	4798      	blx	r3
				return NULL;
    5e52:	4626      	mov	r6, r4
    5e54:	e01a      	b.n	5e8c <pbuf_alloc+0x104>
		p = (struct pbuf *)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    5e56:	f104 0013 	add.w	r0, r4, #19
    5e5a:	f020 0003 	bic.w	r0, r0, #3
    5e5e:	1ccb      	adds	r3, r1, #3
    5e60:	f023 0303 	bic.w	r3, r3, #3
    5e64:	4418      	add	r0, r3
    5e66:	b280      	uxth	r0, r0
    5e68:	4b15      	ldr	r3, [pc, #84]	; (5ec0 <pbuf_alloc+0x138>)
    5e6a:	4798      	blx	r3
		if (p == NULL) {
    5e6c:	4606      	mov	r6, r0
    5e6e:	b168      	cbz	r0, 5e8c <pbuf_alloc+0x104>
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
    5e70:	4404      	add	r4, r0
    5e72:	3413      	adds	r4, #19
    5e74:	f024 0403 	bic.w	r4, r4, #3
    5e78:	6044      	str	r4, [r0, #4]
		p->len = p->tot_len = length;
    5e7a:	8105      	strh	r5, [r0, #8]
    5e7c:	8145      	strh	r5, [r0, #10]
		p->next             = NULL;
    5e7e:	2300      	movs	r3, #0
    5e80:	6003      	str	r3, [r0, #0]
		p->type             = type;
    5e82:	7303      	strb	r3, [r0, #12]
	p->ref = 1;
    5e84:	2301      	movs	r3, #1
    5e86:	81f3      	strh	r3, [r6, #14]
	p->flags = 0;
    5e88:	2300      	movs	r3, #0
    5e8a:	7373      	strb	r3, [r6, #13]
}
    5e8c:	4630      	mov	r0, r6
    5e8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		p = (struct pbuf *)memp_malloc(MEMP_PBUF);
    5e92:	2008      	movs	r0, #8
    5e94:	4b07      	ldr	r3, [pc, #28]	; (5eb4 <pbuf_alloc+0x12c>)
    5e96:	4798      	blx	r3
		if (p == NULL) {
    5e98:	4606      	mov	r6, r0
    5e9a:	2800      	cmp	r0, #0
    5e9c:	d0f6      	beq.n	5e8c <pbuf_alloc+0x104>
		p->payload = NULL;
    5e9e:	2300      	movs	r3, #0
    5ea0:	6043      	str	r3, [r0, #4]
		p->len = p->tot_len = length;
    5ea2:	8105      	strh	r5, [r0, #8]
    5ea4:	8145      	strh	r5, [r0, #10]
		p->next             = NULL;
    5ea6:	6003      	str	r3, [r0, #0]
		p->type             = type;
    5ea8:	7307      	strb	r7, [r0, #12]
		break;
    5eaa:	e7eb      	b.n	5e84 <pbuf_alloc+0xfc>
		return NULL;
    5eac:	2600      	movs	r6, #0
    5eae:	e7ed      	b.n	5e8c <pbuf_alloc+0x104>
		return NULL;
    5eb0:	2600      	movs	r6, #0
    5eb2:	e7eb      	b.n	5e8c <pbuf_alloc+0x104>
    5eb4:	00005a11 	.word	0x00005a11
    5eb8:	200092f8 	.word	0x200092f8
    5ebc:	00005d21 	.word	0x00005d21
    5ec0:	000058c5 	.word	0x000058c5

00005ec4 <pbuf_realloc>:
	if (new_len >= p->tot_len) {
    5ec4:	8902      	ldrh	r2, [r0, #8]
    5ec6:	428a      	cmp	r2, r1
    5ec8:	d926      	bls.n	5f18 <pbuf_realloc+0x54>
{
    5eca:	b538      	push	{r3, r4, r5, lr}
    5ecc:	4604      	mov	r4, r0
	while (rem_len > q->len) {
    5ece:	8943      	ldrh	r3, [r0, #10]
    5ed0:	4299      	cmp	r1, r3
    5ed2:	d91f      	bls.n	5f14 <pbuf_realloc+0x50>
    5ed4:	460d      	mov	r5, r1
		q->tot_len += (u16_t)grow;
    5ed6:	1a89      	subs	r1, r1, r2
		rem_len -= q->len;
    5ed8:	1aeb      	subs	r3, r5, r3
    5eda:	b29d      	uxth	r5, r3
		q->tot_len += (u16_t)grow;
    5edc:	8923      	ldrh	r3, [r4, #8]
    5ede:	440b      	add	r3, r1
    5ee0:	8123      	strh	r3, [r4, #8]
		q = q->next;
    5ee2:	6824      	ldr	r4, [r4, #0]
	while (rem_len > q->len) {
    5ee4:	8963      	ldrh	r3, [r4, #10]
    5ee6:	42ab      	cmp	r3, r5
    5ee8:	d3f6      	bcc.n	5ed8 <pbuf_realloc+0x14>
	if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    5eea:	7b22      	ldrb	r2, [r4, #12]
    5eec:	b94a      	cbnz	r2, 5f02 <pbuf_realloc+0x3e>
    5eee:	429d      	cmp	r5, r3
    5ef0:	d007      	beq.n	5f02 <pbuf_realloc+0x3e>
		q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    5ef2:	6863      	ldr	r3, [r4, #4]
    5ef4:	1b1b      	subs	r3, r3, r4
    5ef6:	18e9      	adds	r1, r5, r3
    5ef8:	b289      	uxth	r1, r1
    5efa:	4620      	mov	r0, r4
    5efc:	4b07      	ldr	r3, [pc, #28]	; (5f1c <pbuf_realloc+0x58>)
    5efe:	4798      	blx	r3
    5f00:	4604      	mov	r4, r0
	q->len     = rem_len;
    5f02:	8165      	strh	r5, [r4, #10]
	q->tot_len = q->len;
    5f04:	8125      	strh	r5, [r4, #8]
	if (q->next != NULL) {
    5f06:	6820      	ldr	r0, [r4, #0]
    5f08:	b108      	cbz	r0, 5f0e <pbuf_realloc+0x4a>
		pbuf_free(q->next);
    5f0a:	4b05      	ldr	r3, [pc, #20]	; (5f20 <pbuf_realloc+0x5c>)
    5f0c:	4798      	blx	r3
	q->next = NULL;
    5f0e:	2300      	movs	r3, #0
    5f10:	6023      	str	r3, [r4, #0]
    5f12:	bd38      	pop	{r3, r4, r5, pc}
	while (rem_len > q->len) {
    5f14:	460d      	mov	r5, r1
    5f16:	e7e8      	b.n	5eea <pbuf_realloc+0x26>
    5f18:	4770      	bx	lr
    5f1a:	bf00      	nop
    5f1c:	000057fd 	.word	0x000057fd
    5f20:	00005d21 	.word	0x00005d21

00005f24 <pbuf_clen>:
u8_t pbuf_clen(struct pbuf *p)
{
	u8_t len;

	len = 0;
	while (p != NULL) {
    5f24:	4603      	mov	r3, r0
    5f26:	b130      	cbz	r0, 5f36 <pbuf_clen+0x12>
    5f28:	2000      	movs	r0, #0
		++len;
    5f2a:	3001      	adds	r0, #1
    5f2c:	b2c0      	uxtb	r0, r0
		p = p->next;
    5f2e:	681b      	ldr	r3, [r3, #0]
	while (p != NULL) {
    5f30:	2b00      	cmp	r3, #0
    5f32:	d1fa      	bne.n	5f2a <pbuf_clen+0x6>
    5f34:	4770      	bx	lr
	len = 0;
    5f36:	2000      	movs	r0, #0
	}
	return len;
}
    5f38:	4770      	bx	lr

00005f3a <pbuf_ref>:
 */
void pbuf_ref(struct pbuf *p)
{
	SYS_ARCH_DECL_PROTECT(old_level);
	/* pbuf given? */
	if (p != NULL) {
    5f3a:	b110      	cbz	r0, 5f42 <pbuf_ref+0x8>
		SYS_ARCH_PROTECT(old_level);
		++(p->ref);
    5f3c:	89c3      	ldrh	r3, [r0, #14]
    5f3e:	3301      	adds	r3, #1
    5f40:	81c3      	strh	r3, [r0, #14]
    5f42:	4770      	bx	lr

00005f44 <pbuf_cat>:
 *
 * @see pbuf_chain()
 */

void pbuf_cat(struct pbuf *h, struct pbuf *t)
{
    5f44:	b510      	push	{r4, lr}
	struct pbuf *p;

	LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)", ((h != NULL) && (t != NULL)), return;);
    5f46:	b128      	cbz	r0, 5f54 <pbuf_cat+0x10>
    5f48:	4602      	mov	r2, r0
    5f4a:	b119      	cbz	r1, 5f54 <pbuf_cat+0x10>

	/* proceed to last pbuf of chain */
	for (p = h; p->next != NULL; p = p->next) {
    5f4c:	6803      	ldr	r3, [r0, #0]
    5f4e:	b953      	cbnz	r3, 5f66 <pbuf_cat+0x22>
    5f50:	4603      	mov	r3, r0
    5f52:	e010      	b.n	5f76 <pbuf_cat+0x32>
	LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)", ((h != NULL) && (t != NULL)), return;);
    5f54:	4b0b      	ldr	r3, [pc, #44]	; (5f84 <pbuf_cat+0x40>)
    5f56:	f240 22df 	movw	r2, #735	; 0x2df
    5f5a:	490b      	ldr	r1, [pc, #44]	; (5f88 <pbuf_cat+0x44>)
    5f5c:	480b      	ldr	r0, [pc, #44]	; (5f8c <pbuf_cat+0x48>)
    5f5e:	4c0c      	ldr	r4, [pc, #48]	; (5f90 <pbuf_cat+0x4c>)
    5f60:	47a0      	blx	r4
    5f62:	e7fe      	b.n	5f62 <pbuf_cat+0x1e>
	for (p = h; p->next != NULL; p = p->next) {
    5f64:	4603      	mov	r3, r0
		/* add total length of second chain to all totals of first chain */
		p->tot_len += t->tot_len;
    5f66:	8910      	ldrh	r0, [r2, #8]
    5f68:	890c      	ldrh	r4, [r1, #8]
    5f6a:	4420      	add	r0, r4
    5f6c:	8110      	strh	r0, [r2, #8]
	for (p = h; p->next != NULL; p = p->next) {
    5f6e:	6818      	ldr	r0, [r3, #0]
    5f70:	461a      	mov	r2, r3
    5f72:	2800      	cmp	r0, #0
    5f74:	d1f6      	bne.n	5f64 <pbuf_cat+0x20>
	}
	/* { p is last pbuf of first h chain, p->next == NULL } */
	LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
	LWIP_ASSERT("p->next == NULL", p->next == NULL);
	/* add total length of second chain to last pbuf total of first chain */
	p->tot_len += t->tot_len;
    5f76:	891a      	ldrh	r2, [r3, #8]
    5f78:	8908      	ldrh	r0, [r1, #8]
    5f7a:	4402      	add	r2, r0
    5f7c:	811a      	strh	r2, [r3, #8]
	/* chain last pbuf of head (p) with first of tail (t) */
	p->next = t;
    5f7e:	6019      	str	r1, [r3, #0]
    5f80:	bd10      	pop	{r4, pc}
    5f82:	bf00      	nop
    5f84:	0000c44c 	.word	0x0000c44c
    5f88:	0000c490 	.word	0x0000c490
    5f8c:	0000b428 	.word	0x0000b428
    5f90:	0000a111 	.word	0x0000a111

00005f94 <pbuf_chain>:
 * The ->next field of the last pbuf of the head chain is adjusted.
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void pbuf_chain(struct pbuf *h, struct pbuf *t)
{
    5f94:	b510      	push	{r4, lr}
    5f96:	460c      	mov	r4, r1
	pbuf_cat(h, t);
    5f98:	4b02      	ldr	r3, [pc, #8]	; (5fa4 <pbuf_chain+0x10>)
    5f9a:	4798      	blx	r3
	/* t is now referenced by h */
	pbuf_ref(t);
    5f9c:	4620      	mov	r0, r4
    5f9e:	4b02      	ldr	r3, [pc, #8]	; (5fa8 <pbuf_chain+0x14>)
    5fa0:	4798      	blx	r3
    5fa2:	bd10      	pop	{r4, pc}
    5fa4:	00005f45 	.word	0x00005f45
    5fa8:	00005f3b 	.word	0x00005f3b

00005fac <pbuf_copy>:
 * @return ERR_OK if pbuf was copied
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
    5fac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	u16_t offset_to = 0, offset_from = 0, len;

	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n", (void *)p_to, (void *)p_from));

	/* is the target big enough to hold the source? */
	LWIP_ERROR("pbuf_copy: target not big enough to hold source",
    5fb0:	b130      	cbz	r0, 5fc0 <pbuf_copy+0x14>
    5fb2:	460d      	mov	r5, r1
    5fb4:	4604      	mov	r4, r0
    5fb6:	b119      	cbz	r1, 5fc0 <pbuf_copy+0x14>
    5fb8:	8902      	ldrh	r2, [r0, #8]
    5fba:	890b      	ldrh	r3, [r1, #8]
    5fbc:	429a      	cmp	r2, r3
    5fbe:	d207      	bcs.n	5fd0 <pbuf_copy+0x24>
    5fc0:	4b33      	ldr	r3, [pc, #204]	; (6090 <pbuf_copy+0xe4>)
    5fc2:	f240 324b 	movw	r2, #843	; 0x34b
    5fc6:	4933      	ldr	r1, [pc, #204]	; (6094 <pbuf_copy+0xe8>)
    5fc8:	4833      	ldr	r0, [pc, #204]	; (6098 <pbuf_copy+0xec>)
    5fca:	4c34      	ldr	r4, [pc, #208]	; (609c <pbuf_copy+0xf0>)
    5fcc:	47a0      	blx	r4
    5fce:	e7fe      	b.n	5fce <pbuf_copy+0x22>
    5fd0:	f04f 0a00 	mov.w	sl, #0
    5fd4:	4657      	mov	r7, sl
			len = p_from->len - offset_from;
		} else {
			/* current p_from does not fit into current p_to */
			len = p_to->len - offset_to;
		}
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    5fd6:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 60a8 <pbuf_copy+0xfc>
		offset_from += len;
		LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
		LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
		if (offset_from >= p_from->len) {
			/* on to next p_from (if any) */
			offset_from = 0;
    5fda:	46d0      	mov	r8, sl
    5fdc:	e02d      	b.n	603a <pbuf_copy+0x8e>
			p_from      = p_from->next;
		}
		if (offset_to == p_to->len) {
			/* on to next p_to (if any) */
			offset_to = 0;
			p_to      = p_to->next;
    5fde:	6824      	ldr	r4, [r4, #0]
			LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
    5fe0:	b10c      	cbz	r4, 5fe6 <pbuf_copy+0x3a>
			offset_to = 0;
    5fe2:	4647      	mov	r7, r8
    5fe4:	e047      	b.n	6076 <pbuf_copy+0xca>
			LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
    5fe6:	b915      	cbnz	r5, 5fee <pbuf_copy+0x42>
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_to->next == NULL), return ERR_VAL;);
		}
	} while (p_from);
	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
	return ERR_OK;
}
    5fe8:	2000      	movs	r0, #0
    5fea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
    5fee:	4b28      	ldr	r3, [pc, #160]	; (6090 <pbuf_copy+0xe4>)
    5ff0:	f240 3265 	movw	r2, #869	; 0x365
    5ff4:	492a      	ldr	r1, [pc, #168]	; (60a0 <pbuf_copy+0xf4>)
    5ff6:	4828      	ldr	r0, [pc, #160]	; (6098 <pbuf_copy+0xec>)
    5ff8:	4c28      	ldr	r4, [pc, #160]	; (609c <pbuf_copy+0xf0>)
    5ffa:	47a0      	blx	r4
    5ffc:	e7fe      	b.n	5ffc <pbuf_copy+0x50>
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_from->next == NULL), return ERR_VAL;);
    5ffe:	682b      	ldr	r3, [r5, #0]
    6000:	2b00      	cmp	r3, #0
    6002:	d03e      	beq.n	6082 <pbuf_copy+0xd6>
    6004:	4b22      	ldr	r3, [pc, #136]	; (6090 <pbuf_copy+0xe4>)
    6006:	f240 326a 	movw	r2, #874	; 0x36a
    600a:	4926      	ldr	r1, [pc, #152]	; (60a4 <pbuf_copy+0xf8>)
    600c:	4822      	ldr	r0, [pc, #136]	; (6098 <pbuf_copy+0xec>)
    600e:	4c23      	ldr	r4, [pc, #140]	; (609c <pbuf_copy+0xf0>)
    6010:	47a0      	blx	r4
    6012:	e7fe      	b.n	6012 <pbuf_copy+0x66>
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_to->next == NULL), return ERR_VAL;);
    6014:	4b1e      	ldr	r3, [pc, #120]	; (6090 <pbuf_copy+0xe4>)
    6016:	f240 326e 	movw	r2, #878	; 0x36e
    601a:	4922      	ldr	r1, [pc, #136]	; (60a4 <pbuf_copy+0xf8>)
    601c:	481e      	ldr	r0, [pc, #120]	; (6098 <pbuf_copy+0xec>)
    601e:	4c1f      	ldr	r4, [pc, #124]	; (609c <pbuf_copy+0xf0>)
    6020:	47a0      	blx	r4
    6022:	e7fe      	b.n	6022 <pbuf_copy+0x76>
		if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    6024:	2c00      	cmp	r4, #0
    6026:	d0df      	beq.n	5fe8 <pbuf_copy+0x3c>
    6028:	8962      	ldrh	r2, [r4, #10]
    602a:	8923      	ldrh	r3, [r4, #8]
    602c:	429a      	cmp	r2, r3
    602e:	d1db      	bne.n	5fe8 <pbuf_copy+0x3c>
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_to->next == NULL), return ERR_VAL;);
    6030:	6823      	ldr	r3, [r4, #0]
    6032:	2b00      	cmp	r3, #0
    6034:	d1ee      	bne.n	6014 <pbuf_copy+0x68>
	} while (p_from);
    6036:	2d00      	cmp	r5, #0
    6038:	d0d6      	beq.n	5fe8 <pbuf_copy+0x3c>
		if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    603a:	8963      	ldrh	r3, [r4, #10]
    603c:	896a      	ldrh	r2, [r5, #10]
    603e:	1bd8      	subs	r0, r3, r7
    6040:	eba2 010a 	sub.w	r1, r2, sl
    6044:	4288      	cmp	r0, r1
			len = p_from->len - offset_from;
    6046:	bfa7      	ittee	ge
    6048:	460a      	movge	r2, r1
    604a:	b296      	uxthge	r6, r2
			len = p_to->len - offset_to;
    604c:	1bdb      	sublt	r3, r3, r7
    604e:	b29e      	uxthlt	r6, r3
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    6050:	6860      	ldr	r0, [r4, #4]
    6052:	6869      	ldr	r1, [r5, #4]
    6054:	4632      	mov	r2, r6
    6056:	4451      	add	r1, sl
    6058:	4438      	add	r0, r7
    605a:	47c8      	blx	r9
		offset_to += len;
    605c:	4437      	add	r7, r6
    605e:	b2bf      	uxth	r7, r7
		offset_from += len;
    6060:	4456      	add	r6, sl
    6062:	fa1f fa86 	uxth.w	sl, r6
		if (offset_from >= p_from->len) {
    6066:	896b      	ldrh	r3, [r5, #10]
    6068:	4553      	cmp	r3, sl
			p_from      = p_from->next;
    606a:	bf9c      	itt	ls
    606c:	682d      	ldrls	r5, [r5, #0]
			offset_from = 0;
    606e:	46c2      	movls	sl, r8
		if (offset_to == p_to->len) {
    6070:	8963      	ldrh	r3, [r4, #10]
    6072:	42bb      	cmp	r3, r7
    6074:	d0b3      	beq.n	5fde <pbuf_copy+0x32>
		if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
    6076:	2d00      	cmp	r5, #0
    6078:	d0d4      	beq.n	6024 <pbuf_copy+0x78>
    607a:	896a      	ldrh	r2, [r5, #10]
    607c:	892b      	ldrh	r3, [r5, #8]
    607e:	429a      	cmp	r2, r3
    6080:	d0bd      	beq.n	5ffe <pbuf_copy+0x52>
		if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    6082:	2c00      	cmp	r4, #0
    6084:	d0d9      	beq.n	603a <pbuf_copy+0x8e>
    6086:	8962      	ldrh	r2, [r4, #10]
    6088:	8923      	ldrh	r3, [r4, #8]
    608a:	429a      	cmp	r2, r3
    608c:	d1d5      	bne.n	603a <pbuf_copy+0x8e>
    608e:	e7cf      	b.n	6030 <pbuf_copy+0x84>
    6090:	0000c44c 	.word	0x0000c44c
    6094:	0000c4c8 	.word	0x0000c4c8
    6098:	0000b428 	.word	0x0000b428
    609c:	0000a111 	.word	0x0000a111
    60a0:	0000c4f8 	.word	0x0000c4f8
    60a4:	0000c508 	.word	0x0000c508
    60a8:	0000a0eb 	.word	0x0000a0eb

000060ac <pbuf_copy_partial>:
 * than buf->tot_len will be copied, irrespective of len
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
    60ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct pbuf *p;
	u16_t        left;
	u16_t        buf_copy_len;
	u16_t        copied_total = 0;

	LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    60b0:	b158      	cbz	r0, 60ca <pbuf_copy_partial+0x1e>
    60b2:	460f      	mov	r7, r1
    60b4:	4692      	mov	sl, r2
    60b6:	4605      	mov	r5, r0
	LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    60b8:	b179      	cbz	r1, 60da <pbuf_copy_partial+0x2e>
	if ((buf == NULL) || (dataptr == NULL)) {
		return 0;
	}

	/* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
	for (p = buf; len != 0 && p != NULL; p = p->next) {
    60ba:	4616      	mov	r6, r2
    60bc:	2a00      	cmp	r2, #0
    60be:	d033      	beq.n	6128 <pbuf_copy_partial+0x7c>
    60c0:	2600      	movs	r6, #0
			/* copy from this buffer. maybe only partially. */
			buf_copy_len = p->len - offset;
			if (buf_copy_len > len)
				buf_copy_len = len;
			/* copy the necessary parts of the buffer */
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    60c2:	f8df 9080 	ldr.w	r9, [pc, #128]	; 6144 <pbuf_copy_partial+0x98>
			copied_total += buf_copy_len;
			left += buf_copy_len;
			len -= buf_copy_len;
			offset = 0;
    60c6:	46b0      	mov	r8, r6
    60c8:	e026      	b.n	6118 <pbuf_copy_partial+0x6c>
	LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    60ca:	4b19      	ldr	r3, [pc, #100]	; (6130 <pbuf_copy_partial+0x84>)
    60cc:	f240 3287 	movw	r2, #903	; 0x387
    60d0:	4918      	ldr	r1, [pc, #96]	; (6134 <pbuf_copy_partial+0x88>)
    60d2:	4819      	ldr	r0, [pc, #100]	; (6138 <pbuf_copy_partial+0x8c>)
    60d4:	4c19      	ldr	r4, [pc, #100]	; (613c <pbuf_copy_partial+0x90>)
    60d6:	47a0      	blx	r4
    60d8:	e7fe      	b.n	60d8 <pbuf_copy_partial+0x2c>
	LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    60da:	4b15      	ldr	r3, [pc, #84]	; (6130 <pbuf_copy_partial+0x84>)
    60dc:	f44f 7262 	mov.w	r2, #904	; 0x388
    60e0:	4917      	ldr	r1, [pc, #92]	; (6140 <pbuf_copy_partial+0x94>)
    60e2:	4815      	ldr	r0, [pc, #84]	; (6138 <pbuf_copy_partial+0x8c>)
    60e4:	4c15      	ldr	r4, [pc, #84]	; (613c <pbuf_copy_partial+0x90>)
    60e6:	47a0      	blx	r4
    60e8:	e7fe      	b.n	60e8 <pbuf_copy_partial+0x3c>
			buf_copy_len = p->len - offset;
    60ea:	896c      	ldrh	r4, [r5, #10]
    60ec:	1ae4      	subs	r4, r4, r3
    60ee:	b2a4      	uxth	r4, r4
    60f0:	4554      	cmp	r4, sl
    60f2:	bf28      	it	cs
    60f4:	4654      	movcs	r4, sl
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    60f6:	6869      	ldr	r1, [r5, #4]
    60f8:	4622      	mov	r2, r4
    60fa:	4419      	add	r1, r3
    60fc:	19b8      	adds	r0, r7, r6
    60fe:	47c8      	blx	r9
			copied_total += buf_copy_len;
    6100:	4426      	add	r6, r4
    6102:	b2b6      	uxth	r6, r6
			len -= buf_copy_len;
    6104:	ebaa 0404 	sub.w	r4, sl, r4
    6108:	fa1f fa84 	uxth.w	sl, r4
			offset = 0;
    610c:	4643      	mov	r3, r8
	for (p = buf; len != 0 && p != NULL; p = p->next) {
    610e:	682d      	ldr	r5, [r5, #0]
    6110:	f1ba 0f00 	cmp.w	sl, #0
    6114:	d008      	beq.n	6128 <pbuf_copy_partial+0x7c>
    6116:	b13d      	cbz	r5, 6128 <pbuf_copy_partial+0x7c>
		if ((offset != 0) && (offset >= p->len)) {
    6118:	2b00      	cmp	r3, #0
    611a:	d0e6      	beq.n	60ea <pbuf_copy_partial+0x3e>
    611c:	896a      	ldrh	r2, [r5, #10]
    611e:	429a      	cmp	r2, r3
    6120:	d8e3      	bhi.n	60ea <pbuf_copy_partial+0x3e>
			offset -= p->len;
    6122:	1a9b      	subs	r3, r3, r2
    6124:	b29b      	uxth	r3, r3
    6126:	e7f2      	b.n	610e <pbuf_copy_partial+0x62>
		}
	}
	return copied_total;
}
    6128:	4630      	mov	r0, r6
    612a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    612e:	bf00      	nop
    6130:	0000c44c 	.word	0x0000c44c
    6134:	0000c534 	.word	0x0000c534
    6138:	0000b428 	.word	0x0000b428
    613c:	0000a111 	.word	0x0000a111
    6140:	0000c554 	.word	0x0000c554
    6144:	0000a0eb 	.word	0x0000a0eb

00006148 <raw_input>:
 * @return - 0 if packet is not eaten (pbuf is still referenced by the
 *           caller).
 *
 */
u8_t raw_input(struct pbuf *p, struct netif *inp)
{
    6148:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	u8_t            eaten = 0;

	LWIP_UNUSED_ARG(inp);

	iphdr = (struct ip_hdr *)p->payload;
	proto = IPH_PROTO(iphdr);
    614c:	6843      	ldr	r3, [r0, #4]
    614e:	7a5e      	ldrb	r6, [r3, #9]

	prev = NULL;
	pcb  = raw_pcbs;
    6150:	4b18      	ldr	r3, [pc, #96]	; (61b4 <raw_input+0x6c>)
    6152:	681c      	ldr	r4, [r3, #0]
	/* loop through all raw pcbs until the packet is eaten by one */
	/* this allows multiple pcbs to match against the packet by design */
	while ((eaten == 0) && (pcb != NULL)) {
    6154:	b35c      	cbz	r4, 61ae <raw_input+0x66>
    6156:	4682      	mov	sl, r0
    6158:	2500      	movs	r5, #0
#endif /* IP_SOF_BROADCAST_RECV */
			{
				/* receive callback function available? */
				if (pcb->recv != NULL) {
					/* the receive callback function did not eat the packet? */
					if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
    615a:	f8df 805c 	ldr.w	r8, [pc, #92]	; 61b8 <raw_input+0x70>
		    && (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
    615e:	f8df 905c 	ldr.w	r9, [pc, #92]	; 61bc <raw_input+0x74>
    6162:	e003      	b.n	616c <raw_input+0x24>
				/* no receive callback function was set for this raw PCB */
			}
			/* drop the packet */
		}
		prev = pcb;
		pcb  = pcb->next;
    6164:	68e3      	ldr	r3, [r4, #12]
    6166:	4625      	mov	r5, r4
	while ((eaten == 0) && (pcb != NULL)) {
    6168:	b1f3      	cbz	r3, 61a8 <raw_input+0x60>
		pcb  = pcb->next;
    616a:	461c      	mov	r4, r3
		if ((pcb->protocol == proto)
    616c:	7c23      	ldrb	r3, [r4, #16]
    616e:	42b3      	cmp	r3, r6
    6170:	d1f8      	bne.n	6164 <raw_input+0x1c>
		    && (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
    6172:	b12c      	cbz	r4, 6180 <raw_input+0x38>
    6174:	6823      	ldr	r3, [r4, #0]
    6176:	b11b      	cbz	r3, 6180 <raw_input+0x38>
    6178:	f8d9 2000 	ldr.w	r2, [r9]
    617c:	4293      	cmp	r3, r2
    617e:	d1f1      	bne.n	6164 <raw_input+0x1c>
				if (pcb->recv != NULL) {
    6180:	6967      	ldr	r7, [r4, #20]
    6182:	2f00      	cmp	r7, #0
    6184:	d0ee      	beq.n	6164 <raw_input+0x1c>
					if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
    6186:	4643      	mov	r3, r8
    6188:	4652      	mov	r2, sl
    618a:	4621      	mov	r1, r4
    618c:	69a0      	ldr	r0, [r4, #24]
    618e:	47b8      	blx	r7
    6190:	2800      	cmp	r0, #0
    6192:	d0e7      	beq.n	6164 <raw_input+0x1c>
						if (prev != NULL) {
    6194:	b12d      	cbz	r5, 61a2 <raw_input+0x5a>
							prev->next = pcb->next;
    6196:	68e3      	ldr	r3, [r4, #12]
    6198:	60eb      	str	r3, [r5, #12]
							pcb->next  = raw_pcbs;
    619a:	4b06      	ldr	r3, [pc, #24]	; (61b4 <raw_input+0x6c>)
    619c:	681a      	ldr	r2, [r3, #0]
    619e:	60e2      	str	r2, [r4, #12]
							raw_pcbs   = pcb;
    61a0:	601c      	str	r4, [r3, #0]
		pcb  = pcb->next;
    61a2:	2001      	movs	r0, #1
	}
	return eaten;
}
    61a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    61a8:	2000      	movs	r0, #0
    61aa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	u8_t            eaten = 0;
    61ae:	2000      	movs	r0, #0
    61b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    61b4:	20007f94 	.word	0x20007f94
    61b8:	2000832c 	.word	0x2000832c
    61bc:	20008334 	.word	0x20008334

000061c0 <tcp_init>:

/**
 * Initialize this module.
 */
void tcp_init(void)
{
    61c0:	4770      	bx	lr

000061c2 <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
    61c2:	b470      	push	{r4, r5, r6}
    61c4:	4602      	mov	r2, r0
	u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    61c6:	6a85      	ldr	r5, [r0, #40]	; 0x28
    61c8:	8d84      	ldrh	r4, [r0, #44]	; 0x2c

	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    61ca:	6b01      	ldr	r1, [r0, #48]	; 0x30
	u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    61cc:	1963      	adds	r3, r4, r5
    61ce:	1a58      	subs	r0, r3, r1
	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    61d0:	8ed3      	ldrh	r3, [r2, #54]	; 0x36
    61d2:	f640 3668 	movw	r6, #2920	; 0xb68
    61d6:	42b3      	cmp	r3, r6
    61d8:	bf94      	ite	ls
    61da:	1ac3      	subls	r3, r0, r3
    61dc:	1b83      	subhi	r3, r0, r6
    61de:	2b00      	cmp	r3, #0
    61e0:	db02      	blt.n	61e8 <tcp_update_rcv_ann_wnd+0x26>
		/* we can advertise more window */
		pcb->rcv_ann_wnd = pcb->rcv_wnd;
    61e2:	85d4      	strh	r4, [r2, #46]	; 0x2e
			LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
			pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
		}
		return 0;
	}
}
    61e4:	bc70      	pop	{r4, r5, r6}
    61e6:	4770      	bx	lr
		if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
    61e8:	1a6b      	subs	r3, r5, r1
    61ea:	2b00      	cmp	r3, #0
    61ec:	dd03      	ble.n	61f6 <tcp_update_rcv_ann_wnd+0x34>
			pcb->rcv_ann_wnd = 0;
    61ee:	2300      	movs	r3, #0
    61f0:	85d3      	strh	r3, [r2, #46]	; 0x2e
		return 0;
    61f2:	4618      	mov	r0, r3
    61f4:	e7f6      	b.n	61e4 <tcp_update_rcv_ann_wnd+0x22>
			u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
    61f6:	1b49      	subs	r1, r1, r5
			pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    61f8:	85d1      	strh	r1, [r2, #46]	; 0x2e
		return 0;
    61fa:	2000      	movs	r0, #0
    61fc:	e7f2      	b.n	61e4 <tcp_update_rcv_ann_wnd+0x22>
	...

00006200 <tcp_recved>:
 *
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
    6200:	b510      	push	{r4, lr}
    6202:	4604      	mov	r4, r0

	/* pcb->state LISTEN not allowed here */
	LWIP_ASSERT("don't call tcp_recved for listen-pcbs", pcb->state != LISTEN);
	LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n", len <= 0xffff - pcb->rcv_wnd);

	pcb->rcv_wnd += len;
    6204:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
    6206:	4419      	add	r1, r3
    6208:	b289      	uxth	r1, r1
	if (pcb->rcv_wnd > TCP_WND) {
    620a:	f241 63d0 	movw	r3, #5840	; 0x16d0
    620e:	4299      	cmp	r1, r3
	pcb->rcv_wnd += len;
    6210:	bf92      	itee	ls
    6212:	8581      	strhls	r1, [r0, #44]	; 0x2c
		pcb->rcv_wnd = TCP_WND;
    6214:	f241 63d0 	movwhi	r3, #5840	; 0x16d0
    6218:	8583      	strhhi	r3, [r0, #44]	; 0x2c
	}

	wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    621a:	4b07      	ldr	r3, [pc, #28]	; (6238 <tcp_recved+0x38>)
    621c:	4798      	blx	r3

	/* If the change in the right edge of window is significant (default
	 * watermark is TCP_WND/4), then send an explicit update now.
	 * Otherwise wait for a packet to be sent in the normal course of
	 * events (or more window to be available later) */
	if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    621e:	f240 53b3 	movw	r3, #1459	; 0x5b3
    6222:	4298      	cmp	r0, r3
    6224:	dc00      	bgt.n	6228 <tcp_recved+0x28>
    6226:	bd10      	pop	{r4, pc}
		tcp_ack_now(pcb);
    6228:	7fa3      	ldrb	r3, [r4, #30]
    622a:	f043 0302 	orr.w	r3, r3, #2
    622e:	77a3      	strb	r3, [r4, #30]
		tcp_output(pcb);
    6230:	4620      	mov	r0, r4
    6232:	4b02      	ldr	r3, [pc, #8]	; (623c <tcp_recved+0x3c>)
    6234:	4798      	blx	r3
	LWIP_DEBUGF(TCP_DEBUG,
	            ("tcp_recved: recveived %" U16_F " bytes, wnd %" U16_F " (%" U16_F ").\n",
	             len,
	             pcb->rcv_wnd,
	             TCP_WND - pcb->rcv_wnd));
}
    6236:	e7f6      	b.n	6226 <tcp_recved+0x26>
    6238:	000061c3 	.word	0x000061c3
    623c:	000082a1 	.word	0x000082a1

00006240 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void tcp_seg_free(struct tcp_seg *seg)
{
	if (seg != NULL) {
    6240:	b150      	cbz	r0, 6258 <tcp_seg_free+0x18>
{
    6242:	b510      	push	{r4, lr}
    6244:	4604      	mov	r4, r0
		if (seg->p != NULL) {
    6246:	6840      	ldr	r0, [r0, #4]
    6248:	b108      	cbz	r0, 624e <tcp_seg_free+0xe>
			pbuf_free(seg->p);
    624a:	4b04      	ldr	r3, [pc, #16]	; (625c <tcp_seg_free+0x1c>)
    624c:	4798      	blx	r3
#if TCP_DEBUG
			seg->p = NULL;
#endif /* TCP_DEBUG */
		}
		memp_free(MEMP_TCP_SEG, seg);
    624e:	4621      	mov	r1, r4
    6250:	2004      	movs	r0, #4
    6252:	4b03      	ldr	r3, [pc, #12]	; (6260 <tcp_seg_free+0x20>)
    6254:	4798      	blx	r3
    6256:	bd10      	pop	{r4, pc}
    6258:	4770      	bx	lr
    625a:	bf00      	nop
    625c:	00005d21 	.word	0x00005d21
    6260:	00005a59 	.word	0x00005a59

00006264 <tcp_segs_free>:
	while (seg != NULL) {
    6264:	b148      	cbz	r0, 627a <tcp_segs_free+0x16>
{
    6266:	b538      	push	{r3, r4, r5, lr}
    6268:	4603      	mov	r3, r0
		tcp_seg_free(seg);
    626a:	4d04      	ldr	r5, [pc, #16]	; (627c <tcp_segs_free+0x18>)
		struct tcp_seg *next = seg->next;
    626c:	681c      	ldr	r4, [r3, #0]
		tcp_seg_free(seg);
    626e:	4618      	mov	r0, r3
    6270:	47a8      	blx	r5
		seg = next;
    6272:	4623      	mov	r3, r4
	while (seg != NULL) {
    6274:	2c00      	cmp	r4, #0
    6276:	d1f9      	bne.n	626c <tcp_segs_free+0x8>
    6278:	bd38      	pop	{r3, r4, r5, pc}
    627a:	4770      	bx	lr
    627c:	00006241 	.word	0x00006241

00006280 <tcp_seg_copy>:
 *
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *tcp_seg_copy(struct tcp_seg *seg)
{
    6280:	b538      	push	{r3, r4, r5, lr}
    6282:	4605      	mov	r5, r0
	struct tcp_seg *cseg;

	cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    6284:	2004      	movs	r0, #4
    6286:	4b09      	ldr	r3, [pc, #36]	; (62ac <tcp_seg_copy+0x2c>)
    6288:	4798      	blx	r3
	if (cseg == NULL) {
    628a:	4604      	mov	r4, r0
    628c:	b160      	cbz	r0, 62a8 <tcp_seg_copy+0x28>
		return NULL;
	}
	SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
    628e:	682b      	ldr	r3, [r5, #0]
    6290:	6868      	ldr	r0, [r5, #4]
    6292:	68a9      	ldr	r1, [r5, #8]
    6294:	68ea      	ldr	r2, [r5, #12]
    6296:	6023      	str	r3, [r4, #0]
    6298:	6060      	str	r0, [r4, #4]
    629a:	60a1      	str	r1, [r4, #8]
    629c:	60e2      	str	r2, [r4, #12]
    629e:	692b      	ldr	r3, [r5, #16]
    62a0:	6123      	str	r3, [r4, #16]
	pbuf_ref(cseg->p);
    62a2:	6860      	ldr	r0, [r4, #4]
    62a4:	4b02      	ldr	r3, [pc, #8]	; (62b0 <tcp_seg_copy+0x30>)
    62a6:	4798      	blx	r3
	return cseg;
}
    62a8:	4620      	mov	r0, r4
    62aa:	bd38      	pop	{r3, r4, r5, pc}
    62ac:	00005a11 	.word	0x00005a11
    62b0:	00005f3b 	.word	0x00005f3b

000062b4 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void tcp_pcb_purge(struct tcp_pcb *pcb)
{
	if (pcb->state != CLOSED && pcb->state != TIME_WAIT && pcb->state != LISTEN) {
    62b4:	7e03      	ldrb	r3, [r0, #24]
    62b6:	2b01      	cmp	r3, #1
    62b8:	d91a      	bls.n	62f0 <tcp_pcb_purge+0x3c>
    62ba:	2b0a      	cmp	r3, #10
    62bc:	d018      	beq.n	62f0 <tcp_pcb_purge+0x3c>
{
    62be:	b570      	push	{r4, r5, r6, lr}
    62c0:	4604      	mov	r4, r0
				}
			}
		}
#endif /* TCP_LISTEN_BACKLOG */

		if (pcb->refused_data != NULL) {
    62c2:	6f80      	ldr	r0, [r0, #120]	; 0x78
    62c4:	b118      	cbz	r0, 62ce <tcp_pcb_purge+0x1a>
			LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
			pbuf_free(pcb->refused_data);
    62c6:	4b0b      	ldr	r3, [pc, #44]	; (62f4 <tcp_pcb_purge+0x40>)
    62c8:	4798      	blx	r3
			pcb->refused_data = NULL;
    62ca:	2300      	movs	r3, #0
    62cc:	67a3      	str	r3, [r4, #120]	; 0x78
		}
#if TCP_QUEUE_OOSEQ
		if (pcb->ooseq != NULL) {
			LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
		}
		tcp_segs_free(pcb->ooseq);
    62ce:	6f60      	ldr	r0, [r4, #116]	; 0x74
    62d0:	4e09      	ldr	r6, [pc, #36]	; (62f8 <tcp_pcb_purge+0x44>)
    62d2:	47b0      	blx	r6
		pcb->ooseq = NULL;
    62d4:	2500      	movs	r5, #0
    62d6:	6765      	str	r5, [r4, #116]	; 0x74
#endif /* TCP_QUEUE_OOSEQ */

		/* Stop the retransmission timer as it will expect data on unacked
		   queue if it fires */
		pcb->rtime = -1;
    62d8:	f64f 73ff 	movw	r3, #65535	; 0xffff
    62dc:	86a3      	strh	r3, [r4, #52]	; 0x34

		tcp_segs_free(pcb->unsent);
    62de:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    62e0:	47b0      	blx	r6
		tcp_segs_free(pcb->unacked);
    62e2:	6f20      	ldr	r0, [r4, #112]	; 0x70
    62e4:	47b0      	blx	r6
		pcb->unacked = pcb->unsent = NULL;
    62e6:	66e5      	str	r5, [r4, #108]	; 0x6c
    62e8:	6725      	str	r5, [r4, #112]	; 0x70
#if TCP_OVERSIZE
		pcb->unsent_oversize = 0;
    62ea:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
    62ee:	bd70      	pop	{r4, r5, r6, pc}
    62f0:	4770      	bx	lr
    62f2:	bf00      	nop
    62f4:	00005d21 	.word	0x00005d21
    62f8:	00006265 	.word	0x00006265

000062fc <tcp_slowtmr>:
{
    62fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6300:	b083      	sub	sp, #12
	++tcp_ticks;
    6302:	4ab6      	ldr	r2, [pc, #728]	; (65dc <tcp_slowtmr+0x2e0>)
    6304:	6813      	ldr	r3, [r2, #0]
    6306:	3301      	adds	r3, #1
    6308:	6013      	str	r3, [r2, #0]
	++tcp_timer_ctr;
    630a:	4ab5      	ldr	r2, [pc, #724]	; (65e0 <tcp_slowtmr+0x2e4>)
    630c:	7813      	ldrb	r3, [r2, #0]
    630e:	3301      	adds	r3, #1
    6310:	7013      	strb	r3, [r2, #0]
		if (pcb->last_timer == tcp_timer_ctr) {
    6312:	4615      	mov	r5, r2
				tcp_active_pcbs_changed = 0;
    6314:	4fb3      	ldr	r7, [pc, #716]	; (65e4 <tcp_slowtmr+0x2e8>)
			if ((u32_t)(tcp_ticks - pcb->tmr) > (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
    6316:	f8df b2f8 	ldr.w	fp, [pc, #760]	; 6610 <tcp_slowtmr+0x314>
	pcb  = tcp_active_pcbs;
    631a:	4bb3      	ldr	r3, [pc, #716]	; (65e8 <tcp_slowtmr+0x2ec>)
    631c:	681c      	ldr	r4, [r3, #0]
	while (pcb != NULL) {
    631e:	2c00      	cmp	r4, #0
    6320:	f000 817d 	beq.w	661e <tcp_slowtmr+0x322>
    6324:	2600      	movs	r6, #0
    6326:	e003      	b.n	6330 <tcp_slowtmr+0x34>
			pcb = pcb->next;
    6328:	68e4      	ldr	r4, [r4, #12]
	while (pcb != NULL) {
    632a:	2c00      	cmp	r4, #0
    632c:	f000 8177 	beq.w	661e <tcp_slowtmr+0x322>
		if (pcb->last_timer == tcp_timer_ctr) {
    6330:	782b      	ldrb	r3, [r5, #0]
    6332:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    6336:	429a      	cmp	r2, r3
    6338:	d0f6      	beq.n	6328 <tcp_slowtmr+0x2c>
		pcb->last_timer = tcp_timer_ctr;
    633a:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
		if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    633e:	7e22      	ldrb	r2, [r4, #24]
    6340:	2a02      	cmp	r2, #2
    6342:	d023      	beq.n	638c <tcp_slowtmr+0x90>
		} else if (pcb->nrtx == TCP_MAXRTX) {
    6344:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
    6348:	2b0c      	cmp	r3, #12
    634a:	d061      	beq.n	6410 <tcp_slowtmr+0x114>
			if (pcb->persist_backoff > 0) {
    634c:	f894 8095 	ldrb.w	r8, [r4, #149]	; 0x95
    6350:	f1b8 0f00 	cmp.w	r8, #0
    6354:	d026      	beq.n	63a4 <tcp_slowtmr+0xa8>
				pcb->persist_cnt++;
    6356:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
    635a:	3301      	adds	r3, #1
    635c:	b2db      	uxtb	r3, r3
    635e:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    6362:	4aa2      	ldr	r2, [pc, #648]	; (65ec <tcp_slowtmr+0x2f0>)
    6364:	4442      	add	r2, r8
    6366:	7bd2      	ldrb	r2, [r2, #15]
    6368:	429a      	cmp	r2, r3
    636a:	d874      	bhi.n	6456 <tcp_slowtmr+0x15a>
					pcb->persist_cnt = 0;
    636c:	2300      	movs	r3, #0
    636e:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
					if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
    6372:	f1b8 0f06 	cmp.w	r8, #6
						pcb->persist_backoff++;
    6376:	bf9c      	itt	ls
    6378:	f108 0801 	addls.w	r8, r8, #1
    637c:	f884 8095 	strbls.w	r8, [r4, #149]	; 0x95
					tcp_zero_window_probe(pcb);
    6380:	4620      	mov	r0, r4
    6382:	4b9b      	ldr	r3, [pc, #620]	; (65f0 <tcp_slowtmr+0x2f4>)
    6384:	4798      	blx	r3
		pcb_remove = 0;
    6386:	f04f 0800 	mov.w	r8, #0
    638a:	e043      	b.n	6414 <tcp_slowtmr+0x118>
		if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    638c:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
    6390:	2b06      	cmp	r3, #6
    6392:	f000 8090 	beq.w	64b6 <tcp_slowtmr+0x1ba>
		} else if (pcb->nrtx == TCP_MAXRTX) {
    6396:	2b0c      	cmp	r3, #12
    6398:	d1d8      	bne.n	634c <tcp_slowtmr+0x50>
		pcb_reset  = 0;
    639a:	f04f 0900 	mov.w	r9, #0
		} else if (pcb->nrtx == TCP_MAXRTX) {
    639e:	f04f 0801 	mov.w	r8, #1
    63a2:	e08f      	b.n	64c4 <tcp_slowtmr+0x1c8>
				if (pcb->rtime >= 0) {
    63a4:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
    63a8:	2900      	cmp	r1, #0
					++pcb->rtime;
    63aa:	bfa4      	itt	ge
    63ac:	3101      	addge	r1, #1
    63ae:	86a1      	strhge	r1, [r4, #52]	; 0x34
				if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
    63b0:	6f21      	ldr	r1, [r4, #112]	; 0x70
    63b2:	b379      	cbz	r1, 6414 <tcp_slowtmr+0x118>
    63b4:	f9b4 0034 	ldrsh.w	r0, [r4, #52]	; 0x34
    63b8:	f9b4 1044 	ldrsh.w	r1, [r4, #68]	; 0x44
    63bc:	4288      	cmp	r0, r1
    63be:	db29      	blt.n	6414 <tcp_slowtmr+0x118>
					if (pcb->state != SYN_SENT) {
    63c0:	2a02      	cmp	r2, #2
    63c2:	d00c      	beq.n	63de <tcp_slowtmr+0xe2>
						pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
    63c4:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
    63c8:	f9b4 2042 	ldrsh.w	r2, [r4, #66]	; 0x42
    63cc:	eb02 02e1 	add.w	r2, r2, r1, asr #3
    63d0:	4986      	ldr	r1, [pc, #536]	; (65ec <tcp_slowtmr+0x2f0>)
    63d2:	440b      	add	r3, r1
    63d4:	7e1b      	ldrb	r3, [r3, #24]
    63d6:	fa02 f303 	lsl.w	r3, r2, r3
    63da:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
					pcb->rtime = 0;
    63de:	2300      	movs	r3, #0
    63e0:	86a3      	strh	r3, [r4, #52]	; 0x34
					eff_wnd       = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    63e2:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
    63e6:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
					pcb->ssthresh = eff_wnd >> 1;
    63ea:	4293      	cmp	r3, r2
    63ec:	bf28      	it	cs
    63ee:	4613      	movcs	r3, r2
    63f0:	085b      	lsrs	r3, r3, #1
    63f2:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
					if (pcb->ssthresh < (pcb->mss << 1)) {
    63f6:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
    63f8:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
						pcb->ssthresh = (pcb->mss << 1);
    63fc:	bfbc      	itt	lt
    63fe:	0053      	lsllt	r3, r2, #1
    6400:	f8a4 304e 	strhlt.w	r3, [r4, #78]	; 0x4e
					pcb->cwnd = pcb->mss;
    6404:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
					tcp_rexmit_rto(pcb);
    6408:	4620      	mov	r0, r4
    640a:	4b7a      	ldr	r3, [pc, #488]	; (65f4 <tcp_slowtmr+0x2f8>)
    640c:	4798      	blx	r3
    640e:	e001      	b.n	6414 <tcp_slowtmr+0x118>
			++pcb_remove;
    6410:	f04f 0801 	mov.w	r8, #1
		if (pcb->state == FIN_WAIT_2) {
    6414:	7e23      	ldrb	r3, [r4, #24]
    6416:	2b06      	cmp	r3, #6
    6418:	d020      	beq.n	645c <tcp_slowtmr+0x160>
		if (ip_get_option(pcb, SOF_KEEPALIVE) && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    641a:	7a22      	ldrb	r2, [r4, #8]
    641c:	f012 0f08 	tst.w	r2, #8
    6420:	d04e      	beq.n	64c0 <tcp_slowtmr+0x1c4>
    6422:	2b04      	cmp	r3, #4
    6424:	d001      	beq.n	642a <tcp_slowtmr+0x12e>
    6426:	2b07      	cmp	r3, #7
    6428:	d17f      	bne.n	652a <tcp_slowtmr+0x22e>
			if ((u32_t)(tcp_ticks - pcb->tmr) > (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
    642a:	4b6c      	ldr	r3, [pc, #432]	; (65dc <tcp_slowtmr+0x2e0>)
    642c:	681a      	ldr	r2, [r3, #0]
    642e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    6430:	1ad2      	subs	r2, r2, r3
    6432:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
    6436:	f501 2324 	add.w	r3, r1, #671744	; 0xa4000
    643a:	f603 43b8 	addw	r3, r3, #3256	; 0xcb8
    643e:	fbab 0303 	umull	r0, r3, fp, r3
    6442:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
    6446:	d91e      	bls.n	6486 <tcp_slowtmr+0x18a>
				++pcb_remove;
    6448:	f108 0801 	add.w	r8, r8, #1
    644c:	fa5f f888 	uxtb.w	r8, r8
				++pcb_reset;
    6450:	f04f 0901 	mov.w	r9, #1
    6454:	e036      	b.n	64c4 <tcp_slowtmr+0x1c8>
		pcb_remove = 0;
    6456:	f04f 0800 	mov.w	r8, #0
    645a:	e7db      	b.n	6414 <tcp_slowtmr+0x118>
			if (pcb->flags & TF_RXCLOSED) {
    645c:	7fa3      	ldrb	r3, [r4, #30]
    645e:	f013 0f10 	tst.w	r3, #16
    6462:	d009      	beq.n	6478 <tcp_slowtmr+0x17c>
				if ((u32_t)(tcp_ticks - pcb->tmr) > TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
    6464:	4b5d      	ldr	r3, [pc, #372]	; (65dc <tcp_slowtmr+0x2e0>)
    6466:	681b      	ldr	r3, [r3, #0]
    6468:	6a62      	ldr	r2, [r4, #36]	; 0x24
    646a:	1a9b      	subs	r3, r3, r2
    646c:	2b28      	cmp	r3, #40	; 0x28
    646e:	d903      	bls.n	6478 <tcp_slowtmr+0x17c>
					++pcb_remove;
    6470:	f108 0801 	add.w	r8, r8, #1
    6474:	fa5f f888 	uxtb.w	r8, r8
		if (pcb->ooseq != NULL && (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    6478:	6f60      	ldr	r0, [r4, #116]	; 0x74
    647a:	2800      	cmp	r0, #0
    647c:	f000 80f1 	beq.w	6662 <tcp_slowtmr+0x366>
		pcb_reset  = 0;
    6480:	f04f 0900 	mov.w	r9, #0
    6484:	e020      	b.n	64c8 <tcp_slowtmr+0x1cc>
			           > (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb)) / TCP_SLOW_INTERVAL) {
    6486:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
    648a:	485b      	ldr	r0, [pc, #364]	; (65f8 <tcp_slowtmr+0x2fc>)
    648c:	fb00 1303 	mla	r3, r0, r3, r1
    6490:	fbab 1303 	umull	r1, r3, fp, r3
			} else if ((u32_t)(tcp_ticks - pcb->tmr)
    6494:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
    6498:	d802      	bhi.n	64a0 <tcp_slowtmr+0x1a4>
		pcb_reset  = 0;
    649a:	f04f 0900 	mov.w	r9, #0
    649e:	e011      	b.n	64c4 <tcp_slowtmr+0x1c8>
				tcp_keepalive(pcb);
    64a0:	4620      	mov	r0, r4
    64a2:	4b56      	ldr	r3, [pc, #344]	; (65fc <tcp_slowtmr+0x300>)
    64a4:	4798      	blx	r3
				pcb->keep_cnt_sent++;
    64a6:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
    64aa:	3301      	adds	r3, #1
    64ac:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
		pcb_reset  = 0;
    64b0:	f04f 0900 	mov.w	r9, #0
    64b4:	e006      	b.n	64c4 <tcp_slowtmr+0x1c8>
    64b6:	f04f 0900 	mov.w	r9, #0
    64ba:	f04f 0801 	mov.w	r8, #1
    64be:	e001      	b.n	64c4 <tcp_slowtmr+0x1c8>
    64c0:	f04f 0900 	mov.w	r9, #0
		if (pcb->ooseq != NULL && (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    64c4:	6f60      	ldr	r0, [r4, #116]	; 0x74
    64c6:	b150      	cbz	r0, 64de <tcp_slowtmr+0x1e2>
    64c8:	4b44      	ldr	r3, [pc, #272]	; (65dc <tcp_slowtmr+0x2e0>)
    64ca:	681a      	ldr	r2, [r3, #0]
    64cc:	6a63      	ldr	r3, [r4, #36]	; 0x24
    64ce:	1ad2      	subs	r2, r2, r3
    64d0:	f9b4 3044 	ldrsh.w	r3, [r4, #68]	; 0x44
    64d4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    64d8:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
    64dc:	d228      	bcs.n	6530 <tcp_slowtmr+0x234>
		if (pcb->state == SYN_RCVD) {
    64de:	7e23      	ldrb	r3, [r4, #24]
    64e0:	2b03      	cmp	r3, #3
    64e2:	d02a      	beq.n	653a <tcp_slowtmr+0x23e>
		if (pcb->state == LAST_ACK) {
    64e4:	2b09      	cmp	r3, #9
    64e6:	d033      	beq.n	6550 <tcp_slowtmr+0x254>
		if (pcb_remove) {
    64e8:	f1b8 0f00 	cmp.w	r8, #0
    64ec:	d13b      	bne.n	6566 <tcp_slowtmr+0x26a>
			pcb  = pcb->next;
    64ee:	f8d4 800c 	ldr.w	r8, [r4, #12]
			++prev->polltmr;
    64f2:	7fe3      	ldrb	r3, [r4, #31]
    64f4:	3301      	adds	r3, #1
    64f6:	b2db      	uxtb	r3, r3
    64f8:	77e3      	strb	r3, [r4, #31]
			if (prev->polltmr >= prev->pollinterval) {
    64fa:	f894 2020 	ldrb.w	r2, [r4, #32]
    64fe:	429a      	cmp	r2, r3
    6500:	f200 808a 	bhi.w	6618 <tcp_slowtmr+0x31c>
				prev->polltmr = 0;
    6504:	2300      	movs	r3, #0
    6506:	77e3      	strb	r3, [r4, #31]
				tcp_active_pcbs_changed = 0;
    6508:	703b      	strb	r3, [r7, #0]
				TCP_EVENT_POLL(prev, err);
    650a:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    650e:	2b00      	cmp	r3, #0
    6510:	d05b      	beq.n	65ca <tcp_slowtmr+0x2ce>
    6512:	4621      	mov	r1, r4
    6514:	6920      	ldr	r0, [r4, #16]
    6516:	4798      	blx	r3
				if (tcp_active_pcbs_changed) {
    6518:	783b      	ldrb	r3, [r7, #0]
    651a:	2b00      	cmp	r3, #0
    651c:	f47f aefd 	bne.w	631a <tcp_slowtmr+0x1e>
				if (err == ERR_OK) {
    6520:	2800      	cmp	r0, #0
    6522:	d052      	beq.n	65ca <tcp_slowtmr+0x2ce>
    6524:	4626      	mov	r6, r4
			pcb  = pcb->next;
    6526:	4644      	mov	r4, r8
    6528:	e6ff      	b.n	632a <tcp_slowtmr+0x2e>
		pcb_reset  = 0;
    652a:	f04f 0900 	mov.w	r9, #0
    652e:	e7c9      	b.n	64c4 <tcp_slowtmr+0x1c8>
			tcp_segs_free(pcb->ooseq);
    6530:	4b33      	ldr	r3, [pc, #204]	; (6600 <tcp_slowtmr+0x304>)
    6532:	4798      	blx	r3
			pcb->ooseq = NULL;
    6534:	2300      	movs	r3, #0
    6536:	6763      	str	r3, [r4, #116]	; 0x74
    6538:	e7d1      	b.n	64de <tcp_slowtmr+0x1e2>
			if ((u32_t)(tcp_ticks - pcb->tmr) > TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
    653a:	4b28      	ldr	r3, [pc, #160]	; (65dc <tcp_slowtmr+0x2e0>)
    653c:	681b      	ldr	r3, [r3, #0]
    653e:	6a62      	ldr	r2, [r4, #36]	; 0x24
    6540:	1a9b      	subs	r3, r3, r2
    6542:	2b28      	cmp	r3, #40	; 0x28
    6544:	d9d0      	bls.n	64e8 <tcp_slowtmr+0x1ec>
				++pcb_remove;
    6546:	f108 0801 	add.w	r8, r8, #1
    654a:	fa5f f888 	uxtb.w	r8, r8
    654e:	e7cb      	b.n	64e8 <tcp_slowtmr+0x1ec>
			if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    6550:	4b22      	ldr	r3, [pc, #136]	; (65dc <tcp_slowtmr+0x2e0>)
    6552:	681b      	ldr	r3, [r3, #0]
    6554:	6a62      	ldr	r2, [r4, #36]	; 0x24
    6556:	1a9b      	subs	r3, r3, r2
    6558:	2bf0      	cmp	r3, #240	; 0xf0
				++pcb_remove;
    655a:	bf84      	itt	hi
    655c:	f108 0801 	addhi.w	r8, r8, #1
    6560:	fa5f f888 	uxtbhi.w	r8, r8
    6564:	e7c0      	b.n	64e8 <tcp_slowtmr+0x1ec>
			tcp_pcb_purge(pcb);
    6566:	4620      	mov	r0, r4
    6568:	4b26      	ldr	r3, [pc, #152]	; (6604 <tcp_slowtmr+0x308>)
    656a:	4798      	blx	r3
			if (prev != NULL) {
    656c:	b1ee      	cbz	r6, 65aa <tcp_slowtmr+0x2ae>
				prev->next = pcb->next;
    656e:	68e3      	ldr	r3, [r4, #12]
    6570:	60f3      	str	r3, [r6, #12]
			if (pcb_reset) {
    6572:	f1b9 0f00 	cmp.w	r9, #0
    6576:	d11c      	bne.n	65b2 <tcp_slowtmr+0x2b6>
			err_fn  = pcb->errf;
    6578:	f8d4 808c 	ldr.w	r8, [r4, #140]	; 0x8c
			err_arg = pcb->callback_arg;
    657c:	f8d4 a010 	ldr.w	sl, [r4, #16]
			pcb     = pcb->next;
    6580:	f8d4 900c 	ldr.w	r9, [r4, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    6584:	4621      	mov	r1, r4
    6586:	2002      	movs	r0, #2
    6588:	4b1f      	ldr	r3, [pc, #124]	; (6608 <tcp_slowtmr+0x30c>)
    658a:	4798      	blx	r3
			tcp_active_pcbs_changed = 0;
    658c:	2300      	movs	r3, #0
    658e:	703b      	strb	r3, [r7, #0]
			TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
    6590:	f1b8 0f00 	cmp.w	r8, #0
    6594:	d01f      	beq.n	65d6 <tcp_slowtmr+0x2da>
    6596:	f06f 0109 	mvn.w	r1, #9
    659a:	4650      	mov	r0, sl
    659c:	47c0      	blx	r8
			if (tcp_active_pcbs_changed) {
    659e:	783b      	ldrb	r3, [r7, #0]
    65a0:	2b00      	cmp	r3, #0
    65a2:	f47f aeba 	bne.w	631a <tcp_slowtmr+0x1e>
			pcb     = pcb->next;
    65a6:	464c      	mov	r4, r9
    65a8:	e6bf      	b.n	632a <tcp_slowtmr+0x2e>
				tcp_active_pcbs = pcb->next;
    65aa:	68e3      	ldr	r3, [r4, #12]
    65ac:	4a0e      	ldr	r2, [pc, #56]	; (65e8 <tcp_slowtmr+0x2ec>)
    65ae:	6013      	str	r3, [r2, #0]
    65b0:	e7df      	b.n	6572 <tcp_slowtmr+0x276>
				tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    65b2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    65b4:	6d20      	ldr	r0, [r4, #80]	; 0x50
    65b6:	8ba3      	ldrh	r3, [r4, #28]
    65b8:	9301      	str	r3, [sp, #4]
    65ba:	8b63      	ldrh	r3, [r4, #26]
    65bc:	9300      	str	r3, [sp, #0]
    65be:	1d23      	adds	r3, r4, #4
    65c0:	4622      	mov	r2, r4
    65c2:	f8df 8050 	ldr.w	r8, [pc, #80]	; 6614 <tcp_slowtmr+0x318>
    65c6:	47c0      	blx	r8
    65c8:	e7d6      	b.n	6578 <tcp_slowtmr+0x27c>
					tcp_output(prev);
    65ca:	4620      	mov	r0, r4
    65cc:	4b0f      	ldr	r3, [pc, #60]	; (660c <tcp_slowtmr+0x310>)
    65ce:	4798      	blx	r3
    65d0:	4626      	mov	r6, r4
			pcb  = pcb->next;
    65d2:	4644      	mov	r4, r8
    65d4:	e6a9      	b.n	632a <tcp_slowtmr+0x2e>
			pcb     = pcb->next;
    65d6:	464c      	mov	r4, r9
    65d8:	e6a7      	b.n	632a <tcp_slowtmr+0x2e>
    65da:	bf00      	nop
    65dc:	20009304 	.word	0x20009304
    65e0:	20007f98 	.word	0x20007f98
    65e4:	200092fc 	.word	0x200092fc
    65e8:	20009300 	.word	0x20009300
    65ec:	0000c5ac 	.word	0x0000c5ac
    65f0:	00008771 	.word	0x00008771
    65f4:	00008619 	.word	0x00008619
    65f8:	000124f8 	.word	0x000124f8
    65fc:	00008705 	.word	0x00008705
    6600:	00006265 	.word	0x00006265
    6604:	000062b5 	.word	0x000062b5
    6608:	00005a59 	.word	0x00005a59
    660c:	000082a1 	.word	0x000082a1
    6610:	10624dd3 	.word	0x10624dd3
    6614:	00008575 	.word	0x00008575
    6618:	4626      	mov	r6, r4
			pcb  = pcb->next;
    661a:	4644      	mov	r4, r8
    661c:	e685      	b.n	632a <tcp_slowtmr+0x2e>
	pcb  = tcp_tw_pcbs;
    661e:	4b14      	ldr	r3, [pc, #80]	; (6670 <tcp_slowtmr+0x374>)
    6620:	681c      	ldr	r4, [r3, #0]
	while (pcb != NULL) {
    6622:	b30c      	cbz	r4, 6668 <tcp_slowtmr+0x36c>
    6624:	2500      	movs	r5, #0
		if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    6626:	4e13      	ldr	r6, [pc, #76]	; (6674 <tcp_slowtmr+0x378>)
			tcp_pcb_purge(pcb);
    6628:	f8df 8050 	ldr.w	r8, [pc, #80]	; 667c <tcp_slowtmr+0x380>
			memp_free(MEMP_TCP_PCB, pcb2);
    662c:	4f12      	ldr	r7, [pc, #72]	; (6678 <tcp_slowtmr+0x37c>)
    662e:	e006      	b.n	663e <tcp_slowtmr+0x342>
				tcp_tw_pcbs = pcb->next;
    6630:	68e2      	ldr	r2, [r4, #12]
    6632:	4b0f      	ldr	r3, [pc, #60]	; (6670 <tcp_slowtmr+0x374>)
    6634:	601a      	str	r2, [r3, #0]
    6636:	e00d      	b.n	6654 <tcp_slowtmr+0x358>
			pcb  = pcb->next;
    6638:	4625      	mov	r5, r4
    663a:	68e4      	ldr	r4, [r4, #12]
	while (pcb != NULL) {
    663c:	b1a4      	cbz	r4, 6668 <tcp_slowtmr+0x36c>
		if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    663e:	6a62      	ldr	r2, [r4, #36]	; 0x24
    6640:	6833      	ldr	r3, [r6, #0]
    6642:	1a9b      	subs	r3, r3, r2
		if (pcb_remove) {
    6644:	2bf0      	cmp	r3, #240	; 0xf0
    6646:	d9f7      	bls.n	6638 <tcp_slowtmr+0x33c>
			tcp_pcb_purge(pcb);
    6648:	4620      	mov	r0, r4
    664a:	47c0      	blx	r8
			if (prev != NULL) {
    664c:	2d00      	cmp	r5, #0
    664e:	d0ef      	beq.n	6630 <tcp_slowtmr+0x334>
				prev->next = pcb->next;
    6650:	68e3      	ldr	r3, [r4, #12]
    6652:	60eb      	str	r3, [r5, #12]
			pcb  = pcb->next;
    6654:	f8d4 900c 	ldr.w	r9, [r4, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    6658:	4621      	mov	r1, r4
    665a:	2002      	movs	r0, #2
    665c:	47b8      	blx	r7
			pcb  = pcb->next;
    665e:	464c      	mov	r4, r9
    6660:	e7ec      	b.n	663c <tcp_slowtmr+0x340>
		pcb_reset  = 0;
    6662:	f04f 0900 	mov.w	r9, #0
    6666:	e73f      	b.n	64e8 <tcp_slowtmr+0x1ec>
}
    6668:	b003      	add	sp, #12
    666a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    666e:	bf00      	nop
    6670:	20009314 	.word	0x20009314
    6674:	20009304 	.word	0x20009304
    6678:	00005a59 	.word	0x00005a59
    667c:	000062b5 	.word	0x000062b5

00006680 <tcp_pcb_remove>:
 *
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
    6680:	b510      	push	{r4, lr}
    6682:	460c      	mov	r4, r1
	TCP_RMV(pcblist, pcb);
    6684:	6802      	ldr	r2, [r0, #0]
    6686:	428a      	cmp	r2, r1
    6688:	d00b      	beq.n	66a2 <tcp_pcb_remove+0x22>
    668a:	4b18      	ldr	r3, [pc, #96]	; (66ec <tcp_pcb_remove+0x6c>)
    668c:	601a      	str	r2, [r3, #0]
    668e:	b17a      	cbz	r2, 66b0 <tcp_pcb_remove+0x30>
    6690:	68d3      	ldr	r3, [r2, #12]
    6692:	4299      	cmp	r1, r3
    6694:	d01d      	beq.n	66d2 <tcp_pcb_remove+0x52>
    6696:	b1f3      	cbz	r3, 66d6 <tcp_pcb_remove+0x56>
    6698:	68da      	ldr	r2, [r3, #12]
    669a:	4294      	cmp	r4, r2
    669c:	d004      	beq.n	66a8 <tcp_pcb_remove+0x28>
    669e:	4613      	mov	r3, r2
    66a0:	e7f9      	b.n	6696 <tcp_pcb_remove+0x16>
    66a2:	68d3      	ldr	r3, [r2, #12]
    66a4:	6003      	str	r3, [r0, #0]
    66a6:	e003      	b.n	66b0 <tcp_pcb_remove+0x30>
    66a8:	4a10      	ldr	r2, [pc, #64]	; (66ec <tcp_pcb_remove+0x6c>)
    66aa:	6013      	str	r3, [r2, #0]
    66ac:	68e2      	ldr	r2, [r4, #12]
    66ae:	60da      	str	r2, [r3, #12]
    66b0:	2300      	movs	r3, #0
    66b2:	60e3      	str	r3, [r4, #12]

	tcp_pcb_purge(pcb);
    66b4:	4620      	mov	r0, r4
    66b6:	4b0e      	ldr	r3, [pc, #56]	; (66f0 <tcp_pcb_remove+0x70>)
    66b8:	4798      	blx	r3

	/* if there is an outstanding delayed ACKs, send it */
	if (pcb->state != TIME_WAIT && pcb->state != LISTEN && pcb->flags & TF_ACK_DELAY) {
    66ba:	7e23      	ldrb	r3, [r4, #24]
    66bc:	2b0a      	cmp	r3, #10
    66be:	d005      	beq.n	66cc <tcp_pcb_remove+0x4c>
    66c0:	2b01      	cmp	r3, #1
    66c2:	d003      	beq.n	66cc <tcp_pcb_remove+0x4c>
    66c4:	7fa3      	ldrb	r3, [r4, #30]
    66c6:	f013 0f01 	tst.w	r3, #1
    66ca:	d108      	bne.n	66de <tcp_pcb_remove+0x5e>
#if TCP_QUEUE_OOSEQ
		LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
	}

	pcb->state = CLOSED;
    66cc:	2300      	movs	r3, #0
    66ce:	7623      	strb	r3, [r4, #24]
    66d0:	bd10      	pop	{r4, pc}
	TCP_RMV(pcblist, pcb);
    66d2:	4613      	mov	r3, r2
    66d4:	e7ea      	b.n	66ac <tcp_pcb_remove+0x2c>
    66d6:	2200      	movs	r2, #0
    66d8:	4b04      	ldr	r3, [pc, #16]	; (66ec <tcp_pcb_remove+0x6c>)
    66da:	601a      	str	r2, [r3, #0]
    66dc:	e7e8      	b.n	66b0 <tcp_pcb_remove+0x30>
		pcb->flags |= TF_ACK_NOW;
    66de:	f043 0302 	orr.w	r3, r3, #2
    66e2:	77a3      	strb	r3, [r4, #30]
		tcp_output(pcb);
    66e4:	4620      	mov	r0, r4
    66e6:	4b03      	ldr	r3, [pc, #12]	; (66f4 <tcp_pcb_remove+0x74>)
    66e8:	4798      	blx	r3
    66ea:	e7ef      	b.n	66cc <tcp_pcb_remove+0x4c>
    66ec:	2000930c 	.word	0x2000930c
    66f0:	000062b5 	.word	0x000062b5
    66f4:	000082a1 	.word	0x000082a1

000066f8 <tcp_close_shutdown>:
{
    66f8:	b530      	push	{r4, r5, lr}
    66fa:	b083      	sub	sp, #12
    66fc:	4604      	mov	r4, r0
	if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    66fe:	b121      	cbz	r1, 670a <tcp_close_shutdown+0x12>
    6700:	7e03      	ldrb	r3, [r0, #24]
    6702:	2b04      	cmp	r3, #4
    6704:	d00b      	beq.n	671e <tcp_close_shutdown+0x26>
    6706:	2b07      	cmp	r3, #7
    6708:	d009      	beq.n	671e <tcp_close_shutdown+0x26>
	switch (pcb->state) {
    670a:	7e23      	ldrb	r3, [r4, #24]
    670c:	2b07      	cmp	r3, #7
    670e:	f200 80ae 	bhi.w	686e <tcp_close_shutdown+0x176>
    6712:	e8df f003 	tbb	[pc, r3]
    6716:	774e      	.short	0x774e
    6718:	ac9a8c80 	.word	0xac9a8c80
    671c:	a3ac      	.short	0xa3ac
		if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
    671e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    6720:	b1e3      	cbz	r3, 675c <tcp_close_shutdown+0x64>
			tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    6722:	8ba3      	ldrh	r3, [r4, #28]
    6724:	9301      	str	r3, [sp, #4]
    6726:	8b63      	ldrh	r3, [r4, #26]
    6728:	9300      	str	r3, [sp, #0]
    672a:	1d23      	adds	r3, r4, #4
    672c:	4622      	mov	r2, r4
    672e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    6730:	6d20      	ldr	r0, [r4, #80]	; 0x50
    6732:	4d51      	ldr	r5, [pc, #324]	; (6878 <tcp_close_shutdown+0x180>)
    6734:	47a8      	blx	r5
			tcp_pcb_purge(pcb);
    6736:	4620      	mov	r0, r4
    6738:	4b50      	ldr	r3, [pc, #320]	; (687c <tcp_close_shutdown+0x184>)
    673a:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    673c:	4b50      	ldr	r3, [pc, #320]	; (6880 <tcp_close_shutdown+0x188>)
    673e:	681a      	ldr	r2, [r3, #0]
    6740:	4294      	cmp	r4, r2
    6742:	d011      	beq.n	6768 <tcp_close_shutdown+0x70>
    6744:	4b4f      	ldr	r3, [pc, #316]	; (6884 <tcp_close_shutdown+0x18c>)
    6746:	601a      	str	r2, [r3, #0]
    6748:	b1aa      	cbz	r2, 6776 <tcp_close_shutdown+0x7e>
    674a:	68d3      	ldr	r3, [r2, #12]
    674c:	429c      	cmp	r4, r3
    674e:	d020      	beq.n	6792 <tcp_close_shutdown+0x9a>
    6750:	b30b      	cbz	r3, 6796 <tcp_close_shutdown+0x9e>
    6752:	68da      	ldr	r2, [r3, #12]
    6754:	4294      	cmp	r4, r2
    6756:	d00a      	beq.n	676e <tcp_close_shutdown+0x76>
    6758:	4613      	mov	r3, r2
    675a:	e7f9      	b.n	6750 <tcp_close_shutdown+0x58>
		if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
    675c:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    675e:	f241 63d0 	movw	r3, #5840	; 0x16d0
    6762:	429a      	cmp	r2, r3
    6764:	d1dd      	bne.n	6722 <tcp_close_shutdown+0x2a>
    6766:	e7d0      	b.n	670a <tcp_close_shutdown+0x12>
			TCP_RMV_ACTIVE(pcb);
    6768:	68d2      	ldr	r2, [r2, #12]
    676a:	601a      	str	r2, [r3, #0]
    676c:	e003      	b.n	6776 <tcp_close_shutdown+0x7e>
    676e:	4a45      	ldr	r2, [pc, #276]	; (6884 <tcp_close_shutdown+0x18c>)
    6770:	6013      	str	r3, [r2, #0]
    6772:	68e2      	ldr	r2, [r4, #12]
    6774:	60da      	str	r2, [r3, #12]
    6776:	2300      	movs	r3, #0
    6778:	60e3      	str	r3, [r4, #12]
    677a:	2201      	movs	r2, #1
    677c:	4b42      	ldr	r3, [pc, #264]	; (6888 <tcp_close_shutdown+0x190>)
    677e:	701a      	strb	r2, [r3, #0]
			if (pcb->state == ESTABLISHED) {
    6780:	7e23      	ldrb	r3, [r4, #24]
    6782:	2b04      	cmp	r3, #4
    6784:	d00b      	beq.n	679e <tcp_close_shutdown+0xa6>
				memp_free(MEMP_TCP_PCB, pcb);
    6786:	4621      	mov	r1, r4
    6788:	2002      	movs	r0, #2
    678a:	4b40      	ldr	r3, [pc, #256]	; (688c <tcp_close_shutdown+0x194>)
    678c:	4798      	blx	r3
			return ERR_OK;
    678e:	2300      	movs	r3, #0
    6790:	e02f      	b.n	67f2 <tcp_close_shutdown+0xfa>
			TCP_RMV_ACTIVE(pcb);
    6792:	4613      	mov	r3, r2
    6794:	e7ed      	b.n	6772 <tcp_close_shutdown+0x7a>
    6796:	2200      	movs	r2, #0
    6798:	4b3a      	ldr	r3, [pc, #232]	; (6884 <tcp_close_shutdown+0x18c>)
    679a:	601a      	str	r2, [r3, #0]
    679c:	e7eb      	b.n	6776 <tcp_close_shutdown+0x7e>
				pcb->state = TIME_WAIT;
    679e:	230a      	movs	r3, #10
    67a0:	7623      	strb	r3, [r4, #24]
				TCP_REG(&tcp_tw_pcbs, pcb);
    67a2:	4b3b      	ldr	r3, [pc, #236]	; (6890 <tcp_close_shutdown+0x198>)
    67a4:	681a      	ldr	r2, [r3, #0]
    67a6:	60e2      	str	r2, [r4, #12]
    67a8:	601c      	str	r4, [r3, #0]
    67aa:	4b3a      	ldr	r3, [pc, #232]	; (6894 <tcp_close_shutdown+0x19c>)
    67ac:	4798      	blx	r3
			return ERR_OK;
    67ae:	2300      	movs	r3, #0
    67b0:	e01f      	b.n	67f2 <tcp_close_shutdown+0xfa>
		if (pcb->local_port != 0) {
    67b2:	8b63      	ldrh	r3, [r4, #26]
    67b4:	b1c3      	cbz	r3, 67e8 <tcp_close_shutdown+0xf0>
			TCP_RMV(&tcp_bound_pcbs, pcb);
    67b6:	4b38      	ldr	r3, [pc, #224]	; (6898 <tcp_close_shutdown+0x1a0>)
    67b8:	681a      	ldr	r2, [r3, #0]
    67ba:	4294      	cmp	r4, r2
    67bc:	d00b      	beq.n	67d6 <tcp_close_shutdown+0xde>
    67be:	4b31      	ldr	r3, [pc, #196]	; (6884 <tcp_close_shutdown+0x18c>)
    67c0:	601a      	str	r2, [r3, #0]
    67c2:	b17a      	cbz	r2, 67e4 <tcp_close_shutdown+0xec>
    67c4:	68d3      	ldr	r3, [r2, #12]
    67c6:	429c      	cmp	r4, r3
    67c8:	d016      	beq.n	67f8 <tcp_close_shutdown+0x100>
    67ca:	b1bb      	cbz	r3, 67fc <tcp_close_shutdown+0x104>
    67cc:	68da      	ldr	r2, [r3, #12]
    67ce:	4294      	cmp	r4, r2
    67d0:	d004      	beq.n	67dc <tcp_close_shutdown+0xe4>
    67d2:	4613      	mov	r3, r2
    67d4:	e7f9      	b.n	67ca <tcp_close_shutdown+0xd2>
    67d6:	68d2      	ldr	r2, [r2, #12]
    67d8:	601a      	str	r2, [r3, #0]
    67da:	e003      	b.n	67e4 <tcp_close_shutdown+0xec>
    67dc:	4a29      	ldr	r2, [pc, #164]	; (6884 <tcp_close_shutdown+0x18c>)
    67de:	6013      	str	r3, [r2, #0]
    67e0:	68e2      	ldr	r2, [r4, #12]
    67e2:	60da      	str	r2, [r3, #12]
    67e4:	2300      	movs	r3, #0
    67e6:	60e3      	str	r3, [r4, #12]
		memp_free(MEMP_TCP_PCB, pcb);
    67e8:	4621      	mov	r1, r4
    67ea:	2002      	movs	r0, #2
    67ec:	4b27      	ldr	r3, [pc, #156]	; (688c <tcp_close_shutdown+0x194>)
    67ee:	4798      	blx	r3
		err = ERR_OK;
    67f0:	2300      	movs	r3, #0
}
    67f2:	4618      	mov	r0, r3
    67f4:	b003      	add	sp, #12
    67f6:	bd30      	pop	{r4, r5, pc}
			TCP_RMV(&tcp_bound_pcbs, pcb);
    67f8:	4613      	mov	r3, r2
    67fa:	e7f1      	b.n	67e0 <tcp_close_shutdown+0xe8>
    67fc:	2200      	movs	r2, #0
    67fe:	4b21      	ldr	r3, [pc, #132]	; (6884 <tcp_close_shutdown+0x18c>)
    6800:	601a      	str	r2, [r3, #0]
    6802:	e7ef      	b.n	67e4 <tcp_close_shutdown+0xec>
		tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
    6804:	4621      	mov	r1, r4
    6806:	4825      	ldr	r0, [pc, #148]	; (689c <tcp_close_shutdown+0x1a4>)
    6808:	4b25      	ldr	r3, [pc, #148]	; (68a0 <tcp_close_shutdown+0x1a8>)
    680a:	4798      	blx	r3
		memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    680c:	4621      	mov	r1, r4
    680e:	2003      	movs	r0, #3
    6810:	4b1e      	ldr	r3, [pc, #120]	; (688c <tcp_close_shutdown+0x194>)
    6812:	4798      	blx	r3
		break;
    6814:	e7ec      	b.n	67f0 <tcp_close_shutdown+0xf8>
		TCP_PCB_REMOVE_ACTIVE(pcb);
    6816:	4621      	mov	r1, r4
    6818:	4819      	ldr	r0, [pc, #100]	; (6880 <tcp_close_shutdown+0x188>)
    681a:	4b21      	ldr	r3, [pc, #132]	; (68a0 <tcp_close_shutdown+0x1a8>)
    681c:	4798      	blx	r3
    681e:	2201      	movs	r2, #1
    6820:	4b19      	ldr	r3, [pc, #100]	; (6888 <tcp_close_shutdown+0x190>)
    6822:	701a      	strb	r2, [r3, #0]
		memp_free(MEMP_TCP_PCB, pcb);
    6824:	4621      	mov	r1, r4
    6826:	2002      	movs	r0, #2
    6828:	4b18      	ldr	r3, [pc, #96]	; (688c <tcp_close_shutdown+0x194>)
    682a:	4798      	blx	r3
		break;
    682c:	e7e0      	b.n	67f0 <tcp_close_shutdown+0xf8>
		err = tcp_send_fin(pcb);
    682e:	4620      	mov	r0, r4
    6830:	4b1c      	ldr	r3, [pc, #112]	; (68a4 <tcp_close_shutdown+0x1ac>)
    6832:	4798      	blx	r3
		if (err == ERR_OK) {
    6834:	4603      	mov	r3, r0
    6836:	2800      	cmp	r0, #0
    6838:	d1db      	bne.n	67f2 <tcp_close_shutdown+0xfa>
			pcb->state = FIN_WAIT_1;
    683a:	2305      	movs	r3, #5
    683c:	7623      	strb	r3, [r4, #24]
	if (pcb != NULL && err == ERR_OK) {
    683e:	b1c4      	cbz	r4, 6872 <tcp_close_shutdown+0x17a>
		tcp_output(pcb);
    6840:	4620      	mov	r0, r4
    6842:	4b19      	ldr	r3, [pc, #100]	; (68a8 <tcp_close_shutdown+0x1b0>)
    6844:	4798      	blx	r3
	return err;
    6846:	2300      	movs	r3, #0
    6848:	e7d3      	b.n	67f2 <tcp_close_shutdown+0xfa>
		err = tcp_send_fin(pcb);
    684a:	4620      	mov	r0, r4
    684c:	4b15      	ldr	r3, [pc, #84]	; (68a4 <tcp_close_shutdown+0x1ac>)
    684e:	4798      	blx	r3
		if (err == ERR_OK) {
    6850:	4603      	mov	r3, r0
    6852:	2800      	cmp	r0, #0
    6854:	d1cd      	bne.n	67f2 <tcp_close_shutdown+0xfa>
			pcb->state = FIN_WAIT_1;
    6856:	2305      	movs	r3, #5
    6858:	7623      	strb	r3, [r4, #24]
    685a:	e7f0      	b.n	683e <tcp_close_shutdown+0x146>
		err = tcp_send_fin(pcb);
    685c:	4620      	mov	r0, r4
    685e:	4b11      	ldr	r3, [pc, #68]	; (68a4 <tcp_close_shutdown+0x1ac>)
    6860:	4798      	blx	r3
		if (err == ERR_OK) {
    6862:	4603      	mov	r3, r0
    6864:	2800      	cmp	r0, #0
    6866:	d1c4      	bne.n	67f2 <tcp_close_shutdown+0xfa>
			pcb->state = LAST_ACK;
    6868:	2309      	movs	r3, #9
    686a:	7623      	strb	r3, [r4, #24]
    686c:	e7e7      	b.n	683e <tcp_close_shutdown+0x146>
		err = ERR_OK;
    686e:	2300      	movs	r3, #0
    6870:	e7bf      	b.n	67f2 <tcp_close_shutdown+0xfa>
	if (pcb != NULL && err == ERR_OK) {
    6872:	2300      	movs	r3, #0
    6874:	e7bd      	b.n	67f2 <tcp_close_shutdown+0xfa>
    6876:	bf00      	nop
    6878:	00008575 	.word	0x00008575
    687c:	000062b5 	.word	0x000062b5
    6880:	20009300 	.word	0x20009300
    6884:	2000930c 	.word	0x2000930c
    6888:	200092fc 	.word	0x200092fc
    688c:	00005a59 	.word	0x00005a59
    6890:	20009314 	.word	0x20009314
    6894:	000088b9 	.word	0x000088b9
    6898:	20009310 	.word	0x20009310
    689c:	20009308 	.word	0x20009308
    68a0:	00006681 	.word	0x00006681
    68a4:	000081d9 	.word	0x000081d9
    68a8:	000082a1 	.word	0x000082a1

000068ac <tcp_close>:
{
    68ac:	b508      	push	{r3, lr}
	if (pcb->state != LISTEN) {
    68ae:	7e03      	ldrb	r3, [r0, #24]
    68b0:	2b01      	cmp	r3, #1
    68b2:	d003      	beq.n	68bc <tcp_close+0x10>
		pcb->flags |= TF_RXCLOSED;
    68b4:	7f83      	ldrb	r3, [r0, #30]
    68b6:	f043 0310 	orr.w	r3, r3, #16
    68ba:	7783      	strb	r3, [r0, #30]
	return tcp_close_shutdown(pcb, 1);
    68bc:	2101      	movs	r1, #1
    68be:	4b01      	ldr	r3, [pc, #4]	; (68c4 <tcp_close+0x18>)
    68c0:	4798      	blx	r3
}
    68c2:	bd08      	pop	{r3, pc}
    68c4:	000066f9 	.word	0x000066f9

000068c8 <tcp_recv_null>:
{
    68c8:	b510      	push	{r4, lr}
    68ca:	4608      	mov	r0, r1
	if (p != NULL) {
    68cc:	b142      	cbz	r2, 68e0 <tcp_recv_null+0x18>
    68ce:	4614      	mov	r4, r2
		tcp_recved(pcb, p->tot_len);
    68d0:	8911      	ldrh	r1, [r2, #8]
    68d2:	4b06      	ldr	r3, [pc, #24]	; (68ec <tcp_recv_null+0x24>)
    68d4:	4798      	blx	r3
		pbuf_free(p);
    68d6:	4620      	mov	r0, r4
    68d8:	4b05      	ldr	r3, [pc, #20]	; (68f0 <tcp_recv_null+0x28>)
    68da:	4798      	blx	r3
	return ERR_OK;
    68dc:	2000      	movs	r0, #0
    68de:	bd10      	pop	{r4, pc}
	} else if (err == ERR_OK) {
    68e0:	b10b      	cbz	r3, 68e6 <tcp_recv_null+0x1e>
	return ERR_OK;
    68e2:	2000      	movs	r0, #0
}
    68e4:	bd10      	pop	{r4, pc}
		return tcp_close(pcb);
    68e6:	4b03      	ldr	r3, [pc, #12]	; (68f4 <tcp_recv_null+0x2c>)
    68e8:	4798      	blx	r3
    68ea:	bd10      	pop	{r4, pc}
    68ec:	00006201 	.word	0x00006201
    68f0:	00005d21 	.word	0x00005d21
    68f4:	000068ad 	.word	0x000068ad

000068f8 <tcp_process_refused_data>:
{
    68f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    68fa:	4604      	mov	r4, r0
	u8_t  refused_flags = pcb->refused_data->flags;
    68fc:	6f86      	ldr	r6, [r0, #120]	; 0x78
    68fe:	7b77      	ldrb	r7, [r6, #13]
	pcb->refused_data         = NULL;
    6900:	2300      	movs	r3, #0
    6902:	6783      	str	r3, [r0, #120]	; 0x78
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    6904:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
    6908:	b1e5      	cbz	r5, 6944 <tcp_process_refused_data+0x4c>
    690a:	4632      	mov	r2, r6
    690c:	4601      	mov	r1, r0
    690e:	6900      	ldr	r0, [r0, #16]
    6910:	47a8      	blx	r5
    6912:	4605      	mov	r5, r0
	if (err == ERR_OK) {
    6914:	b9f5      	cbnz	r5, 6954 <tcp_process_refused_data+0x5c>
		if (refused_flags & PBUF_FLAG_TCP_FIN) {
    6916:	f017 0f20 	tst.w	r7, #32
    691a:	d020      	beq.n	695e <tcp_process_refused_data+0x66>
			if (pcb->rcv_wnd != TCP_WND) {
    691c:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    691e:	f241 62d0 	movw	r2, #5840	; 0x16d0
    6922:	4293      	cmp	r3, r2
				pcb->rcv_wnd++;
    6924:	bf1c      	itt	ne
    6926:	3301      	addne	r3, #1
    6928:	85a3      	strhne	r3, [r4, #44]	; 0x2c
			TCP_EVENT_CLOSED(pcb, err);
    692a:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
    692e:	b1b6      	cbz	r6, 695e <tcp_process_refused_data+0x66>
    6930:	2300      	movs	r3, #0
    6932:	461a      	mov	r2, r3
    6934:	4621      	mov	r1, r4
    6936:	6920      	ldr	r0, [r4, #16]
    6938:	47b0      	blx	r6
				return ERR_ABRT;
    693a:	f110 0f0a 	cmn.w	r0, #10
    693e:	bf08      	it	eq
    6940:	4605      	moveq	r5, r0
    6942:	e00c      	b.n	695e <tcp_process_refused_data+0x66>
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    6944:	2300      	movs	r3, #0
    6946:	4632      	mov	r2, r6
    6948:	4601      	mov	r1, r0
    694a:	4618      	mov	r0, r3
    694c:	4d05      	ldr	r5, [pc, #20]	; (6964 <tcp_process_refused_data+0x6c>)
    694e:	47a8      	blx	r5
    6950:	4605      	mov	r5, r0
    6952:	e7df      	b.n	6914 <tcp_process_refused_data+0x1c>
	} else if (err == ERR_ABRT) {
    6954:	f115 0f0a 	cmn.w	r5, #10
		pcb->refused_data = refused_data;
    6958:	bf1c      	itt	ne
    695a:	67a6      	strne	r6, [r4, #120]	; 0x78
	return ERR_OK;
    695c:	2500      	movne	r5, #0
}
    695e:	4628      	mov	r0, r5
    6960:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6962:	bf00      	nop
    6964:	000068c9 	.word	0x000068c9

00006968 <tcp_fasttmr>:
{
    6968:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	++tcp_timer_ctr;
    696c:	4a18      	ldr	r2, [pc, #96]	; (69d0 <tcp_fasttmr+0x68>)
    696e:	7813      	ldrb	r3, [r2, #0]
    6970:	3301      	adds	r3, #1
    6972:	7013      	strb	r3, [r2, #0]
	pcb = tcp_active_pcbs;
    6974:	4f17      	ldr	r7, [pc, #92]	; (69d4 <tcp_fasttmr+0x6c>)
		if (pcb->last_timer != tcp_timer_ctr) {
    6976:	4615      	mov	r5, r2
				tcp_output(pcb);
    6978:	f8df 8064 	ldr.w	r8, [pc, #100]	; 69e0 <tcp_fasttmr+0x78>
				tcp_active_pcbs_changed = 0;
    697c:	4e16      	ldr	r6, [pc, #88]	; (69d8 <tcp_fasttmr+0x70>)
	pcb = tcp_active_pcbs;
    697e:	683c      	ldr	r4, [r7, #0]
	while (pcb != NULL) {
    6980:	b31c      	cbz	r4, 69ca <tcp_fasttmr+0x62>
		if (pcb->last_timer != tcp_timer_ctr) {
    6982:	782b      	ldrb	r3, [r5, #0]
    6984:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    6988:	429a      	cmp	r2, r3
    698a:	d100      	bne.n	698e <tcp_fasttmr+0x26>
    698c:	e7fe      	b.n	698c <tcp_fasttmr+0x24>
			pcb->last_timer = tcp_timer_ctr;
    698e:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
			if (pcb->flags & TF_ACK_DELAY) {
    6992:	7fa3      	ldrb	r3, [r4, #30]
    6994:	f013 0f01 	tst.w	r3, #1
    6998:	d10d      	bne.n	69b6 <tcp_fasttmr+0x4e>
			next = pcb->next;
    699a:	f8d4 900c 	ldr.w	r9, [r4, #12]
			if (pcb->refused_data != NULL) {
    699e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    69a0:	b13b      	cbz	r3, 69b2 <tcp_fasttmr+0x4a>
				tcp_active_pcbs_changed = 0;
    69a2:	2300      	movs	r3, #0
    69a4:	7033      	strb	r3, [r6, #0]
				tcp_process_refused_data(pcb);
    69a6:	4620      	mov	r0, r4
    69a8:	4b0c      	ldr	r3, [pc, #48]	; (69dc <tcp_fasttmr+0x74>)
    69aa:	4798      	blx	r3
				if (tcp_active_pcbs_changed) {
    69ac:	7833      	ldrb	r3, [r6, #0]
    69ae:	2b00      	cmp	r3, #0
    69b0:	d1e5      	bne.n	697e <tcp_fasttmr+0x16>
{
    69b2:	464c      	mov	r4, r9
    69b4:	e7e4      	b.n	6980 <tcp_fasttmr+0x18>
				tcp_ack_now(pcb);
    69b6:	f043 0302 	orr.w	r3, r3, #2
    69ba:	77a3      	strb	r3, [r4, #30]
				tcp_output(pcb);
    69bc:	4620      	mov	r0, r4
    69be:	47c0      	blx	r8
				pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    69c0:	7fa3      	ldrb	r3, [r4, #30]
    69c2:	f023 0303 	bic.w	r3, r3, #3
    69c6:	77a3      	strb	r3, [r4, #30]
    69c8:	e7e7      	b.n	699a <tcp_fasttmr+0x32>
    69ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    69ce:	bf00      	nop
    69d0:	20007f98 	.word	0x20007f98
    69d4:	20009300 	.word	0x20009300
    69d8:	200092fc 	.word	0x200092fc
    69dc:	000068f9 	.word	0x000068f9
    69e0:	000082a1 	.word	0x000082a1

000069e4 <tcp_tmr>:
{
    69e4:	b508      	push	{r3, lr}
	tcp_fasttmr();
    69e6:	4b07      	ldr	r3, [pc, #28]	; (6a04 <tcp_tmr+0x20>)
    69e8:	4798      	blx	r3
	if (++tcp_timer & 1) {
    69ea:	4a07      	ldr	r2, [pc, #28]	; (6a08 <tcp_tmr+0x24>)
    69ec:	7853      	ldrb	r3, [r2, #1]
    69ee:	3301      	adds	r3, #1
    69f0:	b2db      	uxtb	r3, r3
    69f2:	7053      	strb	r3, [r2, #1]
    69f4:	f013 0f01 	tst.w	r3, #1
    69f8:	d100      	bne.n	69fc <tcp_tmr+0x18>
    69fa:	bd08      	pop	{r3, pc}
		tcp_slowtmr();
    69fc:	4b03      	ldr	r3, [pc, #12]	; (6a0c <tcp_tmr+0x28>)
    69fe:	4798      	blx	r3
}
    6a00:	e7fb      	b.n	69fa <tcp_tmr+0x16>
    6a02:	bf00      	nop
    6a04:	00006969 	.word	0x00006969
    6a08:	20007f98 	.word	0x20007f98
    6a0c:	000062fd 	.word	0x000062fd

00006a10 <tcp_abandon>:
{
    6a10:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6a14:	b083      	sub	sp, #12
    6a16:	4604      	mov	r4, r0
	if (pcb->state == TIME_WAIT) {
    6a18:	7e03      	ldrb	r3, [r0, #24]
    6a1a:	2b0a      	cmp	r3, #10
    6a1c:	d027      	beq.n	6a6e <tcp_abandon+0x5e>
    6a1e:	460e      	mov	r6, r1
		seqno = pcb->snd_nxt;
    6a20:	f8d0 8050 	ldr.w	r8, [r0, #80]	; 0x50
		ackno = pcb->rcv_nxt;
    6a24:	f8d0 9028 	ldr.w	r9, [r0, #40]	; 0x28
		errf = pcb->errf;
    6a28:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c
		errf_arg = pcb->callback_arg;
    6a2c:	6907      	ldr	r7, [r0, #16]
		TCP_PCB_REMOVE_ACTIVE(pcb);
    6a2e:	4601      	mov	r1, r0
    6a30:	4819      	ldr	r0, [pc, #100]	; (6a98 <tcp_abandon+0x88>)
    6a32:	4b1a      	ldr	r3, [pc, #104]	; (6a9c <tcp_abandon+0x8c>)
    6a34:	4798      	blx	r3
    6a36:	2201      	movs	r2, #1
    6a38:	4b19      	ldr	r3, [pc, #100]	; (6aa0 <tcp_abandon+0x90>)
    6a3a:	701a      	strb	r2, [r3, #0]
		if (pcb->unacked != NULL) {
    6a3c:	6f20      	ldr	r0, [r4, #112]	; 0x70
    6a3e:	b108      	cbz	r0, 6a44 <tcp_abandon+0x34>
			tcp_segs_free(pcb->unacked);
    6a40:	4b18      	ldr	r3, [pc, #96]	; (6aa4 <tcp_abandon+0x94>)
    6a42:	4798      	blx	r3
		if (pcb->unsent != NULL) {
    6a44:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    6a46:	b108      	cbz	r0, 6a4c <tcp_abandon+0x3c>
			tcp_segs_free(pcb->unsent);
    6a48:	4b16      	ldr	r3, [pc, #88]	; (6aa4 <tcp_abandon+0x94>)
    6a4a:	4798      	blx	r3
		if (pcb->ooseq != NULL) {
    6a4c:	6f60      	ldr	r0, [r4, #116]	; 0x74
    6a4e:	b108      	cbz	r0, 6a54 <tcp_abandon+0x44>
			tcp_segs_free(pcb->ooseq);
    6a50:	4b14      	ldr	r3, [pc, #80]	; (6aa4 <tcp_abandon+0x94>)
    6a52:	4798      	blx	r3
		if (reset) {
    6a54:	b9a6      	cbnz	r6, 6a80 <tcp_abandon+0x70>
		memp_free(MEMP_TCP_PCB, pcb);
    6a56:	4621      	mov	r1, r4
    6a58:	2002      	movs	r0, #2
    6a5a:	4b13      	ldr	r3, [pc, #76]	; (6aa8 <tcp_abandon+0x98>)
    6a5c:	4798      	blx	r3
		TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    6a5e:	b11d      	cbz	r5, 6a68 <tcp_abandon+0x58>
    6a60:	f06f 0109 	mvn.w	r1, #9
    6a64:	4638      	mov	r0, r7
    6a66:	47a8      	blx	r5
}
    6a68:	b003      	add	sp, #12
    6a6a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    6a6e:	4601      	mov	r1, r0
    6a70:	480e      	ldr	r0, [pc, #56]	; (6aac <tcp_abandon+0x9c>)
    6a72:	4b0a      	ldr	r3, [pc, #40]	; (6a9c <tcp_abandon+0x8c>)
    6a74:	4798      	blx	r3
		memp_free(MEMP_TCP_PCB, pcb);
    6a76:	4621      	mov	r1, r4
    6a78:	2002      	movs	r0, #2
    6a7a:	4b0b      	ldr	r3, [pc, #44]	; (6aa8 <tcp_abandon+0x98>)
    6a7c:	4798      	blx	r3
    6a7e:	e7f3      	b.n	6a68 <tcp_abandon+0x58>
			tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    6a80:	8ba3      	ldrh	r3, [r4, #28]
    6a82:	9301      	str	r3, [sp, #4]
    6a84:	8b63      	ldrh	r3, [r4, #26]
    6a86:	9300      	str	r3, [sp, #0]
    6a88:	1d23      	adds	r3, r4, #4
    6a8a:	4622      	mov	r2, r4
    6a8c:	4649      	mov	r1, r9
    6a8e:	4640      	mov	r0, r8
    6a90:	4e07      	ldr	r6, [pc, #28]	; (6ab0 <tcp_abandon+0xa0>)
    6a92:	47b0      	blx	r6
    6a94:	e7df      	b.n	6a56 <tcp_abandon+0x46>
    6a96:	bf00      	nop
    6a98:	20009300 	.word	0x20009300
    6a9c:	00006681 	.word	0x00006681
    6aa0:	200092fc 	.word	0x200092fc
    6aa4:	00006265 	.word	0x00006265
    6aa8:	00005a59 	.word	0x00005a59
    6aac:	20009314 	.word	0x20009314
    6ab0:	00008575 	.word	0x00008575

00006ab4 <tcp_abort>:
{
    6ab4:	b508      	push	{r3, lr}
	tcp_abandon(pcb, 1);
    6ab6:	2101      	movs	r1, #1
    6ab8:	4b01      	ldr	r3, [pc, #4]	; (6ac0 <tcp_abort+0xc>)
    6aba:	4798      	blx	r3
    6abc:	bd08      	pop	{r3, pc}
    6abe:	bf00      	nop
    6ac0:	00006a11 	.word	0x00006a11

00006ac4 <tcp_next_iss>:
 */
u32_t tcp_next_iss(void)
{
	static u32_t iss = 6510;

	iss += tcp_ticks; /* XXX */
    6ac4:	4b03      	ldr	r3, [pc, #12]	; (6ad4 <tcp_next_iss+0x10>)
    6ac6:	6858      	ldr	r0, [r3, #4]
    6ac8:	4a03      	ldr	r2, [pc, #12]	; (6ad8 <tcp_next_iss+0x14>)
    6aca:	6812      	ldr	r2, [r2, #0]
    6acc:	4410      	add	r0, r2
    6ace:	6058      	str	r0, [r3, #4]
	return iss;
}
    6ad0:	4770      	bx	lr
    6ad2:	bf00      	nop
    6ad4:	20000004 	.word	0x20000004
    6ad8:	20009304 	.word	0x20009304

00006adc <tcp_alloc>:
{
    6adc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6ade:	4605      	mov	r5, r0
	pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    6ae0:	2002      	movs	r0, #2
    6ae2:	4b3e      	ldr	r3, [pc, #248]	; (6bdc <tcp_alloc+0x100>)
    6ae4:	4798      	blx	r3
	if (pcb == NULL) {
    6ae6:	4604      	mov	r4, r0
    6ae8:	2800      	cmp	r0, #0
    6aea:	d03b      	beq.n	6b64 <tcp_alloc+0x88>
		memset(pcb, 0, sizeof(struct tcp_pcb));
    6aec:	2298      	movs	r2, #152	; 0x98
    6aee:	2100      	movs	r1, #0
    6af0:	4620      	mov	r0, r4
    6af2:	4b3b      	ldr	r3, [pc, #236]	; (6be0 <tcp_alloc+0x104>)
    6af4:	4798      	blx	r3
		pcb->prio         = prio;
    6af6:	7665      	strb	r5, [r4, #25]
		pcb->snd_buf      = TCP_SND_BUF;
    6af8:	f640 3368 	movw	r3, #2920	; 0xb68
    6afc:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
		pcb->snd_queuelen = 0;
    6b00:	2500      	movs	r5, #0
    6b02:	f8a4 5068 	strh.w	r5, [r4, #104]	; 0x68
		pcb->rcv_wnd      = TCP_WND;
    6b06:	f241 63d0 	movw	r3, #5840	; 0x16d0
    6b0a:	85a3      	strh	r3, [r4, #44]	; 0x2c
		pcb->rcv_ann_wnd  = TCP_WND;
    6b0c:	85e3      	strh	r3, [r4, #46]	; 0x2e
		pcb->tos          = 0;
    6b0e:	7265      	strb	r5, [r4, #9]
		pcb->ttl          = TCP_TTL;
    6b10:	23ff      	movs	r3, #255	; 0xff
    6b12:	72a3      	strb	r3, [r4, #10]
		pcb->mss        = (TCP_MSS > 536) ? 536 : TCP_MSS;
    6b14:	f44f 7306 	mov.w	r3, #536	; 0x218
    6b18:	86e3      	strh	r3, [r4, #54]	; 0x36
		pcb->rto        = 3000 / TCP_SLOW_INTERVAL;
    6b1a:	2306      	movs	r3, #6
    6b1c:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
		pcb->sa         = 0;
    6b20:	f8a4 5040 	strh.w	r5, [r4, #64]	; 0x40
		pcb->sv         = 3000 / TCP_SLOW_INTERVAL;
    6b24:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
		pcb->rtime      = -1;
    6b28:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6b2c:	86a3      	strh	r3, [r4, #52]	; 0x34
		pcb->cwnd       = 1;
    6b2e:	2301      	movs	r3, #1
    6b30:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		iss             = tcp_next_iss();
    6b34:	4b2b      	ldr	r3, [pc, #172]	; (6be4 <tcp_alloc+0x108>)
    6b36:	4798      	blx	r3
		pcb->snd_wl2    = iss;
    6b38:	65a0      	str	r0, [r4, #88]	; 0x58
		pcb->snd_nxt    = iss;
    6b3a:	6520      	str	r0, [r4, #80]	; 0x50
		pcb->lastack    = iss;
    6b3c:	64a0      	str	r0, [r4, #72]	; 0x48
		pcb->snd_lbb    = iss;
    6b3e:	65e0      	str	r0, [r4, #92]	; 0x5c
		pcb->tmr        = tcp_ticks;
    6b40:	4b29      	ldr	r3, [pc, #164]	; (6be8 <tcp_alloc+0x10c>)
    6b42:	681b      	ldr	r3, [r3, #0]
    6b44:	6263      	str	r3, [r4, #36]	; 0x24
		pcb->last_timer = tcp_timer_ctr;
    6b46:	4b29      	ldr	r3, [pc, #164]	; (6bec <tcp_alloc+0x110>)
    6b48:	781b      	ldrb	r3, [r3, #0]
    6b4a:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
		pcb->polltmr = 0;
    6b4e:	77e5      	strb	r5, [r4, #31]
		pcb->recv = tcp_recv_null;
    6b50:	4b27      	ldr	r3, [pc, #156]	; (6bf0 <tcp_alloc+0x114>)
    6b52:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
		pcb->keep_idle = TCP_KEEPIDLE_DEFAULT;
    6b56:	4b27      	ldr	r3, [pc, #156]	; (6bf4 <tcp_alloc+0x118>)
    6b58:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
		pcb->keep_cnt_sent = 0;
    6b5c:	f884 5096 	strb.w	r5, [r4, #150]	; 0x96
}
    6b60:	4620      	mov	r0, r4
    6b62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    6b64:	4b24      	ldr	r3, [pc, #144]	; (6bf8 <tcp_alloc+0x11c>)
    6b66:	681b      	ldr	r3, [r3, #0]
    6b68:	b17b      	cbz	r3, 6b8a <tcp_alloc+0xae>
		if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6b6a:	4a1f      	ldr	r2, [pc, #124]	; (6be8 <tcp_alloc+0x10c>)
    6b6c:	6810      	ldr	r0, [r2, #0]
    6b6e:	2100      	movs	r1, #0
    6b70:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    6b72:	1a82      	subs	r2, r0, r2
    6b74:	428a      	cmp	r2, r1
			inactivity = tcp_ticks - pcb->tmr;
    6b76:	bf24      	itt	cs
    6b78:	4611      	movcs	r1, r2
		if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6b7a:	461c      	movcs	r4, r3
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    6b7c:	68db      	ldr	r3, [r3, #12]
    6b7e:	2b00      	cmp	r3, #0
    6b80:	d1f6      	bne.n	6b70 <tcp_alloc+0x94>
	if (inactive != NULL) {
    6b82:	b114      	cbz	r4, 6b8a <tcp_alloc+0xae>
		tcp_abort(inactive);
    6b84:	4620      	mov	r0, r4
    6b86:	4b1d      	ldr	r3, [pc, #116]	; (6bfc <tcp_alloc+0x120>)
    6b88:	4798      	blx	r3
		pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    6b8a:	2002      	movs	r0, #2
    6b8c:	4b13      	ldr	r3, [pc, #76]	; (6bdc <tcp_alloc+0x100>)
    6b8e:	4798      	blx	r3
		if (pcb == NULL) {
    6b90:	4604      	mov	r4, r0
    6b92:	2800      	cmp	r0, #0
    6b94:	d1aa      	bne.n	6aec <tcp_alloc+0x10>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    6b96:	4b1a      	ldr	r3, [pc, #104]	; (6c00 <tcp_alloc+0x124>)
    6b98:	681b      	ldr	r3, [r3, #0]
    6b9a:	b1bb      	cbz	r3, 6bcc <tcp_alloc+0xf0>
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6b9c:	4a12      	ldr	r2, [pc, #72]	; (6be8 <tcp_alloc+0x10c>)
    6b9e:	6817      	ldr	r7, [r2, #0]
    6ba0:	2600      	movs	r6, #0
    6ba2:	207f      	movs	r0, #127	; 0x7f
    6ba4:	e001      	b.n	6baa <tcp_alloc+0xce>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    6ba6:	68db      	ldr	r3, [r3, #12]
    6ba8:	b163      	cbz	r3, 6bc4 <tcp_alloc+0xe8>
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6baa:	7e5a      	ldrb	r2, [r3, #25]
    6bac:	4295      	cmp	r5, r2
    6bae:	d3fa      	bcc.n	6ba6 <tcp_alloc+0xca>
    6bb0:	4282      	cmp	r2, r0
    6bb2:	d8f8      	bhi.n	6ba6 <tcp_alloc+0xca>
    6bb4:	6a59      	ldr	r1, [r3, #36]	; 0x24
    6bb6:	1a79      	subs	r1, r7, r1
    6bb8:	42b1      	cmp	r1, r6
    6bba:	d3f4      	bcc.n	6ba6 <tcp_alloc+0xca>
			mprio      = pcb->prio;
    6bbc:	4610      	mov	r0, r2
			inactivity = tcp_ticks - pcb->tmr;
    6bbe:	460e      	mov	r6, r1
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6bc0:	461c      	mov	r4, r3
    6bc2:	e7f0      	b.n	6ba6 <tcp_alloc+0xca>
	if (inactive != NULL) {
    6bc4:	b114      	cbz	r4, 6bcc <tcp_alloc+0xf0>
		tcp_abort(inactive);
    6bc6:	4620      	mov	r0, r4
    6bc8:	4b0c      	ldr	r3, [pc, #48]	; (6bfc <tcp_alloc+0x120>)
    6bca:	4798      	blx	r3
			pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    6bcc:	2002      	movs	r0, #2
    6bce:	4b03      	ldr	r3, [pc, #12]	; (6bdc <tcp_alloc+0x100>)
    6bd0:	4798      	blx	r3
	if (pcb != NULL) {
    6bd2:	4604      	mov	r4, r0
    6bd4:	2800      	cmp	r0, #0
    6bd6:	d0c3      	beq.n	6b60 <tcp_alloc+0x84>
    6bd8:	e788      	b.n	6aec <tcp_alloc+0x10>
    6bda:	bf00      	nop
    6bdc:	00005a11 	.word	0x00005a11
    6be0:	0000a101 	.word	0x0000a101
    6be4:	00006ac5 	.word	0x00006ac5
    6be8:	20009304 	.word	0x20009304
    6bec:	20007f98 	.word	0x20007f98
    6bf0:	000068c9 	.word	0x000068c9
    6bf4:	006ddd00 	.word	0x006ddd00
    6bf8:	20009314 	.word	0x20009314
    6bfc:	00006ab5 	.word	0x00006ab5
    6c00:	20009300 	.word	0x20009300

00006c04 <tcp_eff_send_mss>:
 * Calcluates the effective send mss that can be used for a specific IP address
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
    6c04:	b510      	push	{r4, lr}
    6c06:	4604      	mov	r4, r0
	u16_t         mss_s;
	struct netif *outif;

	outif = ip_route(addr);
    6c08:	4608      	mov	r0, r1
    6c0a:	4b07      	ldr	r3, [pc, #28]	; (6c28 <tcp_eff_send_mss+0x24>)
    6c0c:	4798      	blx	r3
	if ((outif != NULL) && (outif->mtu != 0)) {
    6c0e:	b138      	cbz	r0, 6c20 <tcp_eff_send_mss+0x1c>
    6c10:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
    6c12:	b138      	cbz	r0, 6c24 <tcp_eff_send_mss+0x20>
		mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    6c14:	3828      	subs	r0, #40	; 0x28
		/* RFC 1122, chap 4.2.2.6:
		 * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
		 * We correct for TCP options in tcp_write(), and don't support IP options.
		 */
		sendmss = LWIP_MIN(sendmss, mss_s);
    6c16:	b280      	uxth	r0, r0
    6c18:	42a0      	cmp	r0, r4
    6c1a:	bf28      	it	cs
    6c1c:	4620      	movcs	r0, r4
    6c1e:	bd10      	pop	{r4, pc}
    6c20:	4620      	mov	r0, r4
    6c22:	bd10      	pop	{r4, pc}
    6c24:	4620      	mov	r0, r4
	}
	return sendmss;
}
    6c26:	bd10      	pop	{r4, pc}
    6c28:	00004c25 	.word	0x00004c25

00006c2c <tcp_parseopt>:
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void tcp_parseopt(struct tcp_pcb *pcb)
{
    6c2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6c2e:	4605      	mov	r5, r0
	u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
	u32_t tsval;
#endif

	opts = (u8_t *)tcphdr + TCP_HLEN;
    6c30:	4b22      	ldr	r3, [pc, #136]	; (6cbc <tcp_parseopt+0x90>)
    6c32:	681c      	ldr	r4, [r3, #0]

	/* Parse the TCP MSS option, if present. */
	if (TCPH_HDRLEN(tcphdr) > 0x5) {
    6c34:	89a0      	ldrh	r0, [r4, #12]
    6c36:	4b22      	ldr	r3, [pc, #136]	; (6cc0 <tcp_parseopt+0x94>)
    6c38:	4798      	blx	r3
    6c3a:	f3c0 300f 	ubfx	r0, r0, #12, #16
    6c3e:	2805      	cmp	r0, #5
    6c40:	d800      	bhi.n	6c44 <tcp_parseopt+0x18>
    6c42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    6c44:	4b1d      	ldr	r3, [pc, #116]	; (6cbc <tcp_parseopt+0x90>)
    6c46:	681b      	ldr	r3, [r3, #0]
    6c48:	8998      	ldrh	r0, [r3, #12]
    6c4a:	4b1d      	ldr	r3, [pc, #116]	; (6cc0 <tcp_parseopt+0x94>)
    6c4c:	4798      	blx	r3
    6c4e:	0b06      	lsrs	r6, r0, #12
    6c50:	3e05      	subs	r6, #5
    6c52:	00b6      	lsls	r6, r6, #2
    6c54:	b2b6      	uxth	r6, r6
		for (c = 0; c < max_c;) {
    6c56:	2e00      	cmp	r6, #0
    6c58:	d0f3      	beq.n	6c42 <tcp_parseopt+0x16>
	opts = (u8_t *)tcphdr + TCP_HLEN;
    6c5a:	f104 0214 	add.w	r2, r4, #20
    6c5e:	2300      	movs	r3, #0
					return;
				}
				/* An MSS option with the right option length. */
				mss = (opts[c + 2] << 8) | opts[c + 3];
				/* Limit the mss to the configured TCP_MSS and prevent division by zero */
				pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    6c60:	f240 57b3 	movw	r7, #1459	; 0x5b3
    6c64:	f240 54b4 	movw	r4, #1460	; 0x5b4
    6c68:	e003      	b.n	6c72 <tcp_parseopt+0x46>
				++c;
    6c6a:	3301      	adds	r3, #1
    6c6c:	b29b      	uxth	r3, r3
		for (c = 0; c < max_c;) {
    6c6e:	429e      	cmp	r6, r3
    6c70:	d9e7      	bls.n	6c42 <tcp_parseopt+0x16>
			opt = opts[c];
    6c72:	4618      	mov	r0, r3
			switch (opt) {
    6c74:	5cd1      	ldrb	r1, [r2, r3]
    6c76:	2901      	cmp	r1, #1
    6c78:	d0f7      	beq.n	6c6a <tcp_parseopt+0x3e>
    6c7a:	2900      	cmp	r1, #0
    6c7c:	d0e1      	beq.n	6c42 <tcp_parseopt+0x16>
    6c7e:	2902      	cmp	r1, #2
    6c80:	d006      	beq.n	6c90 <tcp_parseopt+0x64>
				c += 0x0A;
				break;
#endif
			default:
				LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
				if (opts[c + 1] == 0) {
    6c82:	4410      	add	r0, r2
    6c84:	7841      	ldrb	r1, [r0, #1]
    6c86:	2900      	cmp	r1, #0
    6c88:	d0db      	beq.n	6c42 <tcp_parseopt+0x16>
					   and we don't process them further. */
					return;
				}
				/* All other options have a length field, so that we easily
				   can skip past them. */
				c += opts[c + 1];
    6c8a:	440b      	add	r3, r1
    6c8c:	b29b      	uxth	r3, r3
    6c8e:	e7ee      	b.n	6c6e <tcp_parseopt+0x42>
				if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
    6c90:	18d1      	adds	r1, r2, r3
    6c92:	7849      	ldrb	r1, [r1, #1]
    6c94:	2904      	cmp	r1, #4
    6c96:	d1d4      	bne.n	6c42 <tcp_parseopt+0x16>
    6c98:	1d19      	adds	r1, r3, #4
    6c9a:	42b1      	cmp	r1, r6
    6c9c:	dcd1      	bgt.n	6c42 <tcp_parseopt+0x16>
				mss = (opts[c + 2] << 8) | opts[c + 3];
    6c9e:	4410      	add	r0, r2
    6ca0:	f890 e002 	ldrb.w	lr, [r0, #2]
    6ca4:	78c1      	ldrb	r1, [r0, #3]
    6ca6:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
				pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    6caa:	1e48      	subs	r0, r1, #1
    6cac:	b280      	uxth	r0, r0
    6cae:	42b8      	cmp	r0, r7
    6cb0:	bf88      	it	hi
    6cb2:	4621      	movhi	r1, r4
    6cb4:	86e9      	strh	r1, [r5, #54]	; 0x36
				c += 0x04;
    6cb6:	3304      	adds	r3, #4
    6cb8:	b29b      	uxth	r3, r3
				break;
    6cba:	e7d8      	b.n	6c6e <tcp_parseopt+0x42>
    6cbc:	20007f9c 	.word	0x20007f9c
    6cc0:	00002f47 	.word	0x00002f47

00006cc4 <tcp_oos_insert_segment>:
{
    6cc4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6cc8:	4605      	mov	r5, r0
    6cca:	4689      	mov	r9, r1
	if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    6ccc:	6903      	ldr	r3, [r0, #16]
    6cce:	8998      	ldrh	r0, [r3, #12]
    6cd0:	4b2a      	ldr	r3, [pc, #168]	; (6d7c <tcp_oos_insert_segment+0xb8>)
    6cd2:	4798      	blx	r3
    6cd4:	f010 0f01 	tst.w	r0, #1
    6cd8:	d116      	bne.n	6d08 <tcp_oos_insert_segment+0x44>
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    6cda:	f1b9 0f00 	cmp.w	r9, #0
    6cde:	d04a      	beq.n	6d76 <tcp_oos_insert_segment+0xb2>
    6ce0:	f8d9 2010 	ldr.w	r2, [r9, #16]
    6ce4:	892b      	ldrh	r3, [r5, #8]
    6ce6:	6851      	ldr	r1, [r2, #4]
    6ce8:	1a5b      	subs	r3, r3, r1
    6cea:	4925      	ldr	r1, [pc, #148]	; (6d80 <tcp_oos_insert_segment+0xbc>)
    6cec:	6849      	ldr	r1, [r1, #4]
    6cee:	440b      	add	r3, r1
    6cf0:	f8b9 1008 	ldrh.w	r1, [r9, #8]
    6cf4:	1a5b      	subs	r3, r3, r1
    6cf6:	2b00      	cmp	r3, #0
    6cf8:	bfb8      	it	lt
    6cfa:	464c      	movlt	r4, r9
    6cfc:	db29      	blt.n	6d52 <tcp_oos_insert_segment+0x8e>
			if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    6cfe:	4f1f      	ldr	r7, [pc, #124]	; (6d7c <tcp_oos_insert_segment+0xb8>)
				TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    6d00:	f8df 808c 	ldr.w	r8, [pc, #140]	; 6d90 <tcp_oos_insert_segment+0xcc>
			tcp_seg_free(old_seg);
    6d04:	4e1f      	ldr	r6, [pc, #124]	; (6d84 <tcp_oos_insert_segment+0xc0>)
    6d06:	e015      	b.n	6d34 <tcp_oos_insert_segment+0x70>
		tcp_segs_free(next);
    6d08:	4648      	mov	r0, r9
    6d0a:	4b1f      	ldr	r3, [pc, #124]	; (6d88 <tcp_oos_insert_segment+0xc4>)
    6d0c:	4798      	blx	r3
		next = NULL;
    6d0e:	2400      	movs	r4, #0
    6d10:	e02e      	b.n	6d70 <tcp_oos_insert_segment+0xac>
			next    = next->next;
    6d12:	f8d9 4000 	ldr.w	r4, [r9]
			tcp_seg_free(old_seg);
    6d16:	4648      	mov	r0, r9
    6d18:	47b0      	blx	r6
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    6d1a:	b364      	cbz	r4, 6d76 <tcp_oos_insert_segment+0xb2>
    6d1c:	6922      	ldr	r2, [r4, #16]
    6d1e:	892b      	ldrh	r3, [r5, #8]
    6d20:	4917      	ldr	r1, [pc, #92]	; (6d80 <tcp_oos_insert_segment+0xbc>)
    6d22:	6849      	ldr	r1, [r1, #4]
    6d24:	440b      	add	r3, r1
    6d26:	6851      	ldr	r1, [r2, #4]
    6d28:	1a5b      	subs	r3, r3, r1
    6d2a:	8921      	ldrh	r1, [r4, #8]
    6d2c:	1a5b      	subs	r3, r3, r1
    6d2e:	2b00      	cmp	r3, #0
    6d30:	db0f      	blt.n	6d52 <tcp_oos_insert_segment+0x8e>
			next    = next->next;
    6d32:	46a1      	mov	r9, r4
			if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    6d34:	8990      	ldrh	r0, [r2, #12]
    6d36:	47b8      	blx	r7
    6d38:	f010 0f01 	tst.w	r0, #1
    6d3c:	d0e9      	beq.n	6d12 <tcp_oos_insert_segment+0x4e>
				TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    6d3e:	f8d5 a010 	ldr.w	sl, [r5, #16]
    6d42:	f8ba 400c 	ldrh.w	r4, [sl, #12]
    6d46:	2001      	movs	r0, #1
    6d48:	47c0      	blx	r8
    6d4a:	4320      	orrs	r0, r4
    6d4c:	f8aa 000c 	strh.w	r0, [sl, #12]
    6d50:	e7df      	b.n	6d12 <tcp_oos_insert_segment+0x4e>
		if (next && TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
    6d52:	4b0b      	ldr	r3, [pc, #44]	; (6d80 <tcp_oos_insert_segment+0xbc>)
    6d54:	6859      	ldr	r1, [r3, #4]
    6d56:	6923      	ldr	r3, [r4, #16]
    6d58:	685a      	ldr	r2, [r3, #4]
    6d5a:	892b      	ldrh	r3, [r5, #8]
    6d5c:	440b      	add	r3, r1
    6d5e:	1a9b      	subs	r3, r3, r2
    6d60:	2b00      	cmp	r3, #0
    6d62:	dd05      	ble.n	6d70 <tcp_oos_insert_segment+0xac>
			cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    6d64:	1a52      	subs	r2, r2, r1
    6d66:	b291      	uxth	r1, r2
    6d68:	8129      	strh	r1, [r5, #8]
			pbuf_realloc(cseg->p, cseg->len);
    6d6a:	6868      	ldr	r0, [r5, #4]
    6d6c:	4b07      	ldr	r3, [pc, #28]	; (6d8c <tcp_oos_insert_segment+0xc8>)
    6d6e:	4798      	blx	r3
	cseg->next = next;
    6d70:	602c      	str	r4, [r5, #0]
}
    6d72:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		next = NULL;
    6d76:	2400      	movs	r4, #0
    6d78:	e7fa      	b.n	6d70 <tcp_oos_insert_segment+0xac>
    6d7a:	bf00      	nop
    6d7c:	00002f47 	.word	0x00002f47
    6d80:	20007f9c 	.word	0x20007f9c
    6d84:	00006241 	.word	0x00006241
    6d88:	00006265 	.word	0x00006265
    6d8c:	00005ec5 	.word	0x00005ec5
    6d90:	00002f3d 	.word	0x00002f3d

00006d94 <tcp_receive>:
{
    6d94:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6d98:	4604      	mov	r4, r0
	if (flags & TCP_ACK) {
    6d9a:	4baa      	ldr	r3, [pc, #680]	; (7044 <tcp_receive+0x2b0>)
    6d9c:	7a1b      	ldrb	r3, [r3, #8]
    6d9e:	f013 0f10 	tst.w	r3, #16
    6da2:	f000 8163 	beq.w	706c <tcp_receive+0x2d8>
		right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    6da6:	f8b0 5060 	ldrh.w	r5, [r0, #96]	; 0x60
    6daa:	6d80      	ldr	r0, [r0, #88]	; 0x58
		if (TCP_SEQ_LT(pcb->snd_wl1, seqno) || (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno))
    6dac:	6d62      	ldr	r2, [r4, #84]	; 0x54
    6dae:	4ba5      	ldr	r3, [pc, #660]	; (7044 <tcp_receive+0x2b0>)
    6db0:	685b      	ldr	r3, [r3, #4]
    6db2:	1ad1      	subs	r1, r2, r3
    6db4:	2900      	cmp	r1, #0
    6db6:	db28      	blt.n	6e0a <tcp_receive+0x76>
    6db8:	429a      	cmp	r2, r3
    6dba:	d01b      	beq.n	6df4 <tcp_receive+0x60>
		    || (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    6dbc:	4aa1      	ldr	r2, [pc, #644]	; (7044 <tcp_receive+0x2b0>)
    6dbe:	68d2      	ldr	r2, [r2, #12]
    6dc0:	4290      	cmp	r0, r2
    6dc2:	d01d      	beq.n	6e00 <tcp_receive+0x6c>
		if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
    6dc4:	4b9f      	ldr	r3, [pc, #636]	; (7044 <tcp_receive+0x2b0>)
    6dc6:	68da      	ldr	r2, [r3, #12]
    6dc8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    6dca:	1ad1      	subs	r1, r2, r3
    6dcc:	2900      	cmp	r1, #0
    6dce:	dd41      	ble.n	6e54 <tcp_receive+0xc0>
		} else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
    6dd0:	2901      	cmp	r1, #1
    6dd2:	d403      	bmi.n	6ddc <tcp_receive+0x48>
    6dd4:	6d21      	ldr	r1, [r4, #80]	; 0x50
    6dd6:	1a51      	subs	r1, r2, r1
    6dd8:	2900      	cmp	r1, #0
    6dda:	dd6e      	ble.n	6eba <tcp_receive+0x126>
			pcb->acked = 0;
    6ddc:	2300      	movs	r3, #0
    6dde:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
		while (pcb->unsent != NULL
    6de2:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    6de4:	2b00      	cmp	r3, #0
    6de6:	f000 8139 	beq.w	705c <tcp_receive+0x2c8>
		       && TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
    6dea:	4e96      	ldr	r6, [pc, #600]	; (7044 <tcp_receive+0x2b0>)
    6dec:	f8df 8268 	ldr.w	r8, [pc, #616]	; 7058 <tcp_receive+0x2c4>
    6df0:	4f95      	ldr	r7, [pc, #596]	; (7048 <tcp_receive+0x2b4>)
    6df2:	e0f8      	b.n	6fe6 <tcp_receive+0x252>
		if (TCP_SEQ_LT(pcb->snd_wl1, seqno) || (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno))
    6df4:	4a93      	ldr	r2, [pc, #588]	; (7044 <tcp_receive+0x2b0>)
    6df6:	68d2      	ldr	r2, [r2, #12]
    6df8:	1a82      	subs	r2, r0, r2
    6dfa:	2a00      	cmp	r2, #0
    6dfc:	dade      	bge.n	6dbc <tcp_receive+0x28>
    6dfe:	e004      	b.n	6e0a <tcp_receive+0x76>
		    || (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    6e00:	4a90      	ldr	r2, [pc, #576]	; (7044 <tcp_receive+0x2b0>)
    6e02:	6812      	ldr	r2, [r2, #0]
    6e04:	89d2      	ldrh	r2, [r2, #14]
    6e06:	42aa      	cmp	r2, r5
    6e08:	d9dc      	bls.n	6dc4 <tcp_receive+0x30>
			pcb->snd_wnd = tcphdr->wnd;
    6e0a:	4a8e      	ldr	r2, [pc, #568]	; (7044 <tcp_receive+0x2b0>)
    6e0c:	6812      	ldr	r2, [r2, #0]
    6e0e:	89d1      	ldrh	r1, [r2, #14]
    6e10:	b28e      	uxth	r6, r1
    6e12:	f8a4 1060 	strh.w	r1, [r4, #96]	; 0x60
			if (pcb->snd_wnd_max < tcphdr->wnd) {
    6e16:	89d2      	ldrh	r2, [r2, #14]
    6e18:	b291      	uxth	r1, r2
    6e1a:	f8b4 7062 	ldrh.w	r7, [r4, #98]	; 0x62
    6e1e:	428f      	cmp	r7, r1
				pcb->snd_wnd_max = tcphdr->wnd;
    6e20:	bf38      	it	cc
    6e22:	f8a4 2062 	strhcc.w	r2, [r4, #98]	; 0x62
			pcb->snd_wl1 = seqno;
    6e26:	6563      	str	r3, [r4, #84]	; 0x54
			pcb->snd_wl2 = ackno;
    6e28:	4b86      	ldr	r3, [pc, #536]	; (7044 <tcp_receive+0x2b0>)
    6e2a:	68db      	ldr	r3, [r3, #12]
    6e2c:	65a3      	str	r3, [r4, #88]	; 0x58
			if (pcb->snd_wnd == 0) {
    6e2e:	b94e      	cbnz	r6, 6e44 <tcp_receive+0xb0>
				if (pcb->persist_backoff == 0) {
    6e30:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
    6e34:	2b00      	cmp	r3, #0
    6e36:	d1c5      	bne.n	6dc4 <tcp_receive+0x30>
					pcb->persist_cnt     = 0;
    6e38:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
					pcb->persist_backoff = 1;
    6e3c:	2301      	movs	r3, #1
    6e3e:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
    6e42:	e7bf      	b.n	6dc4 <tcp_receive+0x30>
			} else if (pcb->persist_backoff > 0) {
    6e44:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
    6e48:	2b00      	cmp	r3, #0
    6e4a:	d0bb      	beq.n	6dc4 <tcp_receive+0x30>
				pcb->persist_backoff = 0;
    6e4c:	2300      	movs	r3, #0
    6e4e:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
    6e52:	e7b7      	b.n	6dc4 <tcp_receive+0x30>
			pcb->acked = 0;
    6e54:	2100      	movs	r1, #0
    6e56:	f8a4 1064 	strh.w	r1, [r4, #100]	; 0x64
			if (tcplen == 0) {
    6e5a:	497a      	ldr	r1, [pc, #488]	; (7044 <tcp_receive+0x2b0>)
    6e5c:	8a09      	ldrh	r1, [r1, #16]
    6e5e:	b931      	cbnz	r1, 6e6e <tcp_receive+0xda>
		right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    6e60:	4428      	add	r0, r5
				if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
    6e62:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
    6e66:	6da5      	ldr	r5, [r4, #88]	; 0x58
    6e68:	4429      	add	r1, r5
    6e6a:	4288      	cmp	r0, r1
    6e6c:	d003      	beq.n	6e76 <tcp_receive+0xe2>
				pcb->dupacks = 0;
    6e6e:	2300      	movs	r3, #0
    6e70:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
    6e74:	e7b5      	b.n	6de2 <tcp_receive+0x4e>
					if (pcb->rtime >= 0) {
    6e76:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
    6e7a:	2900      	cmp	r1, #0
    6e7c:	dbf7      	blt.n	6e6e <tcp_receive+0xda>
						if (pcb->lastack == ackno) {
    6e7e:	429a      	cmp	r2, r3
    6e80:	d1f5      	bne.n	6e6e <tcp_receive+0xda>
							if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
    6e82:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    6e86:	1c53      	adds	r3, r2, #1
    6e88:	b2db      	uxtb	r3, r3
    6e8a:	429a      	cmp	r2, r3
								++pcb->dupacks;
    6e8c:	bf38      	it	cc
    6e8e:	f884 3047 	strbcc.w	r3, [r4, #71]	; 0x47
							if (pcb->dupacks > 3) {
    6e92:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
    6e96:	2b03      	cmp	r3, #3
    6e98:	d909      	bls.n	6eae <tcp_receive+0x11a>
								if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    6e9a:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    6e9e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    6ea0:	4413      	add	r3, r2
    6ea2:	b29b      	uxth	r3, r3
    6ea4:	429a      	cmp	r2, r3
    6ea6:	d29c      	bcs.n	6de2 <tcp_receive+0x4e>
									pcb->cwnd += pcb->mss;
    6ea8:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    6eac:	e799      	b.n	6de2 <tcp_receive+0x4e>
							} else if (pcb->dupacks == 3) {
    6eae:	2b03      	cmp	r3, #3
    6eb0:	d197      	bne.n	6de2 <tcp_receive+0x4e>
								tcp_rexmit_fast(pcb);
    6eb2:	4620      	mov	r0, r4
    6eb4:	4b65      	ldr	r3, [pc, #404]	; (704c <tcp_receive+0x2b8>)
    6eb6:	4798      	blx	r3
    6eb8:	e793      	b.n	6de2 <tcp_receive+0x4e>
			if (pcb->flags & TF_INFR) {
    6eba:	7fa1      	ldrb	r1, [r4, #30]
    6ebc:	f011 0f04 	tst.w	r1, #4
    6ec0:	d006      	beq.n	6ed0 <tcp_receive+0x13c>
				pcb->flags &= ~TF_INFR;
    6ec2:	f021 0104 	bic.w	r1, r1, #4
    6ec6:	77a1      	strb	r1, [r4, #30]
				pcb->cwnd = pcb->ssthresh;
    6ec8:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
    6ecc:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
			pcb->nrtx = 0;
    6ed0:	2000      	movs	r0, #0
    6ed2:	f884 0046 	strb.w	r0, [r4, #70]	; 0x46
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    6ed6:	f9b4 5040 	ldrsh.w	r5, [r4, #64]	; 0x40
    6eda:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
    6ede:	eb01 01e5 	add.w	r1, r1, r5, asr #3
    6ee2:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
			pcb->acked = (u16_t)(ackno - pcb->lastack);
    6ee6:	1ad3      	subs	r3, r2, r3
    6ee8:	b29b      	uxth	r3, r3
    6eea:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
			pcb->snd_buf += pcb->acked;
    6eee:	f8b4 1066 	ldrh.w	r1, [r4, #102]	; 0x66
    6ef2:	440b      	add	r3, r1
    6ef4:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
			pcb->dupacks = 0;
    6ef8:	f884 0047 	strb.w	r0, [r4, #71]	; 0x47
			pcb->lastack = ackno;
    6efc:	64a2      	str	r2, [r4, #72]	; 0x48
			if (pcb->state >= ESTABLISHED) {
    6efe:	7e23      	ldrb	r3, [r4, #24]
    6f00:	2b03      	cmp	r3, #3
    6f02:	d90c      	bls.n	6f1e <tcp_receive+0x18a>
				if (pcb->cwnd < pcb->ssthresh) {
    6f04:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    6f08:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
    6f0c:	4293      	cmp	r3, r2
    6f0e:	d90e      	bls.n	6f2e <tcp_receive+0x19a>
					if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    6f10:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    6f12:	4413      	add	r3, r2
    6f14:	b29b      	uxth	r3, r3
    6f16:	429a      	cmp	r2, r3
						pcb->cwnd += pcb->mss;
    6f18:	bf38      	it	cc
    6f1a:	f8a4 304c 	strhcc.w	r3, [r4, #76]	; 0x4c
			while (pcb->unacked != NULL
    6f1e:	6f23      	ldr	r3, [r4, #112]	; 0x70
    6f20:	2b00      	cmp	r3, #0
    6f22:	d04b      	beq.n	6fbc <tcp_receive+0x228>
			       && TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked), ackno)) {
    6f24:	f8df 8130 	ldr.w	r8, [pc, #304]	; 7058 <tcp_receive+0x2c4>
    6f28:	4e47      	ldr	r6, [pc, #284]	; (7048 <tcp_receive+0x2b4>)
    6f2a:	4f46      	ldr	r7, [pc, #280]	; (7044 <tcp_receive+0x2b0>)
    6f2c:	e018      	b.n	6f60 <tcp_receive+0x1cc>
					u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
    6f2e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    6f30:	fb03 f303 	mul.w	r3, r3, r3
    6f34:	fb93 f3f2 	sdiv	r3, r3, r2
    6f38:	4413      	add	r3, r2
    6f3a:	b29b      	uxth	r3, r3
					if (new_cwnd > pcb->cwnd) {
    6f3c:	429a      	cmp	r2, r3
    6f3e:	d2ee      	bcs.n	6f1e <tcp_receive+0x18a>
						pcb->cwnd = new_cwnd;
    6f40:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    6f44:	e7eb      	b.n	6f1e <tcp_receive+0x18a>
				pcb->snd_queuelen -= pbuf_clen(next->p);
    6f46:	6868      	ldr	r0, [r5, #4]
    6f48:	4b41      	ldr	r3, [pc, #260]	; (7050 <tcp_receive+0x2bc>)
    6f4a:	4798      	blx	r3
    6f4c:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    6f50:	1a18      	subs	r0, r3, r0
    6f52:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
				tcp_seg_free(next);
    6f56:	4628      	mov	r0, r5
    6f58:	4b3e      	ldr	r3, [pc, #248]	; (7054 <tcp_receive+0x2c0>)
    6f5a:	4798      	blx	r3
			while (pcb->unacked != NULL
    6f5c:	6f23      	ldr	r3, [r4, #112]	; 0x70
    6f5e:	b36b      	cbz	r3, 6fbc <tcp_receive+0x228>
			       && TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked), ackno)) {
    6f60:	691b      	ldr	r3, [r3, #16]
    6f62:	6858      	ldr	r0, [r3, #4]
    6f64:	47c0      	blx	r8
    6f66:	4605      	mov	r5, r0
    6f68:	6f23      	ldr	r3, [r4, #112]	; 0x70
    6f6a:	f8b3 9008 	ldrh.w	r9, [r3, #8]
    6f6e:	691b      	ldr	r3, [r3, #16]
    6f70:	8998      	ldrh	r0, [r3, #12]
    6f72:	47b0      	blx	r6
    6f74:	f010 0003 	ands.w	r0, r0, #3
    6f78:	bf18      	it	ne
    6f7a:	2001      	movne	r0, #1
    6f7c:	4448      	add	r0, r9
    6f7e:	68fb      	ldr	r3, [r7, #12]
    6f80:	1aed      	subs	r5, r5, r3
    6f82:	4428      	add	r0, r5
    6f84:	2800      	cmp	r0, #0
    6f86:	dc12      	bgt.n	6fae <tcp_receive+0x21a>
				next         = pcb->unacked;
    6f88:	6f25      	ldr	r5, [r4, #112]	; 0x70
				pcb->unacked = pcb->unacked->next;
    6f8a:	682b      	ldr	r3, [r5, #0]
    6f8c:	6723      	str	r3, [r4, #112]	; 0x70
				if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    6f8e:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    6f92:	2b00      	cmp	r3, #0
    6f94:	d0d7      	beq.n	6f46 <tcp_receive+0x1b2>
    6f96:	692b      	ldr	r3, [r5, #16]
    6f98:	8998      	ldrh	r0, [r3, #12]
    6f9a:	47b0      	blx	r6
    6f9c:	f010 0f01 	tst.w	r0, #1
    6fa0:	d0d1      	beq.n	6f46 <tcp_receive+0x1b2>
					pcb->acked--;
    6fa2:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    6fa6:	3b01      	subs	r3, #1
    6fa8:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    6fac:	e7cb      	b.n	6f46 <tcp_receive+0x1b2>
			if (pcb->unacked == NULL)
    6fae:	6f23      	ldr	r3, [r4, #112]	; 0x70
    6fb0:	b123      	cbz	r3, 6fbc <tcp_receive+0x228>
				pcb->rtime = 0;
    6fb2:	2300      	movs	r3, #0
    6fb4:	86a3      	strh	r3, [r4, #52]	; 0x34
			pcb->polltmr = 0;
    6fb6:	2300      	movs	r3, #0
    6fb8:	77e3      	strb	r3, [r4, #31]
    6fba:	e712      	b.n	6de2 <tcp_receive+0x4e>
				pcb->rtime = -1;
    6fbc:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6fc0:	86a3      	strh	r3, [r4, #52]	; 0x34
    6fc2:	e7f8      	b.n	6fb6 <tcp_receive+0x222>
				pcb->unsent_oversize = 0;
    6fc4:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
    6fc8:	e02c      	b.n	7024 <tcp_receive+0x290>
			pcb->snd_queuelen -= pbuf_clen(next->p);
    6fca:	6868      	ldr	r0, [r5, #4]
    6fcc:	4b20      	ldr	r3, [pc, #128]	; (7050 <tcp_receive+0x2bc>)
    6fce:	4798      	blx	r3
    6fd0:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    6fd4:	1a18      	subs	r0, r3, r0
    6fd6:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
			tcp_seg_free(next);
    6fda:	4628      	mov	r0, r5
    6fdc:	4b1d      	ldr	r3, [pc, #116]	; (7054 <tcp_receive+0x2c0>)
    6fde:	4798      	blx	r3
		while (pcb->unsent != NULL
    6fe0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    6fe2:	2b00      	cmp	r3, #0
    6fe4:	d03a      	beq.n	705c <tcp_receive+0x2c8>
		       && TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
    6fe6:	68f5      	ldr	r5, [r6, #12]
    6fe8:	691b      	ldr	r3, [r3, #16]
    6fea:	6858      	ldr	r0, [r3, #4]
    6fec:	47c0      	blx	r8
    6fee:	4682      	mov	sl, r0
    6ff0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    6ff2:	f8b3 9008 	ldrh.w	r9, [r3, #8]
    6ff6:	691b      	ldr	r3, [r3, #16]
    6ff8:	8998      	ldrh	r0, [r3, #12]
    6ffa:	47b8      	blx	r7
    6ffc:	eba5 050a 	sub.w	r5, r5, sl
    7000:	f010 0003 	ands.w	r0, r0, #3
    7004:	bf18      	it	ne
    7006:	2001      	movne	r0, #1
    7008:	4448      	add	r0, r9
    700a:	1a2d      	subs	r5, r5, r0
    700c:	2d00      	cmp	r5, #0
    700e:	db25      	blt.n	705c <tcp_receive+0x2c8>
    7010:	68f3      	ldr	r3, [r6, #12]
    7012:	6d22      	ldr	r2, [r4, #80]	; 0x50
    7014:	1a9b      	subs	r3, r3, r2
    7016:	2b00      	cmp	r3, #0
    7018:	dc20      	bgt.n	705c <tcp_receive+0x2c8>
			next        = pcb->unsent;
    701a:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
			pcb->unsent = pcb->unsent->next;
    701c:	682b      	ldr	r3, [r5, #0]
    701e:	66e3      	str	r3, [r4, #108]	; 0x6c
			if (pcb->unsent == NULL) {
    7020:	2b00      	cmp	r3, #0
    7022:	d0cf      	beq.n	6fc4 <tcp_receive+0x230>
			if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    7024:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    7028:	2b00      	cmp	r3, #0
    702a:	d0ce      	beq.n	6fca <tcp_receive+0x236>
    702c:	692b      	ldr	r3, [r5, #16]
    702e:	8998      	ldrh	r0, [r3, #12]
    7030:	47b8      	blx	r7
    7032:	f010 0f01 	tst.w	r0, #1
    7036:	d0c8      	beq.n	6fca <tcp_receive+0x236>
				pcb->acked--;
    7038:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    703c:	3b01      	subs	r3, #1
    703e:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    7042:	e7c2      	b.n	6fca <tcp_receive+0x236>
    7044:	20007f9c 	.word	0x20007f9c
    7048:	00002f47 	.word	0x00002f47
    704c:	000086a9 	.word	0x000086a9
    7050:	00005f25 	.word	0x00005f25
    7054:	00006241 	.word	0x00006241
    7058:	00002f69 	.word	0x00002f69
		if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
    705c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    705e:	b12b      	cbz	r3, 706c <tcp_receive+0x2d8>
    7060:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    7062:	499a      	ldr	r1, [pc, #616]	; (72cc <tcp_receive+0x538>)
    7064:	68c9      	ldr	r1, [r1, #12]
    7066:	1a52      	subs	r2, r2, r1
    7068:	2a00      	cmp	r2, #0
    706a:	db23      	blt.n	70b4 <tcp_receive+0x320>
	if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
    706c:	4b97      	ldr	r3, [pc, #604]	; (72cc <tcp_receive+0x538>)
    706e:	8a1b      	ldrh	r3, [r3, #16]
    7070:	2b00      	cmp	r3, #0
    7072:	f000 8244 	beq.w	74fe <tcp_receive+0x76a>
    7076:	7e22      	ldrb	r2, [r4, #24]
    7078:	2a06      	cmp	r2, #6
    707a:	f200 8240 	bhi.w	74fe <tcp_receive+0x76a>
		if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
    707e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    7080:	4a92      	ldr	r2, [pc, #584]	; (72cc <tcp_receive+0x538>)
    7082:	6852      	ldr	r2, [r2, #4]
    7084:	1a8d      	subs	r5, r1, r2
    7086:	2d01      	cmp	r5, #1
    7088:	d405      	bmi.n	7096 <tcp_receive+0x302>
    708a:	f1c2 0001 	rsb	r0, r2, #1
    708e:	1ac3      	subs	r3, r0, r3
    7090:	440b      	add	r3, r1
    7092:	2b00      	cmp	r3, #0
    7094:	dd2e      	ble.n	70f4 <tcp_receive+0x360>
			if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
    7096:	1a53      	subs	r3, r2, r1
    7098:	2b00      	cmp	r3, #0
    709a:	db54      	blt.n	7146 <tcp_receive+0x3b2>
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    709c:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    709e:	f1c3 0301 	rsb	r3, r3, #1
    70a2:	4413      	add	r3, r2
    70a4:	1a5b      	subs	r3, r3, r1
    70a6:	2b00      	cmp	r3, #0
    70a8:	dd52      	ble.n	7150 <tcp_receive+0x3bc>
			tcp_send_empty_ack(pcb);
    70aa:	4620      	mov	r0, r4
    70ac:	4b88      	ldr	r3, [pc, #544]	; (72d0 <tcp_receive+0x53c>)
    70ae:	4798      	blx	r3
    70b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			m = m - (pcb->sa >> 3);
    70b4:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
			m = (s16_t)(tcp_ticks - pcb->rttest);
    70b8:	4a86      	ldr	r2, [pc, #536]	; (72d4 <tcp_receive+0x540>)
    70ba:	6812      	ldr	r2, [r2, #0]
    70bc:	1ad3      	subs	r3, r2, r3
			m = m - (pcb->sa >> 3);
    70be:	eba3 03e1 	sub.w	r3, r3, r1, asr #3
    70c2:	b29b      	uxth	r3, r3
    70c4:	b218      	sxth	r0, r3
			pcb->sa += m;
    70c6:	185a      	adds	r2, r3, r1
    70c8:	b212      	sxth	r2, r2
    70ca:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
			if (m < 0) {
    70ce:	2800      	cmp	r0, #0
				m = -m;
    70d0:	bfbc      	itt	lt
    70d2:	425b      	neglt	r3, r3
    70d4:	b218      	sxthlt	r0, r3
			m = m - (pcb->sv >> 2);
    70d6:	f9b4 3042 	ldrsh.w	r3, [r4, #66]	; 0x42
			pcb->sv += m;
    70da:	eba3 03a3 	sub.w	r3, r3, r3, asr #2
    70de:	4403      	add	r3, r0
    70e0:	b29b      	uxth	r3, r3
    70e2:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    70e6:	eb03 03e2 	add.w	r3, r3, r2, asr #3
    70ea:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
			pcb->rttest = 0;
    70ee:	2300      	movs	r3, #0
    70f0:	63a3      	str	r3, [r4, #56]	; 0x38
    70f2:	e7bb      	b.n	706c <tcp_receive+0x2d8>
			off = pcb->rcv_nxt - seqno;
    70f4:	462b      	mov	r3, r5
			p   = inseg.p;
    70f6:	4a75      	ldr	r2, [pc, #468]	; (72cc <tcp_receive+0x538>)
    70f8:	6990      	ldr	r0, [r2, #24]
			if (inseg.p->len < off) {
    70fa:	8942      	ldrh	r2, [r0, #10]
    70fc:	4295      	cmp	r5, r2
    70fe:	dd1d      	ble.n	713c <tcp_receive+0x3a8>
				new_tot_len = (u16_t)(inseg.p->tot_len - off);
    7100:	8901      	ldrh	r1, [r0, #8]
    7102:	1b49      	subs	r1, r1, r5
    7104:	b289      	uxth	r1, r1
					p->len     = 0;
    7106:	2500      	movs	r5, #0
					off -= p->len;
    7108:	1a9b      	subs	r3, r3, r2
					p->tot_len = new_tot_len;
    710a:	8101      	strh	r1, [r0, #8]
					p->len     = 0;
    710c:	8145      	strh	r5, [r0, #10]
					p          = p->next;
    710e:	6800      	ldr	r0, [r0, #0]
				while (p->len < off) {
    7110:	8942      	ldrh	r2, [r0, #10]
    7112:	429a      	cmp	r2, r3
    7114:	dbf8      	blt.n	7108 <tcp_receive+0x374>
				if (pbuf_header(p, (s16_t)-off)) {
    7116:	425b      	negs	r3, r3
    7118:	b219      	sxth	r1, r3
    711a:	4b6f      	ldr	r3, [pc, #444]	; (72d8 <tcp_receive+0x544>)
    711c:	4798      	blx	r3
			inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    711e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    7120:	4b6a      	ldr	r3, [pc, #424]	; (72cc <tcp_receive+0x538>)
    7122:	6859      	ldr	r1, [r3, #4]
    7124:	8b98      	ldrh	r0, [r3, #28]
    7126:	4401      	add	r1, r0
    7128:	1a89      	subs	r1, r1, r2
    712a:	8399      	strh	r1, [r3, #28]
			inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    712c:	6a59      	ldr	r1, [r3, #36]	; 0x24
    712e:	605a      	str	r2, [r3, #4]
    7130:	604a      	str	r2, [r1, #4]
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    7132:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    7134:	1a53      	subs	r3, r2, r1
    7136:	2b00      	cmp	r3, #0
    7138:	dab0      	bge.n	709c <tcp_receive+0x308>
    713a:	e7b6      	b.n	70aa <tcp_receive+0x316>
				if (pbuf_header(inseg.p, (s16_t)-off)) {
    713c:	4269      	negs	r1, r5
    713e:	b209      	sxth	r1, r1
    7140:	4b65      	ldr	r3, [pc, #404]	; (72d8 <tcp_receive+0x544>)
    7142:	4798      	blx	r3
    7144:	e7eb      	b.n	711e <tcp_receive+0x38a>
				tcp_ack_now(pcb);
    7146:	7fa3      	ldrb	r3, [r4, #30]
    7148:	f043 0302 	orr.w	r3, r3, #2
    714c:	77a3      	strb	r3, [r4, #30]
    714e:	e7ac      	b.n	70aa <tcp_receive+0x316>
			if (pcb->rcv_nxt == seqno) {
    7150:	428a      	cmp	r2, r1
    7152:	d013      	beq.n	717c <tcp_receive+0x3e8>
				tcp_send_empty_ack(pcb);
    7154:	4620      	mov	r0, r4
    7156:	4b5e      	ldr	r3, [pc, #376]	; (72d0 <tcp_receive+0x53c>)
    7158:	4798      	blx	r3
				if (pcb->ooseq == NULL) {
    715a:	6f66      	ldr	r6, [r4, #116]	; 0x74
    715c:	2e00      	cmp	r6, #0
    715e:	f000 8119 	beq.w	7394 <tcp_receive+0x600>
						if (seqno == next->tcphdr->seqno) {
    7162:	6931      	ldr	r1, [r6, #16]
    7164:	684a      	ldr	r2, [r1, #4]
    7166:	4b59      	ldr	r3, [pc, #356]	; (72cc <tcp_receive+0x538>)
    7168:	6858      	ldr	r0, [r3, #4]
    716a:	4282      	cmp	r2, r0
    716c:	f000 8118 	beq.w	73a0 <tcp_receive+0x60c>
    7170:	2700      	movs	r7, #0
								if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
    7172:	f100 3eff 	add.w	lr, r0, #4294967295
    7176:	f100 0c01 	add.w	ip, r0, #1
    717a:	e134      	b.n	73e6 <tcp_receive+0x652>
				tcplen = TCP_TCPLEN(&inseg);
    717c:	4e53      	ldr	r6, [pc, #332]	; (72cc <tcp_receive+0x538>)
    717e:	8bb5      	ldrh	r5, [r6, #28]
    7180:	6a73      	ldr	r3, [r6, #36]	; 0x24
    7182:	8998      	ldrh	r0, [r3, #12]
    7184:	4b55      	ldr	r3, [pc, #340]	; (72dc <tcp_receive+0x548>)
    7186:	4798      	blx	r3
    7188:	f010 0303 	ands.w	r3, r0, #3
    718c:	bf18      	it	ne
    718e:	2301      	movne	r3, #1
    7190:	442b      	add	r3, r5
    7192:	b29b      	uxth	r3, r3
    7194:	8233      	strh	r3, [r6, #16]
				if (tcplen > pcb->rcv_wnd) {
    7196:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    7198:	429a      	cmp	r2, r3
    719a:	d317      	bcc.n	71cc <tcp_receive+0x438>
				if (pcb->ooseq != NULL) {
    719c:	6f63      	ldr	r3, [r4, #116]	; 0x74
    719e:	2b00      	cmp	r3, #0
    71a0:	f000 81c1 	beq.w	7526 <tcp_receive+0x792>
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    71a4:	4b49      	ldr	r3, [pc, #292]	; (72cc <tcp_receive+0x538>)
    71a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    71a8:	8998      	ldrh	r0, [r3, #12]
    71aa:	4b4c      	ldr	r3, [pc, #304]	; (72dc <tcp_receive+0x548>)
    71ac:	4798      	blx	r3
    71ae:	f010 0f01 	tst.w	r0, #1
    71b2:	d03f      	beq.n	7234 <tcp_receive+0x4a0>
						while (pcb->ooseq != NULL) {
    71b4:	6f60      	ldr	r0, [r4, #116]	; 0x74
    71b6:	2800      	cmp	r0, #0
    71b8:	f000 81b5 	beq.w	7526 <tcp_receive+0x792>
							tcp_seg_free(old_ooseq);
    71bc:	4d48      	ldr	r5, [pc, #288]	; (72e0 <tcp_receive+0x54c>)
							pcb->ooseq                = pcb->ooseq->next;
    71be:	6803      	ldr	r3, [r0, #0]
    71c0:	6763      	str	r3, [r4, #116]	; 0x74
							tcp_seg_free(old_ooseq);
    71c2:	47a8      	blx	r5
						while (pcb->ooseq != NULL) {
    71c4:	6f60      	ldr	r0, [r4, #116]	; 0x74
    71c6:	2800      	cmp	r0, #0
    71c8:	d1f9      	bne.n	71be <tcp_receive+0x42a>
    71ca:	e1ac      	b.n	7526 <tcp_receive+0x792>
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    71cc:	6a73      	ldr	r3, [r6, #36]	; 0x24
    71ce:	8998      	ldrh	r0, [r3, #12]
    71d0:	4b42      	ldr	r3, [pc, #264]	; (72dc <tcp_receive+0x548>)
    71d2:	4798      	blx	r3
    71d4:	f010 0f01 	tst.w	r0, #1
    71d8:	d11e      	bne.n	7218 <tcp_receive+0x484>
					inseg.len = pcb->rcv_wnd;
    71da:	4b3c      	ldr	r3, [pc, #240]	; (72cc <tcp_receive+0x538>)
    71dc:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    71de:	839a      	strh	r2, [r3, #28]
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    71e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    71e2:	8998      	ldrh	r0, [r3, #12]
    71e4:	4b3d      	ldr	r3, [pc, #244]	; (72dc <tcp_receive+0x548>)
    71e6:	4798      	blx	r3
    71e8:	f010 0f02 	tst.w	r0, #2
    71ec:	d003      	beq.n	71f6 <tcp_receive+0x462>
						inseg.len -= 1;
    71ee:	4a37      	ldr	r2, [pc, #220]	; (72cc <tcp_receive+0x538>)
    71f0:	8b93      	ldrh	r3, [r2, #28]
    71f2:	3b01      	subs	r3, #1
    71f4:	8393      	strh	r3, [r2, #28]
					pbuf_realloc(inseg.p, inseg.len);
    71f6:	4d35      	ldr	r5, [pc, #212]	; (72cc <tcp_receive+0x538>)
    71f8:	8ba9      	ldrh	r1, [r5, #28]
    71fa:	69a8      	ldr	r0, [r5, #24]
    71fc:	4b39      	ldr	r3, [pc, #228]	; (72e4 <tcp_receive+0x550>)
    71fe:	4798      	blx	r3
					tcplen = TCP_TCPLEN(&inseg);
    7200:	8bae      	ldrh	r6, [r5, #28]
    7202:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    7204:	8998      	ldrh	r0, [r3, #12]
    7206:	4b35      	ldr	r3, [pc, #212]	; (72dc <tcp_receive+0x548>)
    7208:	4798      	blx	r3
    720a:	f010 0003 	ands.w	r0, r0, #3
    720e:	bf18      	it	ne
    7210:	2001      	movne	r0, #1
    7212:	4406      	add	r6, r0
    7214:	822e      	strh	r6, [r5, #16]
    7216:	e7c1      	b.n	719c <tcp_receive+0x408>
						TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~TCP_FIN);
    7218:	6a76      	ldr	r6, [r6, #36]	; 0x24
    721a:	89b5      	ldrh	r5, [r6, #12]
    721c:	4628      	mov	r0, r5
    721e:	4b2f      	ldr	r3, [pc, #188]	; (72dc <tcp_receive+0x548>)
    7220:	4798      	blx	r3
    7222:	f000 003e 	and.w	r0, r0, #62	; 0x3e
    7226:	4b30      	ldr	r3, [pc, #192]	; (72e8 <tcp_receive+0x554>)
    7228:	4798      	blx	r3
    722a:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
    722e:	4305      	orrs	r5, r0
    7230:	81b5      	strh	r5, [r6, #12]
    7232:	e7d2      	b.n	71da <tcp_receive+0x446>
						next = pcb->ooseq;
    7234:	f8d4 9074 	ldr.w	r9, [r4, #116]	; 0x74
						while (next && TCP_SEQ_GEQ(seqno + tcplen, next->tcphdr->seqno + next->len)) {
    7238:	f1b9 0f00 	cmp.w	r9, #0
    723c:	f000 8171 	beq.w	7522 <tcp_receive+0x78e>
    7240:	f8d9 2010 	ldr.w	r2, [r9, #16]
    7244:	4921      	ldr	r1, [pc, #132]	; (72cc <tcp_receive+0x538>)
    7246:	8a0b      	ldrh	r3, [r1, #16]
    7248:	6849      	ldr	r1, [r1, #4]
    724a:	440b      	add	r3, r1
    724c:	6851      	ldr	r1, [r2, #4]
    724e:	1a5b      	subs	r3, r3, r1
    7250:	f8b9 1008 	ldrh.w	r1, [r9, #8]
    7254:	1a5b      	subs	r3, r3, r1
    7256:	2b00      	cmp	r3, #0
    7258:	f2c0 81a8 	blt.w	75ac <tcp_receive+0x818>
							if (TCPH_FLAGS(next->tcphdr) & TCP_FIN && (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    725c:	4f1f      	ldr	r7, [pc, #124]	; (72dc <tcp_receive+0x548>)
    725e:	4e1b      	ldr	r6, [pc, #108]	; (72cc <tcp_receive+0x538>)
								TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    7260:	f8df 8084 	ldr.w	r8, [pc, #132]	; 72e8 <tcp_receive+0x554>
    7264:	e013      	b.n	728e <tcp_receive+0x4fa>
							next = next->next;
    7266:	f8d9 5000 	ldr.w	r5, [r9]
							tcp_seg_free(prev);
    726a:	4648      	mov	r0, r9
    726c:	4b1c      	ldr	r3, [pc, #112]	; (72e0 <tcp_receive+0x54c>)
    726e:	4798      	blx	r3
						while (next && TCP_SEQ_GEQ(seqno + tcplen, next->tcphdr->seqno + next->len)) {
    7270:	2d00      	cmp	r5, #0
    7272:	f000 8156 	beq.w	7522 <tcp_receive+0x78e>
    7276:	692a      	ldr	r2, [r5, #16]
    7278:	8a33      	ldrh	r3, [r6, #16]
    727a:	6871      	ldr	r1, [r6, #4]
    727c:	440b      	add	r3, r1
    727e:	6851      	ldr	r1, [r2, #4]
    7280:	1a5b      	subs	r3, r3, r1
    7282:	8929      	ldrh	r1, [r5, #8]
    7284:	1a5b      	subs	r3, r3, r1
    7286:	2b00      	cmp	r3, #0
    7288:	f2c0 8191 	blt.w	75ae <tcp_receive+0x81a>
							next = next->next;
    728c:	46a9      	mov	r9, r5
							if (TCPH_FLAGS(next->tcphdr) & TCP_FIN && (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    728e:	8990      	ldrh	r0, [r2, #12]
    7290:	47b8      	blx	r7
    7292:	f010 0f01 	tst.w	r0, #1
    7296:	d0e6      	beq.n	7266 <tcp_receive+0x4d2>
    7298:	6a73      	ldr	r3, [r6, #36]	; 0x24
    729a:	8998      	ldrh	r0, [r3, #12]
    729c:	47b8      	blx	r7
    729e:	f010 0f02 	tst.w	r0, #2
    72a2:	d1e0      	bne.n	7266 <tcp_receive+0x4d2>
								TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    72a4:	f8d6 a024 	ldr.w	sl, [r6, #36]	; 0x24
    72a8:	f8ba 500c 	ldrh.w	r5, [sl, #12]
    72ac:	2001      	movs	r0, #1
    72ae:	47c0      	blx	r8
    72b0:	4328      	orrs	r0, r5
    72b2:	f8aa 000c 	strh.w	r0, [sl, #12]
								tcplen = TCP_TCPLEN(&inseg);
    72b6:	8bb5      	ldrh	r5, [r6, #28]
    72b8:	6a73      	ldr	r3, [r6, #36]	; 0x24
    72ba:	8998      	ldrh	r0, [r3, #12]
    72bc:	47b8      	blx	r7
    72be:	f010 0003 	ands.w	r0, r0, #3
    72c2:	bf18      	it	ne
    72c4:	2001      	movne	r0, #1
    72c6:	4405      	add	r5, r0
    72c8:	8235      	strh	r5, [r6, #16]
    72ca:	e7cc      	b.n	7266 <tcp_receive+0x4d2>
    72cc:	20007f9c 	.word	0x20007f9c
    72d0:	00008229 	.word	0x00008229
    72d4:	20009304 	.word	0x20009304
    72d8:	00005c8d 	.word	0x00005c8d
    72dc:	00002f47 	.word	0x00002f47
    72e0:	00006241 	.word	0x00006241
    72e4:	00005ec5 	.word	0x00005ec5
    72e8:	00002f3d 	.word	0x00002f3d
							recv_data = cseg->p;
    72ec:	62b9      	str	r1, [r7, #40]	; 0x28
						cseg->p = NULL;
    72ee:	2300      	movs	r3, #0
    72f0:	606b      	str	r3, [r5, #4]
					if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    72f2:	692b      	ldr	r3, [r5, #16]
    72f4:	8998      	ldrh	r0, [r3, #12]
    72f6:	47b0      	blx	r6
    72f8:	f010 0f01 	tst.w	r0, #1
    72fc:	d00a      	beq.n	7314 <tcp_receive+0x580>
						recv_flags |= TF_GOT_FIN;
    72fe:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    7302:	f043 0320 	orr.w	r3, r3, #32
    7306:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
						if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
    730a:	7e23      	ldrb	r3, [r4, #24]
    730c:	2b04      	cmp	r3, #4
							pcb->state = CLOSE_WAIT;
    730e:	bf04      	itt	eq
    7310:	2307      	moveq	r3, #7
    7312:	7623      	strbeq	r3, [r4, #24]
					pcb->ooseq = cseg->next;
    7314:	682b      	ldr	r3, [r5, #0]
    7316:	6763      	str	r3, [r4, #116]	; 0x74
					tcp_seg_free(cseg);
    7318:	4628      	mov	r0, r5
    731a:	4b9a      	ldr	r3, [pc, #616]	; (7584 <tcp_receive+0x7f0>)
    731c:	4798      	blx	r3
				while (pcb->ooseq != NULL && pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
    731e:	6f65      	ldr	r5, [r4, #116]	; 0x74
    7320:	2d00      	cmp	r5, #0
    7322:	d02a      	beq.n	737a <tcp_receive+0x5e6>
    7324:	692b      	ldr	r3, [r5, #16]
    7326:	685a      	ldr	r2, [r3, #4]
    7328:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    732a:	428a      	cmp	r2, r1
    732c:	d125      	bne.n	737a <tcp_receive+0x5e6>
					seqno = pcb->ooseq->tcphdr->seqno;
    732e:	607a      	str	r2, [r7, #4]
					pcb->rcv_nxt += TCP_TCPLEN(cseg);
    7330:	f8b5 9008 	ldrh.w	r9, [r5, #8]
    7334:	8998      	ldrh	r0, [r3, #12]
    7336:	47b0      	blx	r6
    7338:	f010 0003 	ands.w	r0, r0, #3
    733c:	bf18      	it	ne
    733e:	2001      	movne	r0, #1
    7340:	4448      	add	r0, r9
    7342:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    7344:	4418      	add	r0, r3
    7346:	62a0      	str	r0, [r4, #40]	; 0x28
					pcb->rcv_wnd -= TCP_TCPLEN(cseg);
    7348:	f8b5 9008 	ldrh.w	r9, [r5, #8]
    734c:	692b      	ldr	r3, [r5, #16]
    734e:	8998      	ldrh	r0, [r3, #12]
    7350:	47b0      	blx	r6
    7352:	f010 0003 	ands.w	r0, r0, #3
    7356:	bf18      	it	ne
    7358:	2001      	movne	r0, #1
    735a:	4448      	add	r0, r9
    735c:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    735e:	1a18      	subs	r0, r3, r0
    7360:	85a0      	strh	r0, [r4, #44]	; 0x2c
					tcp_update_rcv_ann_wnd(pcb);
    7362:	4620      	mov	r0, r4
    7364:	47c0      	blx	r8
					if (cseg->p->tot_len > 0) {
    7366:	6869      	ldr	r1, [r5, #4]
    7368:	890b      	ldrh	r3, [r1, #8]
    736a:	2b00      	cmp	r3, #0
    736c:	d0c1      	beq.n	72f2 <tcp_receive+0x55e>
						if (recv_data) {
    736e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    7370:	2800      	cmp	r0, #0
    7372:	d0bb      	beq.n	72ec <tcp_receive+0x558>
							pbuf_cat(recv_data, cseg->p);
    7374:	4b84      	ldr	r3, [pc, #528]	; (7588 <tcp_receive+0x7f4>)
    7376:	4798      	blx	r3
    7378:	e7b9      	b.n	72ee <tcp_receive+0x55a>
				tcp_ack(pcb);
    737a:	7fa3      	ldrb	r3, [r4, #30]
    737c:	f013 0f01 	tst.w	r3, #1
    7380:	bf1a      	itte	ne
    7382:	f023 0301 	bicne.w	r3, r3, #1
    7386:	f043 0302 	orrne.w	r3, r3, #2
    738a:	f043 0301 	orreq.w	r3, r3, #1
    738e:	77a3      	strb	r3, [r4, #30]
    7390:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					pcb->ooseq = tcp_seg_copy(&inseg);
    7394:	487d      	ldr	r0, [pc, #500]	; (758c <tcp_receive+0x7f8>)
    7396:	4b7e      	ldr	r3, [pc, #504]	; (7590 <tcp_receive+0x7fc>)
    7398:	4798      	blx	r3
    739a:	6760      	str	r0, [r4, #116]	; 0x74
    739c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						if (seqno == next->tcphdr->seqno) {
    73a0:	4635      	mov	r5, r6
    73a2:	2600      	movs	r6, #0
							if (inseg.len > next->len) {
    73a4:	4b7b      	ldr	r3, [pc, #492]	; (7594 <tcp_receive+0x800>)
    73a6:	8b9a      	ldrh	r2, [r3, #28]
    73a8:	892b      	ldrh	r3, [r5, #8]
    73aa:	429a      	cmp	r2, r3
    73ac:	d94f      	bls.n	744e <tcp_receive+0x6ba>
								cseg = tcp_seg_copy(&inseg);
    73ae:	4877      	ldr	r0, [pc, #476]	; (758c <tcp_receive+0x7f8>)
    73b0:	4b77      	ldr	r3, [pc, #476]	; (7590 <tcp_receive+0x7fc>)
    73b2:	4798      	blx	r3
								if (cseg != NULL) {
    73b4:	4603      	mov	r3, r0
    73b6:	2800      	cmp	r0, #0
    73b8:	d049      	beq.n	744e <tcp_receive+0x6ba>
									if (prev != NULL) {
    73ba:	b136      	cbz	r6, 73ca <tcp_receive+0x636>
										prev->next = cseg;
    73bc:	6030      	str	r0, [r6, #0]
									tcp_oos_insert_segment(cseg, next);
    73be:	4629      	mov	r1, r5
    73c0:	4618      	mov	r0, r3
    73c2:	4b75      	ldr	r3, [pc, #468]	; (7598 <tcp_receive+0x804>)
    73c4:	4798      	blx	r3
    73c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
										pcb->ooseq = cseg;
    73ca:	6760      	str	r0, [r4, #116]	; 0x74
    73cc:	e7f7      	b.n	73be <tcp_receive+0x62a>
								if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
    73ce:	1a83      	subs	r3, r0, r2
    73d0:	2b00      	cmp	r3, #0
    73d2:	db2f      	blt.n	7434 <tcp_receive+0x6a0>
							if (next->next == NULL && TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    73d4:	6835      	ldr	r5, [r6, #0]
    73d6:	2d00      	cmp	r5, #0
    73d8:	d036      	beq.n	7448 <tcp_receive+0x6b4>
						if (seqno == next->tcphdr->seqno) {
    73da:	6929      	ldr	r1, [r5, #16]
    73dc:	684a      	ldr	r2, [r1, #4]
    73de:	4637      	mov	r7, r6
    73e0:	4282      	cmp	r2, r0
    73e2:	d0df      	beq.n	73a4 <tcp_receive+0x610>
							if (next->next == NULL && TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    73e4:	462e      	mov	r6, r5
							if (prev == NULL) {
    73e6:	2f00      	cmp	r7, #0
    73e8:	d0f1      	beq.n	73ce <tcp_receive+0x63a>
								if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
    73ea:	693b      	ldr	r3, [r7, #16]
    73ec:	685b      	ldr	r3, [r3, #4]
    73ee:	ebae 0303 	sub.w	r3, lr, r3
    73f2:	2b00      	cmp	r3, #0
    73f4:	dbee      	blt.n	73d4 <tcp_receive+0x640>
    73f6:	ebac 0302 	sub.w	r3, ip, r2
    73fa:	2b00      	cmp	r3, #0
    73fc:	dcea      	bgt.n	73d4 <tcp_receive+0x640>
									cseg = tcp_seg_copy(&inseg);
    73fe:	4863      	ldr	r0, [pc, #396]	; (758c <tcp_receive+0x7f8>)
    7400:	4b63      	ldr	r3, [pc, #396]	; (7590 <tcp_receive+0x7fc>)
    7402:	4798      	blx	r3
									if (cseg != NULL) {
    7404:	4604      	mov	r4, r0
    7406:	b310      	cbz	r0, 744e <tcp_receive+0x6ba>
										if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
    7408:	693b      	ldr	r3, [r7, #16]
    740a:	6859      	ldr	r1, [r3, #4]
    740c:	4b61      	ldr	r3, [pc, #388]	; (7594 <tcp_receive+0x800>)
    740e:	685b      	ldr	r3, [r3, #4]
    7410:	893a      	ldrh	r2, [r7, #8]
    7412:	440a      	add	r2, r1
    7414:	1ad2      	subs	r2, r2, r3
    7416:	2a00      	cmp	r2, #0
    7418:	dd05      	ble.n	7426 <tcp_receive+0x692>
											prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
    741a:	1a5b      	subs	r3, r3, r1
    741c:	b299      	uxth	r1, r3
    741e:	8139      	strh	r1, [r7, #8]
											pbuf_realloc(prev->p, prev->len);
    7420:	6878      	ldr	r0, [r7, #4]
    7422:	4b5e      	ldr	r3, [pc, #376]	; (759c <tcp_receive+0x808>)
    7424:	4798      	blx	r3
										prev->next = cseg;
    7426:	603c      	str	r4, [r7, #0]
										tcp_oos_insert_segment(cseg, next);
    7428:	4631      	mov	r1, r6
    742a:	4620      	mov	r0, r4
    742c:	4b5a      	ldr	r3, [pc, #360]	; (7598 <tcp_receive+0x804>)
    742e:	4798      	blx	r3
    7430:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
									cseg = tcp_seg_copy(&inseg);
    7434:	4855      	ldr	r0, [pc, #340]	; (758c <tcp_receive+0x7f8>)
    7436:	4b56      	ldr	r3, [pc, #344]	; (7590 <tcp_receive+0x7fc>)
    7438:	4798      	blx	r3
									if (cseg != NULL) {
    743a:	b140      	cbz	r0, 744e <tcp_receive+0x6ba>
										pcb->ooseq = cseg;
    743c:	6760      	str	r0, [r4, #116]	; 0x74
										tcp_oos_insert_segment(cseg, next);
    743e:	4631      	mov	r1, r6
    7440:	4b55      	ldr	r3, [pc, #340]	; (7598 <tcp_receive+0x804>)
    7442:	4798      	blx	r3
    7444:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
							if (next->next == NULL && TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    7448:	1a82      	subs	r2, r0, r2
    744a:	2a00      	cmp	r2, #0
    744c:	dc01      	bgt.n	7452 <tcp_receive+0x6be>
    744e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
								if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    7452:	8988      	ldrh	r0, [r1, #12]
    7454:	4b52      	ldr	r3, [pc, #328]	; (75a0 <tcp_receive+0x80c>)
    7456:	4798      	blx	r3
    7458:	f010 0f01 	tst.w	r0, #1
    745c:	d1f7      	bne.n	744e <tcp_receive+0x6ba>
								next->next = tcp_seg_copy(&inseg);
    745e:	484b      	ldr	r0, [pc, #300]	; (758c <tcp_receive+0x7f8>)
    7460:	4b4b      	ldr	r3, [pc, #300]	; (7590 <tcp_receive+0x7fc>)
    7462:	4798      	blx	r3
    7464:	6030      	str	r0, [r6, #0]
								if (next->next != NULL) {
    7466:	2800      	cmp	r0, #0
    7468:	d0f1      	beq.n	744e <tcp_receive+0x6ba>
									if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
    746a:	6933      	ldr	r3, [r6, #16]
    746c:	6859      	ldr	r1, [r3, #4]
    746e:	4b49      	ldr	r3, [pc, #292]	; (7594 <tcp_receive+0x800>)
    7470:	685b      	ldr	r3, [r3, #4]
    7472:	8932      	ldrh	r2, [r6, #8]
    7474:	440a      	add	r2, r1
    7476:	1ad2      	subs	r2, r2, r3
    7478:	2a00      	cmp	r2, #0
    747a:	dd05      	ble.n	7488 <tcp_receive+0x6f4>
										next->len = (u16_t)(seqno - next->tcphdr->seqno);
    747c:	1a5b      	subs	r3, r3, r1
    747e:	b299      	uxth	r1, r3
    7480:	8131      	strh	r1, [r6, #8]
										pbuf_realloc(next->p, next->len);
    7482:	6870      	ldr	r0, [r6, #4]
    7484:	4b45      	ldr	r3, [pc, #276]	; (759c <tcp_receive+0x808>)
    7486:	4798      	blx	r3
									if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
    7488:	4b42      	ldr	r3, [pc, #264]	; (7594 <tcp_receive+0x800>)
    748a:	8a1a      	ldrh	r2, [r3, #16]
    748c:	685b      	ldr	r3, [r3, #4]
    748e:	441a      	add	r2, r3
    7490:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    7492:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    7494:	440b      	add	r3, r1
    7496:	429a      	cmp	r2, r3
    7498:	d9d9      	bls.n	744e <tcp_receive+0x6ba>
										if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
    749a:	6833      	ldr	r3, [r6, #0]
    749c:	691b      	ldr	r3, [r3, #16]
    749e:	8998      	ldrh	r0, [r3, #12]
    74a0:	4b3f      	ldr	r3, [pc, #252]	; (75a0 <tcp_receive+0x80c>)
    74a2:	4798      	blx	r3
    74a4:	f010 0f01 	tst.w	r0, #1
    74a8:	d11a      	bne.n	74e0 <tcp_receive+0x74c>
										next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
    74aa:	6832      	ldr	r2, [r6, #0]
    74ac:	4d39      	ldr	r5, [pc, #228]	; (7594 <tcp_receive+0x800>)
    74ae:	6869      	ldr	r1, [r5, #4]
    74b0:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    74b2:	1a5b      	subs	r3, r3, r1
    74b4:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    74b6:	440b      	add	r3, r1
    74b8:	8113      	strh	r3, [r2, #8]
										pbuf_realloc(next->next->p, next->next->len);
    74ba:	6833      	ldr	r3, [r6, #0]
    74bc:	8919      	ldrh	r1, [r3, #8]
    74be:	6858      	ldr	r0, [r3, #4]
    74c0:	4b36      	ldr	r3, [pc, #216]	; (759c <tcp_receive+0x808>)
    74c2:	4798      	blx	r3
										tcplen = TCP_TCPLEN(next->next);
    74c4:	6833      	ldr	r3, [r6, #0]
    74c6:	891c      	ldrh	r4, [r3, #8]
    74c8:	691b      	ldr	r3, [r3, #16]
    74ca:	8998      	ldrh	r0, [r3, #12]
    74cc:	4b34      	ldr	r3, [pc, #208]	; (75a0 <tcp_receive+0x80c>)
    74ce:	4798      	blx	r3
    74d0:	f010 0003 	ands.w	r0, r0, #3
    74d4:	bf18      	it	ne
    74d6:	2001      	movne	r0, #1
    74d8:	4404      	add	r4, r0
    74da:	822c      	strh	r4, [r5, #16]
    74dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
											TCPH_FLAGS_SET(next->next->tcphdr,
    74e0:	6833      	ldr	r3, [r6, #0]
    74e2:	691f      	ldr	r7, [r3, #16]
    74e4:	89bd      	ldrh	r5, [r7, #12]
    74e6:	4628      	mov	r0, r5
    74e8:	4b2d      	ldr	r3, [pc, #180]	; (75a0 <tcp_receive+0x80c>)
    74ea:	4798      	blx	r3
    74ec:	f000 003e 	and.w	r0, r0, #62	; 0x3e
    74f0:	4b2c      	ldr	r3, [pc, #176]	; (75a4 <tcp_receive+0x810>)
    74f2:	4798      	blx	r3
    74f4:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
    74f8:	4305      	orrs	r5, r0
    74fa:	81bd      	strh	r5, [r7, #12]
    74fc:	e7d5      	b.n	74aa <tcp_receive+0x716>
		if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    74fe:	4b25      	ldr	r3, [pc, #148]	; (7594 <tcp_receive+0x800>)
    7500:	685b      	ldr	r3, [r3, #4]
    7502:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    7504:	1a99      	subs	r1, r3, r2
    7506:	2900      	cmp	r1, #0
    7508:	db05      	blt.n	7516 <tcp_receive+0x782>
    750a:	3301      	adds	r3, #1
    750c:	1a9b      	subs	r3, r3, r2
    750e:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    7510:	1a9b      	subs	r3, r3, r2
    7512:	2b00      	cmp	r3, #0
    7514:	dd9b      	ble.n	744e <tcp_receive+0x6ba>
			tcp_ack_now(pcb);
    7516:	7fa3      	ldrb	r3, [r4, #30]
    7518:	f043 0302 	orr.w	r3, r3, #2
    751c:	77a3      	strb	r3, [r4, #30]
}
    751e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
							next = next->next;
    7522:	2500      	movs	r5, #0
						pcb->ooseq = next;
    7524:	6765      	str	r5, [r4, #116]	; 0x74
				pcb->rcv_nxt = seqno + tcplen;
    7526:	4d1b      	ldr	r5, [pc, #108]	; (7594 <tcp_receive+0x800>)
    7528:	8a2a      	ldrh	r2, [r5, #16]
    752a:	686b      	ldr	r3, [r5, #4]
    752c:	4413      	add	r3, r2
    752e:	62a3      	str	r3, [r4, #40]	; 0x28
				pcb->rcv_wnd -= tcplen;
    7530:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    7532:	1a9b      	subs	r3, r3, r2
    7534:	85a3      	strh	r3, [r4, #44]	; 0x2c
				tcp_update_rcv_ann_wnd(pcb);
    7536:	4620      	mov	r0, r4
    7538:	4b1b      	ldr	r3, [pc, #108]	; (75a8 <tcp_receive+0x814>)
    753a:	4798      	blx	r3
				if (inseg.p->tot_len > 0) {
    753c:	69ab      	ldr	r3, [r5, #24]
    753e:	891a      	ldrh	r2, [r3, #8]
    7540:	b112      	cbz	r2, 7548 <tcp_receive+0x7b4>
					recv_data = inseg.p;
    7542:	62ab      	str	r3, [r5, #40]	; 0x28
					inseg.p = NULL;
    7544:	2300      	movs	r3, #0
    7546:	61ab      	str	r3, [r5, #24]
				if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    7548:	4b12      	ldr	r3, [pc, #72]	; (7594 <tcp_receive+0x800>)
    754a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    754c:	8998      	ldrh	r0, [r3, #12]
    754e:	4b14      	ldr	r3, [pc, #80]	; (75a0 <tcp_receive+0x80c>)
    7550:	4798      	blx	r3
    7552:	f010 0f01 	tst.w	r0, #1
    7556:	d006      	beq.n	7566 <tcp_receive+0x7d2>
					recv_flags |= TF_GOT_FIN;
    7558:	4a0e      	ldr	r2, [pc, #56]	; (7594 <tcp_receive+0x800>)
    755a:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
    755e:	f043 0320 	orr.w	r3, r3, #32
    7562:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
				while (pcb->ooseq != NULL && pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
    7566:	6f65      	ldr	r5, [r4, #116]	; 0x74
    7568:	2d00      	cmp	r5, #0
    756a:	f43f af06 	beq.w	737a <tcp_receive+0x5e6>
    756e:	692b      	ldr	r3, [r5, #16]
    7570:	685a      	ldr	r2, [r3, #4]
    7572:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    7574:	428a      	cmp	r2, r1
    7576:	f47f af00 	bne.w	737a <tcp_receive+0x5e6>
					seqno = pcb->ooseq->tcphdr->seqno;
    757a:	4f06      	ldr	r7, [pc, #24]	; (7594 <tcp_receive+0x800>)
					pcb->rcv_nxt += TCP_TCPLEN(cseg);
    757c:	4e08      	ldr	r6, [pc, #32]	; (75a0 <tcp_receive+0x80c>)
					tcp_update_rcv_ann_wnd(pcb);
    757e:	f8df 8028 	ldr.w	r8, [pc, #40]	; 75a8 <tcp_receive+0x814>
    7582:	e6d4      	b.n	732e <tcp_receive+0x59a>
    7584:	00006241 	.word	0x00006241
    7588:	00005f45 	.word	0x00005f45
    758c:	20007fb0 	.word	0x20007fb0
    7590:	00006281 	.word	0x00006281
    7594:	20007f9c 	.word	0x20007f9c
    7598:	00006cc5 	.word	0x00006cc5
    759c:	00005ec5 	.word	0x00005ec5
    75a0:	00002f47 	.word	0x00002f47
    75a4:	00002f3d 	.word	0x00002f3d
    75a8:	000061c3 	.word	0x000061c3
						next = pcb->ooseq;
    75ac:	464d      	mov	r5, r9
						if (next && TCP_SEQ_GT(seqno + tcplen, next->tcphdr->seqno)) {
    75ae:	4b14      	ldr	r3, [pc, #80]	; (7600 <tcp_receive+0x86c>)
    75b0:	6859      	ldr	r1, [r3, #4]
    75b2:	692a      	ldr	r2, [r5, #16]
    75b4:	6852      	ldr	r2, [r2, #4]
    75b6:	8a1b      	ldrh	r3, [r3, #16]
    75b8:	440b      	add	r3, r1
    75ba:	1a9b      	subs	r3, r3, r2
    75bc:	2b00      	cmp	r3, #0
    75be:	ddb1      	ble.n	7524 <tcp_receive+0x790>
							inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
    75c0:	4b0f      	ldr	r3, [pc, #60]	; (7600 <tcp_receive+0x86c>)
    75c2:	1a52      	subs	r2, r2, r1
    75c4:	839a      	strh	r2, [r3, #28]
							if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    75c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    75c8:	8998      	ldrh	r0, [r3, #12]
    75ca:	4b0e      	ldr	r3, [pc, #56]	; (7604 <tcp_receive+0x870>)
    75cc:	4798      	blx	r3
    75ce:	f010 0f02 	tst.w	r0, #2
    75d2:	d003      	beq.n	75dc <tcp_receive+0x848>
								inseg.len -= 1;
    75d4:	4a0a      	ldr	r2, [pc, #40]	; (7600 <tcp_receive+0x86c>)
    75d6:	8b93      	ldrh	r3, [r2, #28]
    75d8:	3b01      	subs	r3, #1
    75da:	8393      	strh	r3, [r2, #28]
							pbuf_realloc(inseg.p, inseg.len);
    75dc:	4e08      	ldr	r6, [pc, #32]	; (7600 <tcp_receive+0x86c>)
    75de:	8bb1      	ldrh	r1, [r6, #28]
    75e0:	69b0      	ldr	r0, [r6, #24]
    75e2:	4b09      	ldr	r3, [pc, #36]	; (7608 <tcp_receive+0x874>)
    75e4:	4798      	blx	r3
							tcplen = TCP_TCPLEN(&inseg);
    75e6:	8bb7      	ldrh	r7, [r6, #28]
    75e8:	6a73      	ldr	r3, [r6, #36]	; 0x24
    75ea:	8998      	ldrh	r0, [r3, #12]
    75ec:	4b05      	ldr	r3, [pc, #20]	; (7604 <tcp_receive+0x870>)
    75ee:	4798      	blx	r3
    75f0:	f010 0003 	ands.w	r0, r0, #3
    75f4:	bf18      	it	ne
    75f6:	2001      	movne	r0, #1
    75f8:	4407      	add	r7, r0
    75fa:	8237      	strh	r7, [r6, #16]
    75fc:	e792      	b.n	7524 <tcp_receive+0x790>
    75fe:	bf00      	nop
    7600:	20007f9c 	.word	0x20007f9c
    7604:	00002f47 	.word	0x00002f47
    7608:	00005ec5 	.word	0x00005ec5

0000760c <tcp_input>:
{
    760c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    7610:	b083      	sub	sp, #12
    7612:	4604      	mov	r4, r0
    7614:	460d      	mov	r5, r1
	iphdr  = (struct ip_hdr *)p->payload;
    7616:	6843      	ldr	r3, [r0, #4]
    7618:	7819      	ldrb	r1, [r3, #0]
    761a:	f001 010f 	and.w	r1, r1, #15
	tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    761e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    7622:	4a99      	ldr	r2, [pc, #612]	; (7888 <tcp_input+0x27c>)
    7624:	6013      	str	r3, [r2, #0]
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    7626:	0089      	lsls	r1, r1, #2
    7628:	4249      	negs	r1, r1
    762a:	4b98      	ldr	r3, [pc, #608]	; (788c <tcp_input+0x280>)
    762c:	4798      	blx	r3
    762e:	b910      	cbnz	r0, 7636 <tcp_input+0x2a>
    7630:	8923      	ldrh	r3, [r4, #8]
    7632:	2b13      	cmp	r3, #19
    7634:	d805      	bhi.n	7642 <tcp_input+0x36>
	pbuf_free(p);
    7636:	4620      	mov	r0, r4
    7638:	4b95      	ldr	r3, [pc, #596]	; (7890 <tcp_input+0x284>)
    763a:	4798      	blx	r3
}
    763c:	b003      	add	sp, #12
    763e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (ip_addr_isbroadcast(&current_iphdr_dest, inp) || ip_addr_ismulticast(&current_iphdr_dest)) {
    7642:	4629      	mov	r1, r5
    7644:	4b93      	ldr	r3, [pc, #588]	; (7894 <tcp_input+0x288>)
    7646:	6818      	ldr	r0, [r3, #0]
    7648:	4b93      	ldr	r3, [pc, #588]	; (7898 <tcp_input+0x28c>)
    764a:	4798      	blx	r3
    764c:	2800      	cmp	r0, #0
    764e:	d1f2      	bne.n	7636 <tcp_input+0x2a>
    7650:	4b90      	ldr	r3, [pc, #576]	; (7894 <tcp_input+0x288>)
    7652:	681b      	ldr	r3, [r3, #0]
    7654:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    7658:	2be0      	cmp	r3, #224	; 0xe0
    765a:	d0ec      	beq.n	7636 <tcp_input+0x2a>
	if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(), IP_PROTO_TCP, p->tot_len) != 0) {
    765c:	8923      	ldrh	r3, [r4, #8]
    765e:	9300      	str	r3, [sp, #0]
    7660:	2306      	movs	r3, #6
    7662:	4a8c      	ldr	r2, [pc, #560]	; (7894 <tcp_input+0x288>)
    7664:	498d      	ldr	r1, [pc, #564]	; (789c <tcp_input+0x290>)
    7666:	4620      	mov	r0, r4
    7668:	4d8d      	ldr	r5, [pc, #564]	; (78a0 <tcp_input+0x294>)
    766a:	47a8      	blx	r5
    766c:	2800      	cmp	r0, #0
    766e:	d1e2      	bne.n	7636 <tcp_input+0x2a>
	hdrlen = TCPH_HDRLEN(tcphdr);
    7670:	4b85      	ldr	r3, [pc, #532]	; (7888 <tcp_input+0x27c>)
    7672:	681b      	ldr	r3, [r3, #0]
    7674:	8998      	ldrh	r0, [r3, #12]
    7676:	4b8b      	ldr	r3, [pc, #556]	; (78a4 <tcp_input+0x298>)
    7678:	4798      	blx	r3
    767a:	0b00      	lsrs	r0, r0, #12
	if (pbuf_header(p, -(hdrlen * 4))) {
    767c:	ebc0 3080 	rsb	r0, r0, r0, lsl #14
    7680:	0081      	lsls	r1, r0, #2
    7682:	b209      	sxth	r1, r1
    7684:	4620      	mov	r0, r4
    7686:	4b81      	ldr	r3, [pc, #516]	; (788c <tcp_input+0x280>)
    7688:	4798      	blx	r3
    768a:	2800      	cmp	r0, #0
    768c:	d1d3      	bne.n	7636 <tcp_input+0x2a>
	tcphdr->src  = ntohs(tcphdr->src);
    768e:	4d7e      	ldr	r5, [pc, #504]	; (7888 <tcp_input+0x27c>)
    7690:	682f      	ldr	r7, [r5, #0]
    7692:	8838      	ldrh	r0, [r7, #0]
    7694:	4e83      	ldr	r6, [pc, #524]	; (78a4 <tcp_input+0x298>)
    7696:	47b0      	blx	r6
    7698:	8038      	strh	r0, [r7, #0]
	tcphdr->dest = ntohs(tcphdr->dest);
    769a:	682f      	ldr	r7, [r5, #0]
    769c:	8878      	ldrh	r0, [r7, #2]
    769e:	47b0      	blx	r6
    76a0:	8078      	strh	r0, [r7, #2]
	seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    76a2:	682f      	ldr	r7, [r5, #0]
    76a4:	6878      	ldr	r0, [r7, #4]
    76a6:	f8df 8224 	ldr.w	r8, [pc, #548]	; 78cc <tcp_input+0x2c0>
    76aa:	47c0      	blx	r8
    76ac:	6078      	str	r0, [r7, #4]
    76ae:	6068      	str	r0, [r5, #4]
	ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    76b0:	682f      	ldr	r7, [r5, #0]
    76b2:	68b8      	ldr	r0, [r7, #8]
    76b4:	47c0      	blx	r8
    76b6:	60b8      	str	r0, [r7, #8]
    76b8:	60e8      	str	r0, [r5, #12]
	tcphdr->wnd           = ntohs(tcphdr->wnd);
    76ba:	682f      	ldr	r7, [r5, #0]
    76bc:	89f8      	ldrh	r0, [r7, #14]
    76be:	47b0      	blx	r6
    76c0:	81f8      	strh	r0, [r7, #14]
	flags  = TCPH_FLAGS(tcphdr);
    76c2:	682b      	ldr	r3, [r5, #0]
    76c4:	8998      	ldrh	r0, [r3, #12]
    76c6:	47b0      	blx	r6
    76c8:	fa5f fe80 	uxtb.w	lr, r0
    76cc:	f00e 033f 	and.w	r3, lr, #63	; 0x3f
    76d0:	722b      	strb	r3, [r5, #8]
	tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    76d2:	f01e 0303 	ands.w	r3, lr, #3
    76d6:	bf18      	it	ne
    76d8:	2301      	movne	r3, #1
    76da:	8921      	ldrh	r1, [r4, #8]
    76dc:	440b      	add	r3, r1
    76de:	b299      	uxth	r1, r3
    76e0:	8229      	strh	r1, [r5, #16]
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    76e2:	4b71      	ldr	r3, [pc, #452]	; (78a8 <tcp_input+0x29c>)
    76e4:	6818      	ldr	r0, [r3, #0]
    76e6:	2800      	cmp	r0, #0
    76e8:	f000 8084 	beq.w	77f4 <tcp_input+0x1e8>
		if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    76ec:	682f      	ldr	r7, [r5, #0]
    76ee:	883e      	ldrh	r6, [r7, #0]
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    76f0:	4b6a      	ldr	r3, [pc, #424]	; (789c <tcp_input+0x290>)
    76f2:	f8d3 c000 	ldr.w	ip, [r3]
		    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    76f6:	4b67      	ldr	r3, [pc, #412]	; (7894 <tcp_input+0x288>)
    76f8:	f8d3 8000 	ldr.w	r8, [r3]
    76fc:	4605      	mov	r5, r0
    76fe:	2200      	movs	r2, #0
    7700:	e004      	b.n	770c <tcp_input+0x100>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    7702:	68eb      	ldr	r3, [r5, #12]
    7704:	462a      	mov	r2, r5
    7706:	2b00      	cmp	r3, #0
    7708:	d074      	beq.n	77f4 <tcp_input+0x1e8>
    770a:	461d      	mov	r5, r3
		if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    770c:	8bab      	ldrh	r3, [r5, #28]
    770e:	42b3      	cmp	r3, r6
    7710:	d1f7      	bne.n	7702 <tcp_input+0xf6>
    7712:	f8b5 901a 	ldrh.w	r9, [r5, #26]
    7716:	887b      	ldrh	r3, [r7, #2]
    7718:	4599      	cmp	r9, r3
    771a:	d1f2      	bne.n	7702 <tcp_input+0xf6>
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    771c:	686b      	ldr	r3, [r5, #4]
    771e:	4563      	cmp	r3, ip
    7720:	d1ef      	bne.n	7702 <tcp_input+0xf6>
		    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    7722:	682b      	ldr	r3, [r5, #0]
    7724:	4543      	cmp	r3, r8
    7726:	d1ec      	bne.n	7702 <tcp_input+0xf6>
			if (prev != NULL) {
    7728:	b122      	cbz	r2, 7734 <tcp_input+0x128>
				prev->next      = pcb->next;
    772a:	68eb      	ldr	r3, [r5, #12]
    772c:	60d3      	str	r3, [r2, #12]
				pcb->next       = tcp_active_pcbs;
    772e:	60e8      	str	r0, [r5, #12]
				tcp_active_pcbs = pcb;
    7730:	4b5d      	ldr	r3, [pc, #372]	; (78a8 <tcp_input+0x29c>)
    7732:	601d      	str	r5, [r3, #0]
	if (pcb == NULL) {
    7734:	2d00      	cmp	r5, #0
    7736:	d05d      	beq.n	77f4 <tcp_input+0x1e8>
		inseg.next   = NULL;
    7738:	4b53      	ldr	r3, [pc, #332]	; (7888 <tcp_input+0x27c>)
    773a:	2200      	movs	r2, #0
    773c:	615a      	str	r2, [r3, #20]
		inseg.len    = p->tot_len;
    773e:	8921      	ldrh	r1, [r4, #8]
    7740:	8399      	strh	r1, [r3, #28]
		inseg.p      = p;
    7742:	619c      	str	r4, [r3, #24]
		inseg.tcphdr = tcphdr;
    7744:	625f      	str	r7, [r3, #36]	; 0x24
		recv_data  = NULL;
    7746:	629a      	str	r2, [r3, #40]	; 0x28
		recv_flags = 0;
    7748:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
		if (flags & TCP_PSH) {
    774c:	f01e 0f08 	tst.w	lr, #8
    7750:	d003      	beq.n	775a <tcp_input+0x14e>
			p->flags |= PBUF_FLAG_PUSH;
    7752:	7b63      	ldrb	r3, [r4, #13]
    7754:	f043 0301 	orr.w	r3, r3, #1
    7758:	7363      	strb	r3, [r4, #13]
		if (pcb->refused_data != NULL) {
    775a:	6fab      	ldr	r3, [r5, #120]	; 0x78
    775c:	b15b      	cbz	r3, 7776 <tcp_input+0x16a>
			if ((tcp_process_refused_data(pcb) == ERR_ABRT) || ((pcb->refused_data != NULL) && (tcplen > 0))) {
    775e:	4628      	mov	r0, r5
    7760:	4b52      	ldr	r3, [pc, #328]	; (78ac <tcp_input+0x2a0>)
    7762:	4798      	blx	r3
    7764:	f110 0f0a 	cmn.w	r0, #10
    7768:	d035      	beq.n	77d6 <tcp_input+0x1ca>
    776a:	6fab      	ldr	r3, [r5, #120]	; 0x78
    776c:	b11b      	cbz	r3, 7776 <tcp_input+0x16a>
    776e:	4b46      	ldr	r3, [pc, #280]	; (7888 <tcp_input+0x27c>)
    7770:	8a1b      	ldrh	r3, [r3, #16]
    7772:	2b00      	cmp	r3, #0
    7774:	d12f      	bne.n	77d6 <tcp_input+0x1ca>
		tcp_input_pcb = pcb;
    7776:	4b4e      	ldr	r3, [pc, #312]	; (78b0 <tcp_input+0x2a4>)
    7778:	601d      	str	r5, [r3, #0]
	if (flags & TCP_RST) {
    777a:	4b43      	ldr	r3, [pc, #268]	; (7888 <tcp_input+0x27c>)
    777c:	7a1b      	ldrb	r3, [r3, #8]
    777e:	f013 0f04 	tst.w	r3, #4
    7782:	f000 8144 	beq.w	7a0e <tcp_input+0x402>
		if (pcb->state == SYN_SENT) {
    7786:	7e2b      	ldrb	r3, [r5, #24]
    7788:	2b02      	cmp	r3, #2
    778a:	f000 812c 	beq.w	79e6 <tcp_input+0x3da>
			if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
    778e:	4b3e      	ldr	r3, [pc, #248]	; (7888 <tcp_input+0x27c>)
    7790:	685b      	ldr	r3, [r3, #4]
    7792:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    7794:	1a9b      	subs	r3, r3, r2
    7796:	d408      	bmi.n	77aa <tcp_input+0x19e>
    7798:	8daa      	ldrh	r2, [r5, #44]	; 0x2c
    779a:	1a9b      	subs	r3, r3, r2
	u8_t            acceptable = 0;
    779c:	2b00      	cmp	r3, #0
    779e:	bfcc      	ite	gt
    77a0:	2300      	movgt	r3, #0
    77a2:	2301      	movle	r3, #1
		if (acceptable) {
    77a4:	2b00      	cmp	r3, #0
    77a6:	f040 8126 	bne.w	79f6 <tcp_input+0x3ea>
			if (recv_flags & TF_RESET) {
    77aa:	4b37      	ldr	r3, [pc, #220]	; (7888 <tcp_input+0x27c>)
    77ac:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    77b0:	f013 0f08 	tst.w	r3, #8
    77b4:	f000 835d 	beq.w	7e72 <tcp_input+0x866>
				TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
    77b8:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    77bc:	b11b      	cbz	r3, 77c6 <tcp_input+0x1ba>
    77be:	f06f 010a 	mvn.w	r1, #10
    77c2:	6928      	ldr	r0, [r5, #16]
    77c4:	4798      	blx	r3
				tcp_pcb_remove(&tcp_active_pcbs, pcb);
    77c6:	4629      	mov	r1, r5
    77c8:	4837      	ldr	r0, [pc, #220]	; (78a8 <tcp_input+0x29c>)
    77ca:	4b3a      	ldr	r3, [pc, #232]	; (78b4 <tcp_input+0x2a8>)
    77cc:	4798      	blx	r3
				memp_free(MEMP_TCP_PCB, pcb);
    77ce:	4629      	mov	r1, r5
    77d0:	2002      	movs	r0, #2
    77d2:	4b39      	ldr	r3, [pc, #228]	; (78b8 <tcp_input+0x2ac>)
    77d4:	4798      	blx	r3
		tcp_input_pcb = NULL;
    77d6:	2200      	movs	r2, #0
    77d8:	4b35      	ldr	r3, [pc, #212]	; (78b0 <tcp_input+0x2a4>)
    77da:	601a      	str	r2, [r3, #0]
		recv_data     = NULL;
    77dc:	4b2a      	ldr	r3, [pc, #168]	; (7888 <tcp_input+0x27c>)
    77de:	629a      	str	r2, [r3, #40]	; 0x28
		if (inseg.p != NULL) {
    77e0:	6998      	ldr	r0, [r3, #24]
    77e2:	2800      	cmp	r0, #0
    77e4:	f43f af2a 	beq.w	763c <tcp_input+0x30>
			pbuf_free(inseg.p);
    77e8:	4b29      	ldr	r3, [pc, #164]	; (7890 <tcp_input+0x284>)
    77ea:	4798      	blx	r3
			inseg.p = NULL;
    77ec:	2200      	movs	r2, #0
    77ee:	4b26      	ldr	r3, [pc, #152]	; (7888 <tcp_input+0x27c>)
    77f0:	619a      	str	r2, [r3, #24]
    77f2:	e723      	b.n	763c <tcp_input+0x30>
		for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    77f4:	4b31      	ldr	r3, [pc, #196]	; (78bc <tcp_input+0x2b0>)
    77f6:	6818      	ldr	r0, [r3, #0]
    77f8:	2800      	cmp	r0, #0
    77fa:	d069      	beq.n	78d0 <tcp_input+0x2c4>
			if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    77fc:	4b22      	ldr	r3, [pc, #136]	; (7888 <tcp_input+0x27c>)
    77fe:	681f      	ldr	r7, [r3, #0]
    7800:	883a      	ldrh	r2, [r7, #0]
			    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    7802:	4b26      	ldr	r3, [pc, #152]	; (789c <tcp_input+0x290>)
    7804:	f8d3 8000 	ldr.w	r8, [r3]
			    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    7808:	4b22      	ldr	r3, [pc, #136]	; (7894 <tcp_input+0x288>)
    780a:	f8d3 c000 	ldr.w	ip, [r3]
    780e:	e011      	b.n	7834 <tcp_input+0x228>
	} else if (flags & TCP_FIN) {
    7810:	f01e 0f01 	tst.w	lr, #1
    7814:	d002      	beq.n	781c <tcp_input+0x210>
		pcb->tmr = tcp_ticks;
    7816:	4b2a      	ldr	r3, [pc, #168]	; (78c0 <tcp_input+0x2b4>)
    7818:	681b      	ldr	r3, [r3, #0]
    781a:	6243      	str	r3, [r0, #36]	; 0x24
	if ((tcplen > 0)) {
    781c:	2900      	cmp	r1, #0
    781e:	d02e      	beq.n	787e <tcp_input+0x272>
		pcb->flags |= TF_ACK_NOW;
    7820:	7f83      	ldrb	r3, [r0, #30]
    7822:	f043 0302 	orr.w	r3, r3, #2
    7826:	7783      	strb	r3, [r0, #30]
		return tcp_output(pcb);
    7828:	4b26      	ldr	r3, [pc, #152]	; (78c4 <tcp_input+0x2b8>)
    782a:	4798      	blx	r3
    782c:	e027      	b.n	787e <tcp_input+0x272>
		for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    782e:	68c0      	ldr	r0, [r0, #12]
    7830:	2800      	cmp	r0, #0
    7832:	d04d      	beq.n	78d0 <tcp_input+0x2c4>
			if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    7834:	8b83      	ldrh	r3, [r0, #28]
    7836:	4293      	cmp	r3, r2
    7838:	d1f9      	bne.n	782e <tcp_input+0x222>
    783a:	8b45      	ldrh	r5, [r0, #26]
    783c:	887e      	ldrh	r6, [r7, #2]
    783e:	42ae      	cmp	r6, r5
    7840:	d1f5      	bne.n	782e <tcp_input+0x222>
			    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    7842:	6846      	ldr	r6, [r0, #4]
    7844:	4546      	cmp	r6, r8
    7846:	d1f2      	bne.n	782e <tcp_input+0x222>
			    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    7848:	6806      	ldr	r6, [r0, #0]
    784a:	4566      	cmp	r6, ip
    784c:	d1ef      	bne.n	782e <tcp_input+0x222>
	if (flags & TCP_RST) {
    784e:	f01e 0f04 	tst.w	lr, #4
    7852:	d114      	bne.n	787e <tcp_input+0x272>
	if (flags & TCP_SYN) {
    7854:	f01e 0f02 	tst.w	lr, #2
    7858:	d0da      	beq.n	7810 <tcp_input+0x204>
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
    785a:	4a0b      	ldr	r2, [pc, #44]	; (7888 <tcp_input+0x27c>)
    785c:	6856      	ldr	r6, [r2, #4]
    785e:	6a82      	ldr	r2, [r0, #40]	; 0x28
    7860:	1ab2      	subs	r2, r6, r2
    7862:	d4db      	bmi.n	781c <tcp_input+0x210>
    7864:	8d87      	ldrh	r7, [r0, #44]	; 0x2c
    7866:	1bd2      	subs	r2, r2, r7
    7868:	2a00      	cmp	r2, #0
    786a:	dcd7      	bgt.n	781c <tcp_input+0x210>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    786c:	9301      	str	r3, [sp, #4]
    786e:	9500      	str	r5, [sp, #0]
    7870:	4b0a      	ldr	r3, [pc, #40]	; (789c <tcp_input+0x290>)
    7872:	4a08      	ldr	r2, [pc, #32]	; (7894 <tcp_input+0x288>)
    7874:	4431      	add	r1, r6
    7876:	4804      	ldr	r0, [pc, #16]	; (7888 <tcp_input+0x27c>)
    7878:	68c0      	ldr	r0, [r0, #12]
    787a:	4d13      	ldr	r5, [pc, #76]	; (78c8 <tcp_input+0x2bc>)
    787c:	47a8      	blx	r5
				pbuf_free(p);
    787e:	4620      	mov	r0, r4
    7880:	4b03      	ldr	r3, [pc, #12]	; (7890 <tcp_input+0x284>)
    7882:	4798      	blx	r3
				return;
    7884:	e6da      	b.n	763c <tcp_input+0x30>
    7886:	bf00      	nop
    7888:	20007f9c 	.word	0x20007f9c
    788c:	00005c8d 	.word	0x00005c8d
    7890:	00005d21 	.word	0x00005d21
    7894:	20008334 	.word	0x20008334
    7898:	00004f91 	.word	0x00004f91
    789c:	2000832c 	.word	0x2000832c
    78a0:	00004b29 	.word	0x00004b29
    78a4:	00002f47 	.word	0x00002f47
    78a8:	20009300 	.word	0x20009300
    78ac:	000068f9 	.word	0x000068f9
    78b0:	20009318 	.word	0x20009318
    78b4:	00006681 	.word	0x00006681
    78b8:	00005a59 	.word	0x00005a59
    78bc:	20009314 	.word	0x20009314
    78c0:	20009304 	.word	0x20009304
    78c4:	000082a1 	.word	0x000082a1
    78c8:	00008575 	.word	0x00008575
    78cc:	00002f69 	.word	0x00002f69
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    78d0:	4b9c      	ldr	r3, [pc, #624]	; (7b44 <tcp_input+0x538>)
    78d2:	f8d3 c000 	ldr.w	ip, [r3]
    78d6:	f1bc 0f00 	cmp.w	ip, #0
    78da:	f000 8337 	beq.w	7f4c <tcp_input+0x940>
			if (lpcb->local_port == tcphdr->dest) {
    78de:	4b9a      	ldr	r3, [pc, #616]	; (7b48 <tcp_input+0x53c>)
    78e0:	681f      	ldr	r7, [r3, #0]
    78e2:	8878      	ldrh	r0, [r7, #2]
				if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) || ip_addr_isany(&(lpcb->local_ip))) {
    78e4:	4b99      	ldr	r3, [pc, #612]	; (7b4c <tcp_input+0x540>)
    78e6:	681e      	ldr	r6, [r3, #0]
    78e8:	4665      	mov	r5, ip
    78ea:	2200      	movs	r2, #0
    78ec:	e005      	b.n	78fa <tcp_input+0x2ee>
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    78ee:	68eb      	ldr	r3, [r5, #12]
    78f0:	462a      	mov	r2, r5
    78f2:	2b00      	cmp	r3, #0
    78f4:	f000 832a 	beq.w	7f4c <tcp_input+0x940>
    78f8:	461d      	mov	r5, r3
			if (lpcb->local_port == tcphdr->dest) {
    78fa:	8b6b      	ldrh	r3, [r5, #26]
    78fc:	4283      	cmp	r3, r0
    78fe:	d1f6      	bne.n	78ee <tcp_input+0x2e2>
				if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) || ip_addr_isany(&(lpcb->local_ip))) {
    7900:	682b      	ldr	r3, [r5, #0]
    7902:	42b3      	cmp	r3, r6
    7904:	d002      	beq.n	790c <tcp_input+0x300>
    7906:	b10d      	cbz	r5, 790c <tcp_input+0x300>
    7908:	2b00      	cmp	r3, #0
    790a:	d1f0      	bne.n	78ee <tcp_input+0x2e2>
		if (lpcb != NULL) {
    790c:	2d00      	cmp	r5, #0
    790e:	f000 831d 	beq.w	7f4c <tcp_input+0x940>
			if (prev != NULL) {
    7912:	b12a      	cbz	r2, 7920 <tcp_input+0x314>
				((struct tcp_pcb_listen *)prev)->next = lpcb->next;
    7914:	68eb      	ldr	r3, [r5, #12]
    7916:	60d3      	str	r3, [r2, #12]
				lpcb->next = tcp_listen_pcbs.listen_pcbs;
    7918:	f8c5 c00c 	str.w	ip, [r5, #12]
				tcp_listen_pcbs.listen_pcbs = lpcb;
    791c:	4b89      	ldr	r3, [pc, #548]	; (7b44 <tcp_input+0x538>)
    791e:	601d      	str	r5, [r3, #0]
	if (flags & TCP_RST) {
    7920:	f01e 0f04 	tst.w	lr, #4
    7924:	d105      	bne.n	7932 <tcp_input+0x326>
	if (flags & TCP_ACK) {
    7926:	f01e 0f10 	tst.w	lr, #16
    792a:	d106      	bne.n	793a <tcp_input+0x32e>
	} else if (flags & TCP_SYN) {
    792c:	f01e 0f02 	tst.w	lr, #2
    7930:	d110      	bne.n	7954 <tcp_input+0x348>
			pbuf_free(p);
    7932:	4620      	mov	r0, r4
    7934:	4b86      	ldr	r3, [pc, #536]	; (7b50 <tcp_input+0x544>)
    7936:	4798      	blx	r3
			return;
    7938:	e680      	b.n	763c <tcp_input+0x30>
		tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    793a:	4883      	ldr	r0, [pc, #524]	; (7b48 <tcp_input+0x53c>)
    793c:	6845      	ldr	r5, [r0, #4]
    793e:	883b      	ldrh	r3, [r7, #0]
    7940:	9301      	str	r3, [sp, #4]
    7942:	887b      	ldrh	r3, [r7, #2]
    7944:	9300      	str	r3, [sp, #0]
    7946:	4b83      	ldr	r3, [pc, #524]	; (7b54 <tcp_input+0x548>)
    7948:	4a80      	ldr	r2, [pc, #512]	; (7b4c <tcp_input+0x540>)
    794a:	4429      	add	r1, r5
    794c:	68c0      	ldr	r0, [r0, #12]
    794e:	4d82      	ldr	r5, [pc, #520]	; (7b58 <tcp_input+0x54c>)
    7950:	47a8      	blx	r5
    7952:	e7ee      	b.n	7932 <tcp_input+0x326>
		npcb = tcp_alloc(pcb->prio);
    7954:	7e68      	ldrb	r0, [r5, #25]
    7956:	4b81      	ldr	r3, [pc, #516]	; (7b5c <tcp_input+0x550>)
    7958:	4798      	blx	r3
		if (npcb == NULL) {
    795a:	4606      	mov	r6, r0
    795c:	2800      	cmp	r0, #0
    795e:	d0e8      	beq.n	7932 <tcp_input+0x326>
		ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    7960:	4b7a      	ldr	r3, [pc, #488]	; (7b4c <tcp_input+0x540>)
    7962:	681b      	ldr	r3, [r3, #0]
    7964:	6003      	str	r3, [r0, #0]
		npcb->local_port = pcb->local_port;
    7966:	8b6b      	ldrh	r3, [r5, #26]
    7968:	8343      	strh	r3, [r0, #26]
		ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    796a:	4b7a      	ldr	r3, [pc, #488]	; (7b54 <tcp_input+0x548>)
    796c:	681b      	ldr	r3, [r3, #0]
    796e:	6043      	str	r3, [r0, #4]
		npcb->remote_port        = tcphdr->src;
    7970:	4b75      	ldr	r3, [pc, #468]	; (7b48 <tcp_input+0x53c>)
    7972:	681a      	ldr	r2, [r3, #0]
    7974:	8811      	ldrh	r1, [r2, #0]
    7976:	8381      	strh	r1, [r0, #28]
		npcb->state              = SYN_RCVD;
    7978:	2103      	movs	r1, #3
    797a:	7601      	strb	r1, [r0, #24]
		npcb->rcv_nxt            = seqno + 1;
    797c:	685b      	ldr	r3, [r3, #4]
    797e:	1c59      	adds	r1, r3, #1
    7980:	6281      	str	r1, [r0, #40]	; 0x28
		npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    7982:	6301      	str	r1, [r0, #48]	; 0x30
		npcb->snd_wnd            = tcphdr->wnd;
    7984:	89d1      	ldrh	r1, [r2, #14]
    7986:	f8a0 1060 	strh.w	r1, [r0, #96]	; 0x60
		npcb->snd_wnd_max        = tcphdr->wnd;
    798a:	89d2      	ldrh	r2, [r2, #14]
    798c:	f8a0 2062 	strh.w	r2, [r0, #98]	; 0x62
		npcb->ssthresh           = npcb->snd_wnd;
    7990:	f8a0 104e 	strh.w	r1, [r0, #78]	; 0x4e
		npcb->snd_wl1            = seqno - 1; /* initialise to seqno-1 to force window update */
    7994:	3b01      	subs	r3, #1
    7996:	6543      	str	r3, [r0, #84]	; 0x54
		npcb->callback_arg       = pcb->callback_arg;
    7998:	692b      	ldr	r3, [r5, #16]
    799a:	6103      	str	r3, [r0, #16]
		npcb->accept = pcb->accept;
    799c:	696b      	ldr	r3, [r5, #20]
    799e:	6143      	str	r3, [r0, #20]
		npcb->so_options = pcb->so_options & SOF_INHERITED;
    79a0:	7a2b      	ldrb	r3, [r5, #8]
    79a2:	f023 0373 	bic.w	r3, r3, #115	; 0x73
    79a6:	7203      	strb	r3, [r0, #8]
		TCP_REG_ACTIVE(npcb);
    79a8:	4b6d      	ldr	r3, [pc, #436]	; (7b60 <tcp_input+0x554>)
    79aa:	681a      	ldr	r2, [r3, #0]
    79ac:	60c2      	str	r2, [r0, #12]
    79ae:	6018      	str	r0, [r3, #0]
    79b0:	4b6c      	ldr	r3, [pc, #432]	; (7b64 <tcp_input+0x558>)
    79b2:	4798      	blx	r3
    79b4:	2201      	movs	r2, #1
    79b6:	4b6c      	ldr	r3, [pc, #432]	; (7b68 <tcp_input+0x55c>)
    79b8:	701a      	strb	r2, [r3, #0]
		tcp_parseopt(npcb);
    79ba:	4630      	mov	r0, r6
    79bc:	4b6b      	ldr	r3, [pc, #428]	; (7b6c <tcp_input+0x560>)
    79be:	4798      	blx	r3
		npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    79c0:	1d31      	adds	r1, r6, #4
    79c2:	8ef0      	ldrh	r0, [r6, #54]	; 0x36
    79c4:	4b6a      	ldr	r3, [pc, #424]	; (7b70 <tcp_input+0x564>)
    79c6:	4798      	blx	r3
    79c8:	86f0      	strh	r0, [r6, #54]	; 0x36
		rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    79ca:	2112      	movs	r1, #18
    79cc:	4630      	mov	r0, r6
    79ce:	4b69      	ldr	r3, [pc, #420]	; (7b74 <tcp_input+0x568>)
    79d0:	4798      	blx	r3
		if (rc != ERR_OK) {
    79d2:	b918      	cbnz	r0, 79dc <tcp_input+0x3d0>
		return tcp_output(npcb);
    79d4:	4630      	mov	r0, r6
    79d6:	4b68      	ldr	r3, [pc, #416]	; (7b78 <tcp_input+0x56c>)
    79d8:	4798      	blx	r3
    79da:	e7aa      	b.n	7932 <tcp_input+0x326>
			tcp_abandon(npcb, 0);
    79dc:	2100      	movs	r1, #0
    79de:	4630      	mov	r0, r6
    79e0:	4b66      	ldr	r3, [pc, #408]	; (7b7c <tcp_input+0x570>)
    79e2:	4798      	blx	r3
    79e4:	e7a5      	b.n	7932 <tcp_input+0x326>
			if (ackno == pcb->snd_nxt) {
    79e6:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    79e8:	4a57      	ldr	r2, [pc, #348]	; (7b48 <tcp_input+0x53c>)
    79ea:	68d2      	ldr	r2, [r2, #12]
	u8_t            acceptable = 0;
    79ec:	4293      	cmp	r3, r2
    79ee:	bf14      	ite	ne
    79f0:	2300      	movne	r3, #0
    79f2:	2301      	moveq	r3, #1
    79f4:	e6d6      	b.n	77a4 <tcp_input+0x198>
			recv_flags |= TF_RESET;
    79f6:	4a54      	ldr	r2, [pc, #336]	; (7b48 <tcp_input+0x53c>)
    79f8:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
    79fc:	f043 0308 	orr.w	r3, r3, #8
    7a00:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
			pcb->flags &= ~TF_ACK_DELAY;
    7a04:	7fab      	ldrb	r3, [r5, #30]
    7a06:	f023 0301 	bic.w	r3, r3, #1
    7a0a:	77ab      	strb	r3, [r5, #30]
    7a0c:	e6cd      	b.n	77aa <tcp_input+0x19e>
	if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
    7a0e:	f013 0f02 	tst.w	r3, #2
    7a12:	d009      	beq.n	7a28 <tcp_input+0x41c>
    7a14:	7e2b      	ldrb	r3, [r5, #24]
    7a16:	3b02      	subs	r3, #2
    7a18:	b2db      	uxtb	r3, r3
    7a1a:	2b01      	cmp	r3, #1
    7a1c:	d904      	bls.n	7a28 <tcp_input+0x41c>
		tcp_ack_now(pcb);
    7a1e:	7fab      	ldrb	r3, [r5, #30]
    7a20:	f043 0302 	orr.w	r3, r3, #2
    7a24:	77ab      	strb	r3, [r5, #30]
    7a26:	e6c0      	b.n	77aa <tcp_input+0x19e>
	if ((pcb->flags & TF_RXCLOSED) == 0) {
    7a28:	7fab      	ldrb	r3, [r5, #30]
    7a2a:	f013 0f10 	tst.w	r3, #16
    7a2e:	d102      	bne.n	7a36 <tcp_input+0x42a>
		pcb->tmr = tcp_ticks;
    7a30:	4b53      	ldr	r3, [pc, #332]	; (7b80 <tcp_input+0x574>)
    7a32:	681b      	ldr	r3, [r3, #0]
    7a34:	626b      	str	r3, [r5, #36]	; 0x24
	pcb->keep_cnt_sent = 0;
    7a36:	2300      	movs	r3, #0
    7a38:	f885 3096 	strb.w	r3, [r5, #150]	; 0x96
	tcp_parseopt(pcb);
    7a3c:	4628      	mov	r0, r5
    7a3e:	4b4b      	ldr	r3, [pc, #300]	; (7b6c <tcp_input+0x560>)
    7a40:	4798      	blx	r3
	switch (pcb->state) {
    7a42:	7e2b      	ldrb	r3, [r5, #24]
    7a44:	3b02      	subs	r3, #2
    7a46:	2b07      	cmp	r3, #7
    7a48:	f63f aeaf 	bhi.w	77aa <tcp_input+0x19e>
    7a4c:	e8df f013 	tbh	[pc, r3, lsl #1]
    7a50:	009e0008 	.word	0x009e0008
    7a54:	010c00fb 	.word	0x010c00fb
    7a58:	00fb0166 	.word	0x00fb0166
    7a5c:	01fa01a2 	.word	0x01fa01a2
		if ((flags & TCP_ACK) && (flags & TCP_SYN) && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    7a60:	4b39      	ldr	r3, [pc, #228]	; (7b48 <tcp_input+0x53c>)
    7a62:	7a1b      	ldrb	r3, [r3, #8]
    7a64:	f003 0312 	and.w	r3, r3, #18
    7a68:	2b12      	cmp	r3, #18
    7a6a:	d014      	beq.n	7a96 <tcp_input+0x48a>
		else if (flags & TCP_ACK) {
    7a6c:	4b36      	ldr	r3, [pc, #216]	; (7b48 <tcp_input+0x53c>)
    7a6e:	7a1b      	ldrb	r3, [r3, #8]
    7a70:	f013 0f10 	tst.w	r3, #16
    7a74:	f43f ae99 	beq.w	77aa <tcp_input+0x19e>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    7a78:	4833      	ldr	r0, [pc, #204]	; (7b48 <tcp_input+0x53c>)
    7a7a:	6803      	ldr	r3, [r0, #0]
    7a7c:	8a04      	ldrh	r4, [r0, #16]
    7a7e:	6841      	ldr	r1, [r0, #4]
    7a80:	881a      	ldrh	r2, [r3, #0]
    7a82:	9201      	str	r2, [sp, #4]
    7a84:	885b      	ldrh	r3, [r3, #2]
    7a86:	9300      	str	r3, [sp, #0]
    7a88:	4b32      	ldr	r3, [pc, #200]	; (7b54 <tcp_input+0x548>)
    7a8a:	4a30      	ldr	r2, [pc, #192]	; (7b4c <tcp_input+0x540>)
    7a8c:	4421      	add	r1, r4
    7a8e:	68c0      	ldr	r0, [r0, #12]
    7a90:	4c31      	ldr	r4, [pc, #196]	; (7b58 <tcp_input+0x54c>)
    7a92:	47a0      	blx	r4
    7a94:	e689      	b.n	77aa <tcp_input+0x19e>
		if ((flags & TCP_ACK) && (flags & TCP_SYN) && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    7a96:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    7a98:	691b      	ldr	r3, [r3, #16]
    7a9a:	6858      	ldr	r0, [r3, #4]
    7a9c:	4b39      	ldr	r3, [pc, #228]	; (7b84 <tcp_input+0x578>)
    7a9e:	4798      	blx	r3
    7aa0:	3001      	adds	r0, #1
    7aa2:	4b29      	ldr	r3, [pc, #164]	; (7b48 <tcp_input+0x53c>)
    7aa4:	68db      	ldr	r3, [r3, #12]
    7aa6:	4298      	cmp	r0, r3
    7aa8:	d1e0      	bne.n	7a6c <tcp_input+0x460>
			pcb->snd_buf++;
    7aaa:	f8b5 3066 	ldrh.w	r3, [r5, #102]	; 0x66
    7aae:	3301      	adds	r3, #1
    7ab0:	f8a5 3066 	strh.w	r3, [r5, #102]	; 0x66
			pcb->rcv_nxt            = seqno + 1;
    7ab4:	4a24      	ldr	r2, [pc, #144]	; (7b48 <tcp_input+0x53c>)
    7ab6:	6853      	ldr	r3, [r2, #4]
    7ab8:	1c59      	adds	r1, r3, #1
    7aba:	62a9      	str	r1, [r5, #40]	; 0x28
			pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    7abc:	6329      	str	r1, [r5, #48]	; 0x30
			pcb->lastack            = ackno;
    7abe:	64a8      	str	r0, [r5, #72]	; 0x48
			pcb->snd_wnd            = tcphdr->wnd;
    7ac0:	6812      	ldr	r2, [r2, #0]
    7ac2:	89d1      	ldrh	r1, [r2, #14]
    7ac4:	f8a5 1060 	strh.w	r1, [r5, #96]	; 0x60
			pcb->snd_wnd_max        = tcphdr->wnd;
    7ac8:	89d2      	ldrh	r2, [r2, #14]
    7aca:	f8a5 2062 	strh.w	r2, [r5, #98]	; 0x62
			pcb->snd_wl1            = seqno - 1; /* initialise to seqno - 1 to force window update */
    7ace:	3b01      	subs	r3, #1
    7ad0:	656b      	str	r3, [r5, #84]	; 0x54
			pcb->state              = ESTABLISHED;
    7ad2:	2304      	movs	r3, #4
    7ad4:	762b      	strb	r3, [r5, #24]
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    7ad6:	18e9      	adds	r1, r5, r3
    7ad8:	8ee8      	ldrh	r0, [r5, #54]	; 0x36
    7ada:	4b25      	ldr	r3, [pc, #148]	; (7b70 <tcp_input+0x564>)
    7adc:	4798      	blx	r3
    7ade:	86e8      	strh	r0, [r5, #54]	; 0x36
			pcb->ssthresh = pcb->mss * 10;
    7ae0:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    7ae4:	005b      	lsls	r3, r3, #1
    7ae6:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
			pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    7aea:	f8b5 304c 	ldrh.w	r3, [r5, #76]	; 0x4c
    7aee:	2b01      	cmp	r3, #1
    7af0:	bf04      	itt	eq
    7af2:	0040      	lsleq	r0, r0, #1
    7af4:	b280      	uxtheq	r0, r0
    7af6:	f8a5 004c 	strh.w	r0, [r5, #76]	; 0x4c
			--pcb->snd_queuelen;
    7afa:	f8b5 3068 	ldrh.w	r3, [r5, #104]	; 0x68
    7afe:	3b01      	subs	r3, #1
    7b00:	f8a5 3068 	strh.w	r3, [r5, #104]	; 0x68
			rseg         = pcb->unacked;
    7b04:	6f28      	ldr	r0, [r5, #112]	; 0x70
			pcb->unacked = rseg->next;
    7b06:	6803      	ldr	r3, [r0, #0]
    7b08:	672b      	str	r3, [r5, #112]	; 0x70
			tcp_seg_free(rseg);
    7b0a:	4b1f      	ldr	r3, [pc, #124]	; (7b88 <tcp_input+0x57c>)
    7b0c:	4798      	blx	r3
			if (pcb->unacked == NULL)
    7b0e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    7b10:	b993      	cbnz	r3, 7b38 <tcp_input+0x52c>
				pcb->rtime = -1;
    7b12:	f64f 73ff 	movw	r3, #65535	; 0xffff
    7b16:	86ab      	strh	r3, [r5, #52]	; 0x34
			TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    7b18:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
    7b1c:	b13b      	cbz	r3, 7b2e <tcp_input+0x522>
    7b1e:	2200      	movs	r2, #0
    7b20:	4629      	mov	r1, r5
    7b22:	6928      	ldr	r0, [r5, #16]
    7b24:	4798      	blx	r3
			if (err == ERR_ABRT) {
    7b26:	f110 0f0a 	cmn.w	r0, #10
    7b2a:	f43f ae54 	beq.w	77d6 <tcp_input+0x1ca>
			tcp_ack_now(pcb);
    7b2e:	7fab      	ldrb	r3, [r5, #30]
    7b30:	f043 0302 	orr.w	r3, r3, #2
    7b34:	77ab      	strb	r3, [r5, #30]
    7b36:	e638      	b.n	77aa <tcp_input+0x19e>
				pcb->rtime = 0;
    7b38:	2300      	movs	r3, #0
    7b3a:	86ab      	strh	r3, [r5, #52]	; 0x34
				pcb->nrtx  = 0;
    7b3c:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
    7b40:	e7ea      	b.n	7b18 <tcp_input+0x50c>
    7b42:	bf00      	nop
    7b44:	20009308 	.word	0x20009308
    7b48:	20007f9c 	.word	0x20007f9c
    7b4c:	20008334 	.word	0x20008334
    7b50:	00005d21 	.word	0x00005d21
    7b54:	2000832c 	.word	0x2000832c
    7b58:	00008575 	.word	0x00008575
    7b5c:	00006add 	.word	0x00006add
    7b60:	20009300 	.word	0x20009300
    7b64:	000088b9 	.word	0x000088b9
    7b68:	200092fc 	.word	0x200092fc
    7b6c:	00006c2d 	.word	0x00006c2d
    7b70:	00006c05 	.word	0x00006c05
    7b74:	00008105 	.word	0x00008105
    7b78:	000082a1 	.word	0x000082a1
    7b7c:	00006a11 	.word	0x00006a11
    7b80:	20009304 	.word	0x20009304
    7b84:	00002f69 	.word	0x00002f69
    7b88:	00006241 	.word	0x00006241
		if (flags & TCP_ACK) {
    7b8c:	4b9d      	ldr	r3, [pc, #628]	; (7e04 <tcp_input+0x7f8>)
    7b8e:	7a1b      	ldrb	r3, [r3, #8]
    7b90:	f013 0f10 	tst.w	r3, #16
    7b94:	d048      	beq.n	7c28 <tcp_input+0x61c>
			if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
    7b96:	4b9b      	ldr	r3, [pc, #620]	; (7e04 <tcp_input+0x7f8>)
    7b98:	68d8      	ldr	r0, [r3, #12]
    7b9a:	6cab      	ldr	r3, [r5, #72]	; 0x48
    7b9c:	43db      	mvns	r3, r3
    7b9e:	42c3      	cmn	r3, r0
    7ba0:	d434      	bmi.n	7c0c <tcp_input+0x600>
    7ba2:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    7ba4:	1ac3      	subs	r3, r0, r3
    7ba6:	2b00      	cmp	r3, #0
    7ba8:	dc30      	bgt.n	7c0c <tcp_input+0x600>
				pcb->state = ESTABLISHED;
    7baa:	2304      	movs	r3, #4
    7bac:	762b      	strb	r3, [r5, #24]
				TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    7bae:	696b      	ldr	r3, [r5, #20]
    7bb0:	b143      	cbz	r3, 7bc4 <tcp_input+0x5b8>
    7bb2:	2200      	movs	r2, #0
    7bb4:	4629      	mov	r1, r5
    7bb6:	6928      	ldr	r0, [r5, #16]
    7bb8:	4798      	blx	r3
				if (err != ERR_OK) {
    7bba:	b138      	cbz	r0, 7bcc <tcp_input+0x5c0>
					if (err != ERR_ABRT) {
    7bbc:	f110 0f0a 	cmn.w	r0, #10
    7bc0:	f43f ae09 	beq.w	77d6 <tcp_input+0x1ca>
						tcp_abort(pcb);
    7bc4:	4628      	mov	r0, r5
    7bc6:	4b90      	ldr	r3, [pc, #576]	; (7e08 <tcp_input+0x7fc>)
    7bc8:	4798      	blx	r3
    7bca:	e604      	b.n	77d6 <tcp_input+0x1ca>
				old_cwnd = pcb->cwnd;
    7bcc:	f8b5 404c 	ldrh.w	r4, [r5, #76]	; 0x4c
				tcp_receive(pcb);
    7bd0:	4628      	mov	r0, r5
    7bd2:	4b8e      	ldr	r3, [pc, #568]	; (7e0c <tcp_input+0x800>)
    7bd4:	4798      	blx	r3
				if (pcb->acked != 0) {
    7bd6:	f8b5 3064 	ldrh.w	r3, [r5, #100]	; 0x64
    7bda:	b113      	cbz	r3, 7be2 <tcp_input+0x5d6>
					pcb->acked--;
    7bdc:	3b01      	subs	r3, #1
    7bde:	f8a5 3064 	strh.w	r3, [r5, #100]	; 0x64
				pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    7be2:	2c01      	cmp	r4, #1
    7be4:	8eeb      	ldrh	r3, [r5, #54]	; 0x36
    7be6:	bf04      	itt	eq
    7be8:	005b      	lsleq	r3, r3, #1
    7bea:	b29b      	uxtheq	r3, r3
    7bec:	f8a5 304c 	strh.w	r3, [r5, #76]	; 0x4c
				if (recv_flags & TF_GOT_FIN) {
    7bf0:	4b84      	ldr	r3, [pc, #528]	; (7e04 <tcp_input+0x7f8>)
    7bf2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    7bf6:	f013 0f20 	tst.w	r3, #32
    7bfa:	f43f add6 	beq.w	77aa <tcp_input+0x19e>
					tcp_ack_now(pcb);
    7bfe:	7fab      	ldrb	r3, [r5, #30]
    7c00:	f043 0302 	orr.w	r3, r3, #2
    7c04:	77ab      	strb	r3, [r5, #30]
					pcb->state = CLOSE_WAIT;
    7c06:	2307      	movs	r3, #7
    7c08:	762b      	strb	r3, [r5, #24]
    7c0a:	e5ce      	b.n	77aa <tcp_input+0x19e>
				    ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    7c0c:	4b7d      	ldr	r3, [pc, #500]	; (7e04 <tcp_input+0x7f8>)
    7c0e:	681a      	ldr	r2, [r3, #0]
				tcp_rst(
    7c10:	8a1c      	ldrh	r4, [r3, #16]
    7c12:	6859      	ldr	r1, [r3, #4]
    7c14:	8813      	ldrh	r3, [r2, #0]
    7c16:	9301      	str	r3, [sp, #4]
    7c18:	8853      	ldrh	r3, [r2, #2]
    7c1a:	9300      	str	r3, [sp, #0]
    7c1c:	4b7c      	ldr	r3, [pc, #496]	; (7e10 <tcp_input+0x804>)
    7c1e:	4a7d      	ldr	r2, [pc, #500]	; (7e14 <tcp_input+0x808>)
    7c20:	4421      	add	r1, r4
    7c22:	4c7d      	ldr	r4, [pc, #500]	; (7e18 <tcp_input+0x80c>)
    7c24:	47a0      	blx	r4
    7c26:	e5c0      	b.n	77aa <tcp_input+0x19e>
		} else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
    7c28:	f013 0f02 	tst.w	r3, #2
    7c2c:	f43f adbd 	beq.w	77aa <tcp_input+0x19e>
    7c30:	6aab      	ldr	r3, [r5, #40]	; 0x28
    7c32:	3b01      	subs	r3, #1
    7c34:	4a73      	ldr	r2, [pc, #460]	; (7e04 <tcp_input+0x7f8>)
    7c36:	6852      	ldr	r2, [r2, #4]
    7c38:	4293      	cmp	r3, r2
    7c3a:	f47f adb6 	bne.w	77aa <tcp_input+0x19e>
			tcp_rexmit(pcb);
    7c3e:	4628      	mov	r0, r5
    7c40:	4b76      	ldr	r3, [pc, #472]	; (7e1c <tcp_input+0x810>)
    7c42:	4798      	blx	r3
    7c44:	e5b1      	b.n	77aa <tcp_input+0x19e>
		tcp_receive(pcb);
    7c46:	4628      	mov	r0, r5
    7c48:	4b70      	ldr	r3, [pc, #448]	; (7e0c <tcp_input+0x800>)
    7c4a:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) { /* passive close */
    7c4c:	4b6d      	ldr	r3, [pc, #436]	; (7e04 <tcp_input+0x7f8>)
    7c4e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    7c52:	f013 0f20 	tst.w	r3, #32
    7c56:	f43f ada8 	beq.w	77aa <tcp_input+0x19e>
			tcp_ack_now(pcb);
    7c5a:	7fab      	ldrb	r3, [r5, #30]
    7c5c:	f043 0302 	orr.w	r3, r3, #2
    7c60:	77ab      	strb	r3, [r5, #30]
			pcb->state = CLOSE_WAIT;
    7c62:	2307      	movs	r3, #7
    7c64:	762b      	strb	r3, [r5, #24]
    7c66:	e5a0      	b.n	77aa <tcp_input+0x19e>
		tcp_receive(pcb);
    7c68:	4628      	mov	r0, r5
    7c6a:	4b68      	ldr	r3, [pc, #416]	; (7e0c <tcp_input+0x800>)
    7c6c:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) {
    7c6e:	4b65      	ldr	r3, [pc, #404]	; (7e04 <tcp_input+0x7f8>)
    7c70:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    7c74:	f013 0f20 	tst.w	r3, #32
    7c78:	d041      	beq.n	7cfe <tcp_input+0x6f2>
			if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    7c7a:	4b62      	ldr	r3, [pc, #392]	; (7e04 <tcp_input+0x7f8>)
    7c7c:	7a1b      	ldrb	r3, [r3, #8]
    7c7e:	f013 0f10 	tst.w	r3, #16
    7c82:	d035      	beq.n	7cf0 <tcp_input+0x6e4>
    7c84:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    7c86:	4b5f      	ldr	r3, [pc, #380]	; (7e04 <tcp_input+0x7f8>)
    7c88:	68db      	ldr	r3, [r3, #12]
    7c8a:	429a      	cmp	r2, r3
    7c8c:	d130      	bne.n	7cf0 <tcp_input+0x6e4>
				tcp_ack_now(pcb);
    7c8e:	7fab      	ldrb	r3, [r5, #30]
    7c90:	f043 0302 	orr.w	r3, r3, #2
    7c94:	77ab      	strb	r3, [r5, #30]
				tcp_pcb_purge(pcb);
    7c96:	4628      	mov	r0, r5
    7c98:	4b61      	ldr	r3, [pc, #388]	; (7e20 <tcp_input+0x814>)
    7c9a:	4798      	blx	r3
				TCP_RMV_ACTIVE(pcb);
    7c9c:	4b61      	ldr	r3, [pc, #388]	; (7e24 <tcp_input+0x818>)
    7c9e:	681b      	ldr	r3, [r3, #0]
    7ca0:	429d      	cmp	r5, r3
    7ca2:	d10e      	bne.n	7cc2 <tcp_input+0x6b6>
    7ca4:	68ea      	ldr	r2, [r5, #12]
    7ca6:	4b5f      	ldr	r3, [pc, #380]	; (7e24 <tcp_input+0x818>)
    7ca8:	601a      	str	r2, [r3, #0]
    7caa:	2201      	movs	r2, #1
    7cac:	4b5e      	ldr	r3, [pc, #376]	; (7e28 <tcp_input+0x81c>)
    7cae:	701a      	strb	r2, [r3, #0]
				pcb->state = TIME_WAIT;
    7cb0:	230a      	movs	r3, #10
    7cb2:	762b      	strb	r3, [r5, #24]
				TCP_REG(&tcp_tw_pcbs, pcb);
    7cb4:	4b5d      	ldr	r3, [pc, #372]	; (7e2c <tcp_input+0x820>)
    7cb6:	681a      	ldr	r2, [r3, #0]
    7cb8:	60ea      	str	r2, [r5, #12]
    7cba:	601d      	str	r5, [r3, #0]
    7cbc:	4b5c      	ldr	r3, [pc, #368]	; (7e30 <tcp_input+0x824>)
    7cbe:	4798      	blx	r3
    7cc0:	e573      	b.n	77aa <tcp_input+0x19e>
				TCP_RMV_ACTIVE(pcb);
    7cc2:	4a5c      	ldr	r2, [pc, #368]	; (7e34 <tcp_input+0x828>)
    7cc4:	6013      	str	r3, [r2, #0]
    7cc6:	2200      	movs	r2, #0
    7cc8:	2001      	movs	r0, #1
    7cca:	b92b      	cbnz	r3, 7cd8 <tcp_input+0x6cc>
    7ccc:	2a00      	cmp	r2, #0
    7cce:	d0ec      	beq.n	7caa <tcp_input+0x69e>
    7cd0:	2200      	movs	r2, #0
    7cd2:	4b58      	ldr	r3, [pc, #352]	; (7e34 <tcp_input+0x828>)
    7cd4:	601a      	str	r2, [r3, #0]
    7cd6:	e7e8      	b.n	7caa <tcp_input+0x69e>
    7cd8:	68d9      	ldr	r1, [r3, #12]
    7cda:	428d      	cmp	r5, r1
    7cdc:	d105      	bne.n	7cea <tcp_input+0x6de>
    7cde:	b10a      	cbz	r2, 7ce4 <tcp_input+0x6d8>
    7ce0:	4a54      	ldr	r2, [pc, #336]	; (7e34 <tcp_input+0x828>)
    7ce2:	6013      	str	r3, [r2, #0]
    7ce4:	68ea      	ldr	r2, [r5, #12]
    7ce6:	60da      	str	r2, [r3, #12]
    7ce8:	e7df      	b.n	7caa <tcp_input+0x69e>
    7cea:	4602      	mov	r2, r0
    7cec:	460b      	mov	r3, r1
    7cee:	e7ec      	b.n	7cca <tcp_input+0x6be>
				tcp_ack_now(pcb);
    7cf0:	7fab      	ldrb	r3, [r5, #30]
    7cf2:	f043 0302 	orr.w	r3, r3, #2
    7cf6:	77ab      	strb	r3, [r5, #30]
				pcb->state = CLOSING;
    7cf8:	2308      	movs	r3, #8
    7cfa:	762b      	strb	r3, [r5, #24]
    7cfc:	e555      	b.n	77aa <tcp_input+0x19e>
		} else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    7cfe:	4b41      	ldr	r3, [pc, #260]	; (7e04 <tcp_input+0x7f8>)
    7d00:	7a1b      	ldrb	r3, [r3, #8]
    7d02:	f013 0f10 	tst.w	r3, #16
    7d06:	f43f ad50 	beq.w	77aa <tcp_input+0x19e>
    7d0a:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    7d0c:	4b3d      	ldr	r3, [pc, #244]	; (7e04 <tcp_input+0x7f8>)
    7d0e:	68db      	ldr	r3, [r3, #12]
    7d10:	429a      	cmp	r2, r3
    7d12:	f47f ad4a 	bne.w	77aa <tcp_input+0x19e>
			pcb->state = FIN_WAIT_2;
    7d16:	2306      	movs	r3, #6
    7d18:	762b      	strb	r3, [r5, #24]
    7d1a:	e546      	b.n	77aa <tcp_input+0x19e>
		tcp_receive(pcb);
    7d1c:	4628      	mov	r0, r5
    7d1e:	4b3b      	ldr	r3, [pc, #236]	; (7e0c <tcp_input+0x800>)
    7d20:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) {
    7d22:	4b38      	ldr	r3, [pc, #224]	; (7e04 <tcp_input+0x7f8>)
    7d24:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    7d28:	f013 0f20 	tst.w	r3, #32
    7d2c:	f43f ad3d 	beq.w	77aa <tcp_input+0x19e>
			tcp_ack_now(pcb);
    7d30:	7fab      	ldrb	r3, [r5, #30]
    7d32:	f043 0302 	orr.w	r3, r3, #2
    7d36:	77ab      	strb	r3, [r5, #30]
			tcp_pcb_purge(pcb);
    7d38:	4628      	mov	r0, r5
    7d3a:	4b39      	ldr	r3, [pc, #228]	; (7e20 <tcp_input+0x814>)
    7d3c:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    7d3e:	4b39      	ldr	r3, [pc, #228]	; (7e24 <tcp_input+0x818>)
    7d40:	681b      	ldr	r3, [r3, #0]
    7d42:	429d      	cmp	r5, r3
    7d44:	d10e      	bne.n	7d64 <tcp_input+0x758>
    7d46:	68ea      	ldr	r2, [r5, #12]
    7d48:	4b36      	ldr	r3, [pc, #216]	; (7e24 <tcp_input+0x818>)
    7d4a:	601a      	str	r2, [r3, #0]
    7d4c:	2201      	movs	r2, #1
    7d4e:	4b36      	ldr	r3, [pc, #216]	; (7e28 <tcp_input+0x81c>)
    7d50:	701a      	strb	r2, [r3, #0]
			pcb->state = TIME_WAIT;
    7d52:	230a      	movs	r3, #10
    7d54:	762b      	strb	r3, [r5, #24]
			TCP_REG(&tcp_tw_pcbs, pcb);
    7d56:	4b35      	ldr	r3, [pc, #212]	; (7e2c <tcp_input+0x820>)
    7d58:	681a      	ldr	r2, [r3, #0]
    7d5a:	60ea      	str	r2, [r5, #12]
    7d5c:	601d      	str	r5, [r3, #0]
    7d5e:	4b34      	ldr	r3, [pc, #208]	; (7e30 <tcp_input+0x824>)
    7d60:	4798      	blx	r3
    7d62:	e522      	b.n	77aa <tcp_input+0x19e>
			TCP_RMV_ACTIVE(pcb);
    7d64:	4a33      	ldr	r2, [pc, #204]	; (7e34 <tcp_input+0x828>)
    7d66:	6013      	str	r3, [r2, #0]
    7d68:	2200      	movs	r2, #0
    7d6a:	2001      	movs	r0, #1
    7d6c:	e004      	b.n	7d78 <tcp_input+0x76c>
    7d6e:	68d9      	ldr	r1, [r3, #12]
    7d70:	428d      	cmp	r5, r1
    7d72:	d009      	beq.n	7d88 <tcp_input+0x77c>
    7d74:	4602      	mov	r2, r0
    7d76:	460b      	mov	r3, r1
    7d78:	2b00      	cmp	r3, #0
    7d7a:	d1f8      	bne.n	7d6e <tcp_input+0x762>
    7d7c:	2a00      	cmp	r2, #0
    7d7e:	d0e5      	beq.n	7d4c <tcp_input+0x740>
    7d80:	2200      	movs	r2, #0
    7d82:	4b2c      	ldr	r3, [pc, #176]	; (7e34 <tcp_input+0x828>)
    7d84:	601a      	str	r2, [r3, #0]
    7d86:	e7e1      	b.n	7d4c <tcp_input+0x740>
    7d88:	b10a      	cbz	r2, 7d8e <tcp_input+0x782>
    7d8a:	4a2a      	ldr	r2, [pc, #168]	; (7e34 <tcp_input+0x828>)
    7d8c:	6013      	str	r3, [r2, #0]
    7d8e:	68ea      	ldr	r2, [r5, #12]
    7d90:	60da      	str	r2, [r3, #12]
    7d92:	e7db      	b.n	7d4c <tcp_input+0x740>
		tcp_receive(pcb);
    7d94:	4628      	mov	r0, r5
    7d96:	4b1d      	ldr	r3, [pc, #116]	; (7e0c <tcp_input+0x800>)
    7d98:	4798      	blx	r3
		if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    7d9a:	4b1a      	ldr	r3, [pc, #104]	; (7e04 <tcp_input+0x7f8>)
    7d9c:	7a1b      	ldrb	r3, [r3, #8]
    7d9e:	f013 0f10 	tst.w	r3, #16
    7da2:	f43f ad02 	beq.w	77aa <tcp_input+0x19e>
    7da6:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    7da8:	4b16      	ldr	r3, [pc, #88]	; (7e04 <tcp_input+0x7f8>)
    7daa:	68db      	ldr	r3, [r3, #12]
    7dac:	429a      	cmp	r2, r3
    7dae:	f47f acfc 	bne.w	77aa <tcp_input+0x19e>
			tcp_pcb_purge(pcb);
    7db2:	4628      	mov	r0, r5
    7db4:	4b1a      	ldr	r3, [pc, #104]	; (7e20 <tcp_input+0x814>)
    7db6:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    7db8:	4b1a      	ldr	r3, [pc, #104]	; (7e24 <tcp_input+0x818>)
    7dba:	681b      	ldr	r3, [r3, #0]
    7dbc:	429d      	cmp	r5, r3
    7dbe:	d10e      	bne.n	7dde <tcp_input+0x7d2>
    7dc0:	68ea      	ldr	r2, [r5, #12]
    7dc2:	4b18      	ldr	r3, [pc, #96]	; (7e24 <tcp_input+0x818>)
    7dc4:	601a      	str	r2, [r3, #0]
    7dc6:	2201      	movs	r2, #1
    7dc8:	4b17      	ldr	r3, [pc, #92]	; (7e28 <tcp_input+0x81c>)
    7dca:	701a      	strb	r2, [r3, #0]
			pcb->state = TIME_WAIT;
    7dcc:	230a      	movs	r3, #10
    7dce:	762b      	strb	r3, [r5, #24]
			TCP_REG(&tcp_tw_pcbs, pcb);
    7dd0:	4b16      	ldr	r3, [pc, #88]	; (7e2c <tcp_input+0x820>)
    7dd2:	681a      	ldr	r2, [r3, #0]
    7dd4:	60ea      	str	r2, [r5, #12]
    7dd6:	601d      	str	r5, [r3, #0]
    7dd8:	4b15      	ldr	r3, [pc, #84]	; (7e30 <tcp_input+0x824>)
    7dda:	4798      	blx	r3
    7ddc:	e4e5      	b.n	77aa <tcp_input+0x19e>
			TCP_RMV_ACTIVE(pcb);
    7dde:	4a15      	ldr	r2, [pc, #84]	; (7e34 <tcp_input+0x828>)
    7de0:	6013      	str	r3, [r2, #0]
    7de2:	2200      	movs	r2, #0
    7de4:	2001      	movs	r0, #1
    7de6:	e004      	b.n	7df2 <tcp_input+0x7e6>
    7de8:	68d9      	ldr	r1, [r3, #12]
    7dea:	428d      	cmp	r5, r1
    7dec:	d024      	beq.n	7e38 <tcp_input+0x82c>
    7dee:	4602      	mov	r2, r0
    7df0:	460b      	mov	r3, r1
    7df2:	2b00      	cmp	r3, #0
    7df4:	d1f8      	bne.n	7de8 <tcp_input+0x7dc>
    7df6:	2a00      	cmp	r2, #0
    7df8:	d0e5      	beq.n	7dc6 <tcp_input+0x7ba>
    7dfa:	2200      	movs	r2, #0
    7dfc:	4b0d      	ldr	r3, [pc, #52]	; (7e34 <tcp_input+0x828>)
    7dfe:	601a      	str	r2, [r3, #0]
    7e00:	e7e1      	b.n	7dc6 <tcp_input+0x7ba>
    7e02:	bf00      	nop
    7e04:	20007f9c 	.word	0x20007f9c
    7e08:	00006ab5 	.word	0x00006ab5
    7e0c:	00006d95 	.word	0x00006d95
    7e10:	2000832c 	.word	0x2000832c
    7e14:	20008334 	.word	0x20008334
    7e18:	00008575 	.word	0x00008575
    7e1c:	0000864d 	.word	0x0000864d
    7e20:	000062b5 	.word	0x000062b5
    7e24:	20009300 	.word	0x20009300
    7e28:	200092fc 	.word	0x200092fc
    7e2c:	20009314 	.word	0x20009314
    7e30:	000088b9 	.word	0x000088b9
    7e34:	2000930c 	.word	0x2000930c
    7e38:	b10a      	cbz	r2, 7e3e <tcp_input+0x832>
    7e3a:	4a52      	ldr	r2, [pc, #328]	; (7f84 <tcp_input+0x978>)
    7e3c:	6013      	str	r3, [r2, #0]
    7e3e:	68ea      	ldr	r2, [r5, #12]
    7e40:	60da      	str	r2, [r3, #12]
    7e42:	e7c0      	b.n	7dc6 <tcp_input+0x7ba>
		tcp_receive(pcb);
    7e44:	4628      	mov	r0, r5
    7e46:	4b50      	ldr	r3, [pc, #320]	; (7f88 <tcp_input+0x97c>)
    7e48:	4798      	blx	r3
		if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    7e4a:	4b50      	ldr	r3, [pc, #320]	; (7f8c <tcp_input+0x980>)
    7e4c:	7a1b      	ldrb	r3, [r3, #8]
    7e4e:	f013 0f10 	tst.w	r3, #16
    7e52:	f43f acaa 	beq.w	77aa <tcp_input+0x19e>
    7e56:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    7e58:	4b4c      	ldr	r3, [pc, #304]	; (7f8c <tcp_input+0x980>)
    7e5a:	68db      	ldr	r3, [r3, #12]
    7e5c:	429a      	cmp	r2, r3
    7e5e:	f47f aca4 	bne.w	77aa <tcp_input+0x19e>
			recv_flags |= TF_CLOSED;
    7e62:	4a4a      	ldr	r2, [pc, #296]	; (7f8c <tcp_input+0x980>)
    7e64:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
    7e68:	f043 0310 	orr.w	r3, r3, #16
    7e6c:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
    7e70:	e49b      	b.n	77aa <tcp_input+0x19e>
			} else if (recv_flags & TF_CLOSED) {
    7e72:	f013 0f10 	tst.w	r3, #16
    7e76:	d013      	beq.n	7ea0 <tcp_input+0x894>
				if (!(pcb->flags & TF_RXCLOSED)) {
    7e78:	7fab      	ldrb	r3, [r5, #30]
    7e7a:	f013 0f10 	tst.w	r3, #16
    7e7e:	d106      	bne.n	7e8e <tcp_input+0x882>
					TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
    7e80:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    7e84:	b11b      	cbz	r3, 7e8e <tcp_input+0x882>
    7e86:	f06f 010b 	mvn.w	r1, #11
    7e8a:	6928      	ldr	r0, [r5, #16]
    7e8c:	4798      	blx	r3
				tcp_pcb_remove(&tcp_active_pcbs, pcb);
    7e8e:	4629      	mov	r1, r5
    7e90:	483f      	ldr	r0, [pc, #252]	; (7f90 <tcp_input+0x984>)
    7e92:	4b40      	ldr	r3, [pc, #256]	; (7f94 <tcp_input+0x988>)
    7e94:	4798      	blx	r3
				memp_free(MEMP_TCP_PCB, pcb);
    7e96:	4629      	mov	r1, r5
    7e98:	2002      	movs	r0, #2
    7e9a:	4b3f      	ldr	r3, [pc, #252]	; (7f98 <tcp_input+0x98c>)
    7e9c:	4798      	blx	r3
    7e9e:	e49a      	b.n	77d6 <tcp_input+0x1ca>
				if (pcb->acked > 0) {
    7ea0:	f8b5 2064 	ldrh.w	r2, [r5, #100]	; 0x64
    7ea4:	b142      	cbz	r2, 7eb8 <tcp_input+0x8ac>
					TCP_EVENT_SENT(pcb, pcb->acked, err);
    7ea6:	6feb      	ldr	r3, [r5, #124]	; 0x7c
    7ea8:	b133      	cbz	r3, 7eb8 <tcp_input+0x8ac>
    7eaa:	4629      	mov	r1, r5
    7eac:	6928      	ldr	r0, [r5, #16]
    7eae:	4798      	blx	r3
					if (err == ERR_ABRT) {
    7eb0:	f110 0f0a 	cmn.w	r0, #10
    7eb4:	f43f ac8f 	beq.w	77d6 <tcp_input+0x1ca>
				if (recv_data != NULL) {
    7eb8:	4b34      	ldr	r3, [pc, #208]	; (7f8c <tcp_input+0x980>)
    7eba:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    7ebc:	b1ca      	cbz	r2, 7ef2 <tcp_input+0x8e6>
					if (pcb->flags & TF_RXCLOSED) {
    7ebe:	7fab      	ldrb	r3, [r5, #30]
    7ec0:	f013 0f10 	tst.w	r3, #16
    7ec4:	d006      	beq.n	7ed4 <tcp_input+0x8c8>
						pbuf_free(recv_data);
    7ec6:	4610      	mov	r0, r2
    7ec8:	4b34      	ldr	r3, [pc, #208]	; (7f9c <tcp_input+0x990>)
    7eca:	4798      	blx	r3
						tcp_abort(pcb);
    7ecc:	4628      	mov	r0, r5
    7ece:	4b34      	ldr	r3, [pc, #208]	; (7fa0 <tcp_input+0x994>)
    7ed0:	4798      	blx	r3
						goto aborted;
    7ed2:	e480      	b.n	77d6 <tcp_input+0x1ca>
					TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    7ed4:	f8d5 4080 	ldr.w	r4, [r5, #128]	; 0x80
    7ed8:	b1f4      	cbz	r4, 7f18 <tcp_input+0x90c>
    7eda:	2300      	movs	r3, #0
    7edc:	4629      	mov	r1, r5
    7ede:	6928      	ldr	r0, [r5, #16]
    7ee0:	47a0      	blx	r4
					if (err == ERR_ABRT) {
    7ee2:	f110 0f0a 	cmn.w	r0, #10
    7ee6:	f43f ac76 	beq.w	77d6 <tcp_input+0x1ca>
					if (err != ERR_OK) {
    7eea:	b110      	cbz	r0, 7ef2 <tcp_input+0x8e6>
						pcb->refused_data = recv_data;
    7eec:	4b27      	ldr	r3, [pc, #156]	; (7f8c <tcp_input+0x980>)
    7eee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    7ef0:	67ab      	str	r3, [r5, #120]	; 0x78
				if (recv_flags & TF_GOT_FIN) {
    7ef2:	4b26      	ldr	r3, [pc, #152]	; (7f8c <tcp_input+0x980>)
    7ef4:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    7ef8:	f013 0f20 	tst.w	r3, #32
    7efc:	d005      	beq.n	7f0a <tcp_input+0x8fe>
					if (pcb->refused_data != NULL) {
    7efe:	6fab      	ldr	r3, [r5, #120]	; 0x78
    7f00:	b183      	cbz	r3, 7f24 <tcp_input+0x918>
						pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
    7f02:	7b5a      	ldrb	r2, [r3, #13]
    7f04:	f042 0220 	orr.w	r2, r2, #32
    7f08:	735a      	strb	r2, [r3, #13]
				tcp_input_pcb = NULL;
    7f0a:	2200      	movs	r2, #0
    7f0c:	4b25      	ldr	r3, [pc, #148]	; (7fa4 <tcp_input+0x998>)
    7f0e:	601a      	str	r2, [r3, #0]
				tcp_output(pcb);
    7f10:	4628      	mov	r0, r5
    7f12:	4b25      	ldr	r3, [pc, #148]	; (7fa8 <tcp_input+0x99c>)
    7f14:	4798      	blx	r3
    7f16:	e45e      	b.n	77d6 <tcp_input+0x1ca>
					TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    7f18:	2300      	movs	r3, #0
    7f1a:	4629      	mov	r1, r5
    7f1c:	4618      	mov	r0, r3
    7f1e:	4c23      	ldr	r4, [pc, #140]	; (7fac <tcp_input+0x9a0>)
    7f20:	47a0      	blx	r4
    7f22:	e7de      	b.n	7ee2 <tcp_input+0x8d6>
						if (pcb->rcv_wnd != TCP_WND) {
    7f24:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    7f26:	f241 62d0 	movw	r2, #5840	; 0x16d0
    7f2a:	4293      	cmp	r3, r2
							pcb->rcv_wnd++;
    7f2c:	bf1c      	itt	ne
    7f2e:	3301      	addne	r3, #1
    7f30:	85ab      	strhne	r3, [r5, #44]	; 0x2c
						TCP_EVENT_CLOSED(pcb, err);
    7f32:	f8d5 4080 	ldr.w	r4, [r5, #128]	; 0x80
    7f36:	2c00      	cmp	r4, #0
    7f38:	d0e7      	beq.n	7f0a <tcp_input+0x8fe>
    7f3a:	2300      	movs	r3, #0
    7f3c:	461a      	mov	r2, r3
    7f3e:	4629      	mov	r1, r5
    7f40:	6928      	ldr	r0, [r5, #16]
    7f42:	47a0      	blx	r4
						if (err == ERR_ABRT) {
    7f44:	f110 0f0a 	cmn.w	r0, #10
    7f48:	d1df      	bne.n	7f0a <tcp_input+0x8fe>
    7f4a:	e444      	b.n	77d6 <tcp_input+0x1ca>
		if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
    7f4c:	4b0f      	ldr	r3, [pc, #60]	; (7f8c <tcp_input+0x980>)
    7f4e:	681b      	ldr	r3, [r3, #0]
    7f50:	8998      	ldrh	r0, [r3, #12]
    7f52:	4b17      	ldr	r3, [pc, #92]	; (7fb0 <tcp_input+0x9a4>)
    7f54:	4798      	blx	r3
    7f56:	f010 0f04 	tst.w	r0, #4
    7f5a:	d004      	beq.n	7f66 <tcp_input+0x95a>
		pbuf_free(p);
    7f5c:	4620      	mov	r0, r4
    7f5e:	4b0f      	ldr	r3, [pc, #60]	; (7f9c <tcp_input+0x990>)
    7f60:	4798      	blx	r3
    7f62:	f7ff bb6b 	b.w	763c <tcp_input+0x30>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    7f66:	4809      	ldr	r0, [pc, #36]	; (7f8c <tcp_input+0x980>)
    7f68:	6803      	ldr	r3, [r0, #0]
    7f6a:	8a05      	ldrh	r5, [r0, #16]
    7f6c:	6841      	ldr	r1, [r0, #4]
    7f6e:	881a      	ldrh	r2, [r3, #0]
    7f70:	9201      	str	r2, [sp, #4]
    7f72:	885b      	ldrh	r3, [r3, #2]
    7f74:	9300      	str	r3, [sp, #0]
    7f76:	4b0f      	ldr	r3, [pc, #60]	; (7fb4 <tcp_input+0x9a8>)
    7f78:	4a0f      	ldr	r2, [pc, #60]	; (7fb8 <tcp_input+0x9ac>)
    7f7a:	4429      	add	r1, r5
    7f7c:	68c0      	ldr	r0, [r0, #12]
    7f7e:	4d0f      	ldr	r5, [pc, #60]	; (7fbc <tcp_input+0x9b0>)
    7f80:	47a8      	blx	r5
    7f82:	e7eb      	b.n	7f5c <tcp_input+0x950>
    7f84:	2000930c 	.word	0x2000930c
    7f88:	00006d95 	.word	0x00006d95
    7f8c:	20007f9c 	.word	0x20007f9c
    7f90:	20009300 	.word	0x20009300
    7f94:	00006681 	.word	0x00006681
    7f98:	00005a59 	.word	0x00005a59
    7f9c:	00005d21 	.word	0x00005d21
    7fa0:	00006ab5 	.word	0x00006ab5
    7fa4:	20009318 	.word	0x20009318
    7fa8:	000082a1 	.word	0x000082a1
    7fac:	000068c9 	.word	0x000068c9
    7fb0:	00002f47 	.word	0x00002f47
    7fb4:	2000832c 	.word	0x2000832c
    7fb8:	20008334 	.word	0x20008334
    7fbc:	00008575 	.word	0x00008575

00007fc0 <tcp_create_segment>:
 * @return a new tcp_seg pointing to p, or NULL.
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
    7fc0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7fc4:	4681      	mov	r9, r0
    7fc6:	4688      	mov	r8, r1
    7fc8:	4616      	mov	r6, r2
    7fca:	469a      	mov	sl, r3
    7fcc:	f89d 7020 	ldrb.w	r7, [sp, #32]
	struct tcp_seg *seg;
	u8_t            optlen = LWIP_TCP_OPT_LENGTH(optflags);
    7fd0:	f007 0301 	and.w	r3, r7, #1
    7fd4:	f007 0202 	and.w	r2, r7, #2
    7fd8:	2a00      	cmp	r2, #0
    7fda:	bf14      	ite	ne
    7fdc:	250c      	movne	r5, #12
    7fde:	2500      	moveq	r5, #0
    7fe0:	eb05 0583 	add.w	r5, r5, r3, lsl #2

	if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    7fe4:	2004      	movs	r0, #4
    7fe6:	4b24      	ldr	r3, [pc, #144]	; (8078 <tcp_create_segment+0xb8>)
    7fe8:	4798      	blx	r3
    7fea:	4604      	mov	r4, r0
    7fec:	2800      	cmp	r0, #0
    7fee:	d039      	beq.n	8064 <tcp_create_segment+0xa4>
		LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
		pbuf_free(p);
		return NULL;
	}
	seg->flags = optflags;
    7ff0:	7307      	strb	r7, [r0, #12]
	seg->next  = NULL;
    7ff2:	2200      	movs	r2, #0
    7ff4:	6002      	str	r2, [r0, #0]
	seg->p     = p;
    7ff6:	f8c0 8004 	str.w	r8, [r0, #4]
	seg->len   = p->tot_len - optlen;
    7ffa:	f8b8 3008 	ldrh.w	r3, [r8, #8]
    7ffe:	1b5b      	subs	r3, r3, r5
    8000:	8103      	strh	r3, [r0, #8]
#if TCP_OVERSIZE_DBGCHECK
	seg->oversize_left = 0;
    8002:	8142      	strh	r2, [r0, #10]
	/* check optflags */
	LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED", (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

	/* build TCP header */
	if (pbuf_header(p, TCP_HLEN)) {
    8004:	2114      	movs	r1, #20
    8006:	4640      	mov	r0, r8
    8008:	4b1c      	ldr	r3, [pc, #112]	; (807c <tcp_create_segment+0xbc>)
    800a:	4798      	blx	r3
    800c:	bb70      	cbnz	r0, 806c <tcp_create_segment+0xac>
		LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
		TCP_STATS_INC(tcp.err);
		tcp_seg_free(seg);
		return NULL;
	}
	seg->tcphdr        = (struct tcp_hdr *)seg->p->payload;
    800e:	6863      	ldr	r3, [r4, #4]
    8010:	f8d3 8004 	ldr.w	r8, [r3, #4]
    8014:	f8c4 8010 	str.w	r8, [r4, #16]
	seg->tcphdr->src   = htons(pcb->local_port);
    8018:	f8b9 001a 	ldrh.w	r0, [r9, #26]
    801c:	4f18      	ldr	r7, [pc, #96]	; (8080 <tcp_create_segment+0xc0>)
    801e:	47b8      	blx	r7
    8020:	f8a8 0000 	strh.w	r0, [r8]
	seg->tcphdr->dest  = htons(pcb->remote_port);
    8024:	f8d4 8010 	ldr.w	r8, [r4, #16]
    8028:	f8b9 001c 	ldrh.w	r0, [r9, #28]
    802c:	47b8      	blx	r7
    802e:	f8a8 0002 	strh.w	r0, [r8, #2]
	seg->tcphdr->seqno = htonl(seqno);
    8032:	f8d4 8010 	ldr.w	r8, [r4, #16]
    8036:	4650      	mov	r0, sl
    8038:	4b12      	ldr	r3, [pc, #72]	; (8084 <tcp_create_segment+0xc4>)
    803a:	4798      	blx	r3
    803c:	f8c8 0004 	str.w	r0, [r8, #4]
	/* ackno is set in tcp_output */
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    8040:	f8d4 8010 	ldr.w	r8, [r4, #16]
    8044:	f3c5 0587 	ubfx	r5, r5, #2, #8
    8048:	3505      	adds	r5, #5
    804a:	ea46 3505 	orr.w	r5, r6, r5, lsl #12
    804e:	b2a8      	uxth	r0, r5
    8050:	47b8      	blx	r7
    8052:	f8a8 000c 	strh.w	r0, [r8, #12]
	/* wnd and chksum are set in tcp_output */
	seg->tcphdr->urgp = 0;
    8056:	6923      	ldr	r3, [r4, #16]
    8058:	2200      	movs	r2, #0
    805a:	749a      	strb	r2, [r3, #18]
    805c:	74da      	strb	r2, [r3, #19]
	return seg;
}
    805e:	4620      	mov	r0, r4
    8060:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		pbuf_free(p);
    8064:	4640      	mov	r0, r8
    8066:	4b08      	ldr	r3, [pc, #32]	; (8088 <tcp_create_segment+0xc8>)
    8068:	4798      	blx	r3
		return NULL;
    806a:	e7f8      	b.n	805e <tcp_create_segment+0x9e>
		tcp_seg_free(seg);
    806c:	4620      	mov	r0, r4
    806e:	4b07      	ldr	r3, [pc, #28]	; (808c <tcp_create_segment+0xcc>)
    8070:	4798      	blx	r3
		return NULL;
    8072:	2400      	movs	r4, #0
    8074:	e7f3      	b.n	805e <tcp_create_segment+0x9e>
    8076:	bf00      	nop
    8078:	00005a11 	.word	0x00005a11
    807c:	00005c8d 	.word	0x00005c8d
    8080:	00002f3d 	.word	0x00002f3d
    8084:	00002f51 	.word	0x00002f51
    8088:	00005d21 	.word	0x00005d21
    808c:	00006241 	.word	0x00006241

00008090 <tcp_output_alloc_header>:
{
    8090:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    8094:	4606      	mov	r6, r0
    8096:	460c      	mov	r4, r1
    8098:	4699      	mov	r9, r3
	struct pbuf *   p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    809a:	3214      	adds	r2, #20
    809c:	4411      	add	r1, r2
    809e:	2200      	movs	r2, #0
    80a0:	b289      	uxth	r1, r1
    80a2:	2001      	movs	r0, #1
    80a4:	4b14      	ldr	r3, [pc, #80]	; (80f8 <tcp_output_alloc_header+0x68>)
    80a6:	4798      	blx	r3
	if (p != NULL) {
    80a8:	4680      	mov	r8, r0
    80aa:	b310      	cbz	r0, 80f2 <tcp_output_alloc_header+0x62>
		tcphdr        = (struct tcp_hdr *)p->payload;
    80ac:	6845      	ldr	r5, [r0, #4]
		tcphdr->src   = htons(pcb->local_port);
    80ae:	8b70      	ldrh	r0, [r6, #26]
    80b0:	4f12      	ldr	r7, [pc, #72]	; (80fc <tcp_output_alloc_header+0x6c>)
    80b2:	47b8      	blx	r7
    80b4:	8028      	strh	r0, [r5, #0]
		tcphdr->dest  = htons(pcb->remote_port);
    80b6:	8bb0      	ldrh	r0, [r6, #28]
    80b8:	47b8      	blx	r7
    80ba:	8068      	strh	r0, [r5, #2]
		tcphdr->seqno = seqno_be;
    80bc:	f8c5 9004 	str.w	r9, [r5, #4]
		tcphdr->ackno = htonl(pcb->rcv_nxt);
    80c0:	6ab0      	ldr	r0, [r6, #40]	; 0x28
    80c2:	4b0f      	ldr	r3, [pc, #60]	; (8100 <tcp_output_alloc_header+0x70>)
    80c4:	4798      	blx	r3
    80c6:	60a8      	str	r0, [r5, #8]
		TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    80c8:	08a0      	lsrs	r0, r4, #2
    80ca:	3005      	adds	r0, #5
    80cc:	0300      	lsls	r0, r0, #12
    80ce:	f400 4070 	and.w	r0, r0, #61440	; 0xf000
    80d2:	f040 0010 	orr.w	r0, r0, #16
    80d6:	47b8      	blx	r7
    80d8:	81a8      	strh	r0, [r5, #12]
		tcphdr->wnd    = htons(pcb->rcv_ann_wnd);
    80da:	8df0      	ldrh	r0, [r6, #46]	; 0x2e
    80dc:	47b8      	blx	r7
    80de:	81e8      	strh	r0, [r5, #14]
		tcphdr->chksum = 0;
    80e0:	2300      	movs	r3, #0
    80e2:	742b      	strb	r3, [r5, #16]
    80e4:	746b      	strb	r3, [r5, #17]
		tcphdr->urgp   = 0;
    80e6:	74ab      	strb	r3, [r5, #18]
    80e8:	74eb      	strb	r3, [r5, #19]
		pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    80ea:	8df2      	ldrh	r2, [r6, #46]	; 0x2e
    80ec:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    80ee:	4413      	add	r3, r2
    80f0:	6333      	str	r3, [r6, #48]	; 0x30
}
    80f2:	4640      	mov	r0, r8
    80f4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    80f8:	00005d89 	.word	0x00005d89
    80fc:	00002f3d 	.word	0x00002f3d
    8100:	00002f51 	.word	0x00002f51

00008104 <tcp_enqueue_flags>:

	LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
	            (flags & (TCP_SYN | TCP_FIN)) != 0);

	/* check for configured max queuelen and possible overflow */
	if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    8104:	f8b0 3068 	ldrh.w	r3, [r0, #104]	; 0x68
    8108:	2b07      	cmp	r3, #7
    810a:	d822      	bhi.n	8152 <tcp_enqueue_flags+0x4e>
{
    810c:	b5f0      	push	{r4, r5, r6, r7, lr}
    810e:	b083      	sub	sp, #12
		TCP_STATS_INC(tcp.memerr);
		pcb->flags |= TF_NAGLEMEMERR;
		return ERR_MEM;
	}

	if (flags & TCP_SYN) {
    8110:	f001 0302 	and.w	r3, r1, #2
	u8_t            optflags = 0;
    8114:	f3c1 0640 	ubfx	r6, r1, #1, #1
#if LWIP_TCP_TIMESTAMPS
	if ((pcb->flags & TF_TIMESTAMP)) {
		optflags |= TF_SEG_OPTS_TS;
	}
#endif /* LWIP_TCP_TIMESTAMPS */
	optlen = LWIP_TCP_OPT_LENGTH(optflags);
    8118:	2b00      	cmp	r3, #0
    811a:	bf14      	ite	ne
    811c:	2704      	movne	r7, #4
    811e:	2700      	moveq	r7, #0

	/* tcp_enqueue_flags is always called with either SYN or FIN in flags.
	 * We need one available snd_buf byte to do that.
	 * This means we can't send FIN while snd_buf==0. A better fix would be to
	 * not include SYN and FIN sequence numbers in the snd_buf count. */
	if (pcb->snd_buf == 0) {
    8120:	f8b0 3066 	ldrh.w	r3, [r0, #102]	; 0x66
    8124:	2b00      	cmp	r3, #0
    8126:	d04e      	beq.n	81c6 <tcp_enqueue_flags+0xc2>
    8128:	460d      	mov	r5, r1
    812a:	4604      	mov	r4, r0
		TCP_STATS_INC(tcp.memerr);
		return ERR_MEM;
	}

	/* Allocate pbuf with room for TCP header + options */
	if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    812c:	2200      	movs	r2, #0
    812e:	4639      	mov	r1, r7
    8130:	4610      	mov	r0, r2
    8132:	4b26      	ldr	r3, [pc, #152]	; (81cc <tcp_enqueue_flags+0xc8>)
    8134:	4798      	blx	r3
    8136:	4601      	mov	r1, r0
    8138:	b190      	cbz	r0, 8160 <tcp_enqueue_flags+0x5c>
		return ERR_MEM;
	}
	LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen", (p->len >= optlen));

	/* Allocate memory for tcp_seg, and fill in fields. */
	if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    813a:	9600      	str	r6, [sp, #0]
    813c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    813e:	462a      	mov	r2, r5
    8140:	4620      	mov	r0, r4
    8142:	4e23      	ldr	r6, [pc, #140]	; (81d0 <tcp_enqueue_flags+0xcc>)
    8144:	47b0      	blx	r6
    8146:	4601      	mov	r1, r0
    8148:	b188      	cbz	r0, 816e <tcp_enqueue_flags+0x6a>
	             ntohl(seg->tcphdr->seqno),
	             ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
	             (u16_t)flags));

	/* Now append seg to pcb->unsent queue */
	if (pcb->unsent == NULL) {
    814a:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
    814c:	b9ba      	cbnz	r2, 817e <tcp_enqueue_flags+0x7a>
		pcb->unsent = seg;
    814e:	66e0      	str	r0, [r4, #108]	; 0x6c
    8150:	e019      	b.n	8186 <tcp_enqueue_flags+0x82>
		pcb->flags |= TF_NAGLEMEMERR;
    8152:	7f83      	ldrb	r3, [r0, #30]
    8154:	f063 037f 	orn	r3, r3, #127	; 0x7f
    8158:	7783      	strb	r3, [r0, #30]
		return ERR_MEM;
    815a:	f04f 30ff 	mov.w	r0, #4294967295
    815e:	4770      	bx	lr
		pcb->flags |= TF_NAGLEMEMERR;
    8160:	7fa3      	ldrb	r3, [r4, #30]
    8162:	f063 037f 	orn	r3, r3, #127	; 0x7f
    8166:	77a3      	strb	r3, [r4, #30]
		return ERR_MEM;
    8168:	f04f 30ff 	mov.w	r0, #4294967295
    816c:	e029      	b.n	81c2 <tcp_enqueue_flags+0xbe>
		pcb->flags |= TF_NAGLEMEMERR;
    816e:	7fa3      	ldrb	r3, [r4, #30]
    8170:	f063 037f 	orn	r3, r3, #127	; 0x7f
    8174:	77a3      	strb	r3, [r4, #30]
		return ERR_MEM;
    8176:	f04f 30ff 	mov.w	r0, #4294967295
    817a:	e022      	b.n	81c2 <tcp_enqueue_flags+0xbe>
	} else {
		struct tcp_seg *useg;
		for (useg = pcb->unsent; useg->next != NULL; useg = useg->next)
    817c:	461a      	mov	r2, r3
    817e:	6813      	ldr	r3, [r2, #0]
    8180:	2b00      	cmp	r3, #0
    8182:	d1fb      	bne.n	817c <tcp_enqueue_flags+0x78>
			;
		useg->next = seg;
    8184:	6011      	str	r1, [r2, #0]
	}
#if TCP_OVERSIZE
	/* The new unsent tail has no space */
	pcb->unsent_oversize = 0;
    8186:	2300      	movs	r3, #0
    8188:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

	/* SYN and FIN bump the sequence number */
	if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    818c:	f015 0f03 	tst.w	r5, #3
    8190:	d007      	beq.n	81a2 <tcp_enqueue_flags+0x9e>
		pcb->snd_lbb++;
    8192:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    8194:	3301      	adds	r3, #1
    8196:	65e3      	str	r3, [r4, #92]	; 0x5c
		/* optlen does not influence snd_buf */
		pcb->snd_buf--;
    8198:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
    819c:	3b01      	subs	r3, #1
    819e:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
	}
	if (flags & TCP_FIN) {
    81a2:	f015 0f01 	tst.w	r5, #1
    81a6:	d003      	beq.n	81b0 <tcp_enqueue_flags+0xac>
		pcb->flags |= TF_FIN;
    81a8:	7fa3      	ldrb	r3, [r4, #30]
    81aa:	f043 0320 	orr.w	r3, r3, #32
    81ae:	77a3      	strb	r3, [r4, #30]
	}

	/* update number of segments on the queues */
	pcb->snd_queuelen += pbuf_clen(seg->p);
    81b0:	6848      	ldr	r0, [r1, #4]
    81b2:	4b08      	ldr	r3, [pc, #32]	; (81d4 <tcp_enqueue_flags+0xd0>)
    81b4:	4798      	blx	r3
    81b6:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    81ba:	4418      	add	r0, r3
    81bc:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
	LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %" S16_F " (after enqueued)\n", pcb->snd_queuelen));
	if (pcb->snd_queuelen != 0) {
		LWIP_ASSERT("tcp_enqueue_flags: invalid queue length", pcb->unacked != NULL || pcb->unsent != NULL);
	}

	return ERR_OK;
    81c0:	2000      	movs	r0, #0
}
    81c2:	b003      	add	sp, #12
    81c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_MEM;
    81c6:	f04f 30ff 	mov.w	r0, #4294967295
    81ca:	e7fa      	b.n	81c2 <tcp_enqueue_flags+0xbe>
    81cc:	00005d89 	.word	0x00005d89
    81d0:	00007fc1 	.word	0x00007fc1
    81d4:	00005f25 	.word	0x00005f25

000081d8 <tcp_send_fin>:
{
    81d8:	b570      	push	{r4, r5, r6, lr}
    81da:	4605      	mov	r5, r0
	if (pcb->unsent != NULL) {
    81dc:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
    81de:	b90c      	cbnz	r4, 81e4 <tcp_send_fin+0xc>
    81e0:	e00a      	b.n	81f8 <tcp_send_fin+0x20>
		for (last_unsent = pcb->unsent; last_unsent->next != NULL; last_unsent = last_unsent->next)
    81e2:	461c      	mov	r4, r3
    81e4:	6823      	ldr	r3, [r4, #0]
    81e6:	2b00      	cmp	r3, #0
    81e8:	d1fb      	bne.n	81e2 <tcp_send_fin+0xa>
		if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
    81ea:	6923      	ldr	r3, [r4, #16]
    81ec:	8998      	ldrh	r0, [r3, #12]
    81ee:	4b0b      	ldr	r3, [pc, #44]	; (821c <tcp_send_fin+0x44>)
    81f0:	4798      	blx	r3
    81f2:	f010 0f07 	tst.w	r0, #7
    81f6:	d004      	beq.n	8202 <tcp_send_fin+0x2a>
	return tcp_enqueue_flags(pcb, TCP_FIN);
    81f8:	2101      	movs	r1, #1
    81fa:	4628      	mov	r0, r5
    81fc:	4b08      	ldr	r3, [pc, #32]	; (8220 <tcp_send_fin+0x48>)
    81fe:	4798      	blx	r3
}
    8200:	bd70      	pop	{r4, r5, r6, pc}
			TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
    8202:	6926      	ldr	r6, [r4, #16]
    8204:	89b4      	ldrh	r4, [r6, #12]
    8206:	2001      	movs	r0, #1
    8208:	4b06      	ldr	r3, [pc, #24]	; (8224 <tcp_send_fin+0x4c>)
    820a:	4798      	blx	r3
    820c:	4320      	orrs	r0, r4
    820e:	81b0      	strh	r0, [r6, #12]
			pcb->flags |= TF_FIN;
    8210:	7fab      	ldrb	r3, [r5, #30]
    8212:	f043 0320 	orr.w	r3, r3, #32
    8216:	77ab      	strb	r3, [r5, #30]
			return ERR_OK;
    8218:	2000      	movs	r0, #0
    821a:	bd70      	pop	{r4, r5, r6, pc}
    821c:	00002f47 	.word	0x00002f47
    8220:	00008105 	.word	0x00008105
    8224:	00002f3d 	.word	0x00002f3d

00008228 <tcp_send_empty_ack>:
/** Send an ACK without data.
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t tcp_send_empty_ack(struct tcp_pcb *pcb)
{
    8228:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    822c:	b082      	sub	sp, #8
    822e:	4604      	mov	r4, r0
	if (pcb->flags & TF_TIMESTAMP) {
		optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
	}
#endif

	p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    8230:	6d00      	ldr	r0, [r0, #80]	; 0x50
    8232:	4b16      	ldr	r3, [pc, #88]	; (828c <tcp_send_empty_ack+0x64>)
    8234:	4798      	blx	r3
    8236:	4603      	mov	r3, r0
    8238:	2200      	movs	r2, #0
    823a:	4611      	mov	r1, r2
    823c:	4620      	mov	r0, r4
    823e:	4d14      	ldr	r5, [pc, #80]	; (8290 <tcp_send_empty_ack+0x68>)
    8240:	47a8      	blx	r5
	if (p == NULL) {
    8242:	b300      	cbz	r0, 8286 <tcp_send_empty_ack+0x5e>
    8244:	4605      	mov	r5, r0
		LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
		return ERR_BUF;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
    8246:	6847      	ldr	r7, [r0, #4]
	LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %" U32_F "\n", pcb->rcv_nxt));
	/* remove ACK flags from the PCB, as we send an empty ACK now */
	pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    8248:	7fa3      	ldrb	r3, [r4, #30]
    824a:	f023 0303 	bic.w	r3, r3, #3
    824e:	77a3      	strb	r3, [r4, #30]
		tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
	}
#endif

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, p->tot_len);
    8250:	1d26      	adds	r6, r4, #4
    8252:	8903      	ldrh	r3, [r0, #8]
    8254:	9300      	str	r3, [sp, #0]
    8256:	2306      	movs	r3, #6
    8258:	4632      	mov	r2, r6
    825a:	4621      	mov	r1, r4
    825c:	f8df 803c 	ldr.w	r8, [pc, #60]	; 829c <tcp_send_empty_ack+0x74>
    8260:	47c0      	blx	r8
    8262:	8238      	strh	r0, [r7, #16]
#endif
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    8264:	7aa3      	ldrb	r3, [r4, #10]
    8266:	2206      	movs	r2, #6
    8268:	9201      	str	r2, [sp, #4]
    826a:	7a62      	ldrb	r2, [r4, #9]
    826c:	9200      	str	r2, [sp, #0]
    826e:	4632      	mov	r2, r6
    8270:	4621      	mov	r1, r4
    8272:	4628      	mov	r0, r5
    8274:	4c07      	ldr	r4, [pc, #28]	; (8294 <tcp_send_empty_ack+0x6c>)
    8276:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/
	pbuf_free(p);
    8278:	4628      	mov	r0, r5
    827a:	4b07      	ldr	r3, [pc, #28]	; (8298 <tcp_send_empty_ack+0x70>)
    827c:	4798      	blx	r3

	return ERR_OK;
    827e:	2000      	movs	r0, #0
}
    8280:	b002      	add	sp, #8
    8282:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_BUF;
    8286:	f06f 0001 	mvn.w	r0, #1
    828a:	e7f9      	b.n	8280 <tcp_send_empty_ack+0x58>
    828c:	00002f51 	.word	0x00002f51
    8290:	00008091 	.word	0x00008091
    8294:	00004f51 	.word	0x00004f51
    8298:	00005d21 	.word	0x00005d21
    829c:	00004b29 	.word	0x00004b29

000082a0 <tcp_output>:

	/* First, check if we are invoked by the TCP input processing
	   code. If so, we do not output anything. Instead, we rely on the
	   input processing code to call us when input processing is done
	   with. */
	if (tcp_input_pcb == pcb) {
    82a0:	4ba7      	ldr	r3, [pc, #668]	; (8540 <tcp_output+0x2a0>)
    82a2:	681b      	ldr	r3, [r3, #0]
    82a4:	4283      	cmp	r3, r0
    82a6:	f000 8163 	beq.w	8570 <tcp_output+0x2d0>
{
    82aa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    82ae:	b085      	sub	sp, #20
    82b0:	4605      	mov	r5, r0
		return ERR_OK;
	}

	wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
    82b2:	f8b0 2060 	ldrh.w	r2, [r0, #96]	; 0x60
    82b6:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
    82ba:	429a      	cmp	r2, r3
    82bc:	bf28      	it	cs
    82be:	461a      	movcs	r2, r3
    82c0:	4692      	mov	sl, r2

	seg = pcb->unsent;
    82c2:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
	 * because the ->unsent queue is empty or because the window does
	 * not allow it), construct an empty ACK segment and send it.
	 *
	 * If data is to be sent, we will just piggyback the ACK (see below).
	 */
	if (pcb->flags & TF_ACK_NOW && (seg == NULL || ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    82c4:	7f83      	ldrb	r3, [r0, #30]
    82c6:	f013 0f02 	tst.w	r3, #2
    82ca:	d014      	beq.n	82f6 <tcp_output+0x56>
    82cc:	b17c      	cbz	r4, 82ee <tcp_output+0x4e>
    82ce:	6923      	ldr	r3, [r4, #16]
    82d0:	6858      	ldr	r0, [r3, #4]
    82d2:	4b9c      	ldr	r3, [pc, #624]	; (8544 <tcp_output+0x2a4>)
    82d4:	4798      	blx	r3
    82d6:	8923      	ldrh	r3, [r4, #8]
    82d8:	6caa      	ldr	r2, [r5, #72]	; 0x48
    82da:	1a9b      	subs	r3, r3, r2
    82dc:	4418      	add	r0, r3
    82de:	4582      	cmp	sl, r0
    82e0:	d305      	bcc.n	82ee <tcp_output+0x4e>
		return tcp_send_empty_ack(pcb);
	}

	/* useg should point to last segment on unacked queue */
	useg = pcb->unacked;
    82e2:	f8d5 8070 	ldr.w	r8, [r5, #112]	; 0x70
	if (useg != NULL) {
    82e6:	f1b8 0f00 	cmp.w	r8, #0
    82ea:	d10f      	bne.n	830c <tcp_output+0x6c>
    82ec:	e015      	b.n	831a <tcp_output+0x7a>
		return tcp_send_empty_ack(pcb);
    82ee:	4628      	mov	r0, r5
    82f0:	4b95      	ldr	r3, [pc, #596]	; (8548 <tcp_output+0x2a8>)
    82f2:	4798      	blx	r3
    82f4:	e120      	b.n	8538 <tcp_output+0x298>
	useg = pcb->unacked;
    82f6:	f8d0 8070 	ldr.w	r8, [r0, #112]	; 0x70
	if (useg != NULL) {
    82fa:	f1b8 0f00 	cmp.w	r8, #0
    82fe:	d105      	bne.n	830c <tcp_output+0x6c>
		             ntohl(seg->tcphdr->seqno),
		             pcb->lastack));
	}
#endif /* TCP_CWND_DEBUG */
	/* data available and window allows it to be sent? */
	while (seg != NULL && ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    8300:	b95c      	cbnz	r4, 831a <tcp_output+0x7a>
		seg = pcb->unsent;
	}
#if TCP_OVERSIZE
	if (pcb->unsent == NULL) {
		/* last unsent has been removed, reset unsent_oversize */
		pcb->unsent_oversize = 0;
    8302:	2300      	movs	r3, #0
    8304:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
    8308:	e111      	b.n	852e <tcp_output+0x28e>
		for (; useg->next != NULL; useg = useg->next)
    830a:	4698      	mov	r8, r3
    830c:	f8d8 3000 	ldr.w	r3, [r8]
    8310:	2b00      	cmp	r3, #0
    8312:	d1fa      	bne.n	830a <tcp_output+0x6a>
	while (seg != NULL && ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    8314:	2c00      	cmp	r4, #0
    8316:	f000 8106 	beq.w	8526 <tcp_output+0x286>
    831a:	4e8a      	ldr	r6, [pc, #552]	; (8544 <tcp_output+0x2a4>)
			TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
    831c:	f8df b248 	ldr.w	fp, [pc, #584]	; 8568 <tcp_output+0x2c8>
    8320:	e0a3      	b.n	846a <tcp_output+0x1ca>
		if ((tcp_do_output_nagle(pcb) == 0) && ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
    8322:	f8b5 2066 	ldrh.w	r2, [r5, #102]	; 0x66
    8326:	b13a      	cbz	r2, 8338 <tcp_output+0x98>
    8328:	f8b5 2068 	ldrh.w	r2, [r5, #104]	; 0x68
    832c:	2a07      	cmp	r2, #7
    832e:	d803      	bhi.n	8338 <tcp_output+0x98>
    8330:	f013 0fa0 	tst.w	r3, #160	; 0xa0
    8334:	f000 80f7 	beq.w	8526 <tcp_output+0x286>
		pcb->unsent = seg->next;
    8338:	6823      	ldr	r3, [r4, #0]
    833a:	66eb      	str	r3, [r5, #108]	; 0x6c
		if (pcb->state != SYN_SENT) {
    833c:	7e2b      	ldrb	r3, [r5, #24]
    833e:	2b02      	cmp	r3, #2
    8340:	d00c      	beq.n	835c <tcp_output+0xbc>
			TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
    8342:	f8d4 9010 	ldr.w	r9, [r4, #16]
    8346:	f8b9 700c 	ldrh.w	r7, [r9, #12]
    834a:	2010      	movs	r0, #16
    834c:	47d8      	blx	fp
    834e:	4338      	orrs	r0, r7
    8350:	f8a9 000c 	strh.w	r0, [r9, #12]
			pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    8354:	7fab      	ldrb	r3, [r5, #30]
    8356:	f023 0303 	bic.w	r3, r3, #3
    835a:	77ab      	strb	r3, [r5, #30]
	/** @bug Exclude retransmitted segments from this count. */
	snmp_inc_tcpoutsegs();

	/* The TCP header has already been constructed, but the ackno and
	 wnd fields remain. */
	seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
    835c:	6927      	ldr	r7, [r4, #16]
    835e:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    8360:	4b7a      	ldr	r3, [pc, #488]	; (854c <tcp_output+0x2ac>)
    8362:	4798      	blx	r3
    8364:	60b8      	str	r0, [r7, #8]

	/* advertise our receive window size in this TCP segment */
	seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    8366:	6927      	ldr	r7, [r4, #16]
    8368:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
    836a:	47d8      	blx	fp
    836c:	81f8      	strh	r0, [r7, #14]

	pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    836e:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
    8370:	6aab      	ldr	r3, [r5, #40]	; 0x28
    8372:	4413      	add	r3, r2
    8374:	632b      	str	r3, [r5, #48]	; 0x30

	/* Add any requested options.  NB MSS option is only set on SYN
	   packets, so ignore it here */
	opts = (u32_t *)(void *)(seg->tcphdr + 1);
	if (seg->flags & TF_SEG_OPTS_MSS) {
    8376:	7b23      	ldrb	r3, [r4, #12]
    8378:	f013 0f01 	tst.w	r3, #1
    837c:	f040 8095 	bne.w	84aa <tcp_output+0x20a>
	}
#endif

	/* Set retransmission timer running if it is not currently enabled
	   This must be set before checking the route. */
	if (pcb->rtime == -1) {
    8380:	f9b5 3034 	ldrsh.w	r3, [r5, #52]	; 0x34
    8384:	f1b3 3fff 	cmp.w	r3, #4294967295
		pcb->rtime = 0;
    8388:	bf04      	itt	eq
    838a:	2300      	moveq	r3, #0
    838c:	86ab      	strheq	r3, [r5, #52]	; 0x34
	}

	/* If we don't have a local IP address, we get one by
	   calling ip_route(). */
	if (ip_addr_isany(&(pcb->local_ip))) {
    838e:	b10d      	cbz	r5, 8394 <tcp_output+0xf4>
    8390:	682b      	ldr	r3, [r5, #0]
    8392:	b933      	cbnz	r3, 83a2 <tcp_output+0x102>
		netif = ip_route(&(pcb->remote_ip));
    8394:	1d28      	adds	r0, r5, #4
    8396:	4b6e      	ldr	r3, [pc, #440]	; (8550 <tcp_output+0x2b0>)
    8398:	4798      	blx	r3
		if (netif == NULL) {
    839a:	2800      	cmp	r0, #0
    839c:	d02e      	beq.n	83fc <tcp_output+0x15c>
			return;
		}
		ip_addr_copy(pcb->local_ip, netif->ip_addr);
    839e:	6843      	ldr	r3, [r0, #4]
    83a0:	602b      	str	r3, [r5, #0]
	}

	if (pcb->rttest == 0) {
    83a2:	6bab      	ldr	r3, [r5, #56]	; 0x38
    83a4:	2b00      	cmp	r3, #0
    83a6:	f000 808c 	beq.w	84c2 <tcp_output+0x222>
	LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
	            ("tcp_output_segment: %" U32_F ":%" U32_F "\n",
	             htonl(seg->tcphdr->seqno),
	             htonl(seg->tcphdr->seqno) + seg->len));

	len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
    83aa:	6862      	ldr	r2, [r4, #4]
    83ac:	6923      	ldr	r3, [r4, #16]
    83ae:	6851      	ldr	r1, [r2, #4]
    83b0:	1a5b      	subs	r3, r3, r1
    83b2:	b29b      	uxth	r3, r3

	seg->p->len -= len;
    83b4:	8951      	ldrh	r1, [r2, #10]
    83b6:	1ac9      	subs	r1, r1, r3
    83b8:	8151      	strh	r1, [r2, #10]
	seg->p->tot_len -= len;
    83ba:	6861      	ldr	r1, [r4, #4]
    83bc:	890a      	ldrh	r2, [r1, #8]
    83be:	1ad3      	subs	r3, r2, r3
    83c0:	810b      	strh	r3, [r1, #8]

	seg->p->payload = seg->tcphdr;
    83c2:	6863      	ldr	r3, [r4, #4]
    83c4:	6922      	ldr	r2, [r4, #16]
    83c6:	605a      	str	r2, [r3, #4]

	seg->tcphdr->chksum = 0;
    83c8:	6923      	ldr	r3, [r4, #16]
    83ca:	2200      	movs	r2, #0
    83cc:	741a      	strb	r2, [r3, #16]
    83ce:	745a      	strb	r2, [r3, #17]
			seg->tcphdr->chksum = chksum_slow;
		}
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
	}
#else  /* TCP_CHECKSUM_ON_COPY */
	seg->tcphdr->chksum
    83d0:	6927      	ldr	r7, [r4, #16]
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    83d2:	6860      	ldr	r0, [r4, #4]
    83d4:	1d2a      	adds	r2, r5, #4
    83d6:	8903      	ldrh	r3, [r0, #8]
    83d8:	9300      	str	r3, [sp, #0]
    83da:	2306      	movs	r3, #6
    83dc:	9203      	str	r2, [sp, #12]
    83de:	4629      	mov	r1, r5
    83e0:	f8df 9188 	ldr.w	r9, [pc, #392]	; 856c <tcp_output+0x2cc>
    83e4:	47c8      	blx	r9
    83e6:	8238      	strh	r0, [r7, #16]
	TCP_STATS_INC(tcp.xmit);

#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    83e8:	7aab      	ldrb	r3, [r5, #10]
    83ea:	6860      	ldr	r0, [r4, #4]
    83ec:	2206      	movs	r2, #6
    83ee:	9201      	str	r2, [sp, #4]
    83f0:	7a6a      	ldrb	r2, [r5, #9]
    83f2:	9200      	str	r2, [sp, #0]
    83f4:	9a03      	ldr	r2, [sp, #12]
    83f6:	4629      	mov	r1, r5
    83f8:	4f56      	ldr	r7, [pc, #344]	; (8554 <tcp_output+0x2b4>)
    83fa:	47b8      	blx	r7
		snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    83fc:	6923      	ldr	r3, [r4, #16]
    83fe:	6858      	ldr	r0, [r3, #4]
    8400:	47b0      	blx	r6
    8402:	4607      	mov	r7, r0
    8404:	f8b4 9008 	ldrh.w	r9, [r4, #8]
    8408:	6923      	ldr	r3, [r4, #16]
    840a:	8998      	ldrh	r0, [r3, #12]
    840c:	4b52      	ldr	r3, [pc, #328]	; (8558 <tcp_output+0x2b8>)
    840e:	4798      	blx	r3
    8410:	f010 0003 	ands.w	r0, r0, #3
    8414:	bf18      	it	ne
    8416:	2001      	movne	r0, #1
    8418:	4448      	add	r0, r9
    841a:	4407      	add	r7, r0
		if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
    841c:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    841e:	1bdb      	subs	r3, r3, r7
    8420:	2b00      	cmp	r3, #0
			pcb->snd_nxt = snd_nxt;
    8422:	bfb8      	it	lt
    8424:	652f      	strlt	r7, [r5, #80]	; 0x50
		if (TCP_TCPLEN(seg) > 0) {
    8426:	8927      	ldrh	r7, [r4, #8]
    8428:	6923      	ldr	r3, [r4, #16]
    842a:	8998      	ldrh	r0, [r3, #12]
    842c:	4b4a      	ldr	r3, [pc, #296]	; (8558 <tcp_output+0x2b8>)
    842e:	4798      	blx	r3
    8430:	f010 0003 	ands.w	r0, r0, #3
    8434:	bf18      	it	ne
    8436:	2001      	movne	r0, #1
    8438:	42f8      	cmn	r0, r7
    843a:	d070      	beq.n	851e <tcp_output+0x27e>
			seg->next = NULL;
    843c:	2300      	movs	r3, #0
    843e:	6023      	str	r3, [r4, #0]
			if (pcb->unacked == NULL) {
    8440:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    8442:	2b00      	cmp	r3, #0
    8444:	d045      	beq.n	84d2 <tcp_output+0x232>
				if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
    8446:	6923      	ldr	r3, [r4, #16]
    8448:	6858      	ldr	r0, [r3, #4]
    844a:	47b0      	blx	r6
    844c:	4607      	mov	r7, r0
    844e:	f8d8 3010 	ldr.w	r3, [r8, #16]
    8452:	6858      	ldr	r0, [r3, #4]
    8454:	47b0      	blx	r6
    8456:	1a38      	subs	r0, r7, r0
    8458:	2800      	cmp	r0, #0
    845a:	db3d      	blt.n	84d8 <tcp_output+0x238>
					useg->next = seg;
    845c:	f8c8 4000 	str.w	r4, [r8]
    8460:	46a0      	mov	r8, r4
		seg = pcb->unsent;
    8462:	6eec      	ldr	r4, [r5, #108]	; 0x6c
	while (seg != NULL && ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    8464:	2c00      	cmp	r4, #0
    8466:	f43f af4c 	beq.w	8302 <tcp_output+0x62>
    846a:	6923      	ldr	r3, [r4, #16]
    846c:	6858      	ldr	r0, [r3, #4]
    846e:	47b0      	blx	r6
    8470:	6cab      	ldr	r3, [r5, #72]	; 0x48
    8472:	1ac0      	subs	r0, r0, r3
    8474:	8923      	ldrh	r3, [r4, #8]
    8476:	4418      	add	r0, r3
    8478:	4582      	cmp	sl, r0
    847a:	d354      	bcc.n	8526 <tcp_output+0x286>
		if ((tcp_do_output_nagle(pcb) == 0) && ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
    847c:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    847e:	2b00      	cmp	r3, #0
    8480:	f43f af5a 	beq.w	8338 <tcp_output+0x98>
    8484:	7fab      	ldrb	r3, [r5, #30]
    8486:	f013 0f44 	tst.w	r3, #68	; 0x44
    848a:	f47f af55 	bne.w	8338 <tcp_output+0x98>
    848e:	6eea      	ldr	r2, [r5, #108]	; 0x6c
    8490:	2a00      	cmp	r2, #0
    8492:	f43f af46 	beq.w	8322 <tcp_output+0x82>
    8496:	6811      	ldr	r1, [r2, #0]
    8498:	2900      	cmp	r1, #0
    849a:	f47f af4d 	bne.w	8338 <tcp_output+0x98>
    849e:	8911      	ldrh	r1, [r2, #8]
    84a0:	8eea      	ldrh	r2, [r5, #54]	; 0x36
    84a2:	4291      	cmp	r1, r2
    84a4:	f4bf af48 	bcs.w	8338 <tcp_output+0x98>
    84a8:	e73b      	b.n	8322 <tcp_output+0x82>
	opts = (u32_t *)(void *)(seg->tcphdr + 1);
    84aa:	6927      	ldr	r7, [r4, #16]
		mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    84ac:	1d29      	adds	r1, r5, #4
    84ae:	f240 50b4 	movw	r0, #1460	; 0x5b4
    84b2:	4b2a      	ldr	r3, [pc, #168]	; (855c <tcp_output+0x2bc>)
    84b4:	4798      	blx	r3
		*opts = TCP_BUILD_MSS_OPTION(mss);
    84b6:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
    84ba:	4b24      	ldr	r3, [pc, #144]	; (854c <tcp_output+0x2ac>)
    84bc:	4798      	blx	r3
    84be:	6178      	str	r0, [r7, #20]
    84c0:	e75e      	b.n	8380 <tcp_output+0xe0>
		pcb->rttest = tcp_ticks;
    84c2:	4b27      	ldr	r3, [pc, #156]	; (8560 <tcp_output+0x2c0>)
    84c4:	681b      	ldr	r3, [r3, #0]
    84c6:	63ab      	str	r3, [r5, #56]	; 0x38
		pcb->rtseq  = ntohl(seg->tcphdr->seqno);
    84c8:	6923      	ldr	r3, [r4, #16]
    84ca:	6858      	ldr	r0, [r3, #4]
    84cc:	47b0      	blx	r6
    84ce:	63e8      	str	r0, [r5, #60]	; 0x3c
    84d0:	e76b      	b.n	83aa <tcp_output+0x10a>
				pcb->unacked = seg;
    84d2:	672c      	str	r4, [r5, #112]	; 0x70
    84d4:	46a0      	mov	r8, r4
    84d6:	e7c4      	b.n	8462 <tcp_output+0x1c2>
					struct tcp_seg **cur_seg = &(pcb->unacked);
    84d8:	f105 0970 	add.w	r9, r5, #112	; 0x70
					while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    84dc:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    84de:	b1c3      	cbz	r3, 8512 <tcp_output+0x272>
    84e0:	4622      	mov	r2, r4
    84e2:	464c      	mov	r4, r9
    84e4:	4691      	mov	r9, r2
    84e6:	691b      	ldr	r3, [r3, #16]
    84e8:	6858      	ldr	r0, [r3, #4]
    84ea:	47b0      	blx	r6
    84ec:	4607      	mov	r7, r0
    84ee:	f8d9 3010 	ldr.w	r3, [r9, #16]
    84f2:	6858      	ldr	r0, [r3, #4]
    84f4:	47b0      	blx	r6
    84f6:	1a38      	subs	r0, r7, r0
    84f8:	2800      	cmp	r0, #0
    84fa:	da07      	bge.n	850c <tcp_output+0x26c>
						cur_seg = &((*cur_seg)->next);
    84fc:	6824      	ldr	r4, [r4, #0]
					while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    84fe:	6823      	ldr	r3, [r4, #0]
    8500:	2b00      	cmp	r3, #0
    8502:	d1f0      	bne.n	84e6 <tcp_output+0x246>
    8504:	464b      	mov	r3, r9
    8506:	46a1      	mov	r9, r4
    8508:	461c      	mov	r4, r3
    850a:	e002      	b.n	8512 <tcp_output+0x272>
    850c:	464b      	mov	r3, r9
    850e:	46a1      	mov	r9, r4
    8510:	461c      	mov	r4, r3
					seg->next  = (*cur_seg);
    8512:	f8d9 3000 	ldr.w	r3, [r9]
    8516:	6023      	str	r3, [r4, #0]
					(*cur_seg) = seg;
    8518:	f8c9 4000 	str.w	r4, [r9]
    851c:	e7a1      	b.n	8462 <tcp_output+0x1c2>
			tcp_seg_free(seg);
    851e:	4620      	mov	r0, r4
    8520:	4b10      	ldr	r3, [pc, #64]	; (8564 <tcp_output+0x2c4>)
    8522:	4798      	blx	r3
    8524:	e79d      	b.n	8462 <tcp_output+0x1c2>
	if (pcb->unsent == NULL) {
    8526:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
    8528:	2b00      	cmp	r3, #0
    852a:	f43f aeea 	beq.w	8302 <tcp_output+0x62>
	pcb->flags &= ~TF_NAGLEMEMERR;
    852e:	7fab      	ldrb	r3, [r5, #30]
    8530:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    8534:	77ab      	strb	r3, [r5, #30]
	return ERR_OK;
    8536:	2000      	movs	r0, #0
}
    8538:	b005      	add	sp, #20
    853a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    853e:	bf00      	nop
    8540:	20009318 	.word	0x20009318
    8544:	00002f69 	.word	0x00002f69
    8548:	00008229 	.word	0x00008229
    854c:	00002f51 	.word	0x00002f51
    8550:	00004c25 	.word	0x00004c25
    8554:	00004f51 	.word	0x00004f51
    8558:	00002f47 	.word	0x00002f47
    855c:	00006c05 	.word	0x00006c05
    8560:	20009304 	.word	0x20009304
    8564:	00006241 	.word	0x00006241
    8568:	00002f3d 	.word	0x00002f3d
    856c:	00004b29 	.word	0x00004b29
		return ERR_OK;
    8570:	2000      	movs	r0, #0
    8572:	4770      	bx	lr

00008574 <tcp_rst>:
 * @param remote_ip the remote IP address to send the segment to
 * @param local_port the local TCP port to send the segment from
 * @param remote_port the remote TCP port to send the segment to
 */
void tcp_rst(u32_t seqno, u32_t ackno, ip_addr_t *local_ip, ip_addr_t *remote_ip, u16_t local_port, u16_t remote_port)
{
    8574:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8578:	b083      	sub	sp, #12
    857a:	4681      	mov	r9, r0
    857c:	468a      	mov	sl, r1
    857e:	4693      	mov	fp, r2
    8580:	4698      	mov	r8, r3
	struct pbuf *   p;
	struct tcp_hdr *tcphdr;
	p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    8582:	2200      	movs	r2, #0
    8584:	2114      	movs	r1, #20
    8586:	2001      	movs	r0, #1
    8588:	4b1d      	ldr	r3, [pc, #116]	; (8600 <tcp_rst+0x8c>)
    858a:	4798      	blx	r3
	if (p == NULL) {
    858c:	2800      	cmp	r0, #0
    858e:	d034      	beq.n	85fa <tcp_rst+0x86>
    8590:	4605      	mov	r5, r0
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
		return;
	}
	LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr", (p->len >= sizeof(struct tcp_hdr)));

	tcphdr        = (struct tcp_hdr *)p->payload;
    8592:	6844      	ldr	r4, [r0, #4]
	tcphdr->src   = htons(local_port);
    8594:	f8bd 0030 	ldrh.w	r0, [sp, #48]	; 0x30
    8598:	4e1a      	ldr	r6, [pc, #104]	; (8604 <tcp_rst+0x90>)
    859a:	47b0      	blx	r6
    859c:	8020      	strh	r0, [r4, #0]
	tcphdr->dest  = htons(remote_port);
    859e:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
    85a2:	47b0      	blx	r6
    85a4:	8060      	strh	r0, [r4, #2]
	tcphdr->seqno = htonl(seqno);
    85a6:	4648      	mov	r0, r9
    85a8:	4f17      	ldr	r7, [pc, #92]	; (8608 <tcp_rst+0x94>)
    85aa:	47b8      	blx	r7
    85ac:	6060      	str	r0, [r4, #4]
	tcphdr->ackno = htonl(ackno);
    85ae:	4650      	mov	r0, sl
    85b0:	47b8      	blx	r7
    85b2:	60a0      	str	r0, [r4, #8]
	TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN / 4, TCP_RST | TCP_ACK);
    85b4:	f245 0014 	movw	r0, #20500	; 0x5014
    85b8:	47b0      	blx	r6
    85ba:	81a0      	strh	r0, [r4, #12]
	tcphdr->wnd    = PP_HTONS(TCP_WND);
    85bc:	2600      	movs	r6, #0
    85be:	2316      	movs	r3, #22
    85c0:	73a3      	strb	r3, [r4, #14]
    85c2:	f06f 032f 	mvn.w	r3, #47	; 0x2f
    85c6:	73e3      	strb	r3, [r4, #15]
	tcphdr->chksum = 0;
    85c8:	7426      	strb	r6, [r4, #16]
    85ca:	7466      	strb	r6, [r4, #17]
	tcphdr->urgp   = 0;
    85cc:	74a6      	strb	r6, [r4, #18]
    85ce:	74e6      	strb	r6, [r4, #19]

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip, IP_PROTO_TCP, p->tot_len);
    85d0:	892b      	ldrh	r3, [r5, #8]
    85d2:	9300      	str	r3, [sp, #0]
    85d4:	2306      	movs	r3, #6
    85d6:	4642      	mov	r2, r8
    85d8:	4659      	mov	r1, fp
    85da:	4628      	mov	r0, r5
    85dc:	4f0b      	ldr	r7, [pc, #44]	; (860c <tcp_rst+0x98>)
    85de:	47b8      	blx	r7
    85e0:	8220      	strh	r0, [r4, #16]
#endif
	TCP_STATS_INC(tcp.xmit);
	snmp_inc_tcpoutrsts();
	/* Send output with hardcoded TTL since we have no access to the pcb */
	ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
    85e2:	2306      	movs	r3, #6
    85e4:	9301      	str	r3, [sp, #4]
    85e6:	9600      	str	r6, [sp, #0]
    85e8:	23ff      	movs	r3, #255	; 0xff
    85ea:	4642      	mov	r2, r8
    85ec:	4659      	mov	r1, fp
    85ee:	4628      	mov	r0, r5
    85f0:	4c07      	ldr	r4, [pc, #28]	; (8610 <tcp_rst+0x9c>)
    85f2:	47a0      	blx	r4
	pbuf_free(p);
    85f4:	4628      	mov	r0, r5
    85f6:	4b07      	ldr	r3, [pc, #28]	; (8614 <tcp_rst+0xa0>)
    85f8:	4798      	blx	r3
	LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %" U32_F " ackno %" U32_F ".\n", seqno, ackno));
}
    85fa:	b003      	add	sp, #12
    85fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8600:	00005d89 	.word	0x00005d89
    8604:	00002f3d 	.word	0x00002f3d
    8608:	00002f51 	.word	0x00002f51
    860c:	00004b29 	.word	0x00004b29
    8610:	00004f51 	.word	0x00004f51
    8614:	00005d21 	.word	0x00005d21

00008618 <tcp_rexmit_rto>:
 */
void tcp_rexmit_rto(struct tcp_pcb *pcb)
{
	struct tcp_seg *seg;

	if (pcb->unacked == NULL) {
    8618:	6f02      	ldr	r2, [r0, #112]	; 0x70
    861a:	b10a      	cbz	r2, 8620 <tcp_rexmit_rto+0x8>
{
    861c:	b508      	push	{r3, lr}
    861e:	e001      	b.n	8624 <tcp_rexmit_rto+0xc>
    8620:	4770      	bx	lr
		return;
	}

	/* Move all unacked segments to the head of the unsent queue */
	for (seg = pcb->unacked; seg->next != NULL; seg = seg->next)
    8622:	461a      	mov	r2, r3
    8624:	6813      	ldr	r3, [r2, #0]
    8626:	2b00      	cmp	r3, #0
    8628:	d1fb      	bne.n	8622 <tcp_rexmit_rto+0xa>
		;
	/* concatenate unsent queue after unacked queue */
	seg->next = pcb->unsent;
    862a:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    862c:	6013      	str	r3, [r2, #0]
	/* unsent queue is the concatenated queue (of unacked, unsent) */
	pcb->unsent = pcb->unacked;
    862e:	6f03      	ldr	r3, [r0, #112]	; 0x70
    8630:	66c3      	str	r3, [r0, #108]	; 0x6c
	/* unacked queue is now empty */
	pcb->unacked = NULL;
    8632:	2200      	movs	r2, #0
    8634:	6702      	str	r2, [r0, #112]	; 0x70
	/* last unsent hasn't changed, no need to reset unsent_oversize */

	/* increment number of retransmissions */
	++pcb->nrtx;
    8636:	f890 3046 	ldrb.w	r3, [r0, #70]	; 0x46
    863a:	3301      	adds	r3, #1
    863c:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46

	/* Don't take any RTT measurements after retransmitting. */
	pcb->rttest = 0;
    8640:	6382      	str	r2, [r0, #56]	; 0x38

	/* Do the actual retransmission */
	tcp_output(pcb);
    8642:	4b01      	ldr	r3, [pc, #4]	; (8648 <tcp_rexmit_rto+0x30>)
    8644:	4798      	blx	r3
    8646:	bd08      	pop	{r3, pc}
    8648:	000082a1 	.word	0x000082a1

0000864c <tcp_rexmit>:
 * Called by tcp_receive() for fast retramsmit.
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void tcp_rexmit(struct tcp_pcb *pcb)
{
    864c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct tcp_seg * seg;
	struct tcp_seg **cur_seg;

	if (pcb->unacked == NULL) {
    8650:	6f07      	ldr	r7, [r0, #112]	; 0x70
    8652:	b317      	cbz	r7, 869a <tcp_rexmit+0x4e>
    8654:	4680      	mov	r8, r0
	}

	/* Move the first unacked segment to the unsent queue */
	/* Keep the unsent queue sorted. */
	seg          = pcb->unacked;
	pcb->unacked = seg->next;
    8656:	683b      	ldr	r3, [r7, #0]
    8658:	6703      	str	r3, [r0, #112]	; 0x70

	cur_seg = &(pcb->unsent);
    865a:	f100 056c 	add.w	r5, r0, #108	; 0x6c
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    865e:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    8660:	b173      	cbz	r3, 8680 <tcp_rexmit+0x34>
    8662:	4e10      	ldr	r6, [pc, #64]	; (86a4 <tcp_rexmit+0x58>)
    8664:	691b      	ldr	r3, [r3, #16]
    8666:	6858      	ldr	r0, [r3, #4]
    8668:	47b0      	blx	r6
    866a:	4604      	mov	r4, r0
    866c:	693b      	ldr	r3, [r7, #16]
    866e:	6858      	ldr	r0, [r3, #4]
    8670:	47b0      	blx	r6
    8672:	1a20      	subs	r0, r4, r0
    8674:	2800      	cmp	r0, #0
    8676:	da03      	bge.n	8680 <tcp_rexmit+0x34>
		cur_seg = &((*cur_seg)->next);
    8678:	682d      	ldr	r5, [r5, #0]
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    867a:	682b      	ldr	r3, [r5, #0]
    867c:	2b00      	cmp	r3, #0
    867e:	d1f1      	bne.n	8664 <tcp_rexmit+0x18>
	}
	seg->next = *cur_seg;
    8680:	682b      	ldr	r3, [r5, #0]
    8682:	603b      	str	r3, [r7, #0]
	*cur_seg  = seg;
    8684:	602f      	str	r7, [r5, #0]
#if TCP_OVERSIZE
	if (seg->next == NULL) {
    8686:	683b      	ldr	r3, [r7, #0]
    8688:	b14b      	cbz	r3, 869e <tcp_rexmit+0x52>
		/* the retransmitted segment is last in unsent, so reset unsent_oversize */
		pcb->unsent_oversize = 0;
	}
#endif /* TCP_OVERSIZE */

	++pcb->nrtx;
    868a:	f898 3046 	ldrb.w	r3, [r8, #70]	; 0x46
    868e:	3301      	adds	r3, #1
    8690:	f888 3046 	strb.w	r3, [r8, #70]	; 0x46

	/* Don't take any rtt measurements after retransmitting. */
	pcb->rttest = 0;
    8694:	2300      	movs	r3, #0
    8696:	f8c8 3038 	str.w	r3, [r8, #56]	; 0x38
    869a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		pcb->unsent_oversize = 0;
    869e:	f8a8 306a 	strh.w	r3, [r8, #106]	; 0x6a
    86a2:	e7f2      	b.n	868a <tcp_rexmit+0x3e>
    86a4:	00002f69 	.word	0x00002f69

000086a8 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void tcp_rexmit_fast(struct tcp_pcb *pcb)
{
	if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    86a8:	6f03      	ldr	r3, [r0, #112]	; 0x70
    86aa:	b11b      	cbz	r3, 86b4 <tcp_rexmit_fast+0xc>
    86ac:	7f83      	ldrb	r3, [r0, #30]
    86ae:	f013 0f04 	tst.w	r3, #4
    86b2:	d000      	beq.n	86b6 <tcp_rexmit_fast+0xe>
    86b4:	4770      	bx	lr
{
    86b6:	b510      	push	{r4, lr}
    86b8:	4604      	mov	r4, r0
		LWIP_DEBUGF(TCP_FR_DEBUG,
		            ("tcp_receive: dupacks %" U16_F " (%" U32_F "), fast retransmit %" U32_F "\n",
		             (u16_t)pcb->dupacks,
		             pcb->lastack,
		             ntohl(pcb->unacked->tcphdr->seqno)));
		tcp_rexmit(pcb);
    86ba:	4b11      	ldr	r3, [pc, #68]	; (8700 <tcp_rexmit_fast+0x58>)
    86bc:	4798      	blx	r3

		/* Set ssthresh to half of the minimum of the current
		 * cwnd and the advertised window */
		if (pcb->cwnd > pcb->snd_wnd) {
    86be:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
    86c2:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
    86c6:	4293      	cmp	r3, r2
			pcb->ssthresh = pcb->snd_wnd / 2;
    86c8:	bf87      	ittee	hi
    86ca:	0852      	lsrhi	r2, r2, #1
    86cc:	f8a4 204e 	strhhi.w	r2, [r4, #78]	; 0x4e
		} else {
			pcb->ssthresh = pcb->cwnd / 2;
    86d0:	085b      	lsrls	r3, r3, #1
    86d2:	f8a4 304e 	strhls.w	r3, [r4, #78]	; 0x4e
		}

		/* The minimum value for ssthresh should be 2 MSS */
		if (pcb->ssthresh < 2 * pcb->mss) {
    86d6:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    86d8:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
    86dc:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
			LWIP_DEBUGF(TCP_FR_DEBUG,
			            ("tcp_receive: The minimum value for ssthresh %" U16_F " should be min 2 mss %" U16_F "...\n",
			             pcb->ssthresh,
			             2 * pcb->mss));
			pcb->ssthresh = 2 * pcb->mss;
    86e0:	bfbc      	itt	lt
    86e2:	005a      	lsllt	r2, r3, #1
    86e4:	f8a4 204e 	strhlt.w	r2, [r4, #78]	; 0x4e
		}

		pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    86e8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    86ec:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
    86f0:	4413      	add	r3, r2
    86f2:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		pcb->flags |= TF_INFR;
    86f6:	7fa3      	ldrb	r3, [r4, #30]
    86f8:	f043 0304 	orr.w	r3, r3, #4
    86fc:	77a3      	strb	r3, [r4, #30]
    86fe:	bd10      	pop	{r4, pc}
    8700:	0000864d 	.word	0x0000864d

00008704 <tcp_keepalive>:
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void tcp_keepalive(struct tcp_pcb *pcb)
{
    8704:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8708:	b082      	sub	sp, #8
    870a:	4604      	mov	r4, r0
	            ("tcp_keepalive: tcp_ticks %" U32_F "   pcb->tmr %" U32_F " pcb->keep_cnt_sent %" U16_F "\n",
	             tcp_ticks,
	             pcb->tmr,
	             pcb->keep_cnt_sent));

	p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    870c:	6d00      	ldr	r0, [r0, #80]	; 0x50
    870e:	3801      	subs	r0, #1
    8710:	4b12      	ldr	r3, [pc, #72]	; (875c <tcp_keepalive+0x58>)
    8712:	4798      	blx	r3
    8714:	4603      	mov	r3, r0
    8716:	2200      	movs	r2, #0
    8718:	4611      	mov	r1, r2
    871a:	4620      	mov	r0, r4
    871c:	4d10      	ldr	r5, [pc, #64]	; (8760 <tcp_keepalive+0x5c>)
    871e:	47a8      	blx	r5
	if (p == NULL) {
    8720:	b1c0      	cbz	r0, 8754 <tcp_keepalive+0x50>
    8722:	4605      	mov	r5, r0
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: could not allocate memory for pbuf\n"));
		return;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
    8724:	6847      	ldr	r7, [r0, #4]

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    8726:	1d26      	adds	r6, r4, #4
    8728:	8903      	ldrh	r3, [r0, #8]
    872a:	9300      	str	r3, [sp, #0]
    872c:	2306      	movs	r3, #6
    872e:	4632      	mov	r2, r6
    8730:	4621      	mov	r1, r4
    8732:	f8df 8038 	ldr.w	r8, [pc, #56]	; 876c <tcp_keepalive+0x68>
    8736:	47c0      	blx	r8
    8738:	8238      	strh	r0, [r7, #16]

	/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    873a:	7aa3      	ldrb	r3, [r4, #10]
    873c:	2206      	movs	r2, #6
    873e:	9201      	str	r2, [sp, #4]
    8740:	2200      	movs	r2, #0
    8742:	9200      	str	r2, [sp, #0]
    8744:	4632      	mov	r2, r6
    8746:	4621      	mov	r1, r4
    8748:	4628      	mov	r0, r5
    874a:	4c06      	ldr	r4, [pc, #24]	; (8764 <tcp_keepalive+0x60>)
    874c:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

	pbuf_free(p);
    874e:	4628      	mov	r0, r5
    8750:	4b05      	ldr	r3, [pc, #20]	; (8768 <tcp_keepalive+0x64>)
    8752:	4798      	blx	r3

	LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %" U32_F " ackno %" U32_F ".\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    8754:	b002      	add	sp, #8
    8756:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    875a:	bf00      	nop
    875c:	00002f51 	.word	0x00002f51
    8760:	00008091 	.word	0x00008091
    8764:	00004f51 	.word	0x00004f51
    8768:	00005d21 	.word	0x00005d21
    876c:	00004b29 	.word	0x00004b29

00008770 <tcp_zero_window_probe>:
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void tcp_zero_window_probe(struct tcp_pcb *pcb)
{
    8770:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8774:	b082      	sub	sp, #8
	            ("tcp_zero_window_probe: tcp_ticks %" U32_F "   pcb->tmr %" U32_F " pcb->keep_cnt_sent %" U16_F "\n",
	             tcp_ticks,
	             pcb->tmr,
	             pcb->keep_cnt_sent));

	seg = pcb->unacked;
    8776:	6f05      	ldr	r5, [r0, #112]	; 0x70

	if (seg == NULL) {
    8778:	b1fd      	cbz	r5, 87ba <tcp_zero_window_probe+0x4a>
    877a:	4604      	mov	r4, r0
	}
	if (seg == NULL) {
		return;
	}

	is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    877c:	692b      	ldr	r3, [r5, #16]
    877e:	8998      	ldrh	r0, [r3, #12]
    8780:	4b26      	ldr	r3, [pc, #152]	; (881c <tcp_zero_window_probe+0xac>)
    8782:	4798      	blx	r3
    8784:	f010 0f01 	tst.w	r0, #1
    8788:	d001      	beq.n	878e <tcp_zero_window_probe+0x1e>
    878a:	892b      	ldrh	r3, [r5, #8]
    878c:	b1c3      	cbz	r3, 87c0 <tcp_zero_window_probe+0x50>
	/* we want to send one seqno: either FIN or data (no options) */
	len = is_fin ? 0 : 1;

	p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    878e:	692b      	ldr	r3, [r5, #16]
    8790:	685b      	ldr	r3, [r3, #4]
    8792:	2201      	movs	r2, #1
    8794:	2100      	movs	r1, #0
    8796:	4620      	mov	r0, r4
    8798:	4e21      	ldr	r6, [pc, #132]	; (8820 <tcp_zero_window_probe+0xb0>)
    879a:	47b0      	blx	r6
	if (p == NULL) {
    879c:	4606      	mov	r6, r0
    879e:	2800      	cmp	r0, #0
    87a0:	d039      	beq.n	8816 <tcp_zero_window_probe+0xa6>
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
		return;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
    87a2:	6877      	ldr	r7, [r6, #4]
		/* Data segment, copy in one byte from the head of the unacked queue */
		char *d = ((char *)p->payload + TCP_HLEN);
		/* Depending on whether the segment has already been sent (unacked) or not
		   (unsent), seg->p->payload points to the IP header or TCP header.
		   Ensure we copy the first TCP data byte: */
		pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
    87a4:	6868      	ldr	r0, [r5, #4]
    87a6:	8903      	ldrh	r3, [r0, #8]
    87a8:	892a      	ldrh	r2, [r5, #8]
    87aa:	1a9b      	subs	r3, r3, r2
    87ac:	b29b      	uxth	r3, r3
    87ae:	2201      	movs	r2, #1
    87b0:	f107 0114 	add.w	r1, r7, #20
    87b4:	4d1b      	ldr	r5, [pc, #108]	; (8824 <tcp_zero_window_probe+0xb4>)
    87b6:	47a8      	blx	r5
    87b8:	e015      	b.n	87e6 <tcp_zero_window_probe+0x76>
		seg = pcb->unsent;
    87ba:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
	if (seg == NULL) {
    87bc:	b35d      	cbz	r5, 8816 <tcp_zero_window_probe+0xa6>
    87be:	e7dc      	b.n	877a <tcp_zero_window_probe+0xa>
	p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    87c0:	692b      	ldr	r3, [r5, #16]
    87c2:	685b      	ldr	r3, [r3, #4]
    87c4:	2200      	movs	r2, #0
    87c6:	4611      	mov	r1, r2
    87c8:	4620      	mov	r0, r4
    87ca:	4d15      	ldr	r5, [pc, #84]	; (8820 <tcp_zero_window_probe+0xb0>)
    87cc:	47a8      	blx	r5
	if (p == NULL) {
    87ce:	4606      	mov	r6, r0
    87d0:	b308      	cbz	r0, 8816 <tcp_zero_window_probe+0xa6>
	tcphdr = (struct tcp_hdr *)p->payload;
    87d2:	6877      	ldr	r7, [r6, #4]
		TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
    87d4:	f9b7 500c 	ldrsh.w	r5, [r7, #12]
    87d8:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
    87dc:	2011      	movs	r0, #17
    87de:	4b12      	ldr	r3, [pc, #72]	; (8828 <tcp_zero_window_probe+0xb8>)
    87e0:	4798      	blx	r3
    87e2:	4328      	orrs	r0, r5
    87e4:	81b8      	strh	r0, [r7, #12]
	}

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    87e6:	1d25      	adds	r5, r4, #4
    87e8:	8933      	ldrh	r3, [r6, #8]
    87ea:	9300      	str	r3, [sp, #0]
    87ec:	2306      	movs	r3, #6
    87ee:	462a      	mov	r2, r5
    87f0:	4621      	mov	r1, r4
    87f2:	4630      	mov	r0, r6
    87f4:	f8df 803c 	ldr.w	r8, [pc, #60]	; 8834 <tcp_zero_window_probe+0xc4>
    87f8:	47c0      	blx	r8
    87fa:	8238      	strh	r0, [r7, #16]

	/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    87fc:	7aa3      	ldrb	r3, [r4, #10]
    87fe:	2206      	movs	r2, #6
    8800:	9201      	str	r2, [sp, #4]
    8802:	2200      	movs	r2, #0
    8804:	9200      	str	r2, [sp, #0]
    8806:	462a      	mov	r2, r5
    8808:	4621      	mov	r1, r4
    880a:	4630      	mov	r0, r6
    880c:	4c07      	ldr	r4, [pc, #28]	; (882c <tcp_zero_window_probe+0xbc>)
    880e:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

	pbuf_free(p);
    8810:	4630      	mov	r0, r6
    8812:	4b07      	ldr	r3, [pc, #28]	; (8830 <tcp_zero_window_probe+0xc0>)
    8814:	4798      	blx	r3

	LWIP_DEBUGF(TCP_DEBUG,
	            ("tcp_zero_window_probe: seqno %" U32_F " ackno %" U32_F ".\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    8816:	b002      	add	sp, #8
    8818:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    881c:	00002f47 	.word	0x00002f47
    8820:	00008091 	.word	0x00008091
    8824:	000060ad 	.word	0x000060ad
    8828:	00002f3d 	.word	0x00002f3d
    882c:	00004f51 	.word	0x00004f51
    8830:	00005d21 	.word	0x00005d21
    8834:	00004b29 	.word	0x00004b29

00008838 <sys_timeout>:
#if LWIP_DEBUG_TIMERNAMES
void sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else  /* LWIP_DEBUG_TIMERNAMES */
void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
    8838:	b570      	push	{r4, r5, r6, lr}
    883a:	4604      	mov	r4, r0
    883c:	460e      	mov	r6, r1
    883e:	4615      	mov	r5, r2
	struct sys_timeo *timeout, *t;

	timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    8840:	2007      	movs	r0, #7
    8842:	4b1b      	ldr	r3, [pc, #108]	; (88b0 <sys_timeout+0x78>)
    8844:	4798      	blx	r3
	if (timeout == NULL) {
    8846:	2800      	cmp	r0, #0
    8848:	d030      	beq.n	88ac <sys_timeout+0x74>
    884a:	4601      	mov	r1, r0
		LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
		return;
	}
	timeout->next = NULL;
    884c:	2300      	movs	r3, #0
    884e:	6003      	str	r3, [r0, #0]
	timeout->h    = handler;
    8850:	6086      	str	r6, [r0, #8]
	timeout->arg  = arg;
    8852:	60c5      	str	r5, [r0, #12]
	timeout->time = msecs;
    8854:	6044      	str	r4, [r0, #4]
	LWIP_DEBUGF(
	    TIMERS_DEBUG,
	    ("sys_timeout: %p msecs=%" U32_F " handler=%s arg=%p\n", (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

	if (next_timeout == NULL) {
    8856:	4b17      	ldr	r3, [pc, #92]	; (88b4 <sys_timeout+0x7c>)
    8858:	681d      	ldr	r5, [r3, #0]
    885a:	b1a5      	cbz	r5, 8886 <sys_timeout+0x4e>
		next_timeout = timeout;
		return;
	}

	if (next_timeout->time > msecs) {
    885c:	6868      	ldr	r0, [r5, #4]
    885e:	4284      	cmp	r4, r0
    8860:	d313      	bcc.n	888a <sys_timeout+0x52>
		next_timeout->time -= msecs;
		timeout->next = next_timeout;
		next_timeout  = timeout;
	} else {
		for (t = next_timeout; t != NULL; t = t->next) {
			timeout->time -= t->time;
    8862:	1a20      	subs	r0, r4, r0
    8864:	6048      	str	r0, [r1, #4]
			if (t->next == NULL || t->next->time > timeout->time) {
    8866:	682a      	ldr	r2, [r5, #0]
    8868:	b1f2      	cbz	r2, 88a8 <sys_timeout+0x70>
    886a:	6853      	ldr	r3, [r2, #4]
    886c:	4298      	cmp	r0, r3
    886e:	d312      	bcc.n	8896 <sys_timeout+0x5e>
			timeout->time -= t->time;
    8870:	6848      	ldr	r0, [r1, #4]
    8872:	6853      	ldr	r3, [r2, #4]
    8874:	1ac0      	subs	r0, r0, r3
    8876:	6048      	str	r0, [r1, #4]
			if (t->next == NULL || t->next->time > timeout->time) {
    8878:	6813      	ldr	r3, [r2, #0]
    887a:	b18b      	cbz	r3, 88a0 <sys_timeout+0x68>
    887c:	685c      	ldr	r4, [r3, #4]
    887e:	42a0      	cmp	r0, r4
    8880:	d30b      	bcc.n	889a <sys_timeout+0x62>
    8882:	461a      	mov	r2, r3
    8884:	e7f4      	b.n	8870 <sys_timeout+0x38>
		next_timeout = timeout;
    8886:	6018      	str	r0, [r3, #0]
		return;
    8888:	bd70      	pop	{r4, r5, r6, pc}
		next_timeout->time -= msecs;
    888a:	1b00      	subs	r0, r0, r4
    888c:	6068      	str	r0, [r5, #4]
		timeout->next = next_timeout;
    888e:	600d      	str	r5, [r1, #0]
		next_timeout  = timeout;
    8890:	4b08      	ldr	r3, [pc, #32]	; (88b4 <sys_timeout+0x7c>)
    8892:	6019      	str	r1, [r3, #0]
    8894:	bd70      	pop	{r4, r5, r6, pc}
			if (t->next == NULL || t->next->time > timeout->time) {
    8896:	4613      	mov	r3, r2
    8898:	462a      	mov	r2, r5
				if (t->next != NULL) {
					t->next->time -= timeout->time;
    889a:	685c      	ldr	r4, [r3, #4]
    889c:	1a20      	subs	r0, r4, r0
    889e:	6058      	str	r0, [r3, #4]
				}
				timeout->next = t->next;
    88a0:	6813      	ldr	r3, [r2, #0]
    88a2:	600b      	str	r3, [r1, #0]
				t->next       = timeout;
    88a4:	6011      	str	r1, [r2, #0]
				break;
    88a6:	bd70      	pop	{r4, r5, r6, pc}
			if (t->next == NULL || t->next->time > timeout->time) {
    88a8:	462a      	mov	r2, r5
    88aa:	e7f9      	b.n	88a0 <sys_timeout+0x68>
    88ac:	bd70      	pop	{r4, r5, r6, pc}
    88ae:	bf00      	nop
    88b0:	00005a11 	.word	0x00005a11
    88b4:	20007fcc 	.word	0x20007fcc

000088b8 <tcp_timer_needed>:
{
    88b8:	b508      	push	{r3, lr}
	if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
    88ba:	4b0a      	ldr	r3, [pc, #40]	; (88e4 <tcp_timer_needed+0x2c>)
    88bc:	685b      	ldr	r3, [r3, #4]
    88be:	b953      	cbnz	r3, 88d6 <tcp_timer_needed+0x1e>
    88c0:	4b09      	ldr	r3, [pc, #36]	; (88e8 <tcp_timer_needed+0x30>)
    88c2:	681b      	ldr	r3, [r3, #0]
    88c4:	b143      	cbz	r3, 88d8 <tcp_timer_needed+0x20>
		tcpip_tcp_timer_active = 1;
    88c6:	2201      	movs	r2, #1
    88c8:	4b06      	ldr	r3, [pc, #24]	; (88e4 <tcp_timer_needed+0x2c>)
    88ca:	605a      	str	r2, [r3, #4]
		sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    88cc:	2200      	movs	r2, #0
    88ce:	4907      	ldr	r1, [pc, #28]	; (88ec <tcp_timer_needed+0x34>)
    88d0:	20fa      	movs	r0, #250	; 0xfa
    88d2:	4b07      	ldr	r3, [pc, #28]	; (88f0 <tcp_timer_needed+0x38>)
    88d4:	4798      	blx	r3
    88d6:	bd08      	pop	{r3, pc}
	if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
    88d8:	4b06      	ldr	r3, [pc, #24]	; (88f4 <tcp_timer_needed+0x3c>)
    88da:	681b      	ldr	r3, [r3, #0]
    88dc:	2b00      	cmp	r3, #0
    88de:	d1f2      	bne.n	88c6 <tcp_timer_needed+0xe>
    88e0:	e7f9      	b.n	88d6 <tcp_timer_needed+0x1e>
    88e2:	bf00      	nop
    88e4:	20007fcc 	.word	0x20007fcc
    88e8:	20009300 	.word	0x20009300
    88ec:	000088f9 	.word	0x000088f9
    88f0:	00008839 	.word	0x00008839
    88f4:	20009314 	.word	0x20009314

000088f8 <tcpip_tcp_timer>:
{
    88f8:	b508      	push	{r3, lr}
	tcp_tmr();
    88fa:	4b09      	ldr	r3, [pc, #36]	; (8920 <tcpip_tcp_timer+0x28>)
    88fc:	4798      	blx	r3
	if (tcp_active_pcbs || tcp_tw_pcbs) {
    88fe:	4b09      	ldr	r3, [pc, #36]	; (8924 <tcpip_tcp_timer+0x2c>)
    8900:	681b      	ldr	r3, [r3, #0]
    8902:	b12b      	cbz	r3, 8910 <tcpip_tcp_timer+0x18>
		sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    8904:	2200      	movs	r2, #0
    8906:	4908      	ldr	r1, [pc, #32]	; (8928 <tcpip_tcp_timer+0x30>)
    8908:	20fa      	movs	r0, #250	; 0xfa
    890a:	4b08      	ldr	r3, [pc, #32]	; (892c <tcpip_tcp_timer+0x34>)
    890c:	4798      	blx	r3
    890e:	bd08      	pop	{r3, pc}
	if (tcp_active_pcbs || tcp_tw_pcbs) {
    8910:	4b07      	ldr	r3, [pc, #28]	; (8930 <tcpip_tcp_timer+0x38>)
    8912:	681b      	ldr	r3, [r3, #0]
    8914:	2b00      	cmp	r3, #0
    8916:	d1f5      	bne.n	8904 <tcpip_tcp_timer+0xc>
		tcpip_tcp_timer_active = 0;
    8918:	2200      	movs	r2, #0
    891a:	4b06      	ldr	r3, [pc, #24]	; (8934 <tcpip_tcp_timer+0x3c>)
    891c:	605a      	str	r2, [r3, #4]
    891e:	bd08      	pop	{r3, pc}
    8920:	000069e5 	.word	0x000069e5
    8924:	20009300 	.word	0x20009300
    8928:	000088f9 	.word	0x000088f9
    892c:	00008839 	.word	0x00008839
    8930:	20009314 	.word	0x20009314
    8934:	20007fcc 	.word	0x20007fcc

00008938 <sys_timeouts_init>:
{
    8938:	b510      	push	{r4, lr}
	sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    893a:	2200      	movs	r2, #0
    893c:	490c      	ldr	r1, [pc, #48]	; (8970 <sys_timeouts_init+0x38>)
    893e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    8942:	4c0c      	ldr	r4, [pc, #48]	; (8974 <sys_timeouts_init+0x3c>)
    8944:	47a0      	blx	r4
	sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    8946:	2200      	movs	r2, #0
    8948:	490b      	ldr	r1, [pc, #44]	; (8978 <sys_timeouts_init+0x40>)
    894a:	f241 3088 	movw	r0, #5000	; 0x1388
    894e:	47a0      	blx	r4
	sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
    8950:	2200      	movs	r2, #0
    8952:	490a      	ldr	r1, [pc, #40]	; (897c <sys_timeouts_init+0x44>)
    8954:	f64e 2060 	movw	r0, #60000	; 0xea60
    8958:	47a0      	blx	r4
	sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    895a:	2200      	movs	r2, #0
    895c:	4908      	ldr	r1, [pc, #32]	; (8980 <sys_timeouts_init+0x48>)
    895e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    8962:	47a0      	blx	r4
	timeouts_last_time = sys_now();
    8964:	4b07      	ldr	r3, [pc, #28]	; (8984 <sys_timeouts_init+0x4c>)
    8966:	4798      	blx	r3
    8968:	4b07      	ldr	r3, [pc, #28]	; (8988 <sys_timeouts_init+0x50>)
    896a:	6098      	str	r0, [r3, #8]
    896c:	bd10      	pop	{r4, pc}
    896e:	bf00      	nop
    8970:	000089ed 	.word	0x000089ed
    8974:	00008839 	.word	0x00008839
    8978:	000089cd 	.word	0x000089cd
    897c:	000089ad 	.word	0x000089ad
    8980:	0000898d 	.word	0x0000898d
    8984:	000098a9 	.word	0x000098a9
    8988:	20007fcc 	.word	0x20007fcc

0000898c <dhcp_timer_fine>:
{
    898c:	b508      	push	{r3, lr}
	dhcp_fine_tmr();
    898e:	4b04      	ldr	r3, [pc, #16]	; (89a0 <dhcp_timer_fine+0x14>)
    8990:	4798      	blx	r3
	sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    8992:	2200      	movs	r2, #0
    8994:	4903      	ldr	r1, [pc, #12]	; (89a4 <dhcp_timer_fine+0x18>)
    8996:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    899a:	4b03      	ldr	r3, [pc, #12]	; (89a8 <dhcp_timer_fine+0x1c>)
    899c:	4798      	blx	r3
    899e:	bd08      	pop	{r3, pc}
    89a0:	00004545 	.word	0x00004545
    89a4:	0000898d 	.word	0x0000898d
    89a8:	00008839 	.word	0x00008839

000089ac <dhcp_timer_coarse>:
{
    89ac:	b508      	push	{r3, lr}
	dhcp_coarse_tmr();
    89ae:	4b04      	ldr	r3, [pc, #16]	; (89c0 <dhcp_timer_coarse+0x14>)
    89b0:	4798      	blx	r3
	sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
    89b2:	2200      	movs	r2, #0
    89b4:	4903      	ldr	r1, [pc, #12]	; (89c4 <dhcp_timer_coarse+0x18>)
    89b6:	f64e 2060 	movw	r0, #60000	; 0xea60
    89ba:	4b03      	ldr	r3, [pc, #12]	; (89c8 <dhcp_timer_coarse+0x1c>)
    89bc:	4798      	blx	r3
    89be:	bd08      	pop	{r3, pc}
    89c0:	00004379 	.word	0x00004379
    89c4:	000089ad 	.word	0x000089ad
    89c8:	00008839 	.word	0x00008839

000089cc <arp_timer>:
{
    89cc:	b508      	push	{r3, lr}
	etharp_tmr();
    89ce:	4b04      	ldr	r3, [pc, #16]	; (89e0 <arp_timer+0x14>)
    89d0:	4798      	blx	r3
	sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    89d2:	2200      	movs	r2, #0
    89d4:	4903      	ldr	r1, [pc, #12]	; (89e4 <arp_timer+0x18>)
    89d6:	f241 3088 	movw	r0, #5000	; 0x1388
    89da:	4b03      	ldr	r3, [pc, #12]	; (89e8 <arp_timer+0x1c>)
    89dc:	4798      	blx	r3
    89de:	bd08      	pop	{r3, pc}
    89e0:	000090bd 	.word	0x000090bd
    89e4:	000089cd 	.word	0x000089cd
    89e8:	00008839 	.word	0x00008839

000089ec <ip_reass_timer>:
{
    89ec:	b508      	push	{r3, lr}
	ip_reass_tmr();
    89ee:	4b04      	ldr	r3, [pc, #16]	; (8a00 <ip_reass_timer+0x14>)
    89f0:	4798      	blx	r3
	sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    89f2:	2200      	movs	r2, #0
    89f4:	4903      	ldr	r1, [pc, #12]	; (8a04 <ip_reass_timer+0x18>)
    89f6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    89fa:	4b03      	ldr	r3, [pc, #12]	; (8a08 <ip_reass_timer+0x1c>)
    89fc:	4798      	blx	r3
    89fe:	bd08      	pop	{r3, pc}
    8a00:	000051d5 	.word	0x000051d5
    8a04:	000089ed 	.word	0x000089ed
    8a08:	00008839 	.word	0x00008839

00008a0c <sys_check_timeouts>:
 *
 * Must be called periodically from your main loop.
 */
void sys_check_timeouts(void)
{
	if (next_timeout) {
    8a0c:	4b15      	ldr	r3, [pc, #84]	; (8a64 <sys_check_timeouts+0x58>)
    8a0e:	681b      	ldr	r3, [r3, #0]
    8a10:	b333      	cbz	r3, 8a60 <sys_check_timeouts+0x54>
{
    8a12:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		sys_timeout_handler handler;
		void *              arg;
		u8_t                had_one;
		u32_t               now;

		now = sys_now();
    8a16:	4b14      	ldr	r3, [pc, #80]	; (8a68 <sys_check_timeouts+0x5c>)
    8a18:	4798      	blx	r3
    8a1a:	4680      	mov	r8, r0
		/* this cares for wraparounds */
		diff = now - timeouts_last_time;
    8a1c:	4b11      	ldr	r3, [pc, #68]	; (8a64 <sys_check_timeouts+0x58>)
    8a1e:	689c      	ldr	r4, [r3, #8]
    8a20:	1b04      	subs	r4, r0, r4
		do {
#if PBUF_POOL_FREE_OOSEQ
			PBUF_CHECK_FREE_OOSEQ();
    8a22:	4f12      	ldr	r7, [pc, #72]	; (8a6c <sys_check_timeouts+0x60>)
    8a24:	f8df 904c 	ldr.w	r9, [pc, #76]	; 8a74 <sys_check_timeouts+0x68>
#endif /* PBUF_POOL_FREE_OOSEQ */
			had_one    = 0;
			tmptimeout = next_timeout;
    8a28:	461d      	mov	r5, r3
			PBUF_CHECK_FREE_OOSEQ();
    8a2a:	783b      	ldrb	r3, [r7, #0]
    8a2c:	b9a3      	cbnz	r3, 8a58 <sys_check_timeouts+0x4c>
			tmptimeout = next_timeout;
    8a2e:	6829      	ldr	r1, [r5, #0]
			if (tmptimeout && (tmptimeout->time <= diff)) {
    8a30:	b1a1      	cbz	r1, 8a5c <sys_check_timeouts+0x50>
    8a32:	684b      	ldr	r3, [r1, #4]
    8a34:	429c      	cmp	r4, r3
    8a36:	d311      	bcc.n	8a5c <sys_check_timeouts+0x50>
				/* timeout has expired */
				had_one            = 1;
				timeouts_last_time = now;
    8a38:	f8c5 8008 	str.w	r8, [r5, #8]
				diff -= tmptimeout->time;
    8a3c:	1ae4      	subs	r4, r4, r3
				next_timeout = tmptimeout->next;
    8a3e:	680b      	ldr	r3, [r1, #0]
    8a40:	602b      	str	r3, [r5, #0]
				handler      = tmptimeout->h;
    8a42:	688e      	ldr	r6, [r1, #8]
				arg          = tmptimeout->arg;
    8a44:	f8d1 a00c 	ldr.w	sl, [r1, #12]
#if LWIP_DEBUG_TIMERNAMES
				if (handler != NULL) {
					LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s arg=%p\n", tmptimeout->handler_name, arg));
				}
#endif /* LWIP_DEBUG_TIMERNAMES */
				memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
    8a48:	2007      	movs	r0, #7
    8a4a:	4b09      	ldr	r3, [pc, #36]	; (8a70 <sys_check_timeouts+0x64>)
    8a4c:	4798      	blx	r3
				if (handler != NULL) {
    8a4e:	2e00      	cmp	r6, #0
    8a50:	d0eb      	beq.n	8a2a <sys_check_timeouts+0x1e>
					handler(arg);
    8a52:	4650      	mov	r0, sl
    8a54:	47b0      	blx	r6
    8a56:	e7e8      	b.n	8a2a <sys_check_timeouts+0x1e>
			PBUF_CHECK_FREE_OOSEQ();
    8a58:	47c8      	blx	r9
    8a5a:	e7e8      	b.n	8a2e <sys_check_timeouts+0x22>
    8a5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8a60:	4770      	bx	lr
    8a62:	bf00      	nop
    8a64:	20007fcc 	.word	0x20007fcc
    8a68:	000098a9 	.word	0x000098a9
    8a6c:	200092f8 	.word	0x200092f8
    8a70:	00005a59 	.word	0x00005a59
    8a74:	00005bf9 	.word	0x00005bf9

00008a78 <udp_init>:

/**
 * Initialize this module.
 */
void udp_init(void)
{
    8a78:	4770      	bx	lr
	...

00008a7c <udp_input>:
 * @param p pbuf to be demultiplexed to a UDP PCB.
 * @param inp network interface on which the datagram was received.
 *
 */
void udp_input(struct pbuf *p, struct netif *inp)
{
    8a7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8a80:	b085      	sub	sp, #20
    8a82:	4604      	mov	r4, r0
    8a84:	4689      	mov	r9, r1

	PERF_START;

	UDP_STATS_INC(udp.recv);

	iphdr = (struct ip_hdr *)p->payload;
    8a86:	6847      	ldr	r7, [r0, #4]
    8a88:	7839      	ldrb	r1, [r7, #0]
    8a8a:	f001 010f 	and.w	r1, r1, #15

	/* Check minimum length (IP header + UDP header)
	 * and move payload pointer to UDP header */
	if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    8a8e:	8903      	ldrh	r3, [r0, #8]
    8a90:	1c8a      	adds	r2, r1, #2
    8a92:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
    8a96:	db04      	blt.n	8aa2 <udp_input+0x26>
    8a98:	0089      	lsls	r1, r1, #2
    8a9a:	4249      	negs	r1, r1
    8a9c:	4b6a      	ldr	r3, [pc, #424]	; (8c48 <udp_input+0x1cc>)
    8a9e:	4798      	blx	r3
    8aa0:	b128      	cbz	r0, 8aae <udp_input+0x32>
		/* drop short packets */
		LWIP_DEBUGF(UDP_DEBUG, ("udp_input: short UDP datagram (%" U16_F " bytes) discarded\n", p->tot_len));
		UDP_STATS_INC(udp.lenerr);
		UDP_STATS_INC(udp.drop);
		snmp_inc_udpinerrors();
		pbuf_free(p);
    8aa2:	4620      	mov	r0, r4
    8aa4:	4b69      	ldr	r3, [pc, #420]	; (8c4c <udp_input+0x1d0>)
    8aa6:	4798      	blx	r3
	} else {
		pbuf_free(p);
	}
end:
	PERF_STOP("udp_input");
}
    8aa8:	b005      	add	sp, #20
    8aaa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	udphdr = (struct udp_hdr *)p->payload;
    8aae:	f8d4 a004 	ldr.w	sl, [r4, #4]
	broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    8ab2:	4649      	mov	r1, r9
    8ab4:	4b66      	ldr	r3, [pc, #408]	; (8c50 <udp_input+0x1d4>)
    8ab6:	6818      	ldr	r0, [r3, #0]
    8ab8:	4b66      	ldr	r3, [pc, #408]	; (8c54 <udp_input+0x1d8>)
    8aba:	4798      	blx	r3
    8abc:	4680      	mov	r8, r0
	src  = ntohs(udphdr->src);
    8abe:	f8ba 0000 	ldrh.w	r0, [sl]
    8ac2:	4e65      	ldr	r6, [pc, #404]	; (8c58 <udp_input+0x1dc>)
    8ac4:	47b0      	blx	r6
    8ac6:	4605      	mov	r5, r0
	dest = ntohs(udphdr->dest);
    8ac8:	f8ba 0002 	ldrh.w	r0, [sl, #2]
    8acc:	47b0      	blx	r6
	if (dest == DHCP_CLIENT_PORT) {
    8ace:	2844      	cmp	r0, #68	; 0x44
    8ad0:	d014      	beq.n	8afc <udp_input+0x80>
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    8ad2:	4b62      	ldr	r3, [pc, #392]	; (8c5c <udp_input+0x1e0>)
    8ad4:	f8d3 e000 	ldr.w	lr, [r3]
    8ad8:	f1be 0f00 	cmp.w	lr, #0
    8adc:	d010      	beq.n	8b00 <udp_input+0x84>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    8ade:	4b5c      	ldr	r3, [pc, #368]	; (8c50 <udp_input+0x1d4>)
    8ae0:	f8d3 c000 	ldr.w	ip, [r3]
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    8ae4:	4b5e      	ldr	r3, [pc, #376]	; (8c60 <udp_input+0x1e4>)
    8ae6:	f8d3 b000 	ldr.w	fp, [r3]
    8aea:	4673      	mov	r3, lr
    8aec:	2600      	movs	r6, #0
    8aee:	4632      	mov	r2, r6
    8af0:	9703      	str	r7, [sp, #12]
    8af2:	4621      	mov	r1, r4
    8af4:	4644      	mov	r4, r8
    8af6:	46f0      	mov	r8, lr
    8af8:	468e      	mov	lr, r1
    8afa:	e097      	b.n	8c2c <udp_input+0x1b0>
		if (src == DHCP_SERVER_PORT) {
    8afc:	2d43      	cmp	r5, #67	; 0x43
    8afe:	d009      	beq.n	8b14 <udp_input+0x98>
	if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    8b00:	f8d9 2004 	ldr.w	r2, [r9, #4]
    8b04:	4b52      	ldr	r3, [pc, #328]	; (8c50 <udp_input+0x1d4>)
    8b06:	681b      	ldr	r3, [r3, #0]
    8b08:	429a      	cmp	r2, r3
    8b0a:	d053      	beq.n	8bb4 <udp_input+0x138>
		pbuf_free(p);
    8b0c:	4620      	mov	r0, r4
    8b0e:	4b4f      	ldr	r3, [pc, #316]	; (8c4c <udp_input+0x1d0>)
    8b10:	4798      	blx	r3
}
    8b12:	e7c9      	b.n	8aa8 <udp_input+0x2c>
			if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
    8b14:	f8d9 3028 	ldr.w	r3, [r9, #40]	; 0x28
    8b18:	2b00      	cmp	r3, #0
    8b1a:	d0f1      	beq.n	8b00 <udp_input+0x84>
    8b1c:	685b      	ldr	r3, [r3, #4]
    8b1e:	2b00      	cmp	r3, #0
    8b20:	d0ee      	beq.n	8b00 <udp_input+0x84>
				if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip)
    8b22:	f113 0f04 	cmn.w	r3, #4
    8b26:	d021      	beq.n	8b6c <udp_input+0xf0>
    8b28:	685a      	ldr	r2, [r3, #4]
    8b2a:	b1fa      	cbz	r2, 8b6c <udp_input+0xf0>
				     || ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
    8b2c:	494c      	ldr	r1, [pc, #304]	; (8c60 <udp_input+0x1e4>)
    8b2e:	6809      	ldr	r1, [r1, #0]
    8b30:	428a      	cmp	r2, r1
    8b32:	d1e5      	bne.n	8b00 <udp_input+0x84>
    8b34:	e01a      	b.n	8b6c <udp_input+0xf0>
					if ((uncon_pcb == NULL) && ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    8b36:	7c19      	ldrb	r1, [r3, #16]
    8b38:	f001 0104 	and.w	r1, r1, #4
    8b3c:	2900      	cmp	r1, #0
    8b3e:	bf08      	it	eq
    8b40:	461e      	moveq	r6, r3
    8b42:	e06b      	b.n	8c1c <udp_input+0x1a0>
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    8b44:	f113 0f04 	cmn.w	r3, #4
    8b48:	d003      	beq.n	8b52 <udp_input+0xd6>
    8b4a:	6859      	ldr	r1, [r3, #4]
    8b4c:	b109      	cbz	r1, 8b52 <udp_input+0xd6>
    8b4e:	4559      	cmp	r1, fp
    8b50:	d167      	bne.n	8c22 <udp_input+0x1a6>
    8b52:	9f03      	ldr	r7, [sp, #12]
    8b54:	4671      	mov	r1, lr
    8b56:	46c6      	mov	lr, r8
    8b58:	46a0      	mov	r8, r4
    8b5a:	460c      	mov	r4, r1
				if (prev != NULL) {
    8b5c:	b12a      	cbz	r2, 8b6a <udp_input+0xee>
					prev->next = pcb->next;
    8b5e:	68d9      	ldr	r1, [r3, #12]
    8b60:	60d1      	str	r1, [r2, #12]
					pcb->next  = udp_pcbs;
    8b62:	f8c3 e00c 	str.w	lr, [r3, #12]
					udp_pcbs   = pcb;
    8b66:	4a3d      	ldr	r2, [pc, #244]	; (8c5c <udp_input+0x1e0>)
    8b68:	6013      	str	r3, [r2, #0]
		if (pcb == NULL) {
    8b6a:	b123      	cbz	r3, 8b76 <udp_input+0xfa>
    8b6c:	461e      	mov	r6, r3
    8b6e:	e004      	b.n	8b7a <udp_input+0xfe>
    8b70:	9f03      	ldr	r7, [sp, #12]
    8b72:	46a0      	mov	r8, r4
    8b74:	4674      	mov	r4, lr
	if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    8b76:	2e00      	cmp	r6, #0
    8b78:	d0c2      	beq.n	8b00 <udp_input+0x84>
			if (udphdr->chksum != 0) {
    8b7a:	f8ba 3006 	ldrh.w	r3, [sl, #6]
    8b7e:	b14b      	cbz	r3, 8b94 <udp_input+0x118>
				if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(), IP_PROTO_UDP, p->tot_len)
    8b80:	8923      	ldrh	r3, [r4, #8]
    8b82:	9300      	str	r3, [sp, #0]
    8b84:	2311      	movs	r3, #17
    8b86:	4a32      	ldr	r2, [pc, #200]	; (8c50 <udp_input+0x1d4>)
    8b88:	4935      	ldr	r1, [pc, #212]	; (8c60 <udp_input+0x1e4>)
    8b8a:	4620      	mov	r0, r4
    8b8c:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 8c68 <udp_input+0x1ec>
    8b90:	47c8      	blx	r9
    8b92:	b988      	cbnz	r0, 8bb8 <udp_input+0x13c>
		if (pbuf_header(p, -UDP_HLEN)) {
    8b94:	f06f 0107 	mvn.w	r1, #7
    8b98:	4620      	mov	r0, r4
    8b9a:	4b2b      	ldr	r3, [pc, #172]	; (8c48 <udp_input+0x1cc>)
    8b9c:	4798      	blx	r3
    8b9e:	b978      	cbnz	r0, 8bc0 <udp_input+0x144>
		if (pcb != NULL) {
    8ba0:	b1b6      	cbz	r6, 8bd0 <udp_input+0x154>
			if (pcb->recv != NULL) {
    8ba2:	69b7      	ldr	r7, [r6, #24]
    8ba4:	b187      	cbz	r7, 8bc8 <udp_input+0x14c>
				pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
    8ba6:	69f0      	ldr	r0, [r6, #28]
    8ba8:	9500      	str	r5, [sp, #0]
    8baa:	4b2d      	ldr	r3, [pc, #180]	; (8c60 <udp_input+0x1e4>)
    8bac:	4622      	mov	r2, r4
    8bae:	4631      	mov	r1, r6
    8bb0:	47b8      	blx	r7
    8bb2:	e779      	b.n	8aa8 <udp_input+0x2c>
    8bb4:	2600      	movs	r6, #0
    8bb6:	e7e0      	b.n	8b7a <udp_input+0xfe>
					pbuf_free(p);
    8bb8:	4620      	mov	r0, r4
    8bba:	4b24      	ldr	r3, [pc, #144]	; (8c4c <udp_input+0x1d0>)
    8bbc:	4798      	blx	r3
					goto end;
    8bbe:	e773      	b.n	8aa8 <udp_input+0x2c>
			pbuf_free(p);
    8bc0:	4620      	mov	r0, r4
    8bc2:	4b22      	ldr	r3, [pc, #136]	; (8c4c <udp_input+0x1d0>)
    8bc4:	4798      	blx	r3
			goto end;
    8bc6:	e76f      	b.n	8aa8 <udp_input+0x2c>
				pbuf_free(p);
    8bc8:	4620      	mov	r0, r4
    8bca:	4b20      	ldr	r3, [pc, #128]	; (8c4c <udp_input+0x1d0>)
    8bcc:	4798      	blx	r3
				goto end;
    8bce:	e76b      	b.n	8aa8 <udp_input+0x2c>
			if (!broadcast && !ip_addr_ismulticast(&current_iphdr_dest)) {
    8bd0:	f1b8 0f00 	cmp.w	r8, #0
    8bd4:	d111      	bne.n	8bfa <udp_input+0x17e>
    8bd6:	4b1e      	ldr	r3, [pc, #120]	; (8c50 <udp_input+0x1d4>)
    8bd8:	681b      	ldr	r3, [r3, #0]
    8bda:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    8bde:	2be0      	cmp	r3, #224	; 0xe0
    8be0:	d00b      	beq.n	8bfa <udp_input+0x17e>
				pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
    8be2:	7839      	ldrb	r1, [r7, #0]
    8be4:	f001 010f 	and.w	r1, r1, #15
    8be8:	3102      	adds	r1, #2
    8bea:	0089      	lsls	r1, r1, #2
    8bec:	4620      	mov	r0, r4
    8bee:	4b16      	ldr	r3, [pc, #88]	; (8c48 <udp_input+0x1cc>)
    8bf0:	4798      	blx	r3
				icmp_dest_unreach(p, ICMP_DUR_PORT);
    8bf2:	2103      	movs	r1, #3
    8bf4:	4620      	mov	r0, r4
    8bf6:	4b1b      	ldr	r3, [pc, #108]	; (8c64 <udp_input+0x1e8>)
    8bf8:	4798      	blx	r3
			pbuf_free(p);
    8bfa:	4620      	mov	r0, r4
    8bfc:	4b13      	ldr	r3, [pc, #76]	; (8c4c <udp_input+0x1d0>)
    8bfe:	4798      	blx	r3
    8c00:	e752      	b.n	8aa8 <udp_input+0x2c>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    8c02:	6819      	ldr	r1, [r3, #0]
    8c04:	458c      	cmp	ip, r1
    8c06:	d007      	beq.n	8c18 <udp_input+0x19c>
				     && (ip_addr_isany(&pcb->local_ip)
    8c08:	b133      	cbz	r3, 8c18 <udp_input+0x19c>
    8c0a:	b129      	cbz	r1, 8c18 <udp_input+0x19c>
				         || ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
    8c0c:	ea8c 0701 	eor.w	r7, ip, r1
    8c10:	f8d9 1008 	ldr.w	r1, [r9, #8]
    8c14:	420f      	tst	r7, r1
    8c16:	d104      	bne.n	8c22 <udp_input+0x1a6>
					if ((uncon_pcb == NULL) && ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    8c18:	2e00      	cmp	r6, #0
    8c1a:	d08c      	beq.n	8b36 <udp_input+0xba>
			if ((local_match != 0) && (pcb->remote_port == src)
    8c1c:	8a99      	ldrh	r1, [r3, #20]
    8c1e:	42a9      	cmp	r1, r5
    8c20:	d090      	beq.n	8b44 <udp_input+0xc8>
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    8c22:	68d9      	ldr	r1, [r3, #12]
    8c24:	461a      	mov	r2, r3
    8c26:	2900      	cmp	r1, #0
    8c28:	d0a2      	beq.n	8b70 <udp_input+0xf4>
    8c2a:	460b      	mov	r3, r1
			if (pcb->local_port == dest) {
    8c2c:	8a59      	ldrh	r1, [r3, #18]
    8c2e:	4281      	cmp	r1, r0
    8c30:	d1f7      	bne.n	8c22 <udp_input+0x1a6>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    8c32:	2c00      	cmp	r4, #0
    8c34:	d1e5      	bne.n	8c02 <udp_input+0x186>
    8c36:	2b00      	cmp	r3, #0
    8c38:	d0ee      	beq.n	8c18 <udp_input+0x19c>
    8c3a:	6819      	ldr	r1, [r3, #0]
    8c3c:	2900      	cmp	r1, #0
    8c3e:	d0eb      	beq.n	8c18 <udp_input+0x19c>
    8c40:	4561      	cmp	r1, ip
    8c42:	d1ee      	bne.n	8c22 <udp_input+0x1a6>
    8c44:	e7e8      	b.n	8c18 <udp_input+0x19c>
    8c46:	bf00      	nop
    8c48:	00005c8d 	.word	0x00005c8d
    8c4c:	00005d21 	.word	0x00005d21
    8c50:	20008334 	.word	0x20008334
    8c54:	00004f91 	.word	0x00004f91
    8c58:	00002f47 	.word	0x00002f47
    8c5c:	2000931c 	.word	0x2000931c
    8c60:	2000832c 	.word	0x2000832c
    8c64:	00004a91 	.word	0x00004a91
    8c68:	00004b29 	.word	0x00004b29

00008c6c <udp_bind>:
 * another UDP PCB.
 *
 * @see udp_disconnect()
 */
err_t udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    8c6c:	b5f0      	push	{r4, r5, r6, r7, lr}
	ip_addr_debug_print(UDP_DEBUG, ipaddr);
	LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %" U16_F ")\n", port));

	rebind = 0;
	/* Check for double bind and rebind of the same pcb */
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    8c6e:	4b34      	ldr	r3, [pc, #208]	; (8d40 <udp_bind+0xd4>)
    8c70:	681b      	ldr	r3, [r3, #0]
    8c72:	b1cb      	cbz	r3, 8ca8 <udp_bind+0x3c>
    8c74:	2600      	movs	r6, #0
		/* is this UDP PCB already on active list? */
		if (pcb == ipcb) {
			/* pcb may occur at most once in active list */
			LWIP_ASSERT("rebind == 0", rebind == 0);
			/* pcb already in list, just rebind */
			rebind = 1;
    8c76:	2701      	movs	r7, #1
    8c78:	e002      	b.n	8c80 <udp_bind+0x14>
    8c7a:	463e      	mov	r6, r7
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    8c7c:	68db      	ldr	r3, [r3, #12]
    8c7e:	b1a3      	cbz	r3, 8caa <udp_bind+0x3e>
		if (pcb == ipcb) {
    8c80:	4298      	cmp	r0, r3
    8c82:	d0fa      	beq.n	8c7a <udp_bind+0xe>
		else if (!ip_get_option(pcb, SOF_REUSEADDR) && !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else  /* SO_REUSE */
		/* port matches that of PCB in list and REUSEADDR not set -> reject */
		else {
#endif /* SO_REUSE */
			if ((ipcb->local_port == port) &&
    8c84:	8a5c      	ldrh	r4, [r3, #18]
    8c86:	4294      	cmp	r4, r2
    8c88:	d1f8      	bne.n	8c7c <udp_bind+0x10>
    8c8a:	2b00      	cmp	r3, #0
    8c8c:	d04a      	beq.n	8d24 <udp_bind+0xb8>
			    /* IP address matches, or one is IP_ADDR_ANY? */
			    (ip_addr_isany(&(ipcb->local_ip)) || ip_addr_isany(ipaddr) || ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
    8c8e:	681c      	ldr	r4, [r3, #0]
    8c90:	2c00      	cmp	r4, #0
    8c92:	d04a      	beq.n	8d2a <udp_bind+0xbe>
    8c94:	2900      	cmp	r1, #0
    8c96:	d04b      	beq.n	8d30 <udp_bind+0xc4>
    8c98:	680d      	ldr	r5, [r1, #0]
    8c9a:	2d00      	cmp	r5, #0
    8c9c:	d04b      	beq.n	8d36 <udp_bind+0xca>
    8c9e:	42ac      	cmp	r4, r5
    8ca0:	d1ec      	bne.n	8c7c <udp_bind+0x10>
				/* other PCB already binds to this local IP and port */
				LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: local port %" U16_F " already bound by another pcb\n", port));
				return ERR_USE;
    8ca2:	f06f 0007 	mvn.w	r0, #7
    8ca6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	rebind = 0;
    8ca8:	2600      	movs	r6, #0
			}
		}
	}

	ip_addr_set(&pcb->local_ip, ipaddr);
    8caa:	b159      	cbz	r1, 8cc4 <udp_bind+0x58>
    8cac:	680b      	ldr	r3, [r1, #0]
    8cae:	6003      	str	r3, [r0, #0]

	/* no port specified? */
	if (port == 0) {
    8cb0:	b152      	cbz	r2, 8cc8 <udp_bind+0x5c>
			/* no more ports available in local range */
			LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
			return ERR_USE;
		}
	}
	pcb->local_port = port;
    8cb2:	8242      	strh	r2, [r0, #18]
	snmp_insert_udpidx_tree(pcb);
	/* pcb not active yet? */
	if (rebind == 0) {
    8cb4:	2e00      	cmp	r6, #0
    8cb6:	d141      	bne.n	8d3c <udp_bind+0xd0>
		/* place the PCB on the active list if not already there */
		pcb->next = udp_pcbs;
    8cb8:	4b21      	ldr	r3, [pc, #132]	; (8d40 <udp_bind+0xd4>)
    8cba:	681a      	ldr	r2, [r3, #0]
    8cbc:	60c2      	str	r2, [r0, #12]
		udp_pcbs  = pcb;
    8cbe:	6018      	str	r0, [r3, #0]
	             ip4_addr1_16(&pcb->local_ip),
	             ip4_addr2_16(&pcb->local_ip),
	             ip4_addr3_16(&pcb->local_ip),
	             ip4_addr4_16(&pcb->local_ip),
	             pcb->local_port));
	return ERR_OK;
    8cc0:	2000      	movs	r0, #0
    8cc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ip_addr_set(&pcb->local_ip, ipaddr);
    8cc4:	2300      	movs	r3, #0
    8cc6:	e7f2      	b.n	8cae <udp_bind+0x42>
    8cc8:	4b1e      	ldr	r3, [pc, #120]	; (8d44 <udp_bind+0xd8>)
    8cca:	8819      	ldrh	r1, [r3, #0]
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    8ccc:	4b1c      	ldr	r3, [pc, #112]	; (8d40 <udp_bind+0xd4>)
    8cce:	681c      	ldr	r4, [r3, #0]
    8cd0:	f44f 4580 	mov.w	r5, #16384	; 0x4000
	if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    8cd4:	f64f 77ff 	movw	r7, #65535	; 0xffff
		udp_port = UDP_LOCAL_PORT_RANGE_START;
    8cd8:	f44f 4e40 	mov.w	lr, #49152	; 0xc000
	if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    8cdc:	42b9      	cmp	r1, r7
    8cde:	bf1a      	itte	ne
    8ce0:	3101      	addne	r1, #1
    8ce2:	b289      	uxthne	r1, r1
		udp_port = UDP_LOCAL_PORT_RANGE_START;
    8ce4:	4671      	moveq	r1, lr
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    8ce6:	b18c      	cbz	r4, 8d0c <udp_bind+0xa0>
		if (pcb->local_port == udp_port) {
    8ce8:	8a63      	ldrh	r3, [r4, #18]
    8cea:	428b      	cmp	r3, r1
    8cec:	d005      	beq.n	8cfa <udp_bind+0x8e>
    8cee:	4623      	mov	r3, r4
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    8cf0:	68db      	ldr	r3, [r3, #12]
    8cf2:	b173      	cbz	r3, 8d12 <udp_bind+0xa6>
		if (pcb->local_port == udp_port) {
    8cf4:	8a5a      	ldrh	r2, [r3, #18]
    8cf6:	428a      	cmp	r2, r1
    8cf8:	d1fa      	bne.n	8cf0 <udp_bind+0x84>
    8cfa:	3d01      	subs	r5, #1
    8cfc:	b2ad      	uxth	r5, r5
			if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
    8cfe:	2d00      	cmp	r5, #0
    8d00:	d1ec      	bne.n	8cdc <udp_bind+0x70>
    8d02:	4b10      	ldr	r3, [pc, #64]	; (8d44 <udp_bind+0xd8>)
    8d04:	8019      	strh	r1, [r3, #0]
			return ERR_USE;
    8d06:	f06f 0007 	mvn.w	r0, #7
    8d0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8d0c:	4b0d      	ldr	r3, [pc, #52]	; (8d44 <udp_bind+0xd8>)
    8d0e:	8019      	strh	r1, [r3, #0]
    8d10:	e001      	b.n	8d16 <udp_bind+0xaa>
    8d12:	4b0c      	ldr	r3, [pc, #48]	; (8d44 <udp_bind+0xd8>)
    8d14:	8019      	strh	r1, [r3, #0]
	return udp_port;
    8d16:	4b0b      	ldr	r3, [pc, #44]	; (8d44 <udp_bind+0xd8>)
    8d18:	881a      	ldrh	r2, [r3, #0]
		if (port == 0) {
    8d1a:	2a00      	cmp	r2, #0
    8d1c:	d1c9      	bne.n	8cb2 <udp_bind+0x46>
			return ERR_USE;
    8d1e:	f06f 0007 	mvn.w	r0, #7
    8d22:	bdf0      	pop	{r4, r5, r6, r7, pc}
				return ERR_USE;
    8d24:	f06f 0007 	mvn.w	r0, #7
    8d28:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8d2a:	f06f 0007 	mvn.w	r0, #7
    8d2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8d30:	f06f 0007 	mvn.w	r0, #7
    8d34:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8d36:	f06f 0007 	mvn.w	r0, #7
    8d3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return ERR_OK;
    8d3c:	2000      	movs	r0, #0
}
    8d3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8d40:	2000931c 	.word	0x2000931c
    8d44:	2000000c 	.word	0x2000000c

00008d48 <udp_sendto_if>:
{
    8d48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8d4c:	b085      	sub	sp, #20
    8d4e:	4604      	mov	r4, r0
    8d50:	460f      	mov	r7, r1
    8d52:	4692      	mov	sl, r2
    8d54:	469b      	mov	fp, r3
    8d56:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
	if (pcb->local_port == 0) {
    8d5a:	8a43      	ldrh	r3, [r0, #18]
    8d5c:	b933      	cbnz	r3, 8d6c <udp_sendto_if+0x24>
		err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    8d5e:	2200      	movs	r2, #0
    8d60:	4601      	mov	r1, r0
    8d62:	4b35      	ldr	r3, [pc, #212]	; (8e38 <udp_sendto_if+0xf0>)
    8d64:	4798      	blx	r3
		if (err != ERR_OK) {
    8d66:	4605      	mov	r5, r0
    8d68:	2800      	cmp	r0, #0
    8d6a:	d13f      	bne.n	8dec <udp_sendto_if+0xa4>
	if (pbuf_header(p, UDP_HLEN)) {
    8d6c:	2108      	movs	r1, #8
    8d6e:	4638      	mov	r0, r7
    8d70:	4b32      	ldr	r3, [pc, #200]	; (8e3c <udp_sendto_if+0xf4>)
    8d72:	4798      	blx	r3
    8d74:	b168      	cbz	r0, 8d92 <udp_sendto_if+0x4a>
		q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    8d76:	2200      	movs	r2, #0
    8d78:	2108      	movs	r1, #8
    8d7a:	2001      	movs	r0, #1
    8d7c:	4b30      	ldr	r3, [pc, #192]	; (8e40 <udp_sendto_if+0xf8>)
    8d7e:	4798      	blx	r3
		if (q == NULL) {
    8d80:	4606      	mov	r6, r0
    8d82:	2800      	cmp	r0, #0
    8d84:	d052      	beq.n	8e2c <udp_sendto_if+0xe4>
		if (p->tot_len != 0) {
    8d86:	893b      	ldrh	r3, [r7, #8]
    8d88:	b123      	cbz	r3, 8d94 <udp_sendto_if+0x4c>
			pbuf_chain(q, p);
    8d8a:	4639      	mov	r1, r7
    8d8c:	4b2d      	ldr	r3, [pc, #180]	; (8e44 <udp_sendto_if+0xfc>)
    8d8e:	4798      	blx	r3
    8d90:	e000      	b.n	8d94 <udp_sendto_if+0x4c>
		q = p;
    8d92:	463e      	mov	r6, r7
	udphdr       = (struct udp_hdr *)q->payload;
    8d94:	6875      	ldr	r5, [r6, #4]
	udphdr->src  = htons(pcb->local_port);
    8d96:	8a60      	ldrh	r0, [r4, #18]
    8d98:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 8e48 <udp_sendto_if+0x100>
    8d9c:	47c0      	blx	r8
    8d9e:	8028      	strh	r0, [r5, #0]
	udphdr->dest = htons(dst_port);
    8da0:	4658      	mov	r0, fp
    8da2:	47c0      	blx	r8
    8da4:	8068      	strh	r0, [r5, #2]
	udphdr->chksum = 0x0000;
    8da6:	2300      	movs	r3, #0
    8da8:	71ab      	strb	r3, [r5, #6]
    8daa:	71eb      	strb	r3, [r5, #7]
	if (ip_addr_isany(&pcb->local_ip)) {
    8dac:	46a0      	mov	r8, r4
    8dae:	b10c      	cbz	r4, 8db4 <udp_sendto_if+0x6c>
    8db0:	6823      	ldr	r3, [r4, #0]
    8db2:	b9fb      	cbnz	r3, 8df4 <udp_sendto_if+0xac>
		src_ip = &(netif->ip_addr);
    8db4:	f109 0804 	add.w	r8, r9, #4
		udphdr->len = htons(q->tot_len);
    8db8:	8930      	ldrh	r0, [r6, #8]
    8dba:	4b23      	ldr	r3, [pc, #140]	; (8e48 <udp_sendto_if+0x100>)
    8dbc:	4798      	blx	r3
    8dbe:	80a8      	strh	r0, [r5, #4]
		if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
    8dc0:	7c23      	ldrb	r3, [r4, #16]
    8dc2:	f013 0f01 	tst.w	r3, #1
    8dc6:	d021      	beq.n	8e0c <udp_sendto_if+0xc4>
		err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
    8dc8:	7aa3      	ldrb	r3, [r4, #10]
    8dca:	f8cd 9008 	str.w	r9, [sp, #8]
    8dce:	2211      	movs	r2, #17
    8dd0:	9201      	str	r2, [sp, #4]
    8dd2:	7a62      	ldrb	r2, [r4, #9]
    8dd4:	9200      	str	r2, [sp, #0]
    8dd6:	4652      	mov	r2, sl
    8dd8:	4641      	mov	r1, r8
    8dda:	4630      	mov	r0, r6
    8ddc:	4c1b      	ldr	r4, [pc, #108]	; (8e4c <udp_sendto_if+0x104>)
    8dde:	47a0      	blx	r4
    8de0:	4605      	mov	r5, r0
	if (q != p) {
    8de2:	42be      	cmp	r6, r7
    8de4:	d002      	beq.n	8dec <udp_sendto_if+0xa4>
		pbuf_free(q);
    8de6:	4630      	mov	r0, r6
    8de8:	4b19      	ldr	r3, [pc, #100]	; (8e50 <udp_sendto_if+0x108>)
    8dea:	4798      	blx	r3
}
    8dec:	4628      	mov	r0, r5
    8dee:	b005      	add	sp, #20
    8df0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
    8df4:	f8d9 2004 	ldr.w	r2, [r9, #4]
    8df8:	4293      	cmp	r3, r2
    8dfa:	d0dd      	beq.n	8db8 <udp_sendto_if+0x70>
			if (q != p) {
    8dfc:	42be      	cmp	r6, r7
    8dfe:	d018      	beq.n	8e32 <udp_sendto_if+0xea>
				pbuf_free(q);
    8e00:	4630      	mov	r0, r6
    8e02:	4b13      	ldr	r3, [pc, #76]	; (8e50 <udp_sendto_if+0x108>)
    8e04:	4798      	blx	r3
			return ERR_VAL;
    8e06:	f06f 0505 	mvn.w	r5, #5
    8e0a:	e7ef      	b.n	8dec <udp_sendto_if+0xa4>
				udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
    8e0c:	8933      	ldrh	r3, [r6, #8]
    8e0e:	9300      	str	r3, [sp, #0]
    8e10:	2311      	movs	r3, #17
    8e12:	4652      	mov	r2, sl
    8e14:	4641      	mov	r1, r8
    8e16:	4630      	mov	r0, r6
    8e18:	f8df b038 	ldr.w	fp, [pc, #56]	; 8e54 <udp_sendto_if+0x10c>
    8e1c:	47d8      	blx	fp
			udphdr->chksum = udpchksum;
    8e1e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8e22:	2800      	cmp	r0, #0
    8e24:	bf08      	it	eq
    8e26:	4618      	moveq	r0, r3
    8e28:	80e8      	strh	r0, [r5, #6]
    8e2a:	e7cd      	b.n	8dc8 <udp_sendto_if+0x80>
			return ERR_MEM;
    8e2c:	f04f 35ff 	mov.w	r5, #4294967295
    8e30:	e7dc      	b.n	8dec <udp_sendto_if+0xa4>
			return ERR_VAL;
    8e32:	f06f 0505 	mvn.w	r5, #5
    8e36:	e7d9      	b.n	8dec <udp_sendto_if+0xa4>
    8e38:	00008c6d 	.word	0x00008c6d
    8e3c:	00005c8d 	.word	0x00005c8d
    8e40:	00005d89 	.word	0x00005d89
    8e44:	00005f95 	.word	0x00005f95
    8e48:	00002f3d 	.word	0x00002f3d
    8e4c:	00004e55 	.word	0x00004e55
    8e50:	00005d21 	.word	0x00005d21
    8e54:	00004b29 	.word	0x00004b29

00008e58 <udp_sendto>:
{
    8e58:	b5f0      	push	{r4, r5, r6, r7, lr}
    8e5a:	b083      	sub	sp, #12
    8e5c:	4605      	mov	r5, r0
    8e5e:	460e      	mov	r6, r1
    8e60:	4614      	mov	r4, r2
    8e62:	461f      	mov	r7, r3
	netif = ip_route(dst_ip);
    8e64:	4610      	mov	r0, r2
    8e66:	4b07      	ldr	r3, [pc, #28]	; (8e84 <udp_sendto+0x2c>)
    8e68:	4798      	blx	r3
	if (netif == NULL) {
    8e6a:	b140      	cbz	r0, 8e7e <udp_sendto+0x26>
	return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
    8e6c:	9000      	str	r0, [sp, #0]
    8e6e:	463b      	mov	r3, r7
    8e70:	4622      	mov	r2, r4
    8e72:	4631      	mov	r1, r6
    8e74:	4628      	mov	r0, r5
    8e76:	4c04      	ldr	r4, [pc, #16]	; (8e88 <udp_sendto+0x30>)
    8e78:	47a0      	blx	r4
}
    8e7a:	b003      	add	sp, #12
    8e7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_RTE;
    8e7e:	f06f 0003 	mvn.w	r0, #3
    8e82:	e7fa      	b.n	8e7a <udp_sendto+0x22>
    8e84:	00004c25 	.word	0x00004c25
    8e88:	00008d49 	.word	0x00008d49

00008e8c <udp_connect>:
 * The udp pcb is bound to a random local port if not already bound.
 *
 * @see udp_disconnect()
 */
err_t udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    8e8c:	b570      	push	{r4, r5, r6, lr}
    8e8e:	4604      	mov	r4, r0
    8e90:	460d      	mov	r5, r1
    8e92:	4616      	mov	r6, r2
	struct udp_pcb *ipcb;

	if (pcb->local_port == 0) {
    8e94:	8a43      	ldrh	r3, [r0, #18]
    8e96:	b19b      	cbz	r3, 8ec0 <udp_connect+0x34>
		if (err != ERR_OK) {
			return err;
		}
	}

	ip_addr_set(&pcb->remote_ip, ipaddr);
    8e98:	b1d5      	cbz	r5, 8ed0 <udp_connect+0x44>
    8e9a:	682b      	ldr	r3, [r5, #0]
    8e9c:	6063      	str	r3, [r4, #4]
	pcb->remote_port = port;
    8e9e:	82a6      	strh	r6, [r4, #20]
	pcb->flags |= UDP_FLAGS_CONNECTED;
    8ea0:	7c23      	ldrb	r3, [r4, #16]
    8ea2:	f043 0304 	orr.w	r3, r3, #4
    8ea6:	7423      	strb	r3, [r4, #16]
	             ip4_addr3_16(&pcb->local_ip),
	             ip4_addr4_16(&pcb->local_ip),
	             pcb->local_port));

	/* Insert UDP PCB into the list of active UDP PCBs. */
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    8ea8:	4b0e      	ldr	r3, [pc, #56]	; (8ee4 <udp_connect+0x58>)
    8eaa:	681a      	ldr	r2, [r3, #0]
    8eac:	b192      	cbz	r2, 8ed4 <udp_connect+0x48>
		if (pcb == ipcb) {
    8eae:	4294      	cmp	r4, r2
    8eb0:	d016      	beq.n	8ee0 <udp_connect+0x54>
    8eb2:	4613      	mov	r3, r2
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    8eb4:	68db      	ldr	r3, [r3, #12]
    8eb6:	b16b      	cbz	r3, 8ed4 <udp_connect+0x48>
		if (pcb == ipcb) {
    8eb8:	429c      	cmp	r4, r3
    8eba:	d1fb      	bne.n	8eb4 <udp_connect+0x28>
			/* already on the list, just return */
			return ERR_OK;
    8ebc:	2300      	movs	r3, #0
    8ebe:	e00d      	b.n	8edc <udp_connect+0x50>
		err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    8ec0:	2200      	movs	r2, #0
    8ec2:	4601      	mov	r1, r0
    8ec4:	4b08      	ldr	r3, [pc, #32]	; (8ee8 <udp_connect+0x5c>)
    8ec6:	4798      	blx	r3
		if (err != ERR_OK) {
    8ec8:	4603      	mov	r3, r0
    8eca:	2800      	cmp	r0, #0
    8ecc:	d0e4      	beq.n	8e98 <udp_connect+0xc>
    8ece:	e005      	b.n	8edc <udp_connect+0x50>
	ip_addr_set(&pcb->remote_ip, ipaddr);
    8ed0:	2300      	movs	r3, #0
    8ed2:	e7e3      	b.n	8e9c <udp_connect+0x10>
		}
	}
	/* PCB not yet on the list, add PCB now */
	pcb->next = udp_pcbs;
    8ed4:	60e2      	str	r2, [r4, #12]
	udp_pcbs  = pcb;
    8ed6:	4b03      	ldr	r3, [pc, #12]	; (8ee4 <udp_connect+0x58>)
    8ed8:	601c      	str	r4, [r3, #0]
	return ERR_OK;
    8eda:	2300      	movs	r3, #0
}
    8edc:	4618      	mov	r0, r3
    8ede:	bd70      	pop	{r4, r5, r6, pc}
			return ERR_OK;
    8ee0:	2300      	movs	r3, #0
    8ee2:	e7fb      	b.n	8edc <udp_connect+0x50>
    8ee4:	2000931c 	.word	0x2000931c
    8ee8:	00008c6d 	.word	0x00008c6d

00008eec <udp_recv>:
 * @param recv_arg additional argument to pass to the callback function
 */
void udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
	/* remember recv() callback and user data */
	pcb->recv     = recv;
    8eec:	6181      	str	r1, [r0, #24]
	pcb->recv_arg = recv_arg;
    8eee:	61c2      	str	r2, [r0, #28]
    8ef0:	4770      	bx	lr
	...

00008ef4 <udp_remove>:
 * UDP PCB's and the data structure is freed from memory.
 *
 * @see udp_new()
 */
void udp_remove(struct udp_pcb *pcb)
{
    8ef4:	b508      	push	{r3, lr}
    8ef6:	4601      	mov	r1, r0
	struct udp_pcb *pcb2;

	snmp_delete_udpidx_tree(pcb);
	/* pcb to be removed is first in list? */
	if (udp_pcbs == pcb) {
    8ef8:	4b0b      	ldr	r3, [pc, #44]	; (8f28 <udp_remove+0x34>)
    8efa:	681a      	ldr	r2, [r3, #0]
    8efc:	4282      	cmp	r2, r0
    8efe:	d001      	beq.n	8f04 <udp_remove+0x10>
		/* make list start at 2nd pcb */
		udp_pcbs = udp_pcbs->next;
		/* pcb not 1st in list */
	} else {
		for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    8f00:	b942      	cbnz	r2, 8f14 <udp_remove+0x20>
    8f02:	e002      	b.n	8f0a <udp_remove+0x16>
		udp_pcbs = udp_pcbs->next;
    8f04:	68d2      	ldr	r2, [r2, #12]
    8f06:	4b08      	ldr	r3, [pc, #32]	; (8f28 <udp_remove+0x34>)
    8f08:	601a      	str	r2, [r3, #0]
				/* remove pcb from list */
				pcb2->next = pcb->next;
			}
		}
	}
	memp_free(MEMP_UDP_PCB, pcb);
    8f0a:	2001      	movs	r0, #1
    8f0c:	4b07      	ldr	r3, [pc, #28]	; (8f2c <udp_remove+0x38>)
    8f0e:	4798      	blx	r3
    8f10:	bd08      	pop	{r3, pc}
{
    8f12:	461a      	mov	r2, r3
			if (pcb2->next != NULL && pcb2->next == pcb) {
    8f14:	68d3      	ldr	r3, [r2, #12]
    8f16:	2b00      	cmp	r3, #0
    8f18:	d0f7      	beq.n	8f0a <udp_remove+0x16>
    8f1a:	4299      	cmp	r1, r3
    8f1c:	d1f9      	bne.n	8f12 <udp_remove+0x1e>
				pcb2->next = pcb->next;
    8f1e:	68cb      	ldr	r3, [r1, #12]
    8f20:	60d3      	str	r3, [r2, #12]
		for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    8f22:	2b00      	cmp	r3, #0
    8f24:	d1f5      	bne.n	8f12 <udp_remove+0x1e>
    8f26:	e7f0      	b.n	8f0a <udp_remove+0x16>
    8f28:	2000931c 	.word	0x2000931c
    8f2c:	00005a59 	.word	0x00005a59

00008f30 <udp_new>:
 * could not be allocated.
 *
 * @see udp_remove()
 */
struct udp_pcb *udp_new(void)
{
    8f30:	b510      	push	{r4, lr}
	struct udp_pcb *pcb;
	pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
    8f32:	2001      	movs	r0, #1
    8f34:	4b05      	ldr	r3, [pc, #20]	; (8f4c <udp_new+0x1c>)
    8f36:	4798      	blx	r3
	/* could allocate UDP PCB? */
	if (pcb != NULL) {
    8f38:	4604      	mov	r4, r0
    8f3a:	b128      	cbz	r0, 8f48 <udp_new+0x18>
		/* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
		 * which means checksum is generated over the whole datagram per default
		 * (recommended as default by RFC 3828). */
		/* initialize PCB to all zeroes */
		memset(pcb, 0, sizeof(struct udp_pcb));
    8f3c:	2220      	movs	r2, #32
    8f3e:	2100      	movs	r1, #0
    8f40:	4b03      	ldr	r3, [pc, #12]	; (8f50 <udp_new+0x20>)
    8f42:	4798      	blx	r3
		pcb->ttl = UDP_TTL;
    8f44:	23ff      	movs	r3, #255	; 0xff
    8f46:	72a3      	strb	r3, [r4, #10]
	}
	return pcb;
}
    8f48:	4620      	mov	r0, r4
    8f4a:	bd10      	pop	{r4, pc}
    8f4c:	00005a11 	.word	0x00005a11
    8f50:	0000a101 	.word	0x0000a101

00008f54 <etharp_free_entry>:

#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void etharp_free_entry(int i)
{
    8f54:	b510      	push	{r4, lr}
    8f56:	4604      	mov	r4, r0
	/* remove from SNMP ARP index tree */
	snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
	/* and empty packet queue */
	if (arp_table[i].q != NULL) {
    8f58:	eb00 0280 	add.w	r2, r0, r0, lsl #2
    8f5c:	4b0c      	ldr	r3, [pc, #48]	; (8f90 <etharp_free_entry+0x3c>)
    8f5e:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    8f62:	b138      	cbz	r0, 8f74 <etharp_free_entry+0x20>
		/* remove all queued packets */
		LWIP_DEBUGF(
		    ETHARP_DEBUG,
		    ("etharp_free_entry: freeing entry %" U16_F ", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
		free_etharp_q(arp_table[i].q);
    8f64:	4b0b      	ldr	r3, [pc, #44]	; (8f94 <etharp_free_entry+0x40>)
    8f66:	4798      	blx	r3
		arp_table[i].q = NULL;
    8f68:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    8f6c:	009b      	lsls	r3, r3, #2
    8f6e:	2100      	movs	r1, #0
    8f70:	4a07      	ldr	r2, [pc, #28]	; (8f90 <etharp_free_entry+0x3c>)
    8f72:	50d1      	str	r1, [r2, r3]
	}
	/* recycle entry for re-use */
	arp_table[i].state = ETHARP_STATE_EMPTY;
    8f74:	4906      	ldr	r1, [pc, #24]	; (8f90 <etharp_free_entry+0x3c>)
    8f76:	00a0      	lsls	r0, r4, #2
    8f78:	1902      	adds	r2, r0, r4
    8f7a:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    8f7e:	2300      	movs	r3, #0
    8f80:	7493      	strb	r3, [r2, #18]
#ifdef LWIP_DEBUG
	/* for debugging, clean out the complete entry */
	arp_table[i].ctime = 0;
    8f82:	74d3      	strb	r3, [r2, #19]
	arp_table[i].netif = NULL;
    8f84:	6093      	str	r3, [r2, #8]
	ip_addr_set_zero(&arp_table[i].ipaddr);
    8f86:	6053      	str	r3, [r2, #4]
	arp_table[i].ethaddr = ethzero;
    8f88:	4614      	mov	r4, r2
    8f8a:	60e3      	str	r3, [r4, #12]
    8f8c:	8223      	strh	r3, [r4, #16]
    8f8e:	bd10      	pop	{r4, pc}
    8f90:	20007fd8 	.word	0x20007fd8
    8f94:	00005d21 	.word	0x00005d21

00008f98 <etharp_find_entry>:
 *
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
    8f98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8f9c:	b083      	sub	sp, #12
    8f9e:	4a3c      	ldr	r2, [pc, #240]	; (9090 <etharp_find_entry+0xf8>)
    8fa0:	2300      	movs	r3, #0
	s8_t empty = ARP_TABLE_SIZE;
	u8_t i = 0, age_pending = 0, age_stable = 0;
	/* oldest entry with packets on queue */
	s8_t old_queue = ARP_TABLE_SIZE;
	/* its age */
	u8_t age_queue = 0;
    8fa2:	4699      	mov	r9, r3
	s8_t old_queue = ARP_TABLE_SIZE;
    8fa4:	f04f 0e0a 	mov.w	lr, #10
	u8_t i = 0, age_pending = 0, age_stable = 0;
    8fa8:	469c      	mov	ip, r3
	s8_t empty = ARP_TABLE_SIZE;
    8faa:	4675      	mov	r5, lr
	s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
    8fac:	46f0      	mov	r8, lr
    8fae:	46f2      	mov	sl, lr
    8fb0:	9301      	str	r3, [sp, #4]
    8fb2:	e005      	b.n	8fc0 <etharp_find_entry+0x28>
	 */

	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
		u8_t state = arp_table[i].state;
		/* no empty entry found yet and now we do find one? */
		if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    8fb4:	b957      	cbnz	r7, 8fcc <etharp_find_entry+0x34>
			LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %" U16_F "\n", (u16_t)i));
			/* remember first empty entry */
			empty = i;
    8fb6:	b25d      	sxtb	r5, r3
    8fb8:	3301      	adds	r3, #1
    8fba:	3214      	adds	r2, #20
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    8fbc:	2b0a      	cmp	r3, #10
    8fbe:	d029      	beq.n	9014 <etharp_find_entry+0x7c>
    8fc0:	4614      	mov	r4, r2
		u8_t state = arp_table[i].state;
    8fc2:	7c97      	ldrb	r7, [r2, #18]
		if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    8fc4:	2d0a      	cmp	r5, #10
    8fc6:	d0f5      	beq.n	8fb4 <etharp_find_entry+0x1c>
		} else if (state != ETHARP_STATE_EMPTY) {
    8fc8:	2f00      	cmp	r7, #0
    8fca:	d0f5      	beq.n	8fb8 <etharp_find_entry+0x20>
			LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
			            state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
			/* if given, does IP address match IP address in ARP entry? */
			if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
    8fcc:	b120      	cbz	r0, 8fd8 <etharp_find_entry+0x40>
    8fce:	6806      	ldr	r6, [r0, #0]
    8fd0:	46b3      	mov	fp, r6
    8fd2:	6866      	ldr	r6, [r4, #4]
    8fd4:	45b3      	cmp	fp, r6
    8fd6:	d00a      	beq.n	8fee <etharp_find_entry+0x56>
				            ("etharp_find_entry: found matching entry %" U16_F "\n", (u16_t)i));
				/* found exact IP address match, simply bail out */
				return i;
			}
			/* pending entry? */
			if (state == ETHARP_STATE_PENDING) {
    8fd8:	2f01      	cmp	r7, #1
    8fda:	d00a      	beq.n	8ff2 <etharp_find_entry+0x5a>
						old_pending = i;
						age_pending = arp_table[i].ctime;
					}
				}
				/* stable entry? */
			} else if (state >= ETHARP_STATE_STABLE) {
    8fdc:	2f01      	cmp	r7, #1
    8fde:	d9eb      	bls.n	8fb8 <etharp_find_entry+0x20>
				/* don't record old_stable for static entries since they never expire */
				if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
				{
					/* remember entry with oldest stable entry in oldest, its age in maxtime */
					if (arp_table[i].ctime >= age_stable) {
    8fe0:	7ce4      	ldrb	r4, [r4, #19]
    8fe2:	4564      	cmp	r4, ip
						old_stable = i;
    8fe4:	bf24      	itt	cs
    8fe6:	fa4f f883 	sxtbcs.w	r8, r3
						age_stable = arp_table[i].ctime;
    8fea:	46a4      	movcs	ip, r4
    8fec:	e7e4      	b.n	8fb8 <etharp_find_entry+0x20>
				return i;
    8fee:	b258      	sxtb	r0, r3
    8ff0:	e029      	b.n	9046 <etharp_find_entry+0xae>
				if (arp_table[i].q != NULL) {
    8ff2:	6827      	ldr	r7, [r4, #0]
    8ff4:	b137      	cbz	r7, 9004 <etharp_find_entry+0x6c>
					if (arp_table[i].ctime >= age_queue) {
    8ff6:	7ce4      	ldrb	r4, [r4, #19]
    8ff8:	454c      	cmp	r4, r9
    8ffa:	d3dd      	bcc.n	8fb8 <etharp_find_entry+0x20>
						old_queue = i;
    8ffc:	fa4f fe83 	sxtb.w	lr, r3
						age_queue = arp_table[i].ctime;
    9000:	46a1      	mov	r9, r4
    9002:	e7d9      	b.n	8fb8 <etharp_find_entry+0x20>
					if (arp_table[i].ctime >= age_pending) {
    9004:	7ce4      	ldrb	r4, [r4, #19]
    9006:	9e01      	ldr	r6, [sp, #4]
    9008:	42b4      	cmp	r4, r6
    900a:	d3d5      	bcc.n	8fb8 <etharp_find_entry+0x20>
						old_pending = i;
    900c:	fa4f fa83 	sxtb.w	sl, r3
						age_pending = arp_table[i].ctime;
    9010:	9401      	str	r4, [sp, #4]
    9012:	e7d1      	b.n	8fb8 <etharp_find_entry+0x20>
		}
	}
	/* { we have no match } => try to create a new entry */

	/* don't create new entry, only search? */
	if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
    9014:	f011 0f02 	tst.w	r1, #2
    9018:	d130      	bne.n	907c <etharp_find_entry+0xe4>
    901a:	4604      	mov	r4, r0
    901c:	2d0a      	cmp	r5, #10
    901e:	d015      	beq.n	904c <etharp_find_entry+0xb4>
	 *
	 * { ETHARP_FLAG_TRY_HARD is set at this point }
	 */

	/* 1) empty entry available? */
	if (empty < ARP_TABLE_SIZE) {
    9020:	2d09      	cmp	r5, #9
    9022:	dc16      	bgt.n	9052 <etharp_find_entry+0xba>
		i = empty;
    9024:	b2ed      	uxtb	r5, r5

	LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
	LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY", arp_table[i].state == ETHARP_STATE_EMPTY);

	/* IP address given? */
	if (ipaddr != NULL) {
    9026:	b134      	cbz	r4, 9036 <etharp_find_entry+0x9e>
		/* set IP address */
		ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
    9028:	6821      	ldr	r1, [r4, #0]
    902a:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    902e:	4a18      	ldr	r2, [pc, #96]	; (9090 <etharp_find_entry+0xf8>)
    9030:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    9034:	6059      	str	r1, [r3, #4]
	}
	arp_table[i].ctime = 0;
    9036:	eb05 0285 	add.w	r2, r5, r5, lsl #2
    903a:	4b15      	ldr	r3, [pc, #84]	; (9090 <etharp_find_entry+0xf8>)
    903c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    9040:	2200      	movs	r2, #0
    9042:	74da      	strb	r2, [r3, #19]
	return (err_t)i;
    9044:	b268      	sxtb	r0, r5
}
    9046:	b003      	add	sp, #12
    9048:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
    904c:	f011 0f01 	tst.w	r1, #1
    9050:	d017      	beq.n	9082 <etharp_find_entry+0xea>
		if (old_stable < ARP_TABLE_SIZE) {
    9052:	f1b8 0f09 	cmp.w	r8, #9
    9056:	dc05      	bgt.n	9064 <etharp_find_entry+0xcc>
			i = old_stable;
    9058:	fa5f f588 	uxtb.w	r5, r8
		etharp_free_entry(i);
    905c:	4628      	mov	r0, r5
    905e:	4b0d      	ldr	r3, [pc, #52]	; (9094 <etharp_find_entry+0xfc>)
    9060:	4798      	blx	r3
    9062:	e7e0      	b.n	9026 <etharp_find_entry+0x8e>
		} else if (old_pending < ARP_TABLE_SIZE) {
    9064:	f1ba 0f09 	cmp.w	sl, #9
    9068:	dc02      	bgt.n	9070 <etharp_find_entry+0xd8>
			i = old_pending;
    906a:	fa5f f58a 	uxtb.w	r5, sl
    906e:	e7f5      	b.n	905c <etharp_find_entry+0xc4>
		} else if (old_queue < ARP_TABLE_SIZE) {
    9070:	f1be 0f09 	cmp.w	lr, #9
    9074:	dc08      	bgt.n	9088 <etharp_find_entry+0xf0>
			i = old_queue;
    9076:	fa5f f58e 	uxtb.w	r5, lr
    907a:	e7ef      	b.n	905c <etharp_find_entry+0xc4>
		return (s8_t)ERR_MEM;
    907c:	f04f 30ff 	mov.w	r0, #4294967295
    9080:	e7e1      	b.n	9046 <etharp_find_entry+0xae>
    9082:	f04f 30ff 	mov.w	r0, #4294967295
    9086:	e7de      	b.n	9046 <etharp_find_entry+0xae>
			return (s8_t)ERR_MEM;
    9088:	f04f 30ff 	mov.w	r0, #4294967295
    908c:	e7db      	b.n	9046 <etharp_find_entry+0xae>
    908e:	bf00      	nop
    9090:	20007fd8 	.word	0x20007fd8
    9094:	00008f55 	.word	0x00008f55

00009098 <etharp_send_ip>:
 * @params src the source MAC address to be copied into the ethernet header
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
    9098:	b538      	push	{r3, r4, r5, lr}
	struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    909a:	684c      	ldr	r4, [r1, #4]

	LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
	            (netif->hwaddr_len == ETHARP_HWADDR_LEN));
	ETHADDR32_COPY(&ethhdr->dest, dst);
    909c:	681d      	ldr	r5, [r3, #0]
    909e:	6025      	str	r5, [r4, #0]
    90a0:	889b      	ldrh	r3, [r3, #4]
    90a2:	80a3      	strh	r3, [r4, #4]
	ETHADDR16_COPY(&ethhdr->src, src);
    90a4:	6813      	ldr	r3, [r2, #0]
    90a6:	f8c4 3006 	str.w	r3, [r4, #6]
    90aa:	8893      	ldrh	r3, [r2, #4]
    90ac:	8163      	strh	r3, [r4, #10]
	ethhdr->type = PP_HTONS(ETHTYPE_IP);
    90ae:	2308      	movs	r3, #8
    90b0:	7323      	strb	r3, [r4, #12]
    90b2:	2300      	movs	r3, #0
    90b4:	7363      	strb	r3, [r4, #13]
	LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
	/* send the packet */
	return netif->linkoutput(netif, p);
    90b6:	6983      	ldr	r3, [r0, #24]
    90b8:	4798      	blx	r3
}
    90ba:	bd38      	pop	{r3, r4, r5, pc}

000090bc <etharp_tmr>:
{
    90bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    90be:	4c0e      	ldr	r4, [pc, #56]	; (90f8 <etharp_tmr+0x3c>)
    90c0:	2500      	movs	r5, #0
				etharp_free_entry(i);
    90c2:	4e0e      	ldr	r6, [pc, #56]	; (90fc <etharp_tmr+0x40>)
				arp_table[i].state = ETHARP_STATE_STABLE;
    90c4:	2702      	movs	r7, #2
    90c6:	e006      	b.n	90d6 <etharp_tmr+0x1a>
			} else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
    90c8:	2a03      	cmp	r2, #3
				arp_table[i].state = ETHARP_STATE_STABLE;
    90ca:	bf08      	it	eq
    90cc:	74a7      	strbeq	r7, [r4, #18]
    90ce:	3501      	adds	r5, #1
    90d0:	3414      	adds	r4, #20
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    90d2:	2d0a      	cmp	r5, #10
    90d4:	d00f      	beq.n	90f6 <etharp_tmr+0x3a>
		u8_t state = arp_table[i].state;
    90d6:	4628      	mov	r0, r5
    90d8:	7ca2      	ldrb	r2, [r4, #18]
		if (state != ETHARP_STATE_EMPTY
    90da:	2a00      	cmp	r2, #0
    90dc:	d0f7      	beq.n	90ce <etharp_tmr+0x12>
			arp_table[i].ctime++;
    90de:	7ce3      	ldrb	r3, [r4, #19]
    90e0:	3301      	adds	r3, #1
    90e2:	b2db      	uxtb	r3, r3
    90e4:	74e3      	strb	r3, [r4, #19]
			if ((arp_table[i].ctime >= ARP_MAXAGE)
    90e6:	2bef      	cmp	r3, #239	; 0xef
    90e8:	d803      	bhi.n	90f2 <etharp_tmr+0x36>
			    || ((arp_table[i].state == ETHARP_STATE_PENDING) && (arp_table[i].ctime >= ARP_MAXPENDING))) {
    90ea:	2a01      	cmp	r2, #1
    90ec:	d1ec      	bne.n	90c8 <etharp_tmr+0xc>
    90ee:	2b01      	cmp	r3, #1
    90f0:	d9ed      	bls.n	90ce <etharp_tmr+0x12>
				etharp_free_entry(i);
    90f2:	47b0      	blx	r6
    90f4:	e7eb      	b.n	90ce <etharp_tmr+0x12>
}
    90f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    90f8:	20007fd8 	.word	0x20007fd8
    90fc:	00008f55 	.word	0x00008f55

00009100 <etharp_cleanup_netif>:
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
    9100:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9102:	4606      	mov	r6, r0
    9104:	4d08      	ldr	r5, [pc, #32]	; (9128 <etharp_cleanup_netif+0x28>)
    9106:	2400      	movs	r4, #0
	u8_t i;

	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
		u8_t state = arp_table[i].state;
		if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
			etharp_free_entry(i);
    9108:	4f08      	ldr	r7, [pc, #32]	; (912c <etharp_cleanup_netif+0x2c>)
    910a:	e003      	b.n	9114 <etharp_cleanup_netif+0x14>
    910c:	3401      	adds	r4, #1
    910e:	3514      	adds	r5, #20
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    9110:	2c0a      	cmp	r4, #10
    9112:	d008      	beq.n	9126 <etharp_cleanup_netif+0x26>
		u8_t state = arp_table[i].state;
    9114:	4620      	mov	r0, r4
		if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
    9116:	7cab      	ldrb	r3, [r5, #18]
    9118:	2b00      	cmp	r3, #0
    911a:	d0f7      	beq.n	910c <etharp_cleanup_netif+0xc>
    911c:	68ab      	ldr	r3, [r5, #8]
    911e:	42b3      	cmp	r3, r6
    9120:	d1f4      	bne.n	910c <etharp_cleanup_netif+0xc>
			etharp_free_entry(i);
    9122:	47b8      	blx	r7
    9124:	e7f2      	b.n	910c <etharp_cleanup_netif+0xc>
		}
	}
}
    9126:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9128:	20007fd8 	.word	0x20007fd8
    912c:	00008f55 	.word	0x00008f55

00009130 <etharp_request>:
 * @return ERR_OK if the request has been sent
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
    9130:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9134:	4605      	mov	r5, r0
    9136:	4688      	mov	r8, r1
	p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
    9138:	2200      	movs	r2, #0
    913a:	212a      	movs	r1, #42	; 0x2a
    913c:	2003      	movs	r0, #3
    913e:	4b21      	ldr	r3, [pc, #132]	; (91c4 <etharp_request+0x94>)
    9140:	4798      	blx	r3
	if (p == NULL) {
    9142:	2800      	cmp	r0, #0
    9144:	d03b      	beq.n	91be <etharp_request+0x8e>
    9146:	4607      	mov	r7, r0
	ethhdr = (struct eth_hdr *)p->payload;
    9148:	6844      	ldr	r4, [r0, #4]
	hdr->opcode = htons(opcode);
    914a:	2001      	movs	r0, #1
    914c:	4b1e      	ldr	r3, [pc, #120]	; (91c8 <etharp_request+0x98>)
    914e:	4798      	blx	r3
    9150:	82a0      	strh	r0, [r4, #20]
	ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    9152:	f8d5 302f 	ldr.w	r3, [r5, #47]	; 0x2f
    9156:	f8c4 3016 	str.w	r3, [r4, #22]
    915a:	f8b5 3033 	ldrh.w	r3, [r5, #51]	; 0x33
    915e:	8363      	strh	r3, [r4, #26]
	ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    9160:	4b1a      	ldr	r3, [pc, #104]	; (91cc <etharp_request+0x9c>)
    9162:	6818      	ldr	r0, [r3, #0]
    9164:	6220      	str	r0, [r4, #32]
    9166:	889a      	ldrh	r2, [r3, #4]
    9168:	84a2      	strh	r2, [r4, #36]	; 0x24
	ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    916a:	6898      	ldr	r0, [r3, #8]
    916c:	6020      	str	r0, [r4, #0]
    916e:	899b      	ldrh	r3, [r3, #12]
    9170:	80a3      	strh	r3, [r4, #4]
	ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
    9172:	f8d5 302f 	ldr.w	r3, [r5, #47]	; 0x2f
    9176:	f8c4 3006 	str.w	r3, [r4, #6]
    917a:	f8b5 3033 	ldrh.w	r3, [r5, #51]	; 0x33
    917e:	8163      	strh	r3, [r4, #10]
	IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
    9180:	686b      	ldr	r3, [r5, #4]
    9182:	61e3      	str	r3, [r4, #28]
	IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
    9184:	f8d8 3000 	ldr.w	r3, [r8]
    9188:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
	hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    918c:	2200      	movs	r2, #0
    918e:	73a2      	strb	r2, [r4, #14]
    9190:	2301      	movs	r3, #1
    9192:	73e3      	strb	r3, [r4, #15]
	hdr->proto  = PP_HTONS(ETHTYPE_IP);
    9194:	2308      	movs	r3, #8
    9196:	7423      	strb	r3, [r4, #16]
    9198:	7462      	strb	r2, [r4, #17]
	hdr->hwlen    = ETHARP_HWADDR_LEN;
    919a:	2206      	movs	r2, #6
    919c:	74a2      	strb	r2, [r4, #18]
	hdr->protolen = sizeof(ip_addr_t);
    919e:	2204      	movs	r2, #4
    91a0:	74e2      	strb	r2, [r4, #19]
	ethhdr->type = PP_HTONS(ETHTYPE_ARP);
    91a2:	7323      	strb	r3, [r4, #12]
    91a4:	2306      	movs	r3, #6
    91a6:	7363      	strb	r3, [r4, #13]
	result = netif->linkoutput(netif, p);
    91a8:	69ab      	ldr	r3, [r5, #24]
    91aa:	4639      	mov	r1, r7
    91ac:	4628      	mov	r0, r5
    91ae:	4798      	blx	r3
    91b0:	4604      	mov	r4, r0
	pbuf_free(p);
    91b2:	4638      	mov	r0, r7
    91b4:	4b06      	ldr	r3, [pc, #24]	; (91d0 <etharp_request+0xa0>)
    91b6:	4798      	blx	r3
	                  (struct eth_addr *)netif->hwaddr,
	                  &netif->ip_addr,
	                  &ethzero,
	                  ipaddr,
	                  ARP_REQUEST);
}
    91b8:	4620      	mov	r0, r4
    91ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_MEM;
    91be:	f04f 34ff 	mov.w	r4, #4294967295
    91c2:	e7f9      	b.n	91b8 <etharp_request+0x88>
    91c4:	00005d89 	.word	0x00005d89
    91c8:	00002f3d 	.word	0x00002f3d
    91cc:	0000c718 	.word	0x0000c718
    91d0:	00005d21 	.word	0x00005d21

000091d4 <etharp_output_to_arp_index>:
{
    91d4:	b570      	push	{r4, r5, r6, lr}
    91d6:	4605      	mov	r5, r0
    91d8:	460e      	mov	r6, r1
    91da:	4614      	mov	r4, r2
	if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    91dc:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    91e0:	4b15      	ldr	r3, [pc, #84]	; (9238 <etharp_output_to_arp_index+0x64>)
    91e2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    91e6:	7c9b      	ldrb	r3, [r3, #18]
    91e8:	2b02      	cmp	r3, #2
    91ea:	d00c      	beq.n	9206 <etharp_output_to_arp_index+0x32>
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr);
    91ec:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    91f0:	4b11      	ldr	r3, [pc, #68]	; (9238 <etharp_output_to_arp_index+0x64>)
    91f2:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    91f6:	330c      	adds	r3, #12
    91f8:	f105 022f 	add.w	r2, r5, #47	; 0x2f
    91fc:	4631      	mov	r1, r6
    91fe:	4628      	mov	r0, r5
    9200:	4c0e      	ldr	r4, [pc, #56]	; (923c <etharp_output_to_arp_index+0x68>)
    9202:	47a0      	blx	r4
}
    9204:	bd70      	pop	{r4, r5, r6, pc}
	if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    9206:	4613      	mov	r3, r2
    9208:	4a0b      	ldr	r2, [pc, #44]	; (9238 <etharp_output_to_arp_index+0x64>)
    920a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    920e:	7cdb      	ldrb	r3, [r3, #19]
    9210:	2be3      	cmp	r3, #227	; 0xe3
    9212:	d9eb      	bls.n	91ec <etharp_output_to_arp_index+0x18>
		if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
    9214:	eb04 0184 	add.w	r1, r4, r4, lsl #2
    9218:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    921c:	3104      	adds	r1, #4
    921e:	4b08      	ldr	r3, [pc, #32]	; (9240 <etharp_output_to_arp_index+0x6c>)
    9220:	4798      	blx	r3
    9222:	2800      	cmp	r0, #0
    9224:	d1e2      	bne.n	91ec <etharp_output_to_arp_index+0x18>
			arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    9226:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    922a:	4a03      	ldr	r2, [pc, #12]	; (9238 <etharp_output_to_arp_index+0x64>)
    922c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    9230:	2203      	movs	r2, #3
    9232:	749a      	strb	r2, [r3, #18]
    9234:	e7da      	b.n	91ec <etharp_output_to_arp_index+0x18>
    9236:	bf00      	nop
    9238:	20007fd8 	.word	0x20007fd8
    923c:	00009099 	.word	0x00009099
    9240:	00009131 	.word	0x00009131

00009244 <etharp_query>:
{
    9244:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9248:	4680      	mov	r8, r0
    924a:	460d      	mov	r5, r1
    924c:	4616      	mov	r6, r2
	if (ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr) || ip_addr_isany(ipaddr)) {
    924e:	4601      	mov	r1, r0
    9250:	6828      	ldr	r0, [r5, #0]
    9252:	4b49      	ldr	r3, [pc, #292]	; (9378 <etharp_query+0x134>)
    9254:	4798      	blx	r3
    9256:	2800      	cmp	r0, #0
    9258:	d161      	bne.n	931e <etharp_query+0xda>
    925a:	682b      	ldr	r3, [r5, #0]
    925c:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    9260:	2ae0      	cmp	r2, #224	; 0xe0
    9262:	d05f      	beq.n	9324 <etharp_query+0xe0>
    9264:	2d00      	cmp	r5, #0
    9266:	d060      	beq.n	932a <etharp_query+0xe6>
    9268:	2b00      	cmp	r3, #0
    926a:	d061      	beq.n	9330 <etharp_query+0xec>
	i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
    926c:	2101      	movs	r1, #1
    926e:	4628      	mov	r0, r5
    9270:	4b42      	ldr	r3, [pc, #264]	; (937c <etharp_query+0x138>)
    9272:	4798      	blx	r3
	if (i < 0) {
    9274:	1e04      	subs	r4, r0, #0
    9276:	db49      	blt.n	930c <etharp_query+0xc8>
	if (arp_table[i].state == ETHARP_STATE_EMPTY) {
    9278:	4627      	mov	r7, r4
    927a:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    927e:	4a40      	ldr	r2, [pc, #256]	; (9380 <etharp_query+0x13c>)
    9280:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    9284:	7c9b      	ldrb	r3, [r3, #18]
    9286:	bb6b      	cbnz	r3, 92e4 <etharp_query+0xa0>
		arp_table[i].state = ETHARP_STATE_PENDING;
    9288:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    928c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    9290:	2201      	movs	r2, #1
    9292:	749a      	strb	r2, [r3, #18]
		result = etharp_request(netif, ipaddr);
    9294:	4629      	mov	r1, r5
    9296:	4640      	mov	r0, r8
    9298:	4b3a      	ldr	r3, [pc, #232]	; (9384 <etharp_query+0x140>)
    929a:	4798      	blx	r3
		if (q == NULL) {
    929c:	2e00      	cmp	r6, #0
    929e:	d04a      	beq.n	9336 <etharp_query+0xf2>
	if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    92a0:	eb07 0387 	add.w	r3, r7, r7, lsl #2
    92a4:	4a36      	ldr	r2, [pc, #216]	; (9380 <etharp_query+0x13c>)
    92a6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    92aa:	7c9b      	ldrb	r3, [r3, #18]
    92ac:	2b01      	cmp	r3, #1
    92ae:	d81e      	bhi.n	92ee <etharp_query+0xaa>
	} else if (arp_table[i].state == ETHARP_STATE_PENDING) {
    92b0:	2b01      	cmp	r3, #1
    92b2:	d142      	bne.n	933a <etharp_query+0xf6>
			if (p->type != PBUF_ROM) {
    92b4:	7b33      	ldrb	r3, [r6, #12]
    92b6:	2b01      	cmp	r3, #1
    92b8:	d15c      	bne.n	9374 <etharp_query+0x130>
    92ba:	4633      	mov	r3, r6
			p = p->next;
    92bc:	681b      	ldr	r3, [r3, #0]
		while (p) {
    92be:	2b00      	cmp	r3, #0
    92c0:	d046      	beq.n	9350 <etharp_query+0x10c>
			if (p->type != PBUF_ROM) {
    92c2:	7b1a      	ldrb	r2, [r3, #12]
    92c4:	2a01      	cmp	r2, #1
    92c6:	d0f9      	beq.n	92bc <etharp_query+0x78>
			p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    92c8:	2200      	movs	r2, #0
    92ca:	8919      	ldrh	r1, [r3, #8]
    92cc:	2003      	movs	r0, #3
    92ce:	4b2e      	ldr	r3, [pc, #184]	; (9388 <etharp_query+0x144>)
    92d0:	4798      	blx	r3
			if (p != NULL) {
    92d2:	4604      	mov	r4, r0
    92d4:	b300      	cbz	r0, 9318 <etharp_query+0xd4>
				if (pbuf_copy(p, q) != ERR_OK) {
    92d6:	4631      	mov	r1, r6
    92d8:	4620      	mov	r0, r4
    92da:	4b2c      	ldr	r3, [pc, #176]	; (938c <etharp_query+0x148>)
    92dc:	4798      	blx	r3
    92de:	b9c0      	cbnz	r0, 9312 <etharp_query+0xce>
			p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    92e0:	4626      	mov	r6, r4
    92e2:	e038      	b.n	9356 <etharp_query+0x112>
	if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    92e4:	2b01      	cmp	r3, #1
    92e6:	d0d5      	beq.n	9294 <etharp_query+0x50>
    92e8:	b34e      	cbz	r6, 933e <etharp_query+0xfa>
	if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    92ea:	2b01      	cmp	r3, #1
    92ec:	d92d      	bls.n	934a <etharp_query+0x106>
		ETHARP_SET_HINT(netif, i);
    92ee:	4b24      	ldr	r3, [pc, #144]	; (9380 <etharp_query+0x13c>)
    92f0:	f883 40c8 	strb.w	r4, [r3, #200]	; 0xc8
		result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    92f4:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    92f8:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    92fc:	330c      	adds	r3, #12
    92fe:	f108 022f 	add.w	r2, r8, #47	; 0x2f
    9302:	4631      	mov	r1, r6
    9304:	4640      	mov	r0, r8
    9306:	4c22      	ldr	r4, [pc, #136]	; (9390 <etharp_query+0x14c>)
    9308:	47a0      	blx	r4
    930a:	4604      	mov	r4, r0
}
    930c:	4620      	mov	r0, r4
    930e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					pbuf_free(p);
    9312:	4620      	mov	r0, r4
    9314:	4b1f      	ldr	r3, [pc, #124]	; (9394 <etharp_query+0x150>)
    9316:	4798      	blx	r3
			result = ERR_MEM;
    9318:	f04f 34ff 	mov.w	r4, #4294967295
    931c:	e7f6      	b.n	930c <etharp_query+0xc8>
		return ERR_ARG;
    931e:	f06f 040d 	mvn.w	r4, #13
    9322:	e7f3      	b.n	930c <etharp_query+0xc8>
    9324:	f06f 040d 	mvn.w	r4, #13
    9328:	e7f0      	b.n	930c <etharp_query+0xc8>
    932a:	f06f 040d 	mvn.w	r4, #13
    932e:	e7ed      	b.n	930c <etharp_query+0xc8>
    9330:	f06f 040d 	mvn.w	r4, #13
    9334:	e7ea      	b.n	930c <etharp_query+0xc8>
		result = etharp_request(netif, ipaddr);
    9336:	4604      	mov	r4, r0
    9338:	e7e8      	b.n	930c <etharp_query+0xc8>
    933a:	4604      	mov	r4, r0
    933c:	e7e6      	b.n	930c <etharp_query+0xc8>
    933e:	4629      	mov	r1, r5
    9340:	4640      	mov	r0, r8
    9342:	4b10      	ldr	r3, [pc, #64]	; (9384 <etharp_query+0x140>)
    9344:	4798      	blx	r3
    9346:	4604      	mov	r4, r0
    9348:	e7e0      	b.n	930c <etharp_query+0xc8>
	err_t            result  = ERR_MEM;
    934a:	f04f 34ff 	mov.w	r4, #4294967295
    934e:	e7dd      	b.n	930c <etharp_query+0xc8>
			pbuf_ref(p);
    9350:	4630      	mov	r0, r6
    9352:	4b11      	ldr	r3, [pc, #68]	; (9398 <etharp_query+0x154>)
    9354:	4798      	blx	r3
			if (arp_table[i].q != NULL) {
    9356:	eb07 0387 	add.w	r3, r7, r7, lsl #2
    935a:	4a09      	ldr	r2, [pc, #36]	; (9380 <etharp_query+0x13c>)
    935c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    9360:	b108      	cbz	r0, 9366 <etharp_query+0x122>
				pbuf_free(arp_table[i].q);
    9362:	4b0c      	ldr	r3, [pc, #48]	; (9394 <etharp_query+0x150>)
    9364:	4798      	blx	r3
			arp_table[i].q = p;
    9366:	eb07 0787 	add.w	r7, r7, r7, lsl #2
    936a:	4b05      	ldr	r3, [pc, #20]	; (9380 <etharp_query+0x13c>)
    936c:	f843 6027 	str.w	r6, [r3, r7, lsl #2]
			result = ERR_OK;
    9370:	2400      	movs	r4, #0
    9372:	e7cb      	b.n	930c <etharp_query+0xc8>
			if (p->type != PBUF_ROM) {
    9374:	4633      	mov	r3, r6
    9376:	e7a7      	b.n	92c8 <etharp_query+0x84>
    9378:	00004f91 	.word	0x00004f91
    937c:	00008f99 	.word	0x00008f99
    9380:	20007fd8 	.word	0x20007fd8
    9384:	00009131 	.word	0x00009131
    9388:	00005d89 	.word	0x00005d89
    938c:	00005fad 	.word	0x00005fad
    9390:	00009099 	.word	0x00009099
    9394:	00005d21 	.word	0x00005d21
    9398:	00005f3b 	.word	0x00005f3b

0000939c <etharp_output>:
{
    939c:	b570      	push	{r4, r5, r6, lr}
    939e:	b082      	sub	sp, #8
    93a0:	4605      	mov	r5, r0
    93a2:	460e      	mov	r6, r1
    93a4:	4614      	mov	r4, r2
	if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    93a6:	210e      	movs	r1, #14
    93a8:	4630      	mov	r0, r6
    93aa:	4b3d      	ldr	r3, [pc, #244]	; (94a0 <etharp_output+0x104>)
    93ac:	4798      	blx	r3
    93ae:	2800      	cmp	r0, #0
    93b0:	d16d      	bne.n	948e <etharp_output+0xf2>
	if (ip_addr_isbroadcast(ipaddr, netif)) {
    93b2:	4629      	mov	r1, r5
    93b4:	6820      	ldr	r0, [r4, #0]
    93b6:	4b3b      	ldr	r3, [pc, #236]	; (94a4 <etharp_output+0x108>)
    93b8:	4798      	blx	r3
    93ba:	2800      	cmp	r0, #0
    93bc:	d15e      	bne.n	947c <etharp_output+0xe0>
	} else if (ip_addr_ismulticast(ipaddr)) {
    93be:	6823      	ldr	r3, [r4, #0]
    93c0:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    93c4:	2ae0      	cmp	r2, #224	; 0xe0
    93c6:	d024      	beq.n	9412 <etharp_output+0x76>
		if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) && !ip_addr_islinklocal(ipaddr)) {
    93c8:	686a      	ldr	r2, [r5, #4]
    93ca:	405a      	eors	r2, r3
    93cc:	68a9      	ldr	r1, [r5, #8]
    93ce:	420a      	tst	r2, r1
    93d0:	d00a      	beq.n	93e8 <etharp_output+0x4c>
    93d2:	b29b      	uxth	r3, r3
    93d4:	f64f 62a9 	movw	r2, #65193	; 0xfea9
    93d8:	4293      	cmp	r3, r2
    93da:	d005      	beq.n	93e8 <etharp_output+0x4c>
				if (!ip_addr_isany(&netif->gw)) {
    93dc:	f115 040c 	adds.w	r4, r5, #12
    93e0:	d058      	beq.n	9494 <etharp_output+0xf8>
    93e2:	68eb      	ldr	r3, [r5, #12]
    93e4:	2b00      	cmp	r3, #0
    93e6:	d058      	beq.n	949a <etharp_output+0xfe>
				if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE)
    93e8:	4b2f      	ldr	r3, [pc, #188]	; (94a8 <etharp_output+0x10c>)
    93ea:	f893 20c8 	ldrb.w	r2, [r3, #200]	; 0xc8
    93ee:	eb02 0182 	add.w	r1, r2, r2, lsl #2
    93f2:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    93f6:	7c9b      	ldrb	r3, [r3, #18]
    93f8:	2b01      	cmp	r3, #1
    93fa:	d907      	bls.n	940c <etharp_output+0x70>
				    && (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
    93fc:	460b      	mov	r3, r1
    93fe:	492a      	ldr	r1, [pc, #168]	; (94a8 <etharp_output+0x10c>)
    9400:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    9404:	6821      	ldr	r1, [r4, #0]
    9406:	685b      	ldr	r3, [r3, #4]
    9408:	4299      	cmp	r1, r3
    940a:	d018      	beq.n	943e <etharp_output+0xa2>
    940c:	4b26      	ldr	r3, [pc, #152]	; (94a8 <etharp_output+0x10c>)
{
    940e:	2200      	movs	r2, #0
    9410:	e01e      	b.n	9450 <etharp_output+0xb4>
		mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    9412:	2301      	movs	r3, #1
    9414:	f88d 3000 	strb.w	r3, [sp]
		mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    9418:	2300      	movs	r3, #0
    941a:	f88d 3001 	strb.w	r3, [sp, #1]
		mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    941e:	235e      	movs	r3, #94	; 0x5e
    9420:	f88d 3002 	strb.w	r3, [sp, #2]
		mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    9424:	7863      	ldrb	r3, [r4, #1]
    9426:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    942a:	f88d 3003 	strb.w	r3, [sp, #3]
		mcastaddr.addr[4] = ip4_addr3(ipaddr);
    942e:	78a3      	ldrb	r3, [r4, #2]
    9430:	f88d 3004 	strb.w	r3, [sp, #4]
		mcastaddr.addr[5] = ip4_addr4(ipaddr);
    9434:	78e3      	ldrb	r3, [r4, #3]
    9436:	f88d 3005 	strb.w	r3, [sp, #5]
		dest = &mcastaddr;
    943a:	466b      	mov	r3, sp
    943c:	e01f      	b.n	947e <etharp_output+0xe2>
					return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
    943e:	4631      	mov	r1, r6
    9440:	4628      	mov	r0, r5
    9442:	4b1a      	ldr	r3, [pc, #104]	; (94ac <etharp_output+0x110>)
    9444:	4798      	blx	r3
    9446:	e020      	b.n	948a <etharp_output+0xee>
    9448:	3201      	adds	r2, #1
    944a:	3314      	adds	r3, #20
		for (i = 0; i < ARP_TABLE_SIZE; i++) {
    944c:	2a0a      	cmp	r2, #10
    944e:	d00f      	beq.n	9470 <etharp_output+0xd4>
			if ((arp_table[i].state >= ETHARP_STATE_STABLE) && (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
    9450:	7c99      	ldrb	r1, [r3, #18]
    9452:	2901      	cmp	r1, #1
    9454:	d9f8      	bls.n	9448 <etharp_output+0xac>
    9456:	6820      	ldr	r0, [r4, #0]
    9458:	6859      	ldr	r1, [r3, #4]
    945a:	4288      	cmp	r0, r1
    945c:	d1f4      	bne.n	9448 <etharp_output+0xac>
				ETHARP_SET_HINT(netif, i);
    945e:	b2d2      	uxtb	r2, r2
    9460:	4b11      	ldr	r3, [pc, #68]	; (94a8 <etharp_output+0x10c>)
    9462:	f883 20c8 	strb.w	r2, [r3, #200]	; 0xc8
				return etharp_output_to_arp_index(netif, q, i);
    9466:	4631      	mov	r1, r6
    9468:	4628      	mov	r0, r5
    946a:	4b10      	ldr	r3, [pc, #64]	; (94ac <etharp_output+0x110>)
    946c:	4798      	blx	r3
    946e:	e00c      	b.n	948a <etharp_output+0xee>
		return etharp_query(netif, dst_addr, q);
    9470:	4632      	mov	r2, r6
    9472:	4621      	mov	r1, r4
    9474:	4628      	mov	r0, r5
    9476:	4b0e      	ldr	r3, [pc, #56]	; (94b0 <etharp_output+0x114>)
    9478:	4798      	blx	r3
    947a:	e006      	b.n	948a <etharp_output+0xee>
		dest = (struct eth_addr *)&ethbroadcast;
    947c:	4b0d      	ldr	r3, [pc, #52]	; (94b4 <etharp_output+0x118>)
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), dest);
    947e:	f105 022f 	add.w	r2, r5, #47	; 0x2f
    9482:	4631      	mov	r1, r6
    9484:	4628      	mov	r0, r5
    9486:	4c0c      	ldr	r4, [pc, #48]	; (94b8 <etharp_output+0x11c>)
    9488:	47a0      	blx	r4
}
    948a:	b002      	add	sp, #8
    948c:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_BUF;
    948e:	f06f 0001 	mvn.w	r0, #1
    9492:	e7fa      	b.n	948a <etharp_output+0xee>
					return ERR_RTE;
    9494:	f06f 0003 	mvn.w	r0, #3
    9498:	e7f7      	b.n	948a <etharp_output+0xee>
    949a:	f06f 0003 	mvn.w	r0, #3
    949e:	e7f4      	b.n	948a <etharp_output+0xee>
    94a0:	00005c8d 	.word	0x00005c8d
    94a4:	00004f91 	.word	0x00004f91
    94a8:	20007fd8 	.word	0x20007fd8
    94ac:	000091d5 	.word	0x000091d5
    94b0:	00009245 	.word	0x00009245
    94b4:	0000c720 	.word	0x0000c720
    94b8:	00009099 	.word	0x00009099

000094bc <ethernet_input>:
 *
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t ethernet_input(struct pbuf *p, struct netif *netif)
{
    94bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    94c0:	b083      	sub	sp, #12
    94c2:	4604      	mov	r4, r0
	u16_t           type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
	s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

	if (p->len <= SIZEOF_ETH_HDR) {
    94c4:	8946      	ldrh	r6, [r0, #10]
    94c6:	2e0e      	cmp	r6, #14
    94c8:	d919      	bls.n	94fe <ethernet_input+0x42>
    94ca:	460f      	mov	r7, r1
		ETHARP_STATS_INC(etharp.drop);
		goto free_and_return;
	}

	/* points to packet payload, which starts with an Ethernet header */
	ethhdr = (struct eth_hdr *)p->payload;
    94cc:	6845      	ldr	r5, [r0, #4]
	             (unsigned)ethhdr->src.addr[3],
	             (unsigned)ethhdr->src.addr[4],
	             (unsigned)ethhdr->src.addr[5],
	             (unsigned)htons(ethhdr->type)));

	type = ethhdr->type;
    94ce:	f8b5 800c 	ldrh.w	r8, [r5, #12]

#if LWIP_ARP_FILTER_NETIF
	netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

	if (ethhdr->dest.addr[0] & 1) {
    94d2:	782b      	ldrb	r3, [r5, #0]
    94d4:	f013 0f01 	tst.w	r3, #1
    94d8:	d00b      	beq.n	94f2 <ethernet_input+0x36>
		/* this might be a multicast or broadcast packet */
		if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
    94da:	2b01      	cmp	r3, #1
    94dc:	d016      	beq.n	950c <ethernet_input+0x50>
			if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) && (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
				/* mark the pbuf as link-layer multicast */
				p->flags |= PBUF_FLAG_LLMCAST;
			}
		} else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
    94de:	2206      	movs	r2, #6
    94e0:	4976      	ldr	r1, [pc, #472]	; (96bc <ethernet_input+0x200>)
    94e2:	4628      	mov	r0, r5
    94e4:	4b76      	ldr	r3, [pc, #472]	; (96c0 <ethernet_input+0x204>)
    94e6:	4798      	blx	r3
    94e8:	b918      	cbnz	r0, 94f2 <ethernet_input+0x36>
			/* mark the pbuf as link-layer broadcast */
			p->flags |= PBUF_FLAG_LLBCAST;
    94ea:	7b63      	ldrb	r3, [r4, #13]
    94ec:	f043 0308 	orr.w	r3, r3, #8
    94f0:	7363      	strb	r3, [r4, #13]
		}
	}

	switch (type) {
    94f2:	f1b8 0f08 	cmp.w	r8, #8
    94f6:	d014      	beq.n	9522 <ethernet_input+0x66>
    94f8:	f5b8 6fc1 	cmp.w	r8, #1544	; 0x608
    94fc:	d022      	beq.n	9544 <ethernet_input+0x88>
	/* This means the pbuf is freed or consumed,
	   so the caller doesn't have to free it again */
	return ERR_OK;

free_and_return:
	pbuf_free(p);
    94fe:	4620      	mov	r0, r4
    9500:	4b70      	ldr	r3, [pc, #448]	; (96c4 <ethernet_input+0x208>)
    9502:	4798      	blx	r3
	return ERR_OK;
}
    9504:	2000      	movs	r0, #0
    9506:	b003      	add	sp, #12
    9508:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) && (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
    950c:	786b      	ldrb	r3, [r5, #1]
    950e:	2b00      	cmp	r3, #0
    9510:	d1ef      	bne.n	94f2 <ethernet_input+0x36>
    9512:	78ab      	ldrb	r3, [r5, #2]
    9514:	2b5e      	cmp	r3, #94	; 0x5e
    9516:	d1ec      	bne.n	94f2 <ethernet_input+0x36>
				p->flags |= PBUF_FLAG_LLMCAST;
    9518:	7b43      	ldrb	r3, [r0, #13]
    951a:	f043 0310 	orr.w	r3, r3, #16
    951e:	7343      	strb	r3, [r0, #13]
    9520:	e7e7      	b.n	94f2 <ethernet_input+0x36>
		if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    9522:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
    9526:	f013 0f20 	tst.w	r3, #32
    952a:	d0e8      	beq.n	94fe <ethernet_input+0x42>
		if (pbuf_header(p, -ip_hdr_offset)) {
    952c:	f06f 010d 	mvn.w	r1, #13
    9530:	4620      	mov	r0, r4
    9532:	4b65      	ldr	r3, [pc, #404]	; (96c8 <ethernet_input+0x20c>)
    9534:	4798      	blx	r3
    9536:	2800      	cmp	r0, #0
    9538:	d1e1      	bne.n	94fe <ethernet_input+0x42>
			ip_input(p, netif);
    953a:	4639      	mov	r1, r7
    953c:	4620      	mov	r0, r4
    953e:	4b63      	ldr	r3, [pc, #396]	; (96cc <ethernet_input+0x210>)
    9540:	4798      	blx	r3
		break;
    9542:	e7df      	b.n	9504 <ethernet_input+0x48>
		if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    9544:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
    9548:	f013 0f20 	tst.w	r3, #32
    954c:	d0d7      	beq.n	94fe <ethernet_input+0x42>
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    954e:	b167      	cbz	r7, 956a <ethernet_input+0xae>
	if (p->len < SIZEOF_ETHARP_PACKET) {
    9550:	2e29      	cmp	r6, #41	; 0x29
    9552:	d912      	bls.n	957a <ethernet_input+0xbe>
	if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) || (hdr->hwlen != ETHARP_HWADDR_LEN)
    9554:	89eb      	ldrh	r3, [r5, #14]
    9556:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    955a:	d102      	bne.n	9562 <ethernet_input+0xa6>
    955c:	7cab      	ldrb	r3, [r5, #18]
    955e:	2b06      	cmp	r3, #6
    9560:	d00f      	beq.n	9582 <ethernet_input+0xc6>
		pbuf_free(p);
    9562:	4620      	mov	r0, r4
    9564:	4b57      	ldr	r3, [pc, #348]	; (96c4 <ethernet_input+0x208>)
    9566:	4798      	blx	r3
    9568:	e7cc      	b.n	9504 <ethernet_input+0x48>
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    956a:	4b59      	ldr	r3, [pc, #356]	; (96d0 <ethernet_input+0x214>)
    956c:	f44f 7233 	mov.w	r2, #716	; 0x2cc
    9570:	4958      	ldr	r1, [pc, #352]	; (96d4 <ethernet_input+0x218>)
    9572:	4859      	ldr	r0, [pc, #356]	; (96d8 <ethernet_input+0x21c>)
    9574:	4c59      	ldr	r4, [pc, #356]	; (96dc <ethernet_input+0x220>)
    9576:	47a0      	blx	r4
    9578:	e7fe      	b.n	9578 <ethernet_input+0xbc>
		pbuf_free(p);
    957a:	4620      	mov	r0, r4
    957c:	4b51      	ldr	r3, [pc, #324]	; (96c4 <ethernet_input+0x208>)
    957e:	4798      	blx	r3
    9580:	e7c0      	b.n	9504 <ethernet_input+0x48>
	    || (hdr->protolen != sizeof(ip_addr_t)) || (hdr->proto != PP_HTONS(ETHTYPE_IP))) {
    9582:	7ceb      	ldrb	r3, [r5, #19]
    9584:	2b04      	cmp	r3, #4
    9586:	d1ec      	bne.n	9562 <ethernet_input+0xa6>
    9588:	8a2b      	ldrh	r3, [r5, #16]
    958a:	2b08      	cmp	r3, #8
    958c:	d1e9      	bne.n	9562 <ethernet_input+0xa6>
	IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
    958e:	69e8      	ldr	r0, [r5, #28]
    9590:	9001      	str	r0, [sp, #4]
	IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
    9592:	f8d5 2026 	ldr.w	r2, [r5, #38]	; 0x26
	if (ip_addr_isany(&netif->ip_addr)) {
    9596:	f117 0f04 	cmn.w	r7, #4
    959a:	f000 8087 	beq.w	96ac <ethernet_input+0x1f0>
    959e:	687b      	ldr	r3, [r7, #4]
    95a0:	2b00      	cmp	r3, #0
    95a2:	f000 8083 	beq.w	96ac <ethernet_input+0x1f0>
		for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
    95a6:	429a      	cmp	r2, r3
    95a8:	bf0c      	ite	eq
    95aa:	f04f 0901 	moveq.w	r9, #1
    95ae:	f04f 0900 	movne.w	r9, #0
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    95b2:	f105 0616 	add.w	r6, r5, #22
    95b6:	bf12      	itee	ne
    95b8:	f04f 0a02 	movne.w	sl, #2
		for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
    95bc:	f04f 0901 	moveq.w	r9, #1
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    95c0:	46ca      	moveq	sl, r9
		etharp_arp_input(netif, (struct eth_addr *)(netif->hwaddr), p);
    95c2:	f107 082f 	add.w	r8, r7, #47	; 0x2f
	if (ip_addr_isany(ipaddr) || ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr)) {
    95c6:	2800      	cmp	r0, #0
    95c8:	d03a      	beq.n	9640 <ethernet_input+0x184>
    95ca:	4639      	mov	r1, r7
    95cc:	4b44      	ldr	r3, [pc, #272]	; (96e0 <ethernet_input+0x224>)
    95ce:	4798      	blx	r3
    95d0:	bbb0      	cbnz	r0, 9640 <ethernet_input+0x184>
    95d2:	9b01      	ldr	r3, [sp, #4]
    95d4:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    95d8:	2be0      	cmp	r3, #224	; 0xe0
    95da:	d031      	beq.n	9640 <ethernet_input+0x184>
	i = etharp_find_entry(ipaddr, flags);
    95dc:	4651      	mov	r1, sl
    95de:	a801      	add	r0, sp, #4
    95e0:	4b40      	ldr	r3, [pc, #256]	; (96e4 <ethernet_input+0x228>)
    95e2:	4798      	blx	r3
	if (i < 0) {
    95e4:	1e03      	subs	r3, r0, #0
    95e6:	db2b      	blt.n	9640 <ethernet_input+0x184>
		arp_table[i].state = ETHARP_STATE_STABLE;
    95e8:	f8df e104 	ldr.w	lr, [pc, #260]	; 96f0 <ethernet_input+0x234>
    95ec:	009a      	lsls	r2, r3, #2
    95ee:	18d1      	adds	r1, r2, r3
    95f0:	0089      	lsls	r1, r1, #2
    95f2:	eb0e 0c01 	add.w	ip, lr, r1
    95f6:	2002      	movs	r0, #2
    95f8:	f88c 0012 	strb.w	r0, [ip, #18]
	arp_table[i].netif = netif;
    95fc:	f8cc 7008 	str.w	r7, [ip, #8]
	ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    9600:	460a      	mov	r2, r1
    9602:	320c      	adds	r2, #12
    9604:	eb0e 0a02 	add.w	sl, lr, r2
    9608:	6830      	ldr	r0, [r6, #0]
    960a:	f84e 0002 	str.w	r0, [lr, r2]
    960e:	88b2      	ldrh	r2, [r6, #4]
    9610:	f8aa 2004 	strh.w	r2, [sl, #4]
	arp_table[i].ctime = 0;
    9614:	2200      	movs	r2, #0
    9616:	f88c 2013 	strb.w	r2, [ip, #19]
	if (arp_table[i].q != NULL) {
    961a:	f85e a001 	ldr.w	sl, [lr, r1]
    961e:	f1ba 0f00 	cmp.w	sl, #0
    9622:	d00d      	beq.n	9640 <ethernet_input+0x184>
		arp_table[i].q = NULL;
    9624:	460b      	mov	r3, r1
    9626:	4611      	mov	r1, r2
    9628:	f84e 1003 	str.w	r1, [lr, r3]
		etharp_send_ip(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr);
    962c:	4633      	mov	r3, r6
    962e:	4642      	mov	r2, r8
    9630:	4651      	mov	r1, sl
    9632:	4638      	mov	r0, r7
    9634:	f8df b0bc 	ldr.w	fp, [pc, #188]	; 96f4 <ethernet_input+0x238>
    9638:	47d8      	blx	fp
		pbuf_free(p);
    963a:	4650      	mov	r0, sl
    963c:	4b21      	ldr	r3, [pc, #132]	; (96c4 <ethernet_input+0x208>)
    963e:	4798      	blx	r3
	switch (hdr->opcode) {
    9640:	8aab      	ldrh	r3, [r5, #20]
    9642:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    9646:	d006      	beq.n	9656 <ethernet_input+0x19a>
    9648:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    964c:	d029      	beq.n	96a2 <ethernet_input+0x1e6>
	pbuf_free(p);
    964e:	4620      	mov	r0, r4
    9650:	4b1c      	ldr	r3, [pc, #112]	; (96c4 <ethernet_input+0x208>)
    9652:	4798      	blx	r3
    9654:	e756      	b.n	9504 <ethernet_input+0x48>
		if (for_us) {
    9656:	f1b9 0f00 	cmp.w	r9, #0
    965a:	d0f8      	beq.n	964e <ethernet_input+0x192>
			hdr->opcode = htons(ARP_REPLY);
    965c:	2002      	movs	r0, #2
    965e:	4b22      	ldr	r3, [pc, #136]	; (96e8 <ethernet_input+0x22c>)
    9660:	4798      	blx	r3
    9662:	82a8      	strh	r0, [r5, #20]
			IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
    9664:	69eb      	ldr	r3, [r5, #28]
    9666:	f8c5 3026 	str.w	r3, [r5, #38]	; 0x26
			IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
    966a:	687b      	ldr	r3, [r7, #4]
    966c:	61eb      	str	r3, [r5, #28]
			ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
    966e:	6833      	ldr	r3, [r6, #0]
    9670:	622b      	str	r3, [r5, #32]
    9672:	88b3      	ldrh	r3, [r6, #4]
    9674:	84ab      	strh	r3, [r5, #36]	; 0x24
			ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
    9676:	6833      	ldr	r3, [r6, #0]
    9678:	602b      	str	r3, [r5, #0]
    967a:	88b3      	ldrh	r3, [r6, #4]
    967c:	80ab      	strh	r3, [r5, #4]
			ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
    967e:	f8d8 3000 	ldr.w	r3, [r8]
    9682:	6033      	str	r3, [r6, #0]
    9684:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    9688:	80b3      	strh	r3, [r6, #4]
			ETHADDR16_COPY(&ethhdr->src, ethaddr);
    968a:	f8d8 3000 	ldr.w	r3, [r8]
    968e:	f8c5 3006 	str.w	r3, [r5, #6]
    9692:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    9696:	816b      	strh	r3, [r5, #10]
			netif->linkoutput(netif, p);
    9698:	69bb      	ldr	r3, [r7, #24]
    969a:	4621      	mov	r1, r4
    969c:	4638      	mov	r0, r7
    969e:	4798      	blx	r3
    96a0:	e7d5      	b.n	964e <ethernet_input+0x192>
		dhcp_arp_reply(netif, &sipaddr);
    96a2:	a901      	add	r1, sp, #4
    96a4:	4638      	mov	r0, r7
    96a6:	4b11      	ldr	r3, [pc, #68]	; (96ec <ethernet_input+0x230>)
    96a8:	4798      	blx	r3
    96aa:	e7d0      	b.n	964e <ethernet_input+0x192>
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    96ac:	f105 0616 	add.w	r6, r5, #22
    96b0:	f04f 0900 	mov.w	r9, #0
    96b4:	f04f 0a02 	mov.w	sl, #2
    96b8:	e783      	b.n	95c2 <ethernet_input+0x106>
    96ba:	bf00      	nop
    96bc:	0000c720 	.word	0x0000c720
    96c0:	0000a0cd 	.word	0x0000a0cd
    96c4:	00005d21 	.word	0x00005d21
    96c8:	00005c8d 	.word	0x00005c8d
    96cc:	00004c69 	.word	0x00004c69
    96d0:	0000c728 	.word	0x0000c728
    96d4:	0000bd34 	.word	0x0000bd34
    96d8:	0000b428 	.word	0x0000b428
    96dc:	0000a111 	.word	0x0000a111
    96e0:	00004f91 	.word	0x00004f91
    96e4:	00008f99 	.word	0x00008f99
    96e8:	00002f3d 	.word	0x00002f3d
    96ec:	00004175 	.word	0x00004175
    96f0:	20007fd8 	.word	0x20007fd8
    96f4:	00009099 	.word	0x00009099

000096f8 <mac_transmit_cb>:
	//gpio_set_pin_level(PHY_YELLOW_LED_PIN,false);
	gpio_set_pin_level(PHY_YELLOW_LED_PIN,true);
}

void mac_transmit_cb(struct mac_async_descriptor *desc)
{
    96f8:	4770      	bx	lr
	...

000096fc <MotorTimerTask_cb>:
#endif		
		
static struct timer_task MotorTimerTask;

static void MotorTimerTask_cb(const struct timer_task *const timer_task)
{
    96fc:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t temp;
	uint8_t i;


	//go through each motor status and set/reset the correct PORTB and PORTC pins
	for(i=0;i<NumMotors;i++) {//NUM_MOTORS;i++) {
    96fe:	4b39      	ldr	r3, [pc, #228]	; (97e4 <MotorTimerTask_cb+0xe8>)
    9700:	781e      	ldrb	r6, [r3, #0]
    9702:	2e00      	cmp	r6, #0
    9704:	d06c      	beq.n	97e0 <MotorTimerTask_cb+0xe4>
				//*Motor[i].PulsePort&=Motor[i].PulseBitMask;
				gpio_set_pin_level(Motor[i].PulsePin,false);
			} //if (Motor[i].StrengthCount<motor[i].Strength)

			Motor[i].StrengthCount++;  //increase duty cycle count
			if (Motor[i].StrengthCount>=NumClocksInMotorDutyCycle) {  //reached end of duty cycle, reset count
    9706:	4b38      	ldr	r3, [pc, #224]	; (97e8 <MotorTimerTask_cb+0xec>)
    9708:	f8d3 e000 	ldr.w	lr, [r3]
    970c:	4b37      	ldr	r3, [pc, #220]	; (97ec <MotorTimerTask_cb+0xf0>)
    970e:	2000      	movs	r0, #0
				Motor[i].Duration--;  //currently units are timer interrupts
			}
			//which depend on MotorDutyCycleClock
		} else {  //no motor Duration - set motor pins to 0

			Motor[i].StrengthCount=0;
    9710:	4607      	mov	r7, r0
 * \param[in] level true  = Pin level set to "high" state
 *                  false = Pin level set to "low" state
 */
static inline void gpio_set_pin_level(const uint8_t pin, const bool level)
{
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    9712:	2501      	movs	r5, #1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9714:	4c36      	ldr	r4, [pc, #216]	; (97f0 <MotorTimerTask_cb+0xf4>)
    9716:	e03e      	b.n	9796 <MotorTimerTask_cb+0x9a>
					gpio_set_pin_level(Motor[i].DirPin,false);
    9718:	7919      	ldrb	r1, [r3, #4]
    971a:	f001 0c1f 	and.w	ip, r1, #31
    971e:	fa05 fc0c 	lsl.w	ip, r5, ip
    9722:	0949      	lsrs	r1, r1, #5
    9724:	eb04 11c1 	add.w	r1, r4, r1, lsl #7
    9728:	f8c1 c014 	str.w	ip, [r1, #20]
    972c:	e04d      	b.n	97ca <MotorTimerTask_cb+0xce>
				if (Motor[i].flags&MOTOR_INST_FIRST_RUN) {
    972e:	7819      	ldrb	r1, [r3, #0]
    9730:	f011 0f02 	tst.w	r1, #2
    9734:	d115      	bne.n	9762 <MotorTimerTask_cb+0x66>
				gpio_set_pin_level(Motor[i].PulsePin,false);
    9736:	7a11      	ldrb	r1, [r2, #8]
    9738:	f001 0c1f 	and.w	ip, r1, #31
    973c:	fa05 fc0c 	lsl.w	ip, r5, ip
    9740:	0949      	lsrs	r1, r1, #5
    9742:	eb04 11c1 	add.w	r1, r4, r1, lsl #7
    9746:	f8c1 c014 	str.w	ip, [r1, #20]
			Motor[i].StrengthCount++;  //increase duty cycle count
    974a:	8c51      	ldrh	r1, [r2, #34]	; 0x22
    974c:	3101      	adds	r1, #1
    974e:	b289      	uxth	r1, r1
    9750:	8451      	strh	r1, [r2, #34]	; 0x22
			if (Motor[i].StrengthCount>=NumClocksInMotorDutyCycle) {  //reached end of duty cycle, reset count
    9752:	4571      	cmp	r1, lr
				Motor[i].StrengthCount=0;
    9754:	bfa8      	it	ge
    9756:	8457      	strhge	r7, [r2, #34]	; 0x22
			if (Motor[i].Duration!=0) { //new inst might set Duration=0
    9758:	6a51      	ldr	r1, [r2, #36]	; 0x24
    975a:	b1b9      	cbz	r1, 978c <MotorTimerTask_cb+0x90>
				Motor[i].Duration--;  //currently units are timer interrupts
    975c:	3901      	subs	r1, #1
    975e:	6251      	str	r1, [r2, #36]	; 0x24
    9760:	e014      	b.n	978c <MotorTimerTask_cb+0x90>
					Motor[i].flags&=~MOTOR_INST_FIRST_RUN; //clear first run bit
    9762:	f021 0102 	bic.w	r1, r1, #2
    9766:	7011      	strb	r1, [r2, #0]
					if (Motor[i].StrengthCount>0) {
    9768:	f1bc 0f00 	cmp.w	ip, #0
    976c:	d0e3      	beq.n	9736 <MotorTimerTask_cb+0x3a>
						Motor[i].StrengthCount--; //set back 1 so direction can get set above
    976e:	f10c 3cff 	add.w	ip, ip, #4294967295
    9772:	f8a2 c022 	strh.w	ip, [r2, #34]	; 0x22
    9776:	e7de      	b.n	9736 <MotorTimerTask_cb+0x3a>
			Motor[i].StrengthCount=0;
    9778:	845f      	strh	r7, [r3, #34]	; 0x22
									    
			gpio_set_pin_level(Motor[i].PulsePin,false);
    977a:	7a1a      	ldrb	r2, [r3, #8]
    977c:	f002 011f 	and.w	r1, r2, #31
    9780:	fa05 f101 	lsl.w	r1, r5, r1
    9784:	0952      	lsrs	r2, r2, #5
    9786:	eb04 12c2 	add.w	r2, r4, r2, lsl #7
    978a:	6151      	str	r1, [r2, #20]
    978c:	3001      	adds	r0, #1
    978e:	332c      	adds	r3, #44	; 0x2c
	for(i=0;i<NumMotors;i++) {//NUM_MOTORS;i++) {
    9790:	b2c2      	uxtb	r2, r0
    9792:	4296      	cmp	r6, r2
    9794:	d924      	bls.n	97e0 <MotorTimerTask_cb+0xe4>
    9796:	461a      	mov	r2, r3
		if (Motor[i].Duration>0) { //this motor is moving, or will start moving
    9798:	6a59      	ldr	r1, [r3, #36]	; 0x24
    979a:	2900      	cmp	r1, #0
    979c:	d0ec      	beq.n	9778 <MotorTimerTask_cb+0x7c>
			if (Motor[i].StrengthCount<Motor[i].Strength && !(Motor[i].flags&MOTOR_INST_FIRST_RUN)) { //set motor pins
    979e:	f8b3 c022 	ldrh.w	ip, [r3, #34]	; 0x22
    97a2:	8c19      	ldrh	r1, [r3, #32]
    97a4:	4561      	cmp	r1, ip
    97a6:	d9c2      	bls.n	972e <MotorTimerTask_cb+0x32>
    97a8:	7819      	ldrb	r1, [r3, #0]
    97aa:	f011 0f02 	tst.w	r1, #2
    97ae:	d1d8      	bne.n	9762 <MotorTimerTask_cb+0x66>
				if (Motor[i].Direction) {
    97b0:	68d9      	ldr	r1, [r3, #12]
    97b2:	2900      	cmp	r1, #0
    97b4:	d0b0      	beq.n	9718 <MotorTimerTask_cb+0x1c>
					gpio_set_pin_level(Motor[i].DirPin,true);
    97b6:	7919      	ldrb	r1, [r3, #4]
    97b8:	f001 0c1f 	and.w	ip, r1, #31
    97bc:	fa05 fc0c 	lsl.w	ip, r5, ip
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    97c0:	0949      	lsrs	r1, r1, #5
    97c2:	eb04 11c1 	add.w	r1, r4, r1, lsl #7
    97c6:	f8c1 c018 	str.w	ip, [r1, #24]
				gpio_set_pin_level(Motor[i].PulsePin,true);
    97ca:	7a11      	ldrb	r1, [r2, #8]
    97cc:	f001 0c1f 	and.w	ip, r1, #31
    97d0:	fa05 fc0c 	lsl.w	ip, r5, ip
    97d4:	0949      	lsrs	r1, r1, #5
    97d6:	eb04 11c1 	add.w	r1, r4, r1, lsl #7
    97da:	f8c1 c018 	str.w	ip, [r1, #24]
    97de:	e7b4      	b.n	974a <MotorTimerTask_cb+0x4e>
    97e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    97e2:	bf00      	nop
    97e4:	20009320 	.word	0x20009320
    97e8:	200095ec 	.word	0x200095ec
    97ec:	2000932c 	.word	0x2000932c
    97f0:	41008000 	.word	0x41008000

000097f4 <mac_receive_cb>:
{
    97f4:	b538      	push	{r3, r4, r5, lr}
	gmac_recv_flag = true;
    97f6:	2001      	movs	r0, #1
    97f8:	4b05      	ldr	r3, [pc, #20]	; (9810 <mac_receive_cb+0x1c>)
    97fa:	7018      	strb	r0, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    97fc:	4c05      	ldr	r4, [pc, #20]	; (9814 <mac_receive_cb+0x20>)
    97fe:	f44f 4580 	mov.w	r5, #16384	; 0x4000
    9802:	f8c4 5114 	str.w	r5, [r4, #276]	; 0x114
	delay_ms(1);
    9806:	4b04      	ldr	r3, [pc, #16]	; (9818 <mac_receive_cb+0x24>)
    9808:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    980a:	f8c4 5118 	str.w	r5, [r4, #280]	; 0x118
    980e:	bd38      	pop	{r3, r4, r5, pc}
    9810:	200080a4 	.word	0x200080a4
    9814:	41008000 	.word	0x41008000
    9818:	00000ed1 	.word	0x00000ed1

0000981c <status_callback>:
{
    981c:	b508      	push	{r3, lr}
	if (n->flags & NETIF_FLAG_UP) {
    981e:	f890 1035 	ldrb.w	r1, [r0, #53]	; 0x35
    9822:	f011 0f01 	tst.w	r1, #1
    9826:	d00b      	beq.n	9840 <status_callback+0x24>
		printf("Interface Up %s:\n",
    9828:	f001 0108 	and.w	r1, r1, #8
    982c:	4b06      	ldr	r3, [pc, #24]	; (9848 <status_callback+0x2c>)
    982e:	4a07      	ldr	r2, [pc, #28]	; (984c <status_callback+0x30>)
    9830:	2900      	cmp	r1, #0
    9832:	bf14      	ite	ne
    9834:	4611      	movne	r1, r2
    9836:	4619      	moveq	r1, r3
    9838:	4805      	ldr	r0, [pc, #20]	; (9850 <status_callback+0x34>)
    983a:	4b06      	ldr	r3, [pc, #24]	; (9854 <status_callback+0x38>)
    983c:	4798      	blx	r3
    983e:	bd08      	pop	{r3, pc}
		printf("Interface Down.\n");
    9840:	4805      	ldr	r0, [pc, #20]	; (9858 <status_callback+0x3c>)
    9842:	4b06      	ldr	r3, [pc, #24]	; (985c <status_callback+0x40>)
    9844:	4798      	blx	r3
    9846:	bd08      	pop	{r3, pc}
    9848:	0000c758 	.word	0x0000c758
    984c:	0000c750 	.word	0x0000c750
    9850:	0000c764 	.word	0x0000c764
    9854:	0000a111 	.word	0x0000a111
    9858:	0000c778 	.word	0x0000c778
    985c:	0000a1f9 	.word	0x0000a1f9

00009860 <link_callback>:
{
    9860:	b510      	push	{r4, lr}
	if (n->flags & NETIF_FLAG_LINK_UP) {
    9862:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
    9866:	f013 0f10 	tst.w	r3, #16
    986a:	d00f      	beq.n	988c <link_callback+0x2c>
    986c:	4604      	mov	r4, r0
		printf("Link Up.\n");
    986e:	4809      	ldr	r0, [pc, #36]	; (9894 <link_callback+0x34>)
    9870:	4b09      	ldr	r3, [pc, #36]	; (9898 <link_callback+0x38>)
    9872:	4798      	blx	r3
		if (n->flags & NETIF_FLAG_DHCP) {
    9874:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    9878:	f013 0f08 	tst.w	r3, #8
    987c:	d009      	beq.n	9892 <link_callback+0x32>
			printf("Restarting DHCP\n");
    987e:	4807      	ldr	r0, [pc, #28]	; (989c <link_callback+0x3c>)
    9880:	4b05      	ldr	r3, [pc, #20]	; (9898 <link_callback+0x38>)
    9882:	4798      	blx	r3
			dhcp_start(n);
    9884:	4620      	mov	r0, r4
    9886:	4b06      	ldr	r3, [pc, #24]	; (98a0 <link_callback+0x40>)
    9888:	4798      	blx	r3
    988a:	bd10      	pop	{r4, pc}
		printf("Link Down.\n");
    988c:	4805      	ldr	r0, [pc, #20]	; (98a4 <link_callback+0x44>)
    988e:	4b02      	ldr	r3, [pc, #8]	; (9898 <link_callback+0x38>)
    9890:	4798      	blx	r3
    9892:	bd10      	pop	{r4, pc}
    9894:	0000c788 	.word	0x0000c788
    9898:	0000a1f9 	.word	0x0000a1f9
    989c:	0000c794 	.word	0x0000c794
    98a0:	000046e1 	.word	0x000046e1
    98a4:	0000c7a4 	.word	0x0000c7a4

000098a8 <sys_now>:
	return systick_timems;
    98a8:	4b01      	ldr	r3, [pc, #4]	; (98b0 <sys_now+0x8>)
    98aa:	6858      	ldr	r0, [r3, #4]
}
    98ac:	4770      	bx	lr
    98ae:	bf00      	nop
    98b0:	200080a4 	.word	0x200080a4

000098b4 <SysTick_Handler>:
	systick_timems++;
    98b4:	4a02      	ldr	r2, [pc, #8]	; (98c0 <SysTick_Handler+0xc>)
    98b6:	6853      	ldr	r3, [r2, #4]
    98b8:	3301      	adds	r3, #1
    98ba:	6053      	str	r3, [r2, #4]
    98bc:	4770      	bx	lr
    98be:	bf00      	nop
    98c0:	200080a4 	.word	0x200080a4

000098c4 <systick_enable>:
	systick_timems = 0;
    98c4:	2200      	movs	r2, #0
    98c6:	4b06      	ldr	r3, [pc, #24]	; (98e0 <systick_enable+0x1c>)
    98c8:	605a      	str	r2, [r3, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    98ca:	4b06      	ldr	r3, [pc, #24]	; (98e4 <systick_enable+0x20>)
    98cc:	4906      	ldr	r1, [pc, #24]	; (98e8 <systick_enable+0x24>)
    98ce:	6059      	str	r1, [r3, #4]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    98d0:	20e0      	movs	r0, #224	; 0xe0
    98d2:	4906      	ldr	r1, [pc, #24]	; (98ec <systick_enable+0x28>)
    98d4:	f881 0023 	strb.w	r0, [r1, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    98d8:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    98da:	2207      	movs	r2, #7
    98dc:	601a      	str	r2, [r3, #0]
    98de:	4770      	bx	lr
    98e0:	200080a4 	.word	0x200080a4
    98e4:	e000e010 	.word	0xe000e010
    98e8:	0001d4bf 	.word	0x0001d4bf
    98ec:	e000ed00 	.word	0xe000ed00

000098f0 <ringbuffer_last>:
{
    98f0:	b510      	push	{r4, lr}
    ASSERT(rb);
    98f2:	4604      	mov	r4, r0
    98f4:	223f      	movs	r2, #63	; 0x3f
    98f6:	4906      	ldr	r1, [pc, #24]	; (9910 <ringbuffer_last+0x20>)
    98f8:	3000      	adds	r0, #0
    98fa:	bf18      	it	ne
    98fc:	2001      	movne	r0, #1
    98fe:	4b05      	ldr	r3, [pc, #20]	; (9914 <ringbuffer_last+0x24>)
    9900:	4798      	blx	r3
    uint8_t data = rb->buf[(rb->write_index-1) & rb->size];
    9902:	68e3      	ldr	r3, [r4, #12]
    9904:	3b01      	subs	r3, #1
    9906:	6862      	ldr	r2, [r4, #4]
    9908:	4013      	ands	r3, r2
    990a:	6822      	ldr	r2, [r4, #0]
}
    990c:	5cd0      	ldrb	r0, [r2, r3]
    990e:	bd10      	pop	{r4, pc}
    9910:	0000c7b0 	.word	0x0000c7b0
    9914:	0000187d 	.word	0x0000187d

00009918 <usart1_receive_cb>:
{
    9918:	b508      	push	{r3, lr}
    if( ringbuffer_last(&io_descr->rx) == 0x0a ) {
    991a:	3034      	adds	r0, #52	; 0x34
    991c:	4b04      	ldr	r3, [pc, #16]	; (9930 <usart1_receive_cb+0x18>)
    991e:	4798      	blx	r3
    9920:	280a      	cmp	r0, #10
    9922:	d000      	beq.n	9926 <usart1_receive_cb+0xe>
    9924:	bd08      	pop	{r3, pc}
        line_available = true;
    9926:	2201      	movs	r2, #1
    9928:	4b02      	ldr	r3, [pc, #8]	; (9934 <usart1_receive_cb+0x1c>)
    992a:	721a      	strb	r2, [r3, #8]
}
    992c:	e7fa      	b.n	9924 <usart1_receive_cb+0xc>
    992e:	bf00      	nop
    9930:	000098f1 	.word	0x000098f1
    9934:	200080a4 	.word	0x200080a4

00009938 <MotorTimer_Initialize>:



//tph - TIMER_0 uses the TC0 peripheral which takes as input the 12MHz general clock divided by 4 = 3Mhz to produce (/75) a 40khz (25us) signal for Motor pwm
void MotorTimer_Initialize(void)
{
    9938:	b510      	push	{r4, lr}
	MotorTimerTask.interval = 1; //clock ticks
    993a:	4907      	ldr	r1, [pc, #28]	; (9958 <MotorTimer_Initialize+0x20>)
    993c:	2301      	movs	r3, #1
    993e:	614b      	str	r3, [r1, #20]
	MotorTimerTask.cb       = MotorTimerTask_cb;
    9940:	4a06      	ldr	r2, [pc, #24]	; (995c <MotorTimer_Initialize+0x24>)
    9942:	618a      	str	r2, [r1, #24]
	MotorTimerTask.mode     = TIMER_TASK_REPEAT;
    9944:	770b      	strb	r3, [r1, #28]

	timer_add_task(&TIMER_0, &MotorTimerTask);
    9946:	4c06      	ldr	r4, [pc, #24]	; (9960 <MotorTimer_Initialize+0x28>)
    9948:	310c      	adds	r1, #12
    994a:	4620      	mov	r0, r4
    994c:	4b05      	ldr	r3, [pc, #20]	; (9964 <MotorTimer_Initialize+0x2c>)
    994e:	4798      	blx	r3
	timer_start(&TIMER_0);
    9950:	4620      	mov	r0, r4
    9952:	4b05      	ldr	r3, [pc, #20]	; (9968 <MotorTimer_Initialize+0x30>)
    9954:	4798      	blx	r3
    9956:	bd10      	pop	{r4, pc}
    9958:	200080a4 	.word	0x200080a4
    995c:	000096fd 	.word	0x000096fd
    9960:	20008288 	.word	0x20008288
    9964:	0000135d 	.word	0x0000135d
    9968:	00001321 	.word	0x00001321

0000996c <SendMotorInst>:
//and contains (in 4 bytes):
//Motor# (0:3),unused(4:7),direction(8),thrust(9:15),duration(16:31)
//was 3 bytes:
//motor# (address):4, direction:1, strength:3,duration:16
void SendMotorInst(uint8_t *MInst)
{
    996c:	b430      	push	{r4, r5}
    uint32_t Duration;

    //set the motor status so the timer interrupt
    //will find that a motor has a duration and needs to be moved
    //determine which motor
    MotorNum=(MInst[0]&0xf0)>>4;
    996e:	7803      	ldrb	r3, [r0, #0]

    Motor[MotorNum].Duration=0; //just in case motor is currently running (pulsing)
    9970:	091b      	lsrs	r3, r3, #4
    9972:	4924      	ldr	r1, [pc, #144]	; (9a04 <SendMotorInst+0x98>)
    9974:	222c      	movs	r2, #44	; 0x2c
    9976:	fb02 f203 	mul.w	r2, r2, r3
    997a:	188c      	adds	r4, r1, r2
    997c:	2500      	movs	r5, #0
    997e:	6265      	str	r5, [r4, #36]	; 0x24
    //SYS_TMR_DelayMS(1);  //wait to make sure motor is stopped if running (pulsing)
    Motor[MotorNum].flags|=MOTOR_INST_FIRST_RUN; //first set motor pins to 00 to avoid short circuit
    9980:	5c8c      	ldrb	r4, [r1, r2]
    9982:	f044 0402 	orr.w	r4, r4, #2
    9986:	548c      	strb	r4, [r1, r2]
    //for example, motor is turning with 10 then a 01 instruction is sent, and for a nanosecond when LATB is being set, possibly 2 pins might be 1 and cause a short at the h-bridge.

    //if ((MInst[0]&0x08)!=0) {
    if ((MInst[1]&0x80)!=0) {
    9988:	f990 2001 	ldrsb.w	r2, [r0, #1]
    998c:	42aa      	cmp	r2, r5
    998e:	db2d      	blt.n	99ec <SendMotorInst+0x80>
         Motor[MotorNum].Direction=MOTOR_COUNTERCLOCKWISE;
    } else {
        //clock-wise
        //Motor[MotorNum].DirectionMask=0x80>>(MotorNum*2);  //clockwise
        //Motor[MotorNum].DirectionMask=0x2<<(MotorNum*2);  //clockwise
        Motor[MotorNum].Direction=MOTOR_CLOCKWISE;
    9990:	222c      	movs	r2, #44	; 0x2c
    9992:	491c      	ldr	r1, [pc, #112]	; (9a04 <SendMotorInst+0x98>)
    9994:	fb02 1203 	mla	r2, r2, r3, r1
    9998:	2100      	movs	r1, #0
    999a:	60d1      	str	r1, [r2, #12]
    //0=stop 20=full speed (NumClkInDutyCycle)
    //this number is multiplied by the NumClocksInMotorDutyCycle/20
    //so for strength=1, Strength*NumClocksInMotorDutyCycle/20 (1 clks of 20 are on)
    //for strength=20 the motor is on for every clock (20 of 20)
    //Motor[MotorNum].Strength=((MInst[0]&0x07)*NumClocksInMotorDutyCycle)/ROBOT_MOTORS_DEFAULT_NUM_CLKS_IN_MOTOR_DUTY_CYCLE;
    Strength=(MInst[1]&0x7f);//max is currently 0 to 127
    999c:	7842      	ldrb	r2, [r0, #1]
    999e:	f002 027f 	and.w	r2, r2, #127	; 0x7f
        Strength=ROBOT_MOTORS_DEFAULT_NUM_CLKS_IN_MOTOR_DUTY_CYCLE;
    }

    //set motor turn duration (is 16-bit little endian int)
    //Motor[MotorNum].Duration=(uint16_t)((MInst[2]<<8)+MInst[1]);
    Duration=(uint32_t)((MInst[3]<<8)+MInst[2]);
    99a2:	78c1      	ldrb	r1, [r0, #3]
    99a4:	7880      	ldrb	r0, [r0, #2]
    99a6:	eb00 2101 	add.w	r1, r0, r1, lsl #8
    //convert ms to 25us units
    //so Duration of 100ms in 25uS units=0.1/0.000025=4000 clocks * 2= 8000
    //in us: (100)*1000/25=4000, so generalizing in us:
    //Duration*1000/MotorDutyCycle = number of TimerInterrupts for 
    //user sent Duration in ms.
    Duration*=1000; //Duration is divided by MotorDutyCycleClock below
    99aa:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    99ae:	fb00 f001 	mul.w	r0, r0, r1
    //at 40khz (25us) a pulse:
	//duty cycle is 25us*20=500us
	//so 1/20 speed is 25us on 475us off (shortest pulse possible for drv8800- 40khz)
	//   19/20 speed is 475us on 25us off

    Motor[MotorNum].Strength=Strength;
    99b2:	212c      	movs	r1, #44	; 0x2c
    99b4:	4c13      	ldr	r4, [pc, #76]	; (9a04 <SendMotorInst+0x98>)
    99b6:	fb01 4103 	mla	r1, r1, r3, r4
    99ba:	2a14      	cmp	r2, #20
    99bc:	bf28      	it	cs
    99be:	2214      	movcs	r2, #20
    99c0:	840a      	strh	r2, [r1, #32]
    Motor[MotorNum].StrengthCount=0;
    99c2:	2200      	movs	r2, #0
    99c4:	844a      	strh	r2, [r1, #34]	; 0x22

    //Convert duration in us to duration in number of timer interrupts
    //since multiplying by 1000 above, I doubt Duration would ever be < MotorDutyCycleClock
    //but just as a failsafe in case Motor[].Duration somehow will get set to 0]
    //and somebody is trying to set strength=0 - probably not needed
    if ((Duration/MotorDutyCycleClock)==0 && Duration>0) {
    99c6:	4a10      	ldr	r2, [pc, #64]	; (9a08 <SendMotorInst+0x9c>)
    99c8:	6812      	ldr	r2, [r2, #0]
    99ca:	fbb0 f2f2 	udiv	r2, r0, r2
    99ce:	b902      	cbnz	r2, 99d2 <SendMotorInst+0x66>
    99d0:	b990      	cbnz	r0, 99f8 <SendMotorInst+0x8c>
      Motor[MotorNum].Duration=1;
    } else {
      Motor[MotorNum].Duration=Duration/MotorDutyCycleClock;  //note: this is the equivalent of enabling the motor
    99d2:	212c      	movs	r1, #44	; 0x2c
    99d4:	480b      	ldr	r0, [pc, #44]	; (9a04 <SendMotorInst+0x98>)
    99d6:	fb01 0103 	mla	r1, r1, r3, r0
    99da:	624a      	str	r2, [r1, #36]	; 0x24
    } 

    Motor[MotorNum].DurationCount=0;
    99dc:	212c      	movs	r1, #44	; 0x2c
    99de:	4a09      	ldr	r2, [pc, #36]	; (9a04 <SendMotorInst+0x98>)
    99e0:	fb01 2303 	mla	r3, r1, r3, r2
    99e4:	2200      	movs	r2, #0
    99e6:	629a      	str	r2, [r3, #40]	; 0x28

	//was: start timer3 if not already started
} //SendMotorInst
    99e8:	bc30      	pop	{r4, r5}
    99ea:	4770      	bx	lr
         Motor[MotorNum].Direction=MOTOR_COUNTERCLOCKWISE;
    99ec:	222c      	movs	r2, #44	; 0x2c
    99ee:	fb02 1203 	mla	r2, r2, r3, r1
    99f2:	2101      	movs	r1, #1
    99f4:	60d1      	str	r1, [r2, #12]
    99f6:	e7d1      	b.n	999c <SendMotorInst+0x30>
      Motor[MotorNum].Duration=1;
    99f8:	222c      	movs	r2, #44	; 0x2c
    99fa:	fb02 4203 	mla	r2, r2, r3, r4
    99fe:	2101      	movs	r1, #1
    9a00:	6251      	str	r1, [r2, #36]	; 0x24
    9a02:	e7eb      	b.n	99dc <SendMotorInst+0x70>
    9a04:	2000932c 	.word	0x2000932c
    9a08:	20009328 	.word	0x20009328

00009a0c <USART_1_input>:
{
    9a0c:	b530      	push	{r4, r5, lr}
    9a0e:	b085      	sub	sp, #20
    usart_async_get_io_descriptor(&USART_1, &io);	// Get the pointer to statically allocated io_descriptor structure.
    9a10:	a903      	add	r1, sp, #12
    9a12:	4823      	ldr	r0, [pc, #140]	; (9aa0 <USART_1_input+0x94>)
    9a14:	4b23      	ldr	r3, [pc, #140]	; (9aa4 <USART_1_input+0x98>)
    9a16:	4798      	blx	r3
    if( nread <= 0 ) {
    9a18:	4b23      	ldr	r3, [pc, #140]	; (9aa8 <USART_1_input+0x9c>)
    9a1a:	6a1b      	ldr	r3, [r3, #32]
    9a1c:	2b00      	cmp	r3, #0
    9a1e:	dd01      	ble.n	9a24 <USART_1_input+0x18>
}
    9a20:	b005      	add	sp, #20
    9a22:	bd30      	pop	{r4, r5, pc}
        CRITICAL_SECTION_ENTER()
    9a24:	a801      	add	r0, sp, #4
    9a26:	4b21      	ldr	r3, [pc, #132]	; (9aac <USART_1_input+0xa0>)
    9a28:	4798      	blx	r3
        if(line_available) {
    9a2a:	4b1f      	ldr	r3, [pc, #124]	; (9aa8 <USART_1_input+0x9c>)
    9a2c:	7a1b      	ldrb	r3, [r3, #8]
    9a2e:	2b00      	cmp	r3, #0
    9a30:	d031      	beq.n	9a96 <USART_1_input+0x8a>
            line_available = false;		// Decrementing the semaphore count from 1 to 0.
    9a32:	4c1d      	ldr	r4, [pc, #116]	; (9aa8 <USART_1_input+0x9c>)
    9a34:	2300      	movs	r3, #0
    9a36:	7223      	strb	r3, [r4, #8]
        CRITICAL_SECTION_LEAVE()
    9a38:	a801      	add	r0, sp, #4
    9a3a:	4b1d      	ldr	r3, [pc, #116]	; (9ab0 <USART_1_input+0xa4>)
    9a3c:	4798      	blx	r3
			nread = io_read(io, buffer, sizeof(buffer));	// Returns count of characters read (or negative error flag).
    9a3e:	f44f 7280 	mov.w	r2, #256	; 0x100
    9a42:	f104 0124 	add.w	r1, r4, #36	; 0x24
    9a46:	9803      	ldr	r0, [sp, #12]
    9a48:	4b1a      	ldr	r3, [pc, #104]	; (9ab4 <USART_1_input+0xa8>)
    9a4a:	4798      	blx	r3
    9a4c:	6220      	str	r0, [r4, #32]
			if (nread>0) {
    9a4e:	2800      	cmp	r0, #0
    9a50:	dde6      	ble.n	9a20 <USART_1_input+0x14>
				buffer[nread]=0; //terminate string
    9a52:	4420      	add	r0, r4
    9a54:	2500      	movs	r5, #0
    9a56:	f880 5024 	strb.w	r5, [r0, #36]	; 0x24
				printf("W: %s:W\n",buffer); //each USART packet ends with 0x0a
    9a5a:	f104 0124 	add.w	r1, r4, #36	; 0x24
    9a5e:	4816      	ldr	r0, [pc, #88]	; (9ab8 <USART_1_input+0xac>)
    9a60:	4b16      	ldr	r3, [pc, #88]	; (9abc <USART_1_input+0xb0>)
    9a62:	4798      	blx	r3
				nread=0;
    9a64:	6225      	str	r5, [r4, #32]
				if (buffer[4]==ROBOT_MOTORS_SEND_4BYTE_INST) {
    9a66:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    9a6a:	2b20      	cmp	r3, #32
    9a6c:	d1d8      	bne.n	9a20 <USART_1_input+0x14>
					MotorInst[0]=buffer[5];  //Motor Num<<4
    9a6e:	f894 2029 	ldrb.w	r2, [r4, #41]	; 0x29
    9a72:	f88d 2008 	strb.w	r2, [sp, #8]
					MotorInst[1]=buffer[6];  //Dir+Strength
    9a76:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
    9a7a:	f88d 2009 	strb.w	r2, [sp, #9]
					MotorInst[2]=buffer[7];  //duration low byte
    9a7e:	f894 202b 	ldrb.w	r2, [r4, #43]	; 0x2b
    9a82:	f88d 200a 	strb.w	r2, [sp, #10]
					MotorInst[3]=buffer[8];  //duration high byte
    9a86:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    9a8a:	f88d 300b 	strb.w	r3, [sp, #11]
					SendMotorInst(MotorInst);
    9a8e:	a802      	add	r0, sp, #8
    9a90:	4b0b      	ldr	r3, [pc, #44]	; (9ac0 <USART_1_input+0xb4>)
    9a92:	4798      	blx	r3
}
    9a94:	e7c4      	b.n	9a20 <USART_1_input+0x14>
        CRITICAL_SECTION_LEAVE()
    9a96:	a801      	add	r0, sp, #4
    9a98:	4b05      	ldr	r3, [pc, #20]	; (9ab0 <USART_1_input+0xa4>)
    9a9a:	4798      	blx	r3
    9a9c:	e7c0      	b.n	9a20 <USART_1_input+0x14>
    9a9e:	bf00      	nop
    9aa0:	200081fc 	.word	0x200081fc
    9aa4:	00001671 	.word	0x00001671
    9aa8:	200080a4 	.word	0x200080a4
    9aac:	00000eb5 	.word	0x00000eb5
    9ab0:	00000ec3 	.word	0x00000ec3
    9ab4:	00000fdd 	.word	0x00000fdd
    9ab8:	0000c7bc 	.word	0x0000c7bc
    9abc:	0000a111 	.word	0x0000a111
    9ac0:	0000996d 	.word	0x0000996d

00009ac4 <udpserver_recv>:
	struct io_descriptor *io; //for ESP-01 UART1
	uint8_t buffer[256]; //temporary buffer
	
	//printf("received at %d, echoing to the same port\n",pcb->local_port);
	//dst_ip = &(pcb->remote_ip); // this is zero always
	if (p != NULL) {
    9ac4:	2a00      	cmp	r2, #0
    9ac6:	f000 8088 	beq.w	9bda <udpserver_recv+0x116>
{
    9aca:	b5f0      	push	{r4, r5, r6, r7, lr}
    9acc:	b0c3      	sub	sp, #268	; 0x10c
    9ace:	4614      	mov	r4, r2
    9ad0:	461e      	mov	r6, r3
    9ad2:	460d      	mov	r5, r1
		//printf("UDP rcv %d bytes: ", (*p).len);
		printf("%d ", (*p).len);
    9ad4:	8951      	ldrh	r1, [r2, #10]
    9ad6:	4841      	ldr	r0, [pc, #260]	; (9bdc <udpserver_recv+0x118>)
    9ad8:	4b41      	ldr	r3, [pc, #260]	; (9be0 <udpserver_recv+0x11c>)
    9ada:	4798      	blx	r3
		//    	printf("\n");
		//udp_sendto(pcb, p, IP_ADDR_BROADCAST, 1234); //dest port
				//		udp_sendto(pcb, p, &forward_ip, fwd_port); //dest port
				
		//Process any UDP instructions recognized
		if (pcb->local_port==UDP_PORT) {  //note that currently there could never be a different port because UDP server only listens to this port
    9adc:	8a6a      	ldrh	r2, [r5, #18]
    9ade:	f24d 1306 	movw	r3, #53510	; 0xd106
    9ae2:	429a      	cmp	r2, r3
    9ae4:	d004      	beq.n	9af0 <udpserver_recv+0x2c>
				io_write(io, (uint8_t *)&InstData[5], InstLen-5);
			break;
			} //switch

		} //if (pcb->local_port==UDP_PORT) {
		pbuf_free(p);
    9ae6:	4620      	mov	r0, r4
    9ae8:	4b3e      	ldr	r3, [pc, #248]	; (9be4 <udpserver_recv+0x120>)
    9aea:	4798      	blx	r3
	} //if (p != NULL) {
} //void udpserver_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
    9aec:	b043      	add	sp, #268	; 0x10c
    9aee:	bdf0      	pop	{r4, r5, r6, r7, pc}
			InstData=(uint8_t *)(*p).payload;  //shorthand to data
    9af0:	6867      	ldr	r7, [r4, #4]
			switch(InstData[4]) //Robot Instruction
    9af2:	793b      	ldrb	r3, [r7, #4]
    9af4:	2b01      	cmp	r3, #1
    9af6:	d03c      	beq.n	9b72 <udpserver_recv+0xae>
    9af8:	b1e3      	cbz	r3, 9b34 <udpserver_recv+0x70>
    9afa:	2b20      	cmp	r3, #32
    9afc:	d05d      	beq.n	9bba <udpserver_recv+0xf6>
    9afe:	2b40      	cmp	r3, #64	; 0x40
    9b00:	d1f1      	bne.n	9ae6 <udpserver_recv+0x22>
			InstLen=(*p).len;
    9b02:	8965      	ldrh	r5, [r4, #10]
				usart_async_get_io_descriptor(&USART_1, &io);
    9b04:	a940      	add	r1, sp, #256	; 0x100
    9b06:	4838      	ldr	r0, [pc, #224]	; (9be8 <udpserver_recv+0x124>)
    9b08:	4b38      	ldr	r3, [pc, #224]	; (9bec <udpserver_recv+0x128>)
    9b0a:	4798      	blx	r3
				memcpy(buffer,&InstData[5],InstLen-5);
    9b0c:	3705      	adds	r7, #5
    9b0e:	3d05      	subs	r5, #5
    9b10:	462a      	mov	r2, r5
    9b12:	4639      	mov	r1, r7
    9b14:	4668      	mov	r0, sp
    9b16:	4b36      	ldr	r3, [pc, #216]	; (9bf0 <udpserver_recv+0x12c>)
    9b18:	4798      	blx	r3
				buffer[InstLen-5]=0; //terminate string
    9b1a:	2300      	movs	r3, #0
    9b1c:	f80d 3005 	strb.w	r3, [sp, r5]
				printf("%s",buffer);
    9b20:	4669      	mov	r1, sp
    9b22:	4834      	ldr	r0, [pc, #208]	; (9bf4 <udpserver_recv+0x130>)
    9b24:	4b2e      	ldr	r3, [pc, #184]	; (9be0 <udpserver_recv+0x11c>)
    9b26:	4798      	blx	r3
				io_write(io, (uint8_t *)&InstData[5], InstLen-5);
    9b28:	b2aa      	uxth	r2, r5
    9b2a:	4639      	mov	r1, r7
    9b2c:	9840      	ldr	r0, [sp, #256]	; 0x100
    9b2e:	4b32      	ldr	r3, [pc, #200]	; (9bf8 <udpserver_recv+0x134>)
    9b30:	4798      	blx	r3
			break;
    9b32:	e7d8      	b.n	9ae6 <udpserver_recv+0x22>
				retbuf = pbuf_alloc(PBUF_TRANSPORT, 10, PBUF_RAM);
    9b34:	2200      	movs	r2, #0
    9b36:	210a      	movs	r1, #10
    9b38:	4610      	mov	r0, r2
    9b3a:	4b30      	ldr	r3, [pc, #192]	; (9bfc <udpserver_recv+0x138>)
    9b3c:	4798      	blx	r3
    9b3e:	4607      	mov	r7, r0
				ReturnInst=retbuf->payload;
    9b40:	6843      	ldr	r3, [r0, #4]
				memcpy(ReturnInst,p->payload,5); //copy IP + inst byte to return instruction
    9b42:	6862      	ldr	r2, [r4, #4]
    9b44:	6811      	ldr	r1, [r2, #0]
    9b46:	6019      	str	r1, [r3, #0]
    9b48:	7912      	ldrb	r2, [r2, #4]
    9b4a:	711a      	strb	r2, [r3, #4]
				ReturnInst[6]=0x12;
    9b4c:	2212      	movs	r2, #18
    9b4e:	719a      	strb	r2, [r3, #6]
				ReturnInst[7]=0x34;
    9b50:	2234      	movs	r2, #52	; 0x34
    9b52:	71da      	strb	r2, [r3, #7]
				ReturnInst[8]=0x56;
    9b54:	2256      	movs	r2, #86	; 0x56
    9b56:	721a      	strb	r2, [r3, #8]
				ReturnInst[9]=0x78;
    9b58:	2278      	movs	r2, #120	; 0x78
    9b5a:	725a      	strb	r2, [r3, #9]
				udp_sendto(pcb, retbuf, addr, UDP_PORT); //dest port
    9b5c:	f24d 1306 	movw	r3, #53510	; 0xd106
    9b60:	4632      	mov	r2, r6
    9b62:	4601      	mov	r1, r0
    9b64:	4628      	mov	r0, r5
    9b66:	4d26      	ldr	r5, [pc, #152]	; (9c00 <udpserver_recv+0x13c>)
    9b68:	47a8      	blx	r5
				pbuf_free(retbuf);
    9b6a:	4638      	mov	r0, r7
    9b6c:	4b1d      	ldr	r3, [pc, #116]	; (9be4 <udpserver_recv+0x120>)
    9b6e:	4798      	blx	r3
				break;
    9b70:	e7b9      	b.n	9ae6 <udpserver_recv+0x22>
				retbuf = pbuf_alloc(PBUF_TRANSPORT, 5+sizeof(LWIP_MACIF_hwaddr)+PCB_NAME_LENGTH, PBUF_RAM);
    9b72:	2200      	movs	r2, #0
    9b74:	2110      	movs	r1, #16
    9b76:	4610      	mov	r0, r2
    9b78:	4b20      	ldr	r3, [pc, #128]	; (9bfc <udpserver_recv+0x138>)
    9b7a:	4798      	blx	r3
    9b7c:	4607      	mov	r7, r0
				ReturnInst=retbuf->payload;
    9b7e:	6843      	ldr	r3, [r0, #4]
				memcpy(ReturnInst,p->payload,5); //copy IP + inst byte to return instruction
    9b80:	6862      	ldr	r2, [r4, #4]
    9b82:	6811      	ldr	r1, [r2, #0]
    9b84:	6019      	str	r1, [r3, #0]
    9b86:	7912      	ldrb	r2, [r2, #4]
    9b88:	711a      	strb	r2, [r3, #4]
				memcpy(ReturnInst+ReturnInstLen,LWIP_MACIF_hwaddr,sizeof(LWIP_MACIF_hwaddr));//copy mac
    9b8a:	4a1e      	ldr	r2, [pc, #120]	; (9c04 <udpserver_recv+0x140>)
    9b8c:	6811      	ldr	r1, [r2, #0]
    9b8e:	f8c3 1005 	str.w	r1, [r3, #5]
    9b92:	8892      	ldrh	r2, [r2, #4]
    9b94:	f8a3 2009 	strh.w	r2, [r3, #9]
				memcpy(ReturnInst+ReturnInstLen,PCB_Name,PCB_NAME_LENGTH);//copy name
    9b98:	4a1b      	ldr	r2, [pc, #108]	; (9c08 <udpserver_recv+0x144>)
    9b9a:	6810      	ldr	r0, [r2, #0]
    9b9c:	f8c3 000b 	str.w	r0, [r3, #11]
    9ba0:	7912      	ldrb	r2, [r2, #4]
    9ba2:	73da      	strb	r2, [r3, #15]
				udp_sendto(pcb, retbuf, addr, UDP_PORT); //dest port
    9ba4:	f24d 1306 	movw	r3, #53510	; 0xd106
    9ba8:	4632      	mov	r2, r6
    9baa:	4639      	mov	r1, r7
    9bac:	4628      	mov	r0, r5
    9bae:	4d14      	ldr	r5, [pc, #80]	; (9c00 <udpserver_recv+0x13c>)
    9bb0:	47a8      	blx	r5
				pbuf_free(retbuf);
    9bb2:	4638      	mov	r0, r7
    9bb4:	4b0b      	ldr	r3, [pc, #44]	; (9be4 <udpserver_recv+0x120>)
    9bb6:	4798      	blx	r3
			break;
    9bb8:	e795      	b.n	9ae6 <udpserver_recv+0x22>
				MotorInst[0]=InstData[5];  //Motor Num<<4
    9bba:	797b      	ldrb	r3, [r7, #5]
    9bbc:	f88d 3104 	strb.w	r3, [sp, #260]	; 0x104
				MotorInst[1]=InstData[6];  //Dir+Strength
    9bc0:	79bb      	ldrb	r3, [r7, #6]
    9bc2:	f88d 3105 	strb.w	r3, [sp, #261]	; 0x105
				MotorInst[2]=InstData[7];  //duration low byte
    9bc6:	79fb      	ldrb	r3, [r7, #7]
    9bc8:	f88d 3106 	strb.w	r3, [sp, #262]	; 0x106
				MotorInst[3]=InstData[8];  //duration high byte
    9bcc:	7a3b      	ldrb	r3, [r7, #8]
    9bce:	f88d 3107 	strb.w	r3, [sp, #263]	; 0x107
				SendMotorInst(MotorInst);
    9bd2:	a841      	add	r0, sp, #260	; 0x104
    9bd4:	4b0d      	ldr	r3, [pc, #52]	; (9c0c <udpserver_recv+0x148>)
    9bd6:	4798      	blx	r3
			break; 
    9bd8:	e785      	b.n	9ae6 <udpserver_recv+0x22>
    9bda:	4770      	bx	lr
    9bdc:	0000c7c8 	.word	0x0000c7c8
    9be0:	0000a111 	.word	0x0000a111
    9be4:	00005d21 	.word	0x00005d21
    9be8:	200081fc 	.word	0x200081fc
    9bec:	00001671 	.word	0x00001671
    9bf0:	0000a0eb 	.word	0x0000a0eb
    9bf4:	0000c7d4 	.word	0x0000c7d4
    9bf8:	00000fad 	.word	0x00000fad
    9bfc:	00005d89 	.word	0x00005d89
    9c00:	00008e59 	.word	0x00008e59
    9c04:	200082a4 	.word	0x200082a4
    9c08:	0000c7cc 	.word	0x0000c7cc
    9c0c:	0000996d 	.word	0x0000996d

00009c10 <InitializeMotors>:

int InitializeMotors(void) 
{
    9c10:	b470      	push	{r4, r5, r6}
	
	int i;
	
	//set number of clocks in motor duty cycle
	//is 7 (but was 14), 7 timer2 interrupts make 1 full motor duty cycle
	NumClocksInMotorDutyCycle=ROBOT_MOTORS_DEFAULT_NUM_CLKS_IN_MOTOR_DUTY_CYCLE;
    9c12:	2214      	movs	r2, #20
    9c14:	4b38      	ldr	r3, [pc, #224]	; (9cf8 <InitializeMotors+0xe8>)
    9c16:	601a      	str	r2, [r3, #0]
	MotorDutyCycleClock=ROBOT_MOTORS_DEFAULT_MOTOR_DUTY_CYCLE_CLK;
    9c18:	2219      	movs	r2, #25
    9c1a:	4b38      	ldr	r3, [pc, #224]	; (9cfc <InitializeMotors+0xec>)
    9c1c:	601a      	str	r2, [r3, #0]
	
	
	NumMotors=8;
    9c1e:	2308      	movs	r3, #8
    9c20:	4a37      	ldr	r2, [pc, #220]	; (9d00 <InitializeMotors+0xf0>)
    9c22:	7013      	strb	r3, [r2, #0]
	//Clear the robot status array
	memset(Motor,sizeof(MotorStatus)*NumMotors,0);

	//Motor[0].flags|=MOTOR_DRIVER_USES_PULSE_PIN;
	Motor[0].DirPin=GPIO(GPIO_PORTB, 13);
    9c24:	4d37      	ldr	r5, [pc, #220]	; (9d04 <InitializeMotors+0xf4>)
    9c26:	222d      	movs	r2, #45	; 0x2d
    9c28:	606a      	str	r2, [r5, #4]
	Motor[0].PulsePin=GPIO(GPIO_PORTB, 12);
    9c2a:	222c      	movs	r2, #44	; 0x2c
    9c2c:	60aa      	str	r2, [r5, #8]
	Motor[1].DirPin=GPIO(GPIO_PORTB, 11);
    9c2e:	222b      	movs	r2, #43	; 0x2b
    9c30:	632a      	str	r2, [r5, #48]	; 0x30
	Motor[1].PulsePin=GPIO(GPIO_PORTB, 10);
    9c32:	222a      	movs	r2, #42	; 0x2a
    9c34:	636a      	str	r2, [r5, #52]	; 0x34
	Motor[2].DirPin=GPIO(GPIO_PORTA, 11);
    9c36:	220b      	movs	r2, #11
    9c38:	65ea      	str	r2, [r5, #92]	; 0x5c
	Motor[2].PulsePin=GPIO(GPIO_PORTA, 10);
    9c3a:	220a      	movs	r2, #10
    9c3c:	662a      	str	r2, [r5, #96]	; 0x60
	Motor[3].DirPin=GPIO(GPIO_PORTA, 9);
    9c3e:	2209      	movs	r2, #9
    9c40:	f8c5 2088 	str.w	r2, [r5, #136]	; 0x88
	Motor[3].PulsePin=GPIO(GPIO_PORTA, 8);
    9c44:	f8c5 308c 	str.w	r3, [r5, #140]	; 0x8c

	Motor[4].DirPin=GPIO(GPIO_PORTA, 7);
    9c48:	2307      	movs	r3, #7
    9c4a:	f8c5 30b4 	str.w	r3, [r5, #180]	; 0xb4
	Motor[4].PulsePin=GPIO(GPIO_PORTA, 6);
    9c4e:	2306      	movs	r3, #6
    9c50:	f8c5 30b8 	str.w	r3, [r5, #184]	; 0xb8
	Motor[5].DirPin=GPIO(GPIO_PORTA, 5);
    9c54:	2305      	movs	r3, #5
    9c56:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
	Motor[5].PulsePin=GPIO(GPIO_PORTA, 4);
    9c5a:	2304      	movs	r3, #4
    9c5c:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
	Motor[6].DirPin=GPIO(GPIO_PORTB, 9);
    9c60:	2329      	movs	r3, #41	; 0x29
    9c62:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c
	Motor[6].PulsePin=GPIO(GPIO_PORTB, 8);
    9c66:	2328      	movs	r3, #40	; 0x28
    9c68:	f8c5 3110 	str.w	r3, [r5, #272]	; 0x110
	Motor[7].DirPin=GPIO(GPIO_PORTB, 7);
    9c6c:	2327      	movs	r3, #39	; 0x27
    9c6e:	f8c5 3138 	str.w	r3, [r5, #312]	; 0x138
	Motor[7].PulsePin=GPIO(GPIO_PORTB, 6);
    9c72:	2326      	movs	r3, #38	; 0x26
    9c74:	f8c5 313c 	str.w	r3, [r5, #316]	; 0x13c
    9c78:	4629      	mov	r1, r5
    9c7a:	f505 75b0 	add.w	r5, r5, #352	; 0x160
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    9c7e:	2401      	movs	r4, #1
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    9c80:	4821      	ldr	r0, [pc, #132]	; (9d08 <InitializeMotors+0xf8>)
	
	for(i=0;i<NumMotors;i++) {
		gpio_set_pin_direction(Motor[i].DirPin,GPIO_DIRECTION_OUT);
    9c82:	790a      	ldrb	r2, [r1, #4]
    9c84:	f002 031f 	and.w	r3, r2, #31
    9c88:	fa04 f303 	lsl.w	r3, r4, r3
    9c8c:	0952      	lsrs	r2, r2, #5
    9c8e:	eb00 12c2 	add.w	r2, r0, r2, lsl #7
    9c92:	6093      	str	r3, [r2, #8]
		                                | ((mask & 0xffff0000) >> 16));
		break;

	case GPIO_DIRECTION_OUT:
		hri_port_set_DIR_reg(PORT, port, mask);
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    9c94:	b29e      	uxth	r6, r3
    9c96:	f046 4680 	orr.w	r6, r6, #1073741824	; 0x40000000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    9c9a:	6296      	str	r6, [r2, #40]	; 0x28
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    9c9c:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    9c9e:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    9ca2:	6293      	str	r3, [r2, #40]	; 0x28
		gpio_set_pin_level(Motor[i].DirPin,false);
    9ca4:	790b      	ldrb	r3, [r1, #4]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    9ca6:	f003 021f 	and.w	r2, r3, #31
    9caa:	fa04 f202 	lsl.w	r2, r4, r2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9cae:	095b      	lsrs	r3, r3, #5
    9cb0:	eb00 13c3 	add.w	r3, r0, r3, lsl #7
    9cb4:	615a      	str	r2, [r3, #20]
		gpio_set_pin_direction(Motor[i].PulsePin,GPIO_DIRECTION_OUT);
    9cb6:	7a0a      	ldrb	r2, [r1, #8]
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    9cb8:	f002 031f 	and.w	r3, r2, #31
    9cbc:	fa04 f303 	lsl.w	r3, r4, r3
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    9cc0:	0952      	lsrs	r2, r2, #5
    9cc2:	eb00 12c2 	add.w	r2, r0, r2, lsl #7
    9cc6:	6093      	str	r3, [r2, #8]
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    9cc8:	b29e      	uxth	r6, r3
    9cca:	f046 4680 	orr.w	r6, r6, #1073741824	; 0x40000000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    9cce:	6296      	str	r6, [r2, #40]	; 0x28
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    9cd0:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    9cd2:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    9cd6:	6293      	str	r3, [r2, #40]	; 0x28
		gpio_set_pin_level(Motor[i].PulsePin,false);
    9cd8:	7a0b      	ldrb	r3, [r1, #8]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    9cda:	f003 021f 	and.w	r2, r3, #31
    9cde:	fa04 f202 	lsl.w	r2, r4, r2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9ce2:	095b      	lsrs	r3, r3, #5
    9ce4:	eb00 13c3 	add.w	r3, r0, r3, lsl #7
    9ce8:	615a      	str	r2, [r3, #20]
    9cea:	312c      	adds	r1, #44	; 0x2c
	for(i=0;i<NumMotors;i++) {
    9cec:	42a9      	cmp	r1, r5
    9cee:	d1c8      	bne.n	9c82 <InitializeMotors+0x72>
	}

	return(1);
} //int InitializeMotors(void)
    9cf0:	2001      	movs	r0, #1
    9cf2:	bc70      	pop	{r4, r5, r6}
    9cf4:	4770      	bx	lr
    9cf6:	bf00      	nop
    9cf8:	200095ec 	.word	0x200095ec
    9cfc:	20009328 	.word	0x20009328
    9d00:	20009320 	.word	0x20009320
    9d04:	2000932c 	.word	0x2000932c
    9d08:	41008000 	.word	0x41008000

00009d0c <main>:


int main(void)
{
    9d0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9d10:	b0c5      	sub	sp, #276	; 0x114
	u8_t    mac[6];
	u8_t ReadBuffer[256];
	//struct usart_async_status iostat;  //currently needed for usart async

	/* Initializes MCU, drivers and middleware - tph - inits phy and uarts*/
	atmel_start_init();
    9d12:	4b70      	ldr	r3, [pc, #448]	; (9ed4 <main+0x1c8>)
    9d14:	4798      	blx	r3
	// Set pin direction to output
	//gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
	//gpio_set_pin_function(LED0, GPIO_PIN_FUNCTION_OFF);

//USART_ASYNC_TXC_CB
	usart_async_register_callback(&USART_1, USART_ASYNC_RXC_CB, usart1_receive_cb);
    9d16:	4c70      	ldr	r4, [pc, #448]	; (9ed8 <main+0x1cc>)
    9d18:	4a70      	ldr	r2, [pc, #448]	; (9edc <main+0x1d0>)
    9d1a:	2100      	movs	r1, #0
    9d1c:	4620      	mov	r0, r4
    9d1e:	4b70      	ldr	r3, [pc, #448]	; (9ee0 <main+0x1d4>)
    9d20:	4798      	blx	r3
	usart_async_enable(&USART_1);
    9d22:	4620      	mov	r0, r4
    9d24:	4b6f      	ldr	r3, [pc, #444]	; (9ee4 <main+0x1d8>)
    9d26:	4798      	blx	r3
	uint8_t addr = 0x9A;
    9d28:	239a      	movs	r3, #154	; 0x9a
    9d2a:	f88d 3003 	strb.w	r3, [sp, #3]
	i2c_m_sync_enable(&I2C_0);
    9d2e:	4c6e      	ldr	r4, [pc, #440]	; (9ee8 <main+0x1dc>)
    9d30:	4620      	mov	r0, r4
    9d32:	4b6e      	ldr	r3, [pc, #440]	; (9eec <main+0x1e0>)
    9d34:	4798      	blx	r3
	i2c_m_sync_set_slaveaddr(&I2C_0, CONF_AT24MAC_ADDRESS, I2C_M_SEVEN);
    9d36:	f44f 6200 	mov.w	r2, #2048	; 0x800
    9d3a:	215e      	movs	r1, #94	; 0x5e
    9d3c:	4620      	mov	r0, r4
    9d3e:	4b6c      	ldr	r3, [pc, #432]	; (9ef0 <main+0x1e4>)
    9d40:	4798      	blx	r3
	io_write(&(I2C_0.io), &addr, 1);
    9d42:	3414      	adds	r4, #20
    9d44:	2201      	movs	r2, #1
    9d46:	f10d 0103 	add.w	r1, sp, #3
    9d4a:	4620      	mov	r0, r4
    9d4c:	f8df 824c 	ldr.w	r8, [pc, #588]	; 9f9c <main+0x290>
    9d50:	47c0      	blx	r8
	io_read(&(I2C_0.io), mac, 6);
    9d52:	2206      	movs	r2, #6
    9d54:	a901      	add	r1, sp, #4
    9d56:	4620      	mov	r0, r4
    9d58:	4b66      	ldr	r3, [pc, #408]	; (9ef4 <main+0x1e8>)
    9d5a:	4798      	blx	r3


	/* Read MacAddress from EEPROM */  //tph: currently just adding a valid public MAC address
	read_macaddress(mac);

	systick_enable();
    9d5c:	4b66      	ldr	r3, [pc, #408]	; (9ef8 <main+0x1ec>)
    9d5e:	4798      	blx	r3

	//MACIF_example();
	
	ETHERNET_PHY_0_example();  //restarts autonegotiation
    9d60:	4b66      	ldr	r3, [pc, #408]	; (9efc <main+0x1f0>)
    9d62:	4798      	blx	r3

	//init usart
	usart_sync_get_io_descriptor(&USART_0, &io);
    9d64:	4c66      	ldr	r4, [pc, #408]	; (9f00 <main+0x1f4>)
    9d66:	a943      	add	r1, sp, #268	; 0x10c
    9d68:	4620      	mov	r0, r4
    9d6a:	4b66      	ldr	r3, [pc, #408]	; (9f04 <main+0x1f8>)
    9d6c:	4798      	blx	r3
	usart_sync_enable(&USART_0);
    9d6e:	4620      	mov	r0, r4
    9d70:	4b65      	ldr	r3, [pc, #404]	; (9f08 <main+0x1fc>)
    9d72:	4798      	blx	r3
	//usart_async_get_io_descriptor(&USART_0, &io);
	//usart_async_enable(&USART_0);
	count=0;
	sprintf((char *)OutStr,"**************************\n");
    9d74:	4e65      	ldr	r6, [pc, #404]	; (9f0c <main+0x200>)
    9d76:	ad03      	add	r5, sp, #12
    9d78:	4634      	mov	r4, r6
    9d7a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    9d7c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    9d7e:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
    9d82:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	io_write(io,OutStr,strlen(OutStr));
    9d86:	a803      	add	r0, sp, #12
    9d88:	f8df 9214 	ldr.w	r9, [pc, #532]	; 9fa0 <main+0x294>
    9d8c:	47c8      	blx	r9
    9d8e:	b282      	uxth	r2, r0
    9d90:	a903      	add	r1, sp, #12
    9d92:	9843      	ldr	r0, [sp, #268]	; 0x10c
    9d94:	47c0      	blx	r8
	
	//while (usart_async_get_status(&USART_0, &iostat)==ERR_BUSY);
	//sprintf((char *)OutStr,"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\n");
	//io_write(io,OutStr,strlen(OutStr));
	sprintf((char *)OutStr,"EthMotorsArm_DRV8800_rev03\n");
    9d96:	ad03      	add	r5, sp, #12
    9d98:	4f5d      	ldr	r7, [pc, #372]	; (9f10 <main+0x204>)
    9d9a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    9d9c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    9d9e:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    9da2:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	io_write(io,OutStr,strlen(OutStr));
    9da6:	a803      	add	r0, sp, #12
    9da8:	47c8      	blx	r9
    9daa:	b282      	uxth	r2, r0
    9dac:	a903      	add	r1, sp, #12
    9dae:	9843      	ldr	r0, [sp, #268]	; 0x10c
    9db0:	47c0      	blx	r8
	//while (usart_async_get_status(&USART_0, &iostat)==ERR_BUSY);

	//sprintf((char *)OutStr,"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\n");
	//io_write(io,OutStr,strlen(OutStr));
	sprintf((char *)OutStr,"**************************\n");
    9db2:	ad03      	add	r5, sp, #12
    9db4:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    9db6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    9db8:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
    9dbc:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	io_write(io,OutStr,strlen(OutStr));
    9dc0:	a803      	add	r0, sp, #12
    9dc2:	47c8      	blx	r9
    9dc4:	b282      	uxth	r2, r0
    9dc6:	a903      	add	r1, sp, #12
    9dc8:	9843      	ldr	r0, [sp, #268]	; 0x10c
    9dca:	47c0      	blx	r8
	//sprintf((char *)OutStr,"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\n");
	//io_write(io,OutStr,strlen(OutStr));



	printf("\r\nHello ATMEL World!\r\n");
    9dcc:	4851      	ldr	r0, [pc, #324]	; (9f14 <main+0x208>)
    9dce:	4b52      	ldr	r3, [pc, #328]	; (9f18 <main+0x20c>)
    9dd0:	4798      	blx	r3
	//fflush(stdio_io);

	//below does not work for printf because printf calls _puts_r which must send one char at a time 
	//while (usart_async_get_status(&USART_0, &iostat)==ERR_BUSY); 

	mac_async_register_callback(&ETHERNET_MAC_0, MAC_ASYNC_RECEIVE_CB, (FUNC_PTR)mac_receive_cb);
    9dd2:	4d52      	ldr	r5, [pc, #328]	; (9f1c <main+0x210>)
    9dd4:	4a52      	ldr	r2, [pc, #328]	; (9f20 <main+0x214>)
    9dd6:	2100      	movs	r1, #0
    9dd8:	4628      	mov	r0, r5
    9dda:	4c52      	ldr	r4, [pc, #328]	; (9f24 <main+0x218>)
    9ddc:	47a0      	blx	r4
	mac_async_register_callback(&ETHERNET_MAC_0, MAC_ASYNC_TRANSMIT_CB, (FUNC_PTR)mac_transmit_cb);
    9dde:	4a52      	ldr	r2, [pc, #328]	; (9f28 <main+0x21c>)
    9de0:	2101      	movs	r1, #1
    9de2:	4628      	mov	r0, r5
    9de4:	47a0      	blx	r4

	eth_ipstack_init();
    9de6:	4b51      	ldr	r3, [pc, #324]	; (9f2c <main+0x220>)
    9de8:	4798      	blx	r3
	do {
		ret = ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_up);
    9dea:	4f51      	ldr	r7, [pc, #324]	; (9f30 <main+0x224>)
    9dec:	f507 7692 	add.w	r6, r7, #292	; 0x124
    9df0:	4d50      	ldr	r5, [pc, #320]	; (9f34 <main+0x228>)
    9df2:	4c51      	ldr	r4, [pc, #324]	; (9f38 <main+0x22c>)
    9df4:	4631      	mov	r1, r6
    9df6:	4628      	mov	r0, r5
    9df8:	47a0      	blx	r4
		if (ret == ERR_NONE && link_up) {
    9dfa:	2800      	cmp	r0, #0
    9dfc:	d1fa      	bne.n	9df4 <main+0xe8>
    9dfe:	f897 3124 	ldrb.w	r3, [r7, #292]	; 0x124
    9e02:	2b00      	cmp	r3, #0
    9e04:	d0f6      	beq.n	9df4 <main+0xe8>
			break;
		}
	} while (true);
	printf("Ethernet Connection established\n");
    9e06:	484d      	ldr	r0, [pc, #308]	; (9f3c <main+0x230>)
    9e08:	4d43      	ldr	r5, [pc, #268]	; (9f18 <main+0x20c>)
    9e0a:	47a8      	blx	r5
	LWIP_MACIF_init(mac);  //tph: add LWIP callback for recvd input: ethernet_input()
    9e0c:	a801      	add	r0, sp, #4
    9e0e:	4b4c      	ldr	r3, [pc, #304]	; (9f40 <main+0x234>)
    9e10:	4798      	blx	r3

	//make this the default interface
	netif_set_default(&LWIP_MACIF_desc);
    9e12:	4c4c      	ldr	r4, [pc, #304]	; (9f44 <main+0x238>)
    9e14:	4620      	mov	r0, r4
    9e16:	4b4c      	ldr	r3, [pc, #304]	; (9f48 <main+0x23c>)
    9e18:	4798      	blx	r3
	
	// Set callback function for netif status change 
	netif_set_status_callback(&LWIP_MACIF_desc, status_callback);
    9e1a:	494c      	ldr	r1, [pc, #304]	; (9f4c <main+0x240>)
    9e1c:	4620      	mov	r0, r4
    9e1e:	4b4c      	ldr	r3, [pc, #304]	; (9f50 <main+0x244>)
    9e20:	4798      	blx	r3

	//Set callback function for link status change
	netif_set_link_callback(&LWIP_MACIF_desc, link_callback);
    9e22:	494c      	ldr	r1, [pc, #304]	; (9f54 <main+0x248>)
    9e24:	4620      	mov	r0, r4
    9e26:	4b4c      	ldr	r3, [pc, #304]	; (9f58 <main+0x24c>)
    9e28:	4798      	blx	r3

		
	mac_async_enable(&ETHERNET_MAC_0);
    9e2a:	483c      	ldr	r0, [pc, #240]	; (9f1c <main+0x210>)
    9e2c:	4b4b      	ldr	r3, [pc, #300]	; (9f5c <main+0x250>)
    9e2e:	4798      	blx	r3


//#if 0 
	//udpecho_init(); //START UDP ECHO THREAD - requires netconn 
	//start_udp();
	udpserver_pcb = udp_new();  //create udp server
    9e30:	4b4b      	ldr	r3, [pc, #300]	; (9f60 <main+0x254>)
    9e32:	4798      	blx	r3
    9e34:	4e4b      	ldr	r6, [pc, #300]	; (9f64 <main+0x258>)
    9e36:	6030      	str	r0, [r6, #0]
	//IP4_ADDR(&forward_ip, 192, 168,   2, 254);
//	udp_bind(udpserver_pcb, IP_ADDR_ANY, UDP_PORT);   //port UDP_PORT 
	udp_bind(udpserver_pcb, &LWIP_MACIF_desc.ip_addr.addr, UDP_PORT);   //port UDP_PORT 
    9e38:	f24d 1206 	movw	r2, #53510	; 0xd106
    9e3c:	1d21      	adds	r1, r4, #4
    9e3e:	4b4a      	ldr	r3, [pc, #296]	; (9f68 <main+0x25c>)
    9e40:	4798      	blx	r3
	udp_recv(udpserver_pcb, udpserver_recv, NULL);  //set udpserver callback function
    9e42:	2200      	movs	r2, #0
    9e44:	4949      	ldr	r1, [pc, #292]	; (9f6c <main+0x260>)
    9e46:	6830      	ldr	r0, [r6, #0]
    9e48:	4b49      	ldr	r3, [pc, #292]	; (9f70 <main+0x264>)
    9e4a:	4798      	blx	r3


	//bring up the network interface - ned to do here so above interrupts are enabled
	#ifdef LWIP_DHCP
	/* DHCP mode. */
	if (ERR_OK != dhcp_start(&LWIP_MACIF_desc)) {
    9e4c:	4620      	mov	r0, r4
    9e4e:	4b49      	ldr	r3, [pc, #292]	; (9f74 <main+0x268>)
    9e50:	4798      	blx	r3
		LWIP_ASSERT("ERR_OK != dhcp_start", 0);
	}
	printf("DHCP Started\r\n");
    9e52:	4849      	ldr	r0, [pc, #292]	; (9f78 <main+0x26c>)
    9e54:	47a8      	blx	r5
	/* Static mode. */
	netif_set_up(&LWIP_MACIF_desc);
	printf("Static IP Address Assigned\r\n");
	#endif

	InitializeMotors(); //set initial settings of all motors
    9e56:	4b49      	ldr	r3, [pc, #292]	; (9f7c <main+0x270>)
    9e58:	4798      	blx	r3
	//currently motor timer stop DHCP from working
	MotorTimer_Initialize();  //start timer for motor pwm
    9e5a:	4b49      	ldr	r3, [pc, #292]	; (9f80 <main+0x274>)
    9e5c:	4798      	blx	r3
			StartDHCP=0;
			dhcp_start(&LWIP_MACIF_desc); //tph start dhcp
		}
*/

		if (gmac_recv_flag) {
    9e5e:	4c34      	ldr	r4, [pc, #208]	; (9f30 <main+0x224>)
			//printf("gmac_recd");
			//sprintf((char *)OutStr,"recvd2\n");
			//io_write(io,OutStr,strlen(OutStr));
			
			gmac_recv_flag = false;
			ethernetif_mac_input(&LWIP_MACIF_desc);
    9e60:	4d38      	ldr	r5, [pc, #224]	; (9f44 <main+0x238>)
    9e62:	4e48      	ldr	r6, [pc, #288]	; (9f84 <main+0x278>)
	printf("IP_ADDR    : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.ip_addr), tmp_buff, 16));
    9e64:	f504 7894 	add.w	r8, r4, #296	; 0x128
    9e68:	1d2f      	adds	r7, r5, #4
	printf("NET_MASK   : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.netmask), tmp_buff, 16));
    9e6a:	f107 0904 	add.w	r9, r7, #4
    9e6e:	e006      	b.n	9e7e <main+0x172>
			gmac_recv_flag = false;
    9e70:	2300      	movs	r3, #0
    9e72:	7023      	strb	r3, [r4, #0]
			ethernetif_mac_input(&LWIP_MACIF_desc);
    9e74:	4628      	mov	r0, r5
    9e76:	47b0      	blx	r6
    9e78:	e004      	b.n	9e84 <main+0x178>
	tsr=hri_gmac_read_TSR_reg(GMAC);  //bit 5 tx complete
#endif	
	//could test loop back send and receive: set LBL bit in NCR


	USART_1_input();  //check for usart1 input
    9e7a:	4b43      	ldr	r3, [pc, #268]	; (9f88 <main+0x27c>)
    9e7c:	4798      	blx	r3
		if (gmac_recv_flag) {
    9e7e:	7823      	ldrb	r3, [r4, #0]
    9e80:	2b00      	cmp	r3, #0
    9e82:	d1f5      	bne.n	9e70 <main+0x164>
		sys_check_timeouts();
    9e84:	4b41      	ldr	r3, [pc, #260]	; (9f8c <main+0x280>)
    9e86:	4798      	blx	r3
		if (link_up && LWIP_MACIF_desc.ip_addr.addr) {
    9e88:	f894 3124 	ldrb.w	r3, [r4, #292]	; 0x124
    9e8c:	2b00      	cmp	r3, #0
    9e8e:	d0f4      	beq.n	9e7a <main+0x16e>
    9e90:	686b      	ldr	r3, [r5, #4]
    9e92:	2b00      	cmp	r3, #0
    9e94:	d0f1      	beq.n	9e7a <main+0x16e>
			link_up = false;
    9e96:	2300      	movs	r3, #0
    9e98:	f884 3124 	strb.w	r3, [r4, #292]	; 0x124
	printf("IP_ADDR    : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.ip_addr), tmp_buff, 16));
    9e9c:	2210      	movs	r2, #16
    9e9e:	4641      	mov	r1, r8
    9ea0:	4638      	mov	r0, r7
    9ea2:	f8df b100 	ldr.w	fp, [pc, #256]	; 9fa4 <main+0x298>
    9ea6:	47d8      	blx	fp
    9ea8:	4601      	mov	r1, r0
    9eaa:	4839      	ldr	r0, [pc, #228]	; (9f90 <main+0x284>)
    9eac:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 9fa8 <main+0x29c>
    9eb0:	47d0      	blx	sl
	printf("NET_MASK   : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.netmask), tmp_buff, 16));
    9eb2:	2210      	movs	r2, #16
    9eb4:	4641      	mov	r1, r8
    9eb6:	4648      	mov	r0, r9
    9eb8:	47d8      	blx	fp
    9eba:	4601      	mov	r1, r0
    9ebc:	4835      	ldr	r0, [pc, #212]	; (9f94 <main+0x288>)
    9ebe:	47d0      	blx	sl
	printf("GATEWAY_IP : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.gw), tmp_buff, 16));
    9ec0:	2210      	movs	r2, #16
    9ec2:	4641      	mov	r1, r8
    9ec4:	f107 0008 	add.w	r0, r7, #8
    9ec8:	47d8      	blx	fp
    9eca:	4601      	mov	r1, r0
    9ecc:	4832      	ldr	r0, [pc, #200]	; (9f98 <main+0x28c>)
    9ece:	47d0      	blx	sl
    9ed0:	e7d3      	b.n	9e7a <main+0x16e>
    9ed2:	bf00      	nop
    9ed4:	000002d1 	.word	0x000002d1
    9ed8:	200081fc 	.word	0x200081fc
    9edc:	00009919 	.word	0x00009919
    9ee0:	00001699 	.word	0x00001699
    9ee4:	00001645 	.word	0x00001645
    9ee8:	2000824c 	.word	0x2000824c
    9eec:	00000f91 	.word	0x00000f91
    9ef0:	00000f9d 	.word	0x00000f9d
    9ef4:	00000fdd 	.word	0x00000fdd
    9ef8:	000098c5 	.word	0x000098c5
    9efc:	00000d99 	.word	0x00000d99
    9f00:	200081f0 	.word	0x200081f0
    9f04:	00001855 	.word	0x00001855
    9f08:	00001829 	.word	0x00001829
    9f0c:	0000c7d8 	.word	0x0000c7d8
    9f10:	0000c7f4 	.word	0x0000c7f4
    9f14:	0000c810 	.word	0x0000c810
    9f18:	0000a1f9 	.word	0x0000a1f9
    9f1c:	2000826c 	.word	0x2000826c
    9f20:	000097f5 	.word	0x000097f5
    9f24:	0000110d 	.word	0x0000110d
    9f28:	000096f9 	.word	0x000096f9
    9f2c:	00000ea9 	.word	0x00000ea9
    9f30:	200080a4 	.word	0x200080a4
    9f34:	200081e8 	.word	0x200081e8
    9f38:	00000d1d 	.word	0x00000d1d
    9f3c:	0000c828 	.word	0x0000c828
    9f40:	00000e5d 	.word	0x00000e5d
    9f44:	200082ac 	.word	0x200082ac
    9f48:	00005b71 	.word	0x00005b71
    9f4c:	0000981d 	.word	0x0000981d
    9f50:	00005bed 	.word	0x00005bed
    9f54:	00009861 	.word	0x00009861
    9f58:	00005bf3 	.word	0x00005bf3
    9f5c:	00001051 	.word	0x00001051
    9f60:	00008f31 	.word	0x00008f31
    9f64:	20009324 	.word	0x20009324
    9f68:	00008c6d 	.word	0x00008c6d
    9f6c:	00009ac5 	.word	0x00009ac5
    9f70:	00008eed 	.word	0x00008eed
    9f74:	000046e1 	.word	0x000046e1
    9f78:	0000c848 	.word	0x0000c848
    9f7c:	00009c11 	.word	0x00009c11
    9f80:	00009939 	.word	0x00009939
    9f84:	00002eb5 	.word	0x00002eb5
    9f88:	00009a0d 	.word	0x00009a0d
    9f8c:	00008a0d 	.word	0x00008a0d
    9f90:	0000c858 	.word	0x0000c858
    9f94:	0000c86c 	.word	0x0000c86c
    9f98:	0000c880 	.word	0x0000c880
    9f9c:	00000fad 	.word	0x00000fad
    9fa0:	0000a375 	.word	0x0000a375
    9fa4:	00004fd1 	.word	0x00004fd1
    9fa8:	0000a111 	.word	0x0000a111

00009fac <_read>:

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
	int n = 0;

	if (file != 0) {
    9fac:	b940      	cbnz	r0, 9fc0 <_read+0x14>
{
    9fae:	b508      	push	{r3, lr}
    9fb0:	460b      	mov	r3, r1
    9fb2:	4611      	mov	r1, r2
    9fb4:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
    9fb6:	4b04      	ldr	r3, [pc, #16]	; (9fc8 <_read+0x1c>)
    9fb8:	4798      	blx	r3
    9fba:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
    9fbe:	bd08      	pop	{r3, pc}
		return -1;
    9fc0:	f04f 30ff 	mov.w	r0, #4294967295
    9fc4:	4770      	bx	lr
    9fc6:	bf00      	nop
    9fc8:	0000a01d 	.word	0x0000a01d

00009fcc <_write>:

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
    9fcc:	3801      	subs	r0, #1
    9fce:	2802      	cmp	r0, #2
    9fd0:	d808      	bhi.n	9fe4 <_write+0x18>
{
    9fd2:	b508      	push	{r3, lr}
    9fd4:	460b      	mov	r3, r1
    9fd6:	4611      	mov	r1, r2
    9fd8:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    9fda:	4b04      	ldr	r3, [pc, #16]	; (9fec <_write+0x20>)
    9fdc:	4798      	blx	r3
    9fde:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
    9fe2:	bd08      	pop	{r3, pc}
		return -1;
    9fe4:	f04f 30ff 	mov.w	r0, #4294967295
    9fe8:	4770      	bx	lr
    9fea:	bf00      	nop
    9fec:	0000a041 	.word	0x0000a041

00009ff0 <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
    9ff0:	b570      	push	{r4, r5, r6, lr}
    9ff2:	4606      	mov	r6, r0
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
    9ff4:	4d06      	ldr	r5, [pc, #24]	; (a010 <stdio_io_init+0x20>)
    9ff6:	682b      	ldr	r3, [r5, #0]
    9ff8:	2100      	movs	r1, #0
    9ffa:	6898      	ldr	r0, [r3, #8]
    9ffc:	4c05      	ldr	r4, [pc, #20]	; (a014 <stdio_io_init+0x24>)
    9ffe:	47a0      	blx	r4
	setbuf(stdin, NULL);
    a000:	682b      	ldr	r3, [r5, #0]
    a002:	2100      	movs	r1, #0
    a004:	6858      	ldr	r0, [r3, #4]
    a006:	47a0      	blx	r4
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
    a008:	4b03      	ldr	r3, [pc, #12]	; (a018 <stdio_io_init+0x28>)
    a00a:	601e      	str	r6, [r3, #0]
    a00c:	bd70      	pop	{r4, r5, r6, pc}
    a00e:	bf00      	nop
    a010:	20000010 	.word	0x20000010
    a014:	0000a209 	.word	0x0000a209
    a018:	200081dc 	.word	0x200081dc

0000a01c <stdio_io_read>:
{
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
    a01c:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
    a01e:	4b06      	ldr	r3, [pc, #24]	; (a038 <stdio_io_read+0x1c>)
    a020:	681b      	ldr	r3, [r3, #0]
    a022:	b133      	cbz	r3, a032 <stdio_io_read+0x16>
    a024:	460a      	mov	r2, r1
    a026:	4601      	mov	r1, r0
		return 0;
	}
	return io_read(stdio_io, buf, len);
    a028:	b292      	uxth	r2, r2
    a02a:	4618      	mov	r0, r3
    a02c:	4b03      	ldr	r3, [pc, #12]	; (a03c <stdio_io_read+0x20>)
    a02e:	4798      	blx	r3
    a030:	bd08      	pop	{r3, pc}
		return 0;
    a032:	2000      	movs	r0, #0
}
    a034:	bd08      	pop	{r3, pc}
    a036:	bf00      	nop
    a038:	200081dc 	.word	0x200081dc
    a03c:	00000fdd 	.word	0x00000fdd

0000a040 <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
    a040:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
    a042:	4b06      	ldr	r3, [pc, #24]	; (a05c <stdio_io_write+0x1c>)
    a044:	681b      	ldr	r3, [r3, #0]
    a046:	b133      	cbz	r3, a056 <stdio_io_write+0x16>
    a048:	460a      	mov	r2, r1
    a04a:	4601      	mov	r1, r0
		return 0;
	}
	return io_write(stdio_io, buf, len);
    a04c:	b292      	uxth	r2, r2
    a04e:	4618      	mov	r0, r3
    a050:	4b03      	ldr	r3, [pc, #12]	; (a060 <stdio_io_write+0x20>)
    a052:	4798      	blx	r3
    a054:	bd08      	pop	{r3, pc}
		return 0;
    a056:	2000      	movs	r0, #0
}
    a058:	bd08      	pop	{r3, pc}
    a05a:	bf00      	nop
    a05c:	200081dc 	.word	0x200081dc
    a060:	00000fad 	.word	0x00000fad

0000a064 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
    a064:	b510      	push	{r4, lr}

	usart_sync_enable(&USART_0);
    a066:	4c04      	ldr	r4, [pc, #16]	; (a078 <stdio_redirect_init+0x14>)
    a068:	4620      	mov	r0, r4
    a06a:	4b04      	ldr	r3, [pc, #16]	; (a07c <stdio_redirect_init+0x18>)
    a06c:	4798      	blx	r3
	stdio_io_init(&USART_0.io);
    a06e:	4620      	mov	r0, r4
    a070:	4b03      	ldr	r3, [pc, #12]	; (a080 <stdio_redirect_init+0x1c>)
    a072:	4798      	blx	r3
    a074:	bd10      	pop	{r4, pc}
    a076:	bf00      	nop
    a078:	200081f0 	.word	0x200081f0
    a07c:	00001829 	.word	0x00001829
    a080:	00009ff1 	.word	0x00009ff1

0000a084 <__libc_init_array>:
    a084:	b570      	push	{r4, r5, r6, lr}
    a086:	4e0d      	ldr	r6, [pc, #52]	; (a0bc <__libc_init_array+0x38>)
    a088:	4c0d      	ldr	r4, [pc, #52]	; (a0c0 <__libc_init_array+0x3c>)
    a08a:	1ba4      	subs	r4, r4, r6
    a08c:	10a4      	asrs	r4, r4, #2
    a08e:	2500      	movs	r5, #0
    a090:	42a5      	cmp	r5, r4
    a092:	d109      	bne.n	a0a8 <__libc_init_array+0x24>
    a094:	4e0b      	ldr	r6, [pc, #44]	; (a0c4 <__libc_init_array+0x40>)
    a096:	4c0c      	ldr	r4, [pc, #48]	; (a0c8 <__libc_init_array+0x44>)
    a098:	f002 fc48 	bl	c92c <_init>
    a09c:	1ba4      	subs	r4, r4, r6
    a09e:	10a4      	asrs	r4, r4, #2
    a0a0:	2500      	movs	r5, #0
    a0a2:	42a5      	cmp	r5, r4
    a0a4:	d105      	bne.n	a0b2 <__libc_init_array+0x2e>
    a0a6:	bd70      	pop	{r4, r5, r6, pc}
    a0a8:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    a0ac:	4798      	blx	r3
    a0ae:	3501      	adds	r5, #1
    a0b0:	e7ee      	b.n	a090 <__libc_init_array+0xc>
    a0b2:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    a0b6:	4798      	blx	r3
    a0b8:	3501      	adds	r5, #1
    a0ba:	e7f2      	b.n	a0a2 <__libc_init_array+0x1e>
    a0bc:	0000c938 	.word	0x0000c938
    a0c0:	0000c938 	.word	0x0000c938
    a0c4:	0000c938 	.word	0x0000c938
    a0c8:	0000c93c 	.word	0x0000c93c

0000a0cc <memcmp>:
    a0cc:	b510      	push	{r4, lr}
    a0ce:	3901      	subs	r1, #1
    a0d0:	4402      	add	r2, r0
    a0d2:	4290      	cmp	r0, r2
    a0d4:	d101      	bne.n	a0da <memcmp+0xe>
    a0d6:	2000      	movs	r0, #0
    a0d8:	bd10      	pop	{r4, pc}
    a0da:	f810 3b01 	ldrb.w	r3, [r0], #1
    a0de:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    a0e2:	42a3      	cmp	r3, r4
    a0e4:	d0f5      	beq.n	a0d2 <memcmp+0x6>
    a0e6:	1b18      	subs	r0, r3, r4
    a0e8:	bd10      	pop	{r4, pc}

0000a0ea <memcpy>:
    a0ea:	b510      	push	{r4, lr}
    a0ec:	1e43      	subs	r3, r0, #1
    a0ee:	440a      	add	r2, r1
    a0f0:	4291      	cmp	r1, r2
    a0f2:	d100      	bne.n	a0f6 <memcpy+0xc>
    a0f4:	bd10      	pop	{r4, pc}
    a0f6:	f811 4b01 	ldrb.w	r4, [r1], #1
    a0fa:	f803 4f01 	strb.w	r4, [r3, #1]!
    a0fe:	e7f7      	b.n	a0f0 <memcpy+0x6>

0000a100 <memset>:
    a100:	4402      	add	r2, r0
    a102:	4603      	mov	r3, r0
    a104:	4293      	cmp	r3, r2
    a106:	d100      	bne.n	a10a <memset+0xa>
    a108:	4770      	bx	lr
    a10a:	f803 1b01 	strb.w	r1, [r3], #1
    a10e:	e7f9      	b.n	a104 <memset+0x4>

0000a110 <iprintf>:
    a110:	b40f      	push	{r0, r1, r2, r3}
    a112:	4b0a      	ldr	r3, [pc, #40]	; (a13c <iprintf+0x2c>)
    a114:	b513      	push	{r0, r1, r4, lr}
    a116:	681c      	ldr	r4, [r3, #0]
    a118:	b124      	cbz	r4, a124 <iprintf+0x14>
    a11a:	69a3      	ldr	r3, [r4, #24]
    a11c:	b913      	cbnz	r3, a124 <iprintf+0x14>
    a11e:	4620      	mov	r0, r4
    a120:	f000 fae2 	bl	a6e8 <__sinit>
    a124:	ab05      	add	r3, sp, #20
    a126:	9a04      	ldr	r2, [sp, #16]
    a128:	68a1      	ldr	r1, [r4, #8]
    a12a:	9301      	str	r3, [sp, #4]
    a12c:	4620      	mov	r0, r4
    a12e:	f000 fca5 	bl	aa7c <_vfiprintf_r>
    a132:	b002      	add	sp, #8
    a134:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    a138:	b004      	add	sp, #16
    a13a:	4770      	bx	lr
    a13c:	20000010 	.word	0x20000010

0000a140 <_puts_r>:
    a140:	b570      	push	{r4, r5, r6, lr}
    a142:	460e      	mov	r6, r1
    a144:	4605      	mov	r5, r0
    a146:	b118      	cbz	r0, a150 <_puts_r+0x10>
    a148:	6983      	ldr	r3, [r0, #24]
    a14a:	b90b      	cbnz	r3, a150 <_puts_r+0x10>
    a14c:	f000 facc 	bl	a6e8 <__sinit>
    a150:	69ab      	ldr	r3, [r5, #24]
    a152:	68ac      	ldr	r4, [r5, #8]
    a154:	b913      	cbnz	r3, a15c <_puts_r+0x1c>
    a156:	4628      	mov	r0, r5
    a158:	f000 fac6 	bl	a6e8 <__sinit>
    a15c:	4b23      	ldr	r3, [pc, #140]	; (a1ec <_puts_r+0xac>)
    a15e:	429c      	cmp	r4, r3
    a160:	d117      	bne.n	a192 <_puts_r+0x52>
    a162:	686c      	ldr	r4, [r5, #4]
    a164:	89a3      	ldrh	r3, [r4, #12]
    a166:	071b      	lsls	r3, r3, #28
    a168:	d51d      	bpl.n	a1a6 <_puts_r+0x66>
    a16a:	6923      	ldr	r3, [r4, #16]
    a16c:	b1db      	cbz	r3, a1a6 <_puts_r+0x66>
    a16e:	3e01      	subs	r6, #1
    a170:	68a3      	ldr	r3, [r4, #8]
    a172:	f816 1f01 	ldrb.w	r1, [r6, #1]!
    a176:	3b01      	subs	r3, #1
    a178:	60a3      	str	r3, [r4, #8]
    a17a:	b9e9      	cbnz	r1, a1b8 <_puts_r+0x78>
    a17c:	2b00      	cmp	r3, #0
    a17e:	da2e      	bge.n	a1de <_puts_r+0x9e>
    a180:	4622      	mov	r2, r4
    a182:	210a      	movs	r1, #10
    a184:	4628      	mov	r0, r5
    a186:	f000 f8fd 	bl	a384 <__swbuf_r>
    a18a:	3001      	adds	r0, #1
    a18c:	d011      	beq.n	a1b2 <_puts_r+0x72>
    a18e:	200a      	movs	r0, #10
    a190:	bd70      	pop	{r4, r5, r6, pc}
    a192:	4b17      	ldr	r3, [pc, #92]	; (a1f0 <_puts_r+0xb0>)
    a194:	429c      	cmp	r4, r3
    a196:	d101      	bne.n	a19c <_puts_r+0x5c>
    a198:	68ac      	ldr	r4, [r5, #8]
    a19a:	e7e3      	b.n	a164 <_puts_r+0x24>
    a19c:	4b15      	ldr	r3, [pc, #84]	; (a1f4 <_puts_r+0xb4>)
    a19e:	429c      	cmp	r4, r3
    a1a0:	bf08      	it	eq
    a1a2:	68ec      	ldreq	r4, [r5, #12]
    a1a4:	e7de      	b.n	a164 <_puts_r+0x24>
    a1a6:	4621      	mov	r1, r4
    a1a8:	4628      	mov	r0, r5
    a1aa:	f000 f93d 	bl	a428 <__swsetup_r>
    a1ae:	2800      	cmp	r0, #0
    a1b0:	d0dd      	beq.n	a16e <_puts_r+0x2e>
    a1b2:	f04f 30ff 	mov.w	r0, #4294967295
    a1b6:	bd70      	pop	{r4, r5, r6, pc}
    a1b8:	2b00      	cmp	r3, #0
    a1ba:	da04      	bge.n	a1c6 <_puts_r+0x86>
    a1bc:	69a2      	ldr	r2, [r4, #24]
    a1be:	4293      	cmp	r3, r2
    a1c0:	db06      	blt.n	a1d0 <_puts_r+0x90>
    a1c2:	290a      	cmp	r1, #10
    a1c4:	d004      	beq.n	a1d0 <_puts_r+0x90>
    a1c6:	6823      	ldr	r3, [r4, #0]
    a1c8:	1c5a      	adds	r2, r3, #1
    a1ca:	6022      	str	r2, [r4, #0]
    a1cc:	7019      	strb	r1, [r3, #0]
    a1ce:	e7cf      	b.n	a170 <_puts_r+0x30>
    a1d0:	4622      	mov	r2, r4
    a1d2:	4628      	mov	r0, r5
    a1d4:	f000 f8d6 	bl	a384 <__swbuf_r>
    a1d8:	3001      	adds	r0, #1
    a1da:	d1c9      	bne.n	a170 <_puts_r+0x30>
    a1dc:	e7e9      	b.n	a1b2 <_puts_r+0x72>
    a1de:	6823      	ldr	r3, [r4, #0]
    a1e0:	200a      	movs	r0, #10
    a1e2:	1c5a      	adds	r2, r3, #1
    a1e4:	6022      	str	r2, [r4, #0]
    a1e6:	7018      	strb	r0, [r3, #0]
    a1e8:	bd70      	pop	{r4, r5, r6, pc}
    a1ea:	bf00      	nop
    a1ec:	0000c8b8 	.word	0x0000c8b8
    a1f0:	0000c8d8 	.word	0x0000c8d8
    a1f4:	0000c898 	.word	0x0000c898

0000a1f8 <puts>:
    a1f8:	4b02      	ldr	r3, [pc, #8]	; (a204 <puts+0xc>)
    a1fa:	4601      	mov	r1, r0
    a1fc:	6818      	ldr	r0, [r3, #0]
    a1fe:	f7ff bf9f 	b.w	a140 <_puts_r>
    a202:	bf00      	nop
    a204:	20000010 	.word	0x20000010

0000a208 <setbuf>:
    a208:	2900      	cmp	r1, #0
    a20a:	f44f 6380 	mov.w	r3, #1024	; 0x400
    a20e:	bf0c      	ite	eq
    a210:	2202      	moveq	r2, #2
    a212:	2200      	movne	r2, #0
    a214:	f000 b800 	b.w	a218 <setvbuf>

0000a218 <setvbuf>:
    a218:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    a21c:	461d      	mov	r5, r3
    a21e:	4b51      	ldr	r3, [pc, #324]	; (a364 <setvbuf+0x14c>)
    a220:	681e      	ldr	r6, [r3, #0]
    a222:	4604      	mov	r4, r0
    a224:	460f      	mov	r7, r1
    a226:	4690      	mov	r8, r2
    a228:	b126      	cbz	r6, a234 <setvbuf+0x1c>
    a22a:	69b3      	ldr	r3, [r6, #24]
    a22c:	b913      	cbnz	r3, a234 <setvbuf+0x1c>
    a22e:	4630      	mov	r0, r6
    a230:	f000 fa5a 	bl	a6e8 <__sinit>
    a234:	4b4c      	ldr	r3, [pc, #304]	; (a368 <setvbuf+0x150>)
    a236:	429c      	cmp	r4, r3
    a238:	d152      	bne.n	a2e0 <setvbuf+0xc8>
    a23a:	6874      	ldr	r4, [r6, #4]
    a23c:	f1b8 0f02 	cmp.w	r8, #2
    a240:	d006      	beq.n	a250 <setvbuf+0x38>
    a242:	f1b8 0f01 	cmp.w	r8, #1
    a246:	f200 8089 	bhi.w	a35c <setvbuf+0x144>
    a24a:	2d00      	cmp	r5, #0
    a24c:	f2c0 8086 	blt.w	a35c <setvbuf+0x144>
    a250:	4621      	mov	r1, r4
    a252:	4630      	mov	r0, r6
    a254:	f000 f9de 	bl	a614 <_fflush_r>
    a258:	6b61      	ldr	r1, [r4, #52]	; 0x34
    a25a:	b141      	cbz	r1, a26e <setvbuf+0x56>
    a25c:	f104 0344 	add.w	r3, r4, #68	; 0x44
    a260:	4299      	cmp	r1, r3
    a262:	d002      	beq.n	a26a <setvbuf+0x52>
    a264:	4630      	mov	r0, r6
    a266:	f000 fb35 	bl	a8d4 <_free_r>
    a26a:	2300      	movs	r3, #0
    a26c:	6363      	str	r3, [r4, #52]	; 0x34
    a26e:	2300      	movs	r3, #0
    a270:	61a3      	str	r3, [r4, #24]
    a272:	6063      	str	r3, [r4, #4]
    a274:	89a3      	ldrh	r3, [r4, #12]
    a276:	061b      	lsls	r3, r3, #24
    a278:	d503      	bpl.n	a282 <setvbuf+0x6a>
    a27a:	6921      	ldr	r1, [r4, #16]
    a27c:	4630      	mov	r0, r6
    a27e:	f000 fb29 	bl	a8d4 <_free_r>
    a282:	89a3      	ldrh	r3, [r4, #12]
    a284:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
    a288:	f023 0303 	bic.w	r3, r3, #3
    a28c:	f1b8 0f02 	cmp.w	r8, #2
    a290:	81a3      	strh	r3, [r4, #12]
    a292:	d05d      	beq.n	a350 <setvbuf+0x138>
    a294:	ab01      	add	r3, sp, #4
    a296:	466a      	mov	r2, sp
    a298:	4621      	mov	r1, r4
    a29a:	4630      	mov	r0, r6
    a29c:	f000 faae 	bl	a7fc <__swhatbuf_r>
    a2a0:	89a3      	ldrh	r3, [r4, #12]
    a2a2:	4318      	orrs	r0, r3
    a2a4:	81a0      	strh	r0, [r4, #12]
    a2a6:	bb2d      	cbnz	r5, a2f4 <setvbuf+0xdc>
    a2a8:	9d00      	ldr	r5, [sp, #0]
    a2aa:	4628      	mov	r0, r5
    a2ac:	f000 fb0a 	bl	a8c4 <malloc>
    a2b0:	4607      	mov	r7, r0
    a2b2:	2800      	cmp	r0, #0
    a2b4:	d14e      	bne.n	a354 <setvbuf+0x13c>
    a2b6:	f8dd 9000 	ldr.w	r9, [sp]
    a2ba:	45a9      	cmp	r9, r5
    a2bc:	d13c      	bne.n	a338 <setvbuf+0x120>
    a2be:	f04f 30ff 	mov.w	r0, #4294967295
    a2c2:	89a3      	ldrh	r3, [r4, #12]
    a2c4:	f043 0302 	orr.w	r3, r3, #2
    a2c8:	81a3      	strh	r3, [r4, #12]
    a2ca:	2300      	movs	r3, #0
    a2cc:	60a3      	str	r3, [r4, #8]
    a2ce:	f104 0347 	add.w	r3, r4, #71	; 0x47
    a2d2:	6023      	str	r3, [r4, #0]
    a2d4:	6123      	str	r3, [r4, #16]
    a2d6:	2301      	movs	r3, #1
    a2d8:	6163      	str	r3, [r4, #20]
    a2da:	b003      	add	sp, #12
    a2dc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    a2e0:	4b22      	ldr	r3, [pc, #136]	; (a36c <setvbuf+0x154>)
    a2e2:	429c      	cmp	r4, r3
    a2e4:	d101      	bne.n	a2ea <setvbuf+0xd2>
    a2e6:	68b4      	ldr	r4, [r6, #8]
    a2e8:	e7a8      	b.n	a23c <setvbuf+0x24>
    a2ea:	4b21      	ldr	r3, [pc, #132]	; (a370 <setvbuf+0x158>)
    a2ec:	429c      	cmp	r4, r3
    a2ee:	bf08      	it	eq
    a2f0:	68f4      	ldreq	r4, [r6, #12]
    a2f2:	e7a3      	b.n	a23c <setvbuf+0x24>
    a2f4:	2f00      	cmp	r7, #0
    a2f6:	d0d8      	beq.n	a2aa <setvbuf+0x92>
    a2f8:	69b3      	ldr	r3, [r6, #24]
    a2fa:	b913      	cbnz	r3, a302 <setvbuf+0xea>
    a2fc:	4630      	mov	r0, r6
    a2fe:	f000 f9f3 	bl	a6e8 <__sinit>
    a302:	f1b8 0f01 	cmp.w	r8, #1
    a306:	bf08      	it	eq
    a308:	89a3      	ldrheq	r3, [r4, #12]
    a30a:	6027      	str	r7, [r4, #0]
    a30c:	bf04      	itt	eq
    a30e:	f043 0301 	orreq.w	r3, r3, #1
    a312:	81a3      	strheq	r3, [r4, #12]
    a314:	89a3      	ldrh	r3, [r4, #12]
    a316:	6127      	str	r7, [r4, #16]
    a318:	f013 0008 	ands.w	r0, r3, #8
    a31c:	6165      	str	r5, [r4, #20]
    a31e:	d01b      	beq.n	a358 <setvbuf+0x140>
    a320:	f013 0001 	ands.w	r0, r3, #1
    a324:	bf18      	it	ne
    a326:	426d      	negne	r5, r5
    a328:	f04f 0300 	mov.w	r3, #0
    a32c:	bf1d      	ittte	ne
    a32e:	60a3      	strne	r3, [r4, #8]
    a330:	61a5      	strne	r5, [r4, #24]
    a332:	4618      	movne	r0, r3
    a334:	60a5      	streq	r5, [r4, #8]
    a336:	e7d0      	b.n	a2da <setvbuf+0xc2>
    a338:	4648      	mov	r0, r9
    a33a:	f000 fac3 	bl	a8c4 <malloc>
    a33e:	4607      	mov	r7, r0
    a340:	2800      	cmp	r0, #0
    a342:	d0bc      	beq.n	a2be <setvbuf+0xa6>
    a344:	89a3      	ldrh	r3, [r4, #12]
    a346:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    a34a:	81a3      	strh	r3, [r4, #12]
    a34c:	464d      	mov	r5, r9
    a34e:	e7d3      	b.n	a2f8 <setvbuf+0xe0>
    a350:	2000      	movs	r0, #0
    a352:	e7b6      	b.n	a2c2 <setvbuf+0xaa>
    a354:	46a9      	mov	r9, r5
    a356:	e7f5      	b.n	a344 <setvbuf+0x12c>
    a358:	60a0      	str	r0, [r4, #8]
    a35a:	e7be      	b.n	a2da <setvbuf+0xc2>
    a35c:	f04f 30ff 	mov.w	r0, #4294967295
    a360:	e7bb      	b.n	a2da <setvbuf+0xc2>
    a362:	bf00      	nop
    a364:	20000010 	.word	0x20000010
    a368:	0000c8b8 	.word	0x0000c8b8
    a36c:	0000c8d8 	.word	0x0000c8d8
    a370:	0000c898 	.word	0x0000c898

0000a374 <strlen>:
    a374:	4603      	mov	r3, r0
    a376:	f813 2b01 	ldrb.w	r2, [r3], #1
    a37a:	2a00      	cmp	r2, #0
    a37c:	d1fb      	bne.n	a376 <strlen+0x2>
    a37e:	1a18      	subs	r0, r3, r0
    a380:	3801      	subs	r0, #1
    a382:	4770      	bx	lr

0000a384 <__swbuf_r>:
    a384:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a386:	460e      	mov	r6, r1
    a388:	4614      	mov	r4, r2
    a38a:	4605      	mov	r5, r0
    a38c:	b118      	cbz	r0, a396 <__swbuf_r+0x12>
    a38e:	6983      	ldr	r3, [r0, #24]
    a390:	b90b      	cbnz	r3, a396 <__swbuf_r+0x12>
    a392:	f000 f9a9 	bl	a6e8 <__sinit>
    a396:	4b21      	ldr	r3, [pc, #132]	; (a41c <__swbuf_r+0x98>)
    a398:	429c      	cmp	r4, r3
    a39a:	d12a      	bne.n	a3f2 <__swbuf_r+0x6e>
    a39c:	686c      	ldr	r4, [r5, #4]
    a39e:	69a3      	ldr	r3, [r4, #24]
    a3a0:	60a3      	str	r3, [r4, #8]
    a3a2:	89a3      	ldrh	r3, [r4, #12]
    a3a4:	071a      	lsls	r2, r3, #28
    a3a6:	d52e      	bpl.n	a406 <__swbuf_r+0x82>
    a3a8:	6923      	ldr	r3, [r4, #16]
    a3aa:	b363      	cbz	r3, a406 <__swbuf_r+0x82>
    a3ac:	6923      	ldr	r3, [r4, #16]
    a3ae:	6820      	ldr	r0, [r4, #0]
    a3b0:	1ac0      	subs	r0, r0, r3
    a3b2:	6963      	ldr	r3, [r4, #20]
    a3b4:	b2f6      	uxtb	r6, r6
    a3b6:	4298      	cmp	r0, r3
    a3b8:	4637      	mov	r7, r6
    a3ba:	db04      	blt.n	a3c6 <__swbuf_r+0x42>
    a3bc:	4621      	mov	r1, r4
    a3be:	4628      	mov	r0, r5
    a3c0:	f000 f928 	bl	a614 <_fflush_r>
    a3c4:	bb28      	cbnz	r0, a412 <__swbuf_r+0x8e>
    a3c6:	68a3      	ldr	r3, [r4, #8]
    a3c8:	3b01      	subs	r3, #1
    a3ca:	60a3      	str	r3, [r4, #8]
    a3cc:	6823      	ldr	r3, [r4, #0]
    a3ce:	1c5a      	adds	r2, r3, #1
    a3d0:	6022      	str	r2, [r4, #0]
    a3d2:	701e      	strb	r6, [r3, #0]
    a3d4:	6963      	ldr	r3, [r4, #20]
    a3d6:	3001      	adds	r0, #1
    a3d8:	4298      	cmp	r0, r3
    a3da:	d004      	beq.n	a3e6 <__swbuf_r+0x62>
    a3dc:	89a3      	ldrh	r3, [r4, #12]
    a3de:	07db      	lsls	r3, r3, #31
    a3e0:	d519      	bpl.n	a416 <__swbuf_r+0x92>
    a3e2:	2e0a      	cmp	r6, #10
    a3e4:	d117      	bne.n	a416 <__swbuf_r+0x92>
    a3e6:	4621      	mov	r1, r4
    a3e8:	4628      	mov	r0, r5
    a3ea:	f000 f913 	bl	a614 <_fflush_r>
    a3ee:	b190      	cbz	r0, a416 <__swbuf_r+0x92>
    a3f0:	e00f      	b.n	a412 <__swbuf_r+0x8e>
    a3f2:	4b0b      	ldr	r3, [pc, #44]	; (a420 <__swbuf_r+0x9c>)
    a3f4:	429c      	cmp	r4, r3
    a3f6:	d101      	bne.n	a3fc <__swbuf_r+0x78>
    a3f8:	68ac      	ldr	r4, [r5, #8]
    a3fa:	e7d0      	b.n	a39e <__swbuf_r+0x1a>
    a3fc:	4b09      	ldr	r3, [pc, #36]	; (a424 <__swbuf_r+0xa0>)
    a3fe:	429c      	cmp	r4, r3
    a400:	bf08      	it	eq
    a402:	68ec      	ldreq	r4, [r5, #12]
    a404:	e7cb      	b.n	a39e <__swbuf_r+0x1a>
    a406:	4621      	mov	r1, r4
    a408:	4628      	mov	r0, r5
    a40a:	f000 f80d 	bl	a428 <__swsetup_r>
    a40e:	2800      	cmp	r0, #0
    a410:	d0cc      	beq.n	a3ac <__swbuf_r+0x28>
    a412:	f04f 37ff 	mov.w	r7, #4294967295
    a416:	4638      	mov	r0, r7
    a418:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a41a:	bf00      	nop
    a41c:	0000c8b8 	.word	0x0000c8b8
    a420:	0000c8d8 	.word	0x0000c8d8
    a424:	0000c898 	.word	0x0000c898

0000a428 <__swsetup_r>:
    a428:	4b32      	ldr	r3, [pc, #200]	; (a4f4 <__swsetup_r+0xcc>)
    a42a:	b570      	push	{r4, r5, r6, lr}
    a42c:	681d      	ldr	r5, [r3, #0]
    a42e:	4606      	mov	r6, r0
    a430:	460c      	mov	r4, r1
    a432:	b125      	cbz	r5, a43e <__swsetup_r+0x16>
    a434:	69ab      	ldr	r3, [r5, #24]
    a436:	b913      	cbnz	r3, a43e <__swsetup_r+0x16>
    a438:	4628      	mov	r0, r5
    a43a:	f000 f955 	bl	a6e8 <__sinit>
    a43e:	4b2e      	ldr	r3, [pc, #184]	; (a4f8 <__swsetup_r+0xd0>)
    a440:	429c      	cmp	r4, r3
    a442:	d10f      	bne.n	a464 <__swsetup_r+0x3c>
    a444:	686c      	ldr	r4, [r5, #4]
    a446:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a44a:	b29a      	uxth	r2, r3
    a44c:	0715      	lsls	r5, r2, #28
    a44e:	d42c      	bmi.n	a4aa <__swsetup_r+0x82>
    a450:	06d0      	lsls	r0, r2, #27
    a452:	d411      	bmi.n	a478 <__swsetup_r+0x50>
    a454:	2209      	movs	r2, #9
    a456:	6032      	str	r2, [r6, #0]
    a458:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a45c:	81a3      	strh	r3, [r4, #12]
    a45e:	f04f 30ff 	mov.w	r0, #4294967295
    a462:	bd70      	pop	{r4, r5, r6, pc}
    a464:	4b25      	ldr	r3, [pc, #148]	; (a4fc <__swsetup_r+0xd4>)
    a466:	429c      	cmp	r4, r3
    a468:	d101      	bne.n	a46e <__swsetup_r+0x46>
    a46a:	68ac      	ldr	r4, [r5, #8]
    a46c:	e7eb      	b.n	a446 <__swsetup_r+0x1e>
    a46e:	4b24      	ldr	r3, [pc, #144]	; (a500 <__swsetup_r+0xd8>)
    a470:	429c      	cmp	r4, r3
    a472:	bf08      	it	eq
    a474:	68ec      	ldreq	r4, [r5, #12]
    a476:	e7e6      	b.n	a446 <__swsetup_r+0x1e>
    a478:	0751      	lsls	r1, r2, #29
    a47a:	d512      	bpl.n	a4a2 <__swsetup_r+0x7a>
    a47c:	6b61      	ldr	r1, [r4, #52]	; 0x34
    a47e:	b141      	cbz	r1, a492 <__swsetup_r+0x6a>
    a480:	f104 0344 	add.w	r3, r4, #68	; 0x44
    a484:	4299      	cmp	r1, r3
    a486:	d002      	beq.n	a48e <__swsetup_r+0x66>
    a488:	4630      	mov	r0, r6
    a48a:	f000 fa23 	bl	a8d4 <_free_r>
    a48e:	2300      	movs	r3, #0
    a490:	6363      	str	r3, [r4, #52]	; 0x34
    a492:	89a3      	ldrh	r3, [r4, #12]
    a494:	f023 0324 	bic.w	r3, r3, #36	; 0x24
    a498:	81a3      	strh	r3, [r4, #12]
    a49a:	2300      	movs	r3, #0
    a49c:	6063      	str	r3, [r4, #4]
    a49e:	6923      	ldr	r3, [r4, #16]
    a4a0:	6023      	str	r3, [r4, #0]
    a4a2:	89a3      	ldrh	r3, [r4, #12]
    a4a4:	f043 0308 	orr.w	r3, r3, #8
    a4a8:	81a3      	strh	r3, [r4, #12]
    a4aa:	6923      	ldr	r3, [r4, #16]
    a4ac:	b94b      	cbnz	r3, a4c2 <__swsetup_r+0x9a>
    a4ae:	89a3      	ldrh	r3, [r4, #12]
    a4b0:	f403 7320 	and.w	r3, r3, #640	; 0x280
    a4b4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    a4b8:	d003      	beq.n	a4c2 <__swsetup_r+0x9a>
    a4ba:	4621      	mov	r1, r4
    a4bc:	4630      	mov	r0, r6
    a4be:	f000 f9c1 	bl	a844 <__smakebuf_r>
    a4c2:	89a2      	ldrh	r2, [r4, #12]
    a4c4:	f012 0301 	ands.w	r3, r2, #1
    a4c8:	d00c      	beq.n	a4e4 <__swsetup_r+0xbc>
    a4ca:	2300      	movs	r3, #0
    a4cc:	60a3      	str	r3, [r4, #8]
    a4ce:	6963      	ldr	r3, [r4, #20]
    a4d0:	425b      	negs	r3, r3
    a4d2:	61a3      	str	r3, [r4, #24]
    a4d4:	6923      	ldr	r3, [r4, #16]
    a4d6:	b953      	cbnz	r3, a4ee <__swsetup_r+0xc6>
    a4d8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a4dc:	f013 0080 	ands.w	r0, r3, #128	; 0x80
    a4e0:	d1ba      	bne.n	a458 <__swsetup_r+0x30>
    a4e2:	bd70      	pop	{r4, r5, r6, pc}
    a4e4:	0792      	lsls	r2, r2, #30
    a4e6:	bf58      	it	pl
    a4e8:	6963      	ldrpl	r3, [r4, #20]
    a4ea:	60a3      	str	r3, [r4, #8]
    a4ec:	e7f2      	b.n	a4d4 <__swsetup_r+0xac>
    a4ee:	2000      	movs	r0, #0
    a4f0:	e7f7      	b.n	a4e2 <__swsetup_r+0xba>
    a4f2:	bf00      	nop
    a4f4:	20000010 	.word	0x20000010
    a4f8:	0000c8b8 	.word	0x0000c8b8
    a4fc:	0000c8d8 	.word	0x0000c8d8
    a500:	0000c898 	.word	0x0000c898

0000a504 <__sflush_r>:
    a504:	898a      	ldrh	r2, [r1, #12]
    a506:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a50a:	4605      	mov	r5, r0
    a50c:	0710      	lsls	r0, r2, #28
    a50e:	460c      	mov	r4, r1
    a510:	d45a      	bmi.n	a5c8 <__sflush_r+0xc4>
    a512:	684b      	ldr	r3, [r1, #4]
    a514:	2b00      	cmp	r3, #0
    a516:	dc05      	bgt.n	a524 <__sflush_r+0x20>
    a518:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    a51a:	2b00      	cmp	r3, #0
    a51c:	dc02      	bgt.n	a524 <__sflush_r+0x20>
    a51e:	2000      	movs	r0, #0
    a520:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a524:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    a526:	2e00      	cmp	r6, #0
    a528:	d0f9      	beq.n	a51e <__sflush_r+0x1a>
    a52a:	2300      	movs	r3, #0
    a52c:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
    a530:	682f      	ldr	r7, [r5, #0]
    a532:	602b      	str	r3, [r5, #0]
    a534:	d033      	beq.n	a59e <__sflush_r+0x9a>
    a536:	6d60      	ldr	r0, [r4, #84]	; 0x54
    a538:	89a3      	ldrh	r3, [r4, #12]
    a53a:	075a      	lsls	r2, r3, #29
    a53c:	d505      	bpl.n	a54a <__sflush_r+0x46>
    a53e:	6863      	ldr	r3, [r4, #4]
    a540:	1ac0      	subs	r0, r0, r3
    a542:	6b63      	ldr	r3, [r4, #52]	; 0x34
    a544:	b10b      	cbz	r3, a54a <__sflush_r+0x46>
    a546:	6c23      	ldr	r3, [r4, #64]	; 0x40
    a548:	1ac0      	subs	r0, r0, r3
    a54a:	2300      	movs	r3, #0
    a54c:	4602      	mov	r2, r0
    a54e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    a550:	6a21      	ldr	r1, [r4, #32]
    a552:	4628      	mov	r0, r5
    a554:	47b0      	blx	r6
    a556:	1c43      	adds	r3, r0, #1
    a558:	89a3      	ldrh	r3, [r4, #12]
    a55a:	d106      	bne.n	a56a <__sflush_r+0x66>
    a55c:	6829      	ldr	r1, [r5, #0]
    a55e:	291d      	cmp	r1, #29
    a560:	d84b      	bhi.n	a5fa <__sflush_r+0xf6>
    a562:	4a2b      	ldr	r2, [pc, #172]	; (a610 <__sflush_r+0x10c>)
    a564:	40ca      	lsrs	r2, r1
    a566:	07d6      	lsls	r6, r2, #31
    a568:	d547      	bpl.n	a5fa <__sflush_r+0xf6>
    a56a:	2200      	movs	r2, #0
    a56c:	6062      	str	r2, [r4, #4]
    a56e:	04d9      	lsls	r1, r3, #19
    a570:	6922      	ldr	r2, [r4, #16]
    a572:	6022      	str	r2, [r4, #0]
    a574:	d504      	bpl.n	a580 <__sflush_r+0x7c>
    a576:	1c42      	adds	r2, r0, #1
    a578:	d101      	bne.n	a57e <__sflush_r+0x7a>
    a57a:	682b      	ldr	r3, [r5, #0]
    a57c:	b903      	cbnz	r3, a580 <__sflush_r+0x7c>
    a57e:	6560      	str	r0, [r4, #84]	; 0x54
    a580:	6b61      	ldr	r1, [r4, #52]	; 0x34
    a582:	602f      	str	r7, [r5, #0]
    a584:	2900      	cmp	r1, #0
    a586:	d0ca      	beq.n	a51e <__sflush_r+0x1a>
    a588:	f104 0344 	add.w	r3, r4, #68	; 0x44
    a58c:	4299      	cmp	r1, r3
    a58e:	d002      	beq.n	a596 <__sflush_r+0x92>
    a590:	4628      	mov	r0, r5
    a592:	f000 f99f 	bl	a8d4 <_free_r>
    a596:	2000      	movs	r0, #0
    a598:	6360      	str	r0, [r4, #52]	; 0x34
    a59a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a59e:	6a21      	ldr	r1, [r4, #32]
    a5a0:	2301      	movs	r3, #1
    a5a2:	4628      	mov	r0, r5
    a5a4:	47b0      	blx	r6
    a5a6:	1c41      	adds	r1, r0, #1
    a5a8:	d1c6      	bne.n	a538 <__sflush_r+0x34>
    a5aa:	682b      	ldr	r3, [r5, #0]
    a5ac:	2b00      	cmp	r3, #0
    a5ae:	d0c3      	beq.n	a538 <__sflush_r+0x34>
    a5b0:	2b1d      	cmp	r3, #29
    a5b2:	d001      	beq.n	a5b8 <__sflush_r+0xb4>
    a5b4:	2b16      	cmp	r3, #22
    a5b6:	d101      	bne.n	a5bc <__sflush_r+0xb8>
    a5b8:	602f      	str	r7, [r5, #0]
    a5ba:	e7b0      	b.n	a51e <__sflush_r+0x1a>
    a5bc:	89a3      	ldrh	r3, [r4, #12]
    a5be:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a5c2:	81a3      	strh	r3, [r4, #12]
    a5c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a5c8:	690f      	ldr	r7, [r1, #16]
    a5ca:	2f00      	cmp	r7, #0
    a5cc:	d0a7      	beq.n	a51e <__sflush_r+0x1a>
    a5ce:	0793      	lsls	r3, r2, #30
    a5d0:	680e      	ldr	r6, [r1, #0]
    a5d2:	bf08      	it	eq
    a5d4:	694b      	ldreq	r3, [r1, #20]
    a5d6:	600f      	str	r7, [r1, #0]
    a5d8:	bf18      	it	ne
    a5da:	2300      	movne	r3, #0
    a5dc:	eba6 0807 	sub.w	r8, r6, r7
    a5e0:	608b      	str	r3, [r1, #8]
    a5e2:	f1b8 0f00 	cmp.w	r8, #0
    a5e6:	dd9a      	ble.n	a51e <__sflush_r+0x1a>
    a5e8:	4643      	mov	r3, r8
    a5ea:	463a      	mov	r2, r7
    a5ec:	6a21      	ldr	r1, [r4, #32]
    a5ee:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    a5f0:	4628      	mov	r0, r5
    a5f2:	47b0      	blx	r6
    a5f4:	2800      	cmp	r0, #0
    a5f6:	dc07      	bgt.n	a608 <__sflush_r+0x104>
    a5f8:	89a3      	ldrh	r3, [r4, #12]
    a5fa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a5fe:	81a3      	strh	r3, [r4, #12]
    a600:	f04f 30ff 	mov.w	r0, #4294967295
    a604:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a608:	4407      	add	r7, r0
    a60a:	eba8 0800 	sub.w	r8, r8, r0
    a60e:	e7e8      	b.n	a5e2 <__sflush_r+0xde>
    a610:	20400001 	.word	0x20400001

0000a614 <_fflush_r>:
    a614:	b538      	push	{r3, r4, r5, lr}
    a616:	690b      	ldr	r3, [r1, #16]
    a618:	4605      	mov	r5, r0
    a61a:	460c      	mov	r4, r1
    a61c:	b1db      	cbz	r3, a656 <_fflush_r+0x42>
    a61e:	b118      	cbz	r0, a628 <_fflush_r+0x14>
    a620:	6983      	ldr	r3, [r0, #24]
    a622:	b90b      	cbnz	r3, a628 <_fflush_r+0x14>
    a624:	f000 f860 	bl	a6e8 <__sinit>
    a628:	4b0c      	ldr	r3, [pc, #48]	; (a65c <_fflush_r+0x48>)
    a62a:	429c      	cmp	r4, r3
    a62c:	d109      	bne.n	a642 <_fflush_r+0x2e>
    a62e:	686c      	ldr	r4, [r5, #4]
    a630:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a634:	b17b      	cbz	r3, a656 <_fflush_r+0x42>
    a636:	4621      	mov	r1, r4
    a638:	4628      	mov	r0, r5
    a63a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    a63e:	f7ff bf61 	b.w	a504 <__sflush_r>
    a642:	4b07      	ldr	r3, [pc, #28]	; (a660 <_fflush_r+0x4c>)
    a644:	429c      	cmp	r4, r3
    a646:	d101      	bne.n	a64c <_fflush_r+0x38>
    a648:	68ac      	ldr	r4, [r5, #8]
    a64a:	e7f1      	b.n	a630 <_fflush_r+0x1c>
    a64c:	4b05      	ldr	r3, [pc, #20]	; (a664 <_fflush_r+0x50>)
    a64e:	429c      	cmp	r4, r3
    a650:	bf08      	it	eq
    a652:	68ec      	ldreq	r4, [r5, #12]
    a654:	e7ec      	b.n	a630 <_fflush_r+0x1c>
    a656:	2000      	movs	r0, #0
    a658:	bd38      	pop	{r3, r4, r5, pc}
    a65a:	bf00      	nop
    a65c:	0000c8b8 	.word	0x0000c8b8
    a660:	0000c8d8 	.word	0x0000c8d8
    a664:	0000c898 	.word	0x0000c898

0000a668 <_cleanup_r>:
    a668:	4901      	ldr	r1, [pc, #4]	; (a670 <_cleanup_r+0x8>)
    a66a:	f000 b8a9 	b.w	a7c0 <_fwalk_reent>
    a66e:	bf00      	nop
    a670:	0000a615 	.word	0x0000a615

0000a674 <std.isra.0>:
    a674:	2300      	movs	r3, #0
    a676:	b510      	push	{r4, lr}
    a678:	4604      	mov	r4, r0
    a67a:	6003      	str	r3, [r0, #0]
    a67c:	6043      	str	r3, [r0, #4]
    a67e:	6083      	str	r3, [r0, #8]
    a680:	8181      	strh	r1, [r0, #12]
    a682:	6643      	str	r3, [r0, #100]	; 0x64
    a684:	81c2      	strh	r2, [r0, #14]
    a686:	6103      	str	r3, [r0, #16]
    a688:	6143      	str	r3, [r0, #20]
    a68a:	6183      	str	r3, [r0, #24]
    a68c:	4619      	mov	r1, r3
    a68e:	2208      	movs	r2, #8
    a690:	305c      	adds	r0, #92	; 0x5c
    a692:	f7ff fd35 	bl	a100 <memset>
    a696:	4b05      	ldr	r3, [pc, #20]	; (a6ac <std.isra.0+0x38>)
    a698:	6263      	str	r3, [r4, #36]	; 0x24
    a69a:	4b05      	ldr	r3, [pc, #20]	; (a6b0 <std.isra.0+0x3c>)
    a69c:	62a3      	str	r3, [r4, #40]	; 0x28
    a69e:	4b05      	ldr	r3, [pc, #20]	; (a6b4 <std.isra.0+0x40>)
    a6a0:	62e3      	str	r3, [r4, #44]	; 0x2c
    a6a2:	4b05      	ldr	r3, [pc, #20]	; (a6b8 <std.isra.0+0x44>)
    a6a4:	6224      	str	r4, [r4, #32]
    a6a6:	6323      	str	r3, [r4, #48]	; 0x30
    a6a8:	bd10      	pop	{r4, pc}
    a6aa:	bf00      	nop
    a6ac:	0000aff5 	.word	0x0000aff5
    a6b0:	0000b017 	.word	0x0000b017
    a6b4:	0000b04f 	.word	0x0000b04f
    a6b8:	0000b073 	.word	0x0000b073

0000a6bc <__sfmoreglue>:
    a6bc:	b570      	push	{r4, r5, r6, lr}
    a6be:	1e4a      	subs	r2, r1, #1
    a6c0:	2568      	movs	r5, #104	; 0x68
    a6c2:	4355      	muls	r5, r2
    a6c4:	460e      	mov	r6, r1
    a6c6:	f105 0174 	add.w	r1, r5, #116	; 0x74
    a6ca:	f000 f951 	bl	a970 <_malloc_r>
    a6ce:	4604      	mov	r4, r0
    a6d0:	b140      	cbz	r0, a6e4 <__sfmoreglue+0x28>
    a6d2:	2100      	movs	r1, #0
    a6d4:	e880 0042 	stmia.w	r0, {r1, r6}
    a6d8:	300c      	adds	r0, #12
    a6da:	60a0      	str	r0, [r4, #8]
    a6dc:	f105 0268 	add.w	r2, r5, #104	; 0x68
    a6e0:	f7ff fd0e 	bl	a100 <memset>
    a6e4:	4620      	mov	r0, r4
    a6e6:	bd70      	pop	{r4, r5, r6, pc}

0000a6e8 <__sinit>:
    a6e8:	6983      	ldr	r3, [r0, #24]
    a6ea:	b510      	push	{r4, lr}
    a6ec:	4604      	mov	r4, r0
    a6ee:	bb33      	cbnz	r3, a73e <__sinit+0x56>
    a6f0:	6483      	str	r3, [r0, #72]	; 0x48
    a6f2:	64c3      	str	r3, [r0, #76]	; 0x4c
    a6f4:	6503      	str	r3, [r0, #80]	; 0x50
    a6f6:	4b12      	ldr	r3, [pc, #72]	; (a740 <__sinit+0x58>)
    a6f8:	4a12      	ldr	r2, [pc, #72]	; (a744 <__sinit+0x5c>)
    a6fa:	681b      	ldr	r3, [r3, #0]
    a6fc:	6282      	str	r2, [r0, #40]	; 0x28
    a6fe:	4298      	cmp	r0, r3
    a700:	bf04      	itt	eq
    a702:	2301      	moveq	r3, #1
    a704:	6183      	streq	r3, [r0, #24]
    a706:	f000 f81f 	bl	a748 <__sfp>
    a70a:	6060      	str	r0, [r4, #4]
    a70c:	4620      	mov	r0, r4
    a70e:	f000 f81b 	bl	a748 <__sfp>
    a712:	60a0      	str	r0, [r4, #8]
    a714:	4620      	mov	r0, r4
    a716:	f000 f817 	bl	a748 <__sfp>
    a71a:	2200      	movs	r2, #0
    a71c:	60e0      	str	r0, [r4, #12]
    a71e:	2104      	movs	r1, #4
    a720:	6860      	ldr	r0, [r4, #4]
    a722:	f7ff ffa7 	bl	a674 <std.isra.0>
    a726:	2201      	movs	r2, #1
    a728:	2109      	movs	r1, #9
    a72a:	68a0      	ldr	r0, [r4, #8]
    a72c:	f7ff ffa2 	bl	a674 <std.isra.0>
    a730:	2202      	movs	r2, #2
    a732:	2112      	movs	r1, #18
    a734:	68e0      	ldr	r0, [r4, #12]
    a736:	f7ff ff9d 	bl	a674 <std.isra.0>
    a73a:	2301      	movs	r3, #1
    a73c:	61a3      	str	r3, [r4, #24]
    a73e:	bd10      	pop	{r4, pc}
    a740:	0000c894 	.word	0x0000c894
    a744:	0000a669 	.word	0x0000a669

0000a748 <__sfp>:
    a748:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a74a:	4b1c      	ldr	r3, [pc, #112]	; (a7bc <__sfp+0x74>)
    a74c:	681e      	ldr	r6, [r3, #0]
    a74e:	69b3      	ldr	r3, [r6, #24]
    a750:	4607      	mov	r7, r0
    a752:	b913      	cbnz	r3, a75a <__sfp+0x12>
    a754:	4630      	mov	r0, r6
    a756:	f7ff ffc7 	bl	a6e8 <__sinit>
    a75a:	3648      	adds	r6, #72	; 0x48
    a75c:	68b4      	ldr	r4, [r6, #8]
    a75e:	6873      	ldr	r3, [r6, #4]
    a760:	3b01      	subs	r3, #1
    a762:	d503      	bpl.n	a76c <__sfp+0x24>
    a764:	6833      	ldr	r3, [r6, #0]
    a766:	b133      	cbz	r3, a776 <__sfp+0x2e>
    a768:	6836      	ldr	r6, [r6, #0]
    a76a:	e7f7      	b.n	a75c <__sfp+0x14>
    a76c:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
    a770:	b16d      	cbz	r5, a78e <__sfp+0x46>
    a772:	3468      	adds	r4, #104	; 0x68
    a774:	e7f4      	b.n	a760 <__sfp+0x18>
    a776:	2104      	movs	r1, #4
    a778:	4638      	mov	r0, r7
    a77a:	f7ff ff9f 	bl	a6bc <__sfmoreglue>
    a77e:	6030      	str	r0, [r6, #0]
    a780:	2800      	cmp	r0, #0
    a782:	d1f1      	bne.n	a768 <__sfp+0x20>
    a784:	230c      	movs	r3, #12
    a786:	603b      	str	r3, [r7, #0]
    a788:	4604      	mov	r4, r0
    a78a:	4620      	mov	r0, r4
    a78c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a78e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    a792:	81e3      	strh	r3, [r4, #14]
    a794:	2301      	movs	r3, #1
    a796:	81a3      	strh	r3, [r4, #12]
    a798:	6665      	str	r5, [r4, #100]	; 0x64
    a79a:	6025      	str	r5, [r4, #0]
    a79c:	60a5      	str	r5, [r4, #8]
    a79e:	6065      	str	r5, [r4, #4]
    a7a0:	6125      	str	r5, [r4, #16]
    a7a2:	6165      	str	r5, [r4, #20]
    a7a4:	61a5      	str	r5, [r4, #24]
    a7a6:	2208      	movs	r2, #8
    a7a8:	4629      	mov	r1, r5
    a7aa:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    a7ae:	f7ff fca7 	bl	a100 <memset>
    a7b2:	6365      	str	r5, [r4, #52]	; 0x34
    a7b4:	63a5      	str	r5, [r4, #56]	; 0x38
    a7b6:	64a5      	str	r5, [r4, #72]	; 0x48
    a7b8:	64e5      	str	r5, [r4, #76]	; 0x4c
    a7ba:	e7e6      	b.n	a78a <__sfp+0x42>
    a7bc:	0000c894 	.word	0x0000c894

0000a7c0 <_fwalk_reent>:
    a7c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a7c4:	4680      	mov	r8, r0
    a7c6:	4689      	mov	r9, r1
    a7c8:	f100 0448 	add.w	r4, r0, #72	; 0x48
    a7cc:	2600      	movs	r6, #0
    a7ce:	b914      	cbnz	r4, a7d6 <_fwalk_reent+0x16>
    a7d0:	4630      	mov	r0, r6
    a7d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a7d6:	68a5      	ldr	r5, [r4, #8]
    a7d8:	6867      	ldr	r7, [r4, #4]
    a7da:	3f01      	subs	r7, #1
    a7dc:	d501      	bpl.n	a7e2 <_fwalk_reent+0x22>
    a7de:	6824      	ldr	r4, [r4, #0]
    a7e0:	e7f5      	b.n	a7ce <_fwalk_reent+0xe>
    a7e2:	89ab      	ldrh	r3, [r5, #12]
    a7e4:	2b01      	cmp	r3, #1
    a7e6:	d907      	bls.n	a7f8 <_fwalk_reent+0x38>
    a7e8:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
    a7ec:	3301      	adds	r3, #1
    a7ee:	d003      	beq.n	a7f8 <_fwalk_reent+0x38>
    a7f0:	4629      	mov	r1, r5
    a7f2:	4640      	mov	r0, r8
    a7f4:	47c8      	blx	r9
    a7f6:	4306      	orrs	r6, r0
    a7f8:	3568      	adds	r5, #104	; 0x68
    a7fa:	e7ee      	b.n	a7da <_fwalk_reent+0x1a>

0000a7fc <__swhatbuf_r>:
    a7fc:	b570      	push	{r4, r5, r6, lr}
    a7fe:	460e      	mov	r6, r1
    a800:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    a804:	2900      	cmp	r1, #0
    a806:	b090      	sub	sp, #64	; 0x40
    a808:	4614      	mov	r4, r2
    a80a:	461d      	mov	r5, r3
    a80c:	da07      	bge.n	a81e <__swhatbuf_r+0x22>
    a80e:	2300      	movs	r3, #0
    a810:	602b      	str	r3, [r5, #0]
    a812:	89b3      	ldrh	r3, [r6, #12]
    a814:	061a      	lsls	r2, r3, #24
    a816:	d410      	bmi.n	a83a <__swhatbuf_r+0x3e>
    a818:	f44f 6380 	mov.w	r3, #1024	; 0x400
    a81c:	e00e      	b.n	a83c <__swhatbuf_r+0x40>
    a81e:	aa01      	add	r2, sp, #4
    a820:	f000 fc4e 	bl	b0c0 <_fstat_r>
    a824:	2800      	cmp	r0, #0
    a826:	dbf2      	blt.n	a80e <__swhatbuf_r+0x12>
    a828:	9a02      	ldr	r2, [sp, #8]
    a82a:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
    a82e:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
    a832:	425a      	negs	r2, r3
    a834:	415a      	adcs	r2, r3
    a836:	602a      	str	r2, [r5, #0]
    a838:	e7ee      	b.n	a818 <__swhatbuf_r+0x1c>
    a83a:	2340      	movs	r3, #64	; 0x40
    a83c:	2000      	movs	r0, #0
    a83e:	6023      	str	r3, [r4, #0]
    a840:	b010      	add	sp, #64	; 0x40
    a842:	bd70      	pop	{r4, r5, r6, pc}

0000a844 <__smakebuf_r>:
    a844:	898b      	ldrh	r3, [r1, #12]
    a846:	b573      	push	{r0, r1, r4, r5, r6, lr}
    a848:	079d      	lsls	r5, r3, #30
    a84a:	4606      	mov	r6, r0
    a84c:	460c      	mov	r4, r1
    a84e:	d507      	bpl.n	a860 <__smakebuf_r+0x1c>
    a850:	f104 0347 	add.w	r3, r4, #71	; 0x47
    a854:	6023      	str	r3, [r4, #0]
    a856:	6123      	str	r3, [r4, #16]
    a858:	2301      	movs	r3, #1
    a85a:	6163      	str	r3, [r4, #20]
    a85c:	b002      	add	sp, #8
    a85e:	bd70      	pop	{r4, r5, r6, pc}
    a860:	ab01      	add	r3, sp, #4
    a862:	466a      	mov	r2, sp
    a864:	f7ff ffca 	bl	a7fc <__swhatbuf_r>
    a868:	9900      	ldr	r1, [sp, #0]
    a86a:	4605      	mov	r5, r0
    a86c:	4630      	mov	r0, r6
    a86e:	f000 f87f 	bl	a970 <_malloc_r>
    a872:	b948      	cbnz	r0, a888 <__smakebuf_r+0x44>
    a874:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a878:	059a      	lsls	r2, r3, #22
    a87a:	d4ef      	bmi.n	a85c <__smakebuf_r+0x18>
    a87c:	f023 0303 	bic.w	r3, r3, #3
    a880:	f043 0302 	orr.w	r3, r3, #2
    a884:	81a3      	strh	r3, [r4, #12]
    a886:	e7e3      	b.n	a850 <__smakebuf_r+0xc>
    a888:	4b0d      	ldr	r3, [pc, #52]	; (a8c0 <__smakebuf_r+0x7c>)
    a88a:	62b3      	str	r3, [r6, #40]	; 0x28
    a88c:	89a3      	ldrh	r3, [r4, #12]
    a88e:	6020      	str	r0, [r4, #0]
    a890:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    a894:	81a3      	strh	r3, [r4, #12]
    a896:	9b00      	ldr	r3, [sp, #0]
    a898:	6163      	str	r3, [r4, #20]
    a89a:	9b01      	ldr	r3, [sp, #4]
    a89c:	6120      	str	r0, [r4, #16]
    a89e:	b15b      	cbz	r3, a8b8 <__smakebuf_r+0x74>
    a8a0:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    a8a4:	4630      	mov	r0, r6
    a8a6:	f000 fc1d 	bl	b0e4 <_isatty_r>
    a8aa:	b128      	cbz	r0, a8b8 <__smakebuf_r+0x74>
    a8ac:	89a3      	ldrh	r3, [r4, #12]
    a8ae:	f023 0303 	bic.w	r3, r3, #3
    a8b2:	f043 0301 	orr.w	r3, r3, #1
    a8b6:	81a3      	strh	r3, [r4, #12]
    a8b8:	89a3      	ldrh	r3, [r4, #12]
    a8ba:	431d      	orrs	r5, r3
    a8bc:	81a5      	strh	r5, [r4, #12]
    a8be:	e7cd      	b.n	a85c <__smakebuf_r+0x18>
    a8c0:	0000a669 	.word	0x0000a669

0000a8c4 <malloc>:
    a8c4:	4b02      	ldr	r3, [pc, #8]	; (a8d0 <malloc+0xc>)
    a8c6:	4601      	mov	r1, r0
    a8c8:	6818      	ldr	r0, [r3, #0]
    a8ca:	f000 b851 	b.w	a970 <_malloc_r>
    a8ce:	bf00      	nop
    a8d0:	20000010 	.word	0x20000010

0000a8d4 <_free_r>:
    a8d4:	b538      	push	{r3, r4, r5, lr}
    a8d6:	4605      	mov	r5, r0
    a8d8:	2900      	cmp	r1, #0
    a8da:	d045      	beq.n	a968 <_free_r+0x94>
    a8dc:	f851 3c04 	ldr.w	r3, [r1, #-4]
    a8e0:	1f0c      	subs	r4, r1, #4
    a8e2:	2b00      	cmp	r3, #0
    a8e4:	bfb8      	it	lt
    a8e6:	18e4      	addlt	r4, r4, r3
    a8e8:	f000 fc72 	bl	b1d0 <__malloc_lock>
    a8ec:	4a1f      	ldr	r2, [pc, #124]	; (a96c <_free_r+0x98>)
    a8ee:	6813      	ldr	r3, [r2, #0]
    a8f0:	4610      	mov	r0, r2
    a8f2:	b933      	cbnz	r3, a902 <_free_r+0x2e>
    a8f4:	6063      	str	r3, [r4, #4]
    a8f6:	6014      	str	r4, [r2, #0]
    a8f8:	4628      	mov	r0, r5
    a8fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    a8fe:	f000 bc68 	b.w	b1d2 <__malloc_unlock>
    a902:	42a3      	cmp	r3, r4
    a904:	d90c      	bls.n	a920 <_free_r+0x4c>
    a906:	6821      	ldr	r1, [r4, #0]
    a908:	1862      	adds	r2, r4, r1
    a90a:	4293      	cmp	r3, r2
    a90c:	bf04      	itt	eq
    a90e:	681a      	ldreq	r2, [r3, #0]
    a910:	685b      	ldreq	r3, [r3, #4]
    a912:	6063      	str	r3, [r4, #4]
    a914:	bf04      	itt	eq
    a916:	1852      	addeq	r2, r2, r1
    a918:	6022      	streq	r2, [r4, #0]
    a91a:	6004      	str	r4, [r0, #0]
    a91c:	e7ec      	b.n	a8f8 <_free_r+0x24>
    a91e:	4613      	mov	r3, r2
    a920:	685a      	ldr	r2, [r3, #4]
    a922:	b10a      	cbz	r2, a928 <_free_r+0x54>
    a924:	42a2      	cmp	r2, r4
    a926:	d9fa      	bls.n	a91e <_free_r+0x4a>
    a928:	6819      	ldr	r1, [r3, #0]
    a92a:	1858      	adds	r0, r3, r1
    a92c:	42a0      	cmp	r0, r4
    a92e:	d10b      	bne.n	a948 <_free_r+0x74>
    a930:	6820      	ldr	r0, [r4, #0]
    a932:	4401      	add	r1, r0
    a934:	1858      	adds	r0, r3, r1
    a936:	4282      	cmp	r2, r0
    a938:	6019      	str	r1, [r3, #0]
    a93a:	d1dd      	bne.n	a8f8 <_free_r+0x24>
    a93c:	6810      	ldr	r0, [r2, #0]
    a93e:	6852      	ldr	r2, [r2, #4]
    a940:	605a      	str	r2, [r3, #4]
    a942:	4401      	add	r1, r0
    a944:	6019      	str	r1, [r3, #0]
    a946:	e7d7      	b.n	a8f8 <_free_r+0x24>
    a948:	d902      	bls.n	a950 <_free_r+0x7c>
    a94a:	230c      	movs	r3, #12
    a94c:	602b      	str	r3, [r5, #0]
    a94e:	e7d3      	b.n	a8f8 <_free_r+0x24>
    a950:	6820      	ldr	r0, [r4, #0]
    a952:	1821      	adds	r1, r4, r0
    a954:	428a      	cmp	r2, r1
    a956:	bf04      	itt	eq
    a958:	6811      	ldreq	r1, [r2, #0]
    a95a:	6852      	ldreq	r2, [r2, #4]
    a95c:	6062      	str	r2, [r4, #4]
    a95e:	bf04      	itt	eq
    a960:	1809      	addeq	r1, r1, r0
    a962:	6021      	streq	r1, [r4, #0]
    a964:	605c      	str	r4, [r3, #4]
    a966:	e7c7      	b.n	a8f8 <_free_r+0x24>
    a968:	bd38      	pop	{r3, r4, r5, pc}
    a96a:	bf00      	nop
    a96c:	200081e0 	.word	0x200081e0

0000a970 <_malloc_r>:
    a970:	b570      	push	{r4, r5, r6, lr}
    a972:	1ccd      	adds	r5, r1, #3
    a974:	f025 0503 	bic.w	r5, r5, #3
    a978:	3508      	adds	r5, #8
    a97a:	2d0c      	cmp	r5, #12
    a97c:	bf38      	it	cc
    a97e:	250c      	movcc	r5, #12
    a980:	2d00      	cmp	r5, #0
    a982:	4606      	mov	r6, r0
    a984:	db01      	blt.n	a98a <_malloc_r+0x1a>
    a986:	42a9      	cmp	r1, r5
    a988:	d903      	bls.n	a992 <_malloc_r+0x22>
    a98a:	230c      	movs	r3, #12
    a98c:	6033      	str	r3, [r6, #0]
    a98e:	2000      	movs	r0, #0
    a990:	bd70      	pop	{r4, r5, r6, pc}
    a992:	f000 fc1d 	bl	b1d0 <__malloc_lock>
    a996:	4a23      	ldr	r2, [pc, #140]	; (aa24 <_malloc_r+0xb4>)
    a998:	6814      	ldr	r4, [r2, #0]
    a99a:	4621      	mov	r1, r4
    a99c:	b991      	cbnz	r1, a9c4 <_malloc_r+0x54>
    a99e:	4c22      	ldr	r4, [pc, #136]	; (aa28 <_malloc_r+0xb8>)
    a9a0:	6823      	ldr	r3, [r4, #0]
    a9a2:	b91b      	cbnz	r3, a9ac <_malloc_r+0x3c>
    a9a4:	4630      	mov	r0, r6
    a9a6:	f000 fb15 	bl	afd4 <_sbrk_r>
    a9aa:	6020      	str	r0, [r4, #0]
    a9ac:	4629      	mov	r1, r5
    a9ae:	4630      	mov	r0, r6
    a9b0:	f000 fb10 	bl	afd4 <_sbrk_r>
    a9b4:	1c43      	adds	r3, r0, #1
    a9b6:	d126      	bne.n	aa06 <_malloc_r+0x96>
    a9b8:	230c      	movs	r3, #12
    a9ba:	6033      	str	r3, [r6, #0]
    a9bc:	4630      	mov	r0, r6
    a9be:	f000 fc08 	bl	b1d2 <__malloc_unlock>
    a9c2:	e7e4      	b.n	a98e <_malloc_r+0x1e>
    a9c4:	680b      	ldr	r3, [r1, #0]
    a9c6:	1b5b      	subs	r3, r3, r5
    a9c8:	d41a      	bmi.n	aa00 <_malloc_r+0x90>
    a9ca:	2b0b      	cmp	r3, #11
    a9cc:	d90f      	bls.n	a9ee <_malloc_r+0x7e>
    a9ce:	600b      	str	r3, [r1, #0]
    a9d0:	50cd      	str	r5, [r1, r3]
    a9d2:	18cc      	adds	r4, r1, r3
    a9d4:	4630      	mov	r0, r6
    a9d6:	f000 fbfc 	bl	b1d2 <__malloc_unlock>
    a9da:	f104 000b 	add.w	r0, r4, #11
    a9de:	1d23      	adds	r3, r4, #4
    a9e0:	f020 0007 	bic.w	r0, r0, #7
    a9e4:	1ac3      	subs	r3, r0, r3
    a9e6:	d01b      	beq.n	aa20 <_malloc_r+0xb0>
    a9e8:	425a      	negs	r2, r3
    a9ea:	50e2      	str	r2, [r4, r3]
    a9ec:	bd70      	pop	{r4, r5, r6, pc}
    a9ee:	428c      	cmp	r4, r1
    a9f0:	bf0d      	iteet	eq
    a9f2:	6863      	ldreq	r3, [r4, #4]
    a9f4:	684b      	ldrne	r3, [r1, #4]
    a9f6:	6063      	strne	r3, [r4, #4]
    a9f8:	6013      	streq	r3, [r2, #0]
    a9fa:	bf18      	it	ne
    a9fc:	460c      	movne	r4, r1
    a9fe:	e7e9      	b.n	a9d4 <_malloc_r+0x64>
    aa00:	460c      	mov	r4, r1
    aa02:	6849      	ldr	r1, [r1, #4]
    aa04:	e7ca      	b.n	a99c <_malloc_r+0x2c>
    aa06:	1cc4      	adds	r4, r0, #3
    aa08:	f024 0403 	bic.w	r4, r4, #3
    aa0c:	42a0      	cmp	r0, r4
    aa0e:	d005      	beq.n	aa1c <_malloc_r+0xac>
    aa10:	1a21      	subs	r1, r4, r0
    aa12:	4630      	mov	r0, r6
    aa14:	f000 fade 	bl	afd4 <_sbrk_r>
    aa18:	3001      	adds	r0, #1
    aa1a:	d0cd      	beq.n	a9b8 <_malloc_r+0x48>
    aa1c:	6025      	str	r5, [r4, #0]
    aa1e:	e7d9      	b.n	a9d4 <_malloc_r+0x64>
    aa20:	bd70      	pop	{r4, r5, r6, pc}
    aa22:	bf00      	nop
    aa24:	200081e0 	.word	0x200081e0
    aa28:	200081e4 	.word	0x200081e4

0000aa2c <__sfputc_r>:
    aa2c:	6893      	ldr	r3, [r2, #8]
    aa2e:	3b01      	subs	r3, #1
    aa30:	2b00      	cmp	r3, #0
    aa32:	b410      	push	{r4}
    aa34:	6093      	str	r3, [r2, #8]
    aa36:	da08      	bge.n	aa4a <__sfputc_r+0x1e>
    aa38:	6994      	ldr	r4, [r2, #24]
    aa3a:	42a3      	cmp	r3, r4
    aa3c:	db02      	blt.n	aa44 <__sfputc_r+0x18>
    aa3e:	b2cb      	uxtb	r3, r1
    aa40:	2b0a      	cmp	r3, #10
    aa42:	d102      	bne.n	aa4a <__sfputc_r+0x1e>
    aa44:	bc10      	pop	{r4}
    aa46:	f7ff bc9d 	b.w	a384 <__swbuf_r>
    aa4a:	6813      	ldr	r3, [r2, #0]
    aa4c:	1c58      	adds	r0, r3, #1
    aa4e:	6010      	str	r0, [r2, #0]
    aa50:	7019      	strb	r1, [r3, #0]
    aa52:	b2c8      	uxtb	r0, r1
    aa54:	bc10      	pop	{r4}
    aa56:	4770      	bx	lr

0000aa58 <__sfputs_r>:
    aa58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    aa5a:	4606      	mov	r6, r0
    aa5c:	460f      	mov	r7, r1
    aa5e:	4614      	mov	r4, r2
    aa60:	18d5      	adds	r5, r2, r3
    aa62:	42ac      	cmp	r4, r5
    aa64:	d101      	bne.n	aa6a <__sfputs_r+0x12>
    aa66:	2000      	movs	r0, #0
    aa68:	e007      	b.n	aa7a <__sfputs_r+0x22>
    aa6a:	463a      	mov	r2, r7
    aa6c:	f814 1b01 	ldrb.w	r1, [r4], #1
    aa70:	4630      	mov	r0, r6
    aa72:	f7ff ffdb 	bl	aa2c <__sfputc_r>
    aa76:	1c43      	adds	r3, r0, #1
    aa78:	d1f3      	bne.n	aa62 <__sfputs_r+0xa>
    aa7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000aa7c <_vfiprintf_r>:
    aa7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    aa80:	b09d      	sub	sp, #116	; 0x74
    aa82:	460c      	mov	r4, r1
    aa84:	4617      	mov	r7, r2
    aa86:	9303      	str	r3, [sp, #12]
    aa88:	4606      	mov	r6, r0
    aa8a:	b118      	cbz	r0, aa94 <_vfiprintf_r+0x18>
    aa8c:	6983      	ldr	r3, [r0, #24]
    aa8e:	b90b      	cbnz	r3, aa94 <_vfiprintf_r+0x18>
    aa90:	f7ff fe2a 	bl	a6e8 <__sinit>
    aa94:	4b7c      	ldr	r3, [pc, #496]	; (ac88 <_vfiprintf_r+0x20c>)
    aa96:	429c      	cmp	r4, r3
    aa98:	d157      	bne.n	ab4a <_vfiprintf_r+0xce>
    aa9a:	6874      	ldr	r4, [r6, #4]
    aa9c:	89a3      	ldrh	r3, [r4, #12]
    aa9e:	0718      	lsls	r0, r3, #28
    aaa0:	d55d      	bpl.n	ab5e <_vfiprintf_r+0xe2>
    aaa2:	6923      	ldr	r3, [r4, #16]
    aaa4:	2b00      	cmp	r3, #0
    aaa6:	d05a      	beq.n	ab5e <_vfiprintf_r+0xe2>
    aaa8:	2300      	movs	r3, #0
    aaaa:	9309      	str	r3, [sp, #36]	; 0x24
    aaac:	2320      	movs	r3, #32
    aaae:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    aab2:	2330      	movs	r3, #48	; 0x30
    aab4:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    aab8:	f04f 0b01 	mov.w	fp, #1
    aabc:	46b8      	mov	r8, r7
    aabe:	4645      	mov	r5, r8
    aac0:	f815 3b01 	ldrb.w	r3, [r5], #1
    aac4:	2b00      	cmp	r3, #0
    aac6:	d155      	bne.n	ab74 <_vfiprintf_r+0xf8>
    aac8:	ebb8 0a07 	subs.w	sl, r8, r7
    aacc:	d00b      	beq.n	aae6 <_vfiprintf_r+0x6a>
    aace:	4653      	mov	r3, sl
    aad0:	463a      	mov	r2, r7
    aad2:	4621      	mov	r1, r4
    aad4:	4630      	mov	r0, r6
    aad6:	f7ff ffbf 	bl	aa58 <__sfputs_r>
    aada:	3001      	adds	r0, #1
    aadc:	f000 80c4 	beq.w	ac68 <_vfiprintf_r+0x1ec>
    aae0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    aae2:	4453      	add	r3, sl
    aae4:	9309      	str	r3, [sp, #36]	; 0x24
    aae6:	f898 3000 	ldrb.w	r3, [r8]
    aaea:	2b00      	cmp	r3, #0
    aaec:	f000 80bc 	beq.w	ac68 <_vfiprintf_r+0x1ec>
    aaf0:	2300      	movs	r3, #0
    aaf2:	f04f 32ff 	mov.w	r2, #4294967295
    aaf6:	9304      	str	r3, [sp, #16]
    aaf8:	9307      	str	r3, [sp, #28]
    aafa:	9205      	str	r2, [sp, #20]
    aafc:	9306      	str	r3, [sp, #24]
    aafe:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    ab02:	931a      	str	r3, [sp, #104]	; 0x68
    ab04:	2205      	movs	r2, #5
    ab06:	7829      	ldrb	r1, [r5, #0]
    ab08:	4860      	ldr	r0, [pc, #384]	; (ac8c <_vfiprintf_r+0x210>)
    ab0a:	f000 fb11 	bl	b130 <memchr>
    ab0e:	f105 0801 	add.w	r8, r5, #1
    ab12:	9b04      	ldr	r3, [sp, #16]
    ab14:	2800      	cmp	r0, #0
    ab16:	d131      	bne.n	ab7c <_vfiprintf_r+0x100>
    ab18:	06d9      	lsls	r1, r3, #27
    ab1a:	bf44      	itt	mi
    ab1c:	2220      	movmi	r2, #32
    ab1e:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    ab22:	071a      	lsls	r2, r3, #28
    ab24:	bf44      	itt	mi
    ab26:	222b      	movmi	r2, #43	; 0x2b
    ab28:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    ab2c:	782a      	ldrb	r2, [r5, #0]
    ab2e:	2a2a      	cmp	r2, #42	; 0x2a
    ab30:	d02c      	beq.n	ab8c <_vfiprintf_r+0x110>
    ab32:	9a07      	ldr	r2, [sp, #28]
    ab34:	2100      	movs	r1, #0
    ab36:	200a      	movs	r0, #10
    ab38:	46a8      	mov	r8, r5
    ab3a:	3501      	adds	r5, #1
    ab3c:	f898 3000 	ldrb.w	r3, [r8]
    ab40:	3b30      	subs	r3, #48	; 0x30
    ab42:	2b09      	cmp	r3, #9
    ab44:	d96d      	bls.n	ac22 <_vfiprintf_r+0x1a6>
    ab46:	b371      	cbz	r1, aba6 <_vfiprintf_r+0x12a>
    ab48:	e026      	b.n	ab98 <_vfiprintf_r+0x11c>
    ab4a:	4b51      	ldr	r3, [pc, #324]	; (ac90 <_vfiprintf_r+0x214>)
    ab4c:	429c      	cmp	r4, r3
    ab4e:	d101      	bne.n	ab54 <_vfiprintf_r+0xd8>
    ab50:	68b4      	ldr	r4, [r6, #8]
    ab52:	e7a3      	b.n	aa9c <_vfiprintf_r+0x20>
    ab54:	4b4f      	ldr	r3, [pc, #316]	; (ac94 <_vfiprintf_r+0x218>)
    ab56:	429c      	cmp	r4, r3
    ab58:	bf08      	it	eq
    ab5a:	68f4      	ldreq	r4, [r6, #12]
    ab5c:	e79e      	b.n	aa9c <_vfiprintf_r+0x20>
    ab5e:	4621      	mov	r1, r4
    ab60:	4630      	mov	r0, r6
    ab62:	f7ff fc61 	bl	a428 <__swsetup_r>
    ab66:	2800      	cmp	r0, #0
    ab68:	d09e      	beq.n	aaa8 <_vfiprintf_r+0x2c>
    ab6a:	f04f 30ff 	mov.w	r0, #4294967295
    ab6e:	b01d      	add	sp, #116	; 0x74
    ab70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ab74:	2b25      	cmp	r3, #37	; 0x25
    ab76:	d0a7      	beq.n	aac8 <_vfiprintf_r+0x4c>
    ab78:	46a8      	mov	r8, r5
    ab7a:	e7a0      	b.n	aabe <_vfiprintf_r+0x42>
    ab7c:	4a43      	ldr	r2, [pc, #268]	; (ac8c <_vfiprintf_r+0x210>)
    ab7e:	1a80      	subs	r0, r0, r2
    ab80:	fa0b f000 	lsl.w	r0, fp, r0
    ab84:	4318      	orrs	r0, r3
    ab86:	9004      	str	r0, [sp, #16]
    ab88:	4645      	mov	r5, r8
    ab8a:	e7bb      	b.n	ab04 <_vfiprintf_r+0x88>
    ab8c:	9a03      	ldr	r2, [sp, #12]
    ab8e:	1d11      	adds	r1, r2, #4
    ab90:	6812      	ldr	r2, [r2, #0]
    ab92:	9103      	str	r1, [sp, #12]
    ab94:	2a00      	cmp	r2, #0
    ab96:	db01      	blt.n	ab9c <_vfiprintf_r+0x120>
    ab98:	9207      	str	r2, [sp, #28]
    ab9a:	e004      	b.n	aba6 <_vfiprintf_r+0x12a>
    ab9c:	4252      	negs	r2, r2
    ab9e:	f043 0302 	orr.w	r3, r3, #2
    aba2:	9207      	str	r2, [sp, #28]
    aba4:	9304      	str	r3, [sp, #16]
    aba6:	f898 3000 	ldrb.w	r3, [r8]
    abaa:	2b2e      	cmp	r3, #46	; 0x2e
    abac:	d110      	bne.n	abd0 <_vfiprintf_r+0x154>
    abae:	f898 3001 	ldrb.w	r3, [r8, #1]
    abb2:	2b2a      	cmp	r3, #42	; 0x2a
    abb4:	f108 0101 	add.w	r1, r8, #1
    abb8:	d137      	bne.n	ac2a <_vfiprintf_r+0x1ae>
    abba:	9b03      	ldr	r3, [sp, #12]
    abbc:	1d1a      	adds	r2, r3, #4
    abbe:	681b      	ldr	r3, [r3, #0]
    abc0:	9203      	str	r2, [sp, #12]
    abc2:	2b00      	cmp	r3, #0
    abc4:	bfb8      	it	lt
    abc6:	f04f 33ff 	movlt.w	r3, #4294967295
    abca:	f108 0802 	add.w	r8, r8, #2
    abce:	9305      	str	r3, [sp, #20]
    abd0:	4d31      	ldr	r5, [pc, #196]	; (ac98 <_vfiprintf_r+0x21c>)
    abd2:	f898 1000 	ldrb.w	r1, [r8]
    abd6:	2203      	movs	r2, #3
    abd8:	4628      	mov	r0, r5
    abda:	f000 faa9 	bl	b130 <memchr>
    abde:	b140      	cbz	r0, abf2 <_vfiprintf_r+0x176>
    abe0:	2340      	movs	r3, #64	; 0x40
    abe2:	1b40      	subs	r0, r0, r5
    abe4:	fa03 f000 	lsl.w	r0, r3, r0
    abe8:	9b04      	ldr	r3, [sp, #16]
    abea:	4303      	orrs	r3, r0
    abec:	9304      	str	r3, [sp, #16]
    abee:	f108 0801 	add.w	r8, r8, #1
    abf2:	f898 1000 	ldrb.w	r1, [r8]
    abf6:	4829      	ldr	r0, [pc, #164]	; (ac9c <_vfiprintf_r+0x220>)
    abf8:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    abfc:	2206      	movs	r2, #6
    abfe:	f108 0701 	add.w	r7, r8, #1
    ac02:	f000 fa95 	bl	b130 <memchr>
    ac06:	2800      	cmp	r0, #0
    ac08:	d034      	beq.n	ac74 <_vfiprintf_r+0x1f8>
    ac0a:	4b25      	ldr	r3, [pc, #148]	; (aca0 <_vfiprintf_r+0x224>)
    ac0c:	bb03      	cbnz	r3, ac50 <_vfiprintf_r+0x1d4>
    ac0e:	9b03      	ldr	r3, [sp, #12]
    ac10:	3307      	adds	r3, #7
    ac12:	f023 0307 	bic.w	r3, r3, #7
    ac16:	3308      	adds	r3, #8
    ac18:	9303      	str	r3, [sp, #12]
    ac1a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ac1c:	444b      	add	r3, r9
    ac1e:	9309      	str	r3, [sp, #36]	; 0x24
    ac20:	e74c      	b.n	aabc <_vfiprintf_r+0x40>
    ac22:	fb00 3202 	mla	r2, r0, r2, r3
    ac26:	2101      	movs	r1, #1
    ac28:	e786      	b.n	ab38 <_vfiprintf_r+0xbc>
    ac2a:	2300      	movs	r3, #0
    ac2c:	9305      	str	r3, [sp, #20]
    ac2e:	4618      	mov	r0, r3
    ac30:	250a      	movs	r5, #10
    ac32:	4688      	mov	r8, r1
    ac34:	3101      	adds	r1, #1
    ac36:	f898 2000 	ldrb.w	r2, [r8]
    ac3a:	3a30      	subs	r2, #48	; 0x30
    ac3c:	2a09      	cmp	r2, #9
    ac3e:	d903      	bls.n	ac48 <_vfiprintf_r+0x1cc>
    ac40:	2b00      	cmp	r3, #0
    ac42:	d0c5      	beq.n	abd0 <_vfiprintf_r+0x154>
    ac44:	9005      	str	r0, [sp, #20]
    ac46:	e7c3      	b.n	abd0 <_vfiprintf_r+0x154>
    ac48:	fb05 2000 	mla	r0, r5, r0, r2
    ac4c:	2301      	movs	r3, #1
    ac4e:	e7f0      	b.n	ac32 <_vfiprintf_r+0x1b6>
    ac50:	ab03      	add	r3, sp, #12
    ac52:	9300      	str	r3, [sp, #0]
    ac54:	4622      	mov	r2, r4
    ac56:	4b13      	ldr	r3, [pc, #76]	; (aca4 <_vfiprintf_r+0x228>)
    ac58:	a904      	add	r1, sp, #16
    ac5a:	4630      	mov	r0, r6
    ac5c:	f3af 8000 	nop.w
    ac60:	f1b0 3fff 	cmp.w	r0, #4294967295
    ac64:	4681      	mov	r9, r0
    ac66:	d1d8      	bne.n	ac1a <_vfiprintf_r+0x19e>
    ac68:	89a3      	ldrh	r3, [r4, #12]
    ac6a:	065b      	lsls	r3, r3, #25
    ac6c:	f53f af7d 	bmi.w	ab6a <_vfiprintf_r+0xee>
    ac70:	9809      	ldr	r0, [sp, #36]	; 0x24
    ac72:	e77c      	b.n	ab6e <_vfiprintf_r+0xf2>
    ac74:	ab03      	add	r3, sp, #12
    ac76:	9300      	str	r3, [sp, #0]
    ac78:	4622      	mov	r2, r4
    ac7a:	4b0a      	ldr	r3, [pc, #40]	; (aca4 <_vfiprintf_r+0x228>)
    ac7c:	a904      	add	r1, sp, #16
    ac7e:	4630      	mov	r0, r6
    ac80:	f000 f888 	bl	ad94 <_printf_i>
    ac84:	e7ec      	b.n	ac60 <_vfiprintf_r+0x1e4>
    ac86:	bf00      	nop
    ac88:	0000c8b8 	.word	0x0000c8b8
    ac8c:	0000c8f8 	.word	0x0000c8f8
    ac90:	0000c8d8 	.word	0x0000c8d8
    ac94:	0000c898 	.word	0x0000c898
    ac98:	0000c8fe 	.word	0x0000c8fe
    ac9c:	0000c902 	.word	0x0000c902
    aca0:	00000000 	.word	0x00000000
    aca4:	0000aa59 	.word	0x0000aa59

0000aca8 <_printf_common>:
    aca8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    acac:	4691      	mov	r9, r2
    acae:	461f      	mov	r7, r3
    acb0:	688a      	ldr	r2, [r1, #8]
    acb2:	690b      	ldr	r3, [r1, #16]
    acb4:	f8dd 8020 	ldr.w	r8, [sp, #32]
    acb8:	4293      	cmp	r3, r2
    acba:	bfb8      	it	lt
    acbc:	4613      	movlt	r3, r2
    acbe:	f8c9 3000 	str.w	r3, [r9]
    acc2:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
    acc6:	4606      	mov	r6, r0
    acc8:	460c      	mov	r4, r1
    acca:	b112      	cbz	r2, acd2 <_printf_common+0x2a>
    accc:	3301      	adds	r3, #1
    acce:	f8c9 3000 	str.w	r3, [r9]
    acd2:	6823      	ldr	r3, [r4, #0]
    acd4:	0699      	lsls	r1, r3, #26
    acd6:	bf42      	ittt	mi
    acd8:	f8d9 3000 	ldrmi.w	r3, [r9]
    acdc:	3302      	addmi	r3, #2
    acde:	f8c9 3000 	strmi.w	r3, [r9]
    ace2:	6825      	ldr	r5, [r4, #0]
    ace4:	f015 0506 	ands.w	r5, r5, #6
    ace8:	d107      	bne.n	acfa <_printf_common+0x52>
    acea:	f104 0a19 	add.w	sl, r4, #25
    acee:	68e3      	ldr	r3, [r4, #12]
    acf0:	f8d9 2000 	ldr.w	r2, [r9]
    acf4:	1a9b      	subs	r3, r3, r2
    acf6:	429d      	cmp	r5, r3
    acf8:	db29      	blt.n	ad4e <_printf_common+0xa6>
    acfa:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    acfe:	6822      	ldr	r2, [r4, #0]
    ad00:	3300      	adds	r3, #0
    ad02:	bf18      	it	ne
    ad04:	2301      	movne	r3, #1
    ad06:	0692      	lsls	r2, r2, #26
    ad08:	d42e      	bmi.n	ad68 <_printf_common+0xc0>
    ad0a:	f104 0243 	add.w	r2, r4, #67	; 0x43
    ad0e:	4639      	mov	r1, r7
    ad10:	4630      	mov	r0, r6
    ad12:	47c0      	blx	r8
    ad14:	3001      	adds	r0, #1
    ad16:	d021      	beq.n	ad5c <_printf_common+0xb4>
    ad18:	6823      	ldr	r3, [r4, #0]
    ad1a:	68e5      	ldr	r5, [r4, #12]
    ad1c:	f8d9 2000 	ldr.w	r2, [r9]
    ad20:	f003 0306 	and.w	r3, r3, #6
    ad24:	2b04      	cmp	r3, #4
    ad26:	bf08      	it	eq
    ad28:	1aad      	subeq	r5, r5, r2
    ad2a:	68a3      	ldr	r3, [r4, #8]
    ad2c:	6922      	ldr	r2, [r4, #16]
    ad2e:	bf0c      	ite	eq
    ad30:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
    ad34:	2500      	movne	r5, #0
    ad36:	4293      	cmp	r3, r2
    ad38:	bfc4      	itt	gt
    ad3a:	1a9b      	subgt	r3, r3, r2
    ad3c:	18ed      	addgt	r5, r5, r3
    ad3e:	f04f 0900 	mov.w	r9, #0
    ad42:	341a      	adds	r4, #26
    ad44:	454d      	cmp	r5, r9
    ad46:	d11b      	bne.n	ad80 <_printf_common+0xd8>
    ad48:	2000      	movs	r0, #0
    ad4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ad4e:	2301      	movs	r3, #1
    ad50:	4652      	mov	r2, sl
    ad52:	4639      	mov	r1, r7
    ad54:	4630      	mov	r0, r6
    ad56:	47c0      	blx	r8
    ad58:	3001      	adds	r0, #1
    ad5a:	d103      	bne.n	ad64 <_printf_common+0xbc>
    ad5c:	f04f 30ff 	mov.w	r0, #4294967295
    ad60:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ad64:	3501      	adds	r5, #1
    ad66:	e7c2      	b.n	acee <_printf_common+0x46>
    ad68:	18e1      	adds	r1, r4, r3
    ad6a:	1c5a      	adds	r2, r3, #1
    ad6c:	2030      	movs	r0, #48	; 0x30
    ad6e:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
    ad72:	4422      	add	r2, r4
    ad74:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
    ad78:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
    ad7c:	3302      	adds	r3, #2
    ad7e:	e7c4      	b.n	ad0a <_printf_common+0x62>
    ad80:	2301      	movs	r3, #1
    ad82:	4622      	mov	r2, r4
    ad84:	4639      	mov	r1, r7
    ad86:	4630      	mov	r0, r6
    ad88:	47c0      	blx	r8
    ad8a:	3001      	adds	r0, #1
    ad8c:	d0e6      	beq.n	ad5c <_printf_common+0xb4>
    ad8e:	f109 0901 	add.w	r9, r9, #1
    ad92:	e7d7      	b.n	ad44 <_printf_common+0x9c>

0000ad94 <_printf_i>:
    ad94:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    ad98:	4617      	mov	r7, r2
    ad9a:	7e0a      	ldrb	r2, [r1, #24]
    ad9c:	b085      	sub	sp, #20
    ad9e:	2a6e      	cmp	r2, #110	; 0x6e
    ada0:	4698      	mov	r8, r3
    ada2:	4606      	mov	r6, r0
    ada4:	460c      	mov	r4, r1
    ada6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    ada8:	f101 0e43 	add.w	lr, r1, #67	; 0x43
    adac:	f000 80bc 	beq.w	af28 <_printf_i+0x194>
    adb0:	d81a      	bhi.n	ade8 <_printf_i+0x54>
    adb2:	2a63      	cmp	r2, #99	; 0x63
    adb4:	d02e      	beq.n	ae14 <_printf_i+0x80>
    adb6:	d80a      	bhi.n	adce <_printf_i+0x3a>
    adb8:	2a00      	cmp	r2, #0
    adba:	f000 80c8 	beq.w	af4e <_printf_i+0x1ba>
    adbe:	2a58      	cmp	r2, #88	; 0x58
    adc0:	f000 808a 	beq.w	aed8 <_printf_i+0x144>
    adc4:	f104 0542 	add.w	r5, r4, #66	; 0x42
    adc8:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
    adcc:	e02a      	b.n	ae24 <_printf_i+0x90>
    adce:	2a64      	cmp	r2, #100	; 0x64
    add0:	d001      	beq.n	add6 <_printf_i+0x42>
    add2:	2a69      	cmp	r2, #105	; 0x69
    add4:	d1f6      	bne.n	adc4 <_printf_i+0x30>
    add6:	6821      	ldr	r1, [r4, #0]
    add8:	681a      	ldr	r2, [r3, #0]
    adda:	f011 0f80 	tst.w	r1, #128	; 0x80
    adde:	d023      	beq.n	ae28 <_printf_i+0x94>
    ade0:	1d11      	adds	r1, r2, #4
    ade2:	6019      	str	r1, [r3, #0]
    ade4:	6813      	ldr	r3, [r2, #0]
    ade6:	e027      	b.n	ae38 <_printf_i+0xa4>
    ade8:	2a73      	cmp	r2, #115	; 0x73
    adea:	f000 80b4 	beq.w	af56 <_printf_i+0x1c2>
    adee:	d808      	bhi.n	ae02 <_printf_i+0x6e>
    adf0:	2a6f      	cmp	r2, #111	; 0x6f
    adf2:	d02a      	beq.n	ae4a <_printf_i+0xb6>
    adf4:	2a70      	cmp	r2, #112	; 0x70
    adf6:	d1e5      	bne.n	adc4 <_printf_i+0x30>
    adf8:	680a      	ldr	r2, [r1, #0]
    adfa:	f042 0220 	orr.w	r2, r2, #32
    adfe:	600a      	str	r2, [r1, #0]
    ae00:	e003      	b.n	ae0a <_printf_i+0x76>
    ae02:	2a75      	cmp	r2, #117	; 0x75
    ae04:	d021      	beq.n	ae4a <_printf_i+0xb6>
    ae06:	2a78      	cmp	r2, #120	; 0x78
    ae08:	d1dc      	bne.n	adc4 <_printf_i+0x30>
    ae0a:	2278      	movs	r2, #120	; 0x78
    ae0c:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
    ae10:	496e      	ldr	r1, [pc, #440]	; (afcc <_printf_i+0x238>)
    ae12:	e064      	b.n	aede <_printf_i+0x14a>
    ae14:	681a      	ldr	r2, [r3, #0]
    ae16:	f101 0542 	add.w	r5, r1, #66	; 0x42
    ae1a:	1d11      	adds	r1, r2, #4
    ae1c:	6019      	str	r1, [r3, #0]
    ae1e:	6813      	ldr	r3, [r2, #0]
    ae20:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    ae24:	2301      	movs	r3, #1
    ae26:	e0a3      	b.n	af70 <_printf_i+0x1dc>
    ae28:	f011 0f40 	tst.w	r1, #64	; 0x40
    ae2c:	f102 0104 	add.w	r1, r2, #4
    ae30:	6019      	str	r1, [r3, #0]
    ae32:	d0d7      	beq.n	ade4 <_printf_i+0x50>
    ae34:	f9b2 3000 	ldrsh.w	r3, [r2]
    ae38:	2b00      	cmp	r3, #0
    ae3a:	da03      	bge.n	ae44 <_printf_i+0xb0>
    ae3c:	222d      	movs	r2, #45	; 0x2d
    ae3e:	425b      	negs	r3, r3
    ae40:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
    ae44:	4962      	ldr	r1, [pc, #392]	; (afd0 <_printf_i+0x23c>)
    ae46:	220a      	movs	r2, #10
    ae48:	e017      	b.n	ae7a <_printf_i+0xe6>
    ae4a:	6820      	ldr	r0, [r4, #0]
    ae4c:	6819      	ldr	r1, [r3, #0]
    ae4e:	f010 0f80 	tst.w	r0, #128	; 0x80
    ae52:	d003      	beq.n	ae5c <_printf_i+0xc8>
    ae54:	1d08      	adds	r0, r1, #4
    ae56:	6018      	str	r0, [r3, #0]
    ae58:	680b      	ldr	r3, [r1, #0]
    ae5a:	e006      	b.n	ae6a <_printf_i+0xd6>
    ae5c:	f010 0f40 	tst.w	r0, #64	; 0x40
    ae60:	f101 0004 	add.w	r0, r1, #4
    ae64:	6018      	str	r0, [r3, #0]
    ae66:	d0f7      	beq.n	ae58 <_printf_i+0xc4>
    ae68:	880b      	ldrh	r3, [r1, #0]
    ae6a:	4959      	ldr	r1, [pc, #356]	; (afd0 <_printf_i+0x23c>)
    ae6c:	2a6f      	cmp	r2, #111	; 0x6f
    ae6e:	bf14      	ite	ne
    ae70:	220a      	movne	r2, #10
    ae72:	2208      	moveq	r2, #8
    ae74:	2000      	movs	r0, #0
    ae76:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
    ae7a:	6865      	ldr	r5, [r4, #4]
    ae7c:	60a5      	str	r5, [r4, #8]
    ae7e:	2d00      	cmp	r5, #0
    ae80:	f2c0 809c 	blt.w	afbc <_printf_i+0x228>
    ae84:	6820      	ldr	r0, [r4, #0]
    ae86:	f020 0004 	bic.w	r0, r0, #4
    ae8a:	6020      	str	r0, [r4, #0]
    ae8c:	2b00      	cmp	r3, #0
    ae8e:	d13f      	bne.n	af10 <_printf_i+0x17c>
    ae90:	2d00      	cmp	r5, #0
    ae92:	f040 8095 	bne.w	afc0 <_printf_i+0x22c>
    ae96:	4675      	mov	r5, lr
    ae98:	2a08      	cmp	r2, #8
    ae9a:	d10b      	bne.n	aeb4 <_printf_i+0x120>
    ae9c:	6823      	ldr	r3, [r4, #0]
    ae9e:	07da      	lsls	r2, r3, #31
    aea0:	d508      	bpl.n	aeb4 <_printf_i+0x120>
    aea2:	6923      	ldr	r3, [r4, #16]
    aea4:	6862      	ldr	r2, [r4, #4]
    aea6:	429a      	cmp	r2, r3
    aea8:	bfde      	ittt	le
    aeaa:	2330      	movle	r3, #48	; 0x30
    aeac:	f805 3c01 	strble.w	r3, [r5, #-1]
    aeb0:	f105 35ff 	addle.w	r5, r5, #4294967295
    aeb4:	ebae 0305 	sub.w	r3, lr, r5
    aeb8:	6123      	str	r3, [r4, #16]
    aeba:	f8cd 8000 	str.w	r8, [sp]
    aebe:	463b      	mov	r3, r7
    aec0:	aa03      	add	r2, sp, #12
    aec2:	4621      	mov	r1, r4
    aec4:	4630      	mov	r0, r6
    aec6:	f7ff feef 	bl	aca8 <_printf_common>
    aeca:	3001      	adds	r0, #1
    aecc:	d155      	bne.n	af7a <_printf_i+0x1e6>
    aece:	f04f 30ff 	mov.w	r0, #4294967295
    aed2:	b005      	add	sp, #20
    aed4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    aed8:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
    aedc:	493c      	ldr	r1, [pc, #240]	; (afd0 <_printf_i+0x23c>)
    aede:	6822      	ldr	r2, [r4, #0]
    aee0:	6818      	ldr	r0, [r3, #0]
    aee2:	f012 0f80 	tst.w	r2, #128	; 0x80
    aee6:	f100 0504 	add.w	r5, r0, #4
    aeea:	601d      	str	r5, [r3, #0]
    aeec:	d001      	beq.n	aef2 <_printf_i+0x15e>
    aeee:	6803      	ldr	r3, [r0, #0]
    aef0:	e002      	b.n	aef8 <_printf_i+0x164>
    aef2:	0655      	lsls	r5, r2, #25
    aef4:	d5fb      	bpl.n	aeee <_printf_i+0x15a>
    aef6:	8803      	ldrh	r3, [r0, #0]
    aef8:	07d0      	lsls	r0, r2, #31
    aefa:	bf44      	itt	mi
    aefc:	f042 0220 	orrmi.w	r2, r2, #32
    af00:	6022      	strmi	r2, [r4, #0]
    af02:	b91b      	cbnz	r3, af0c <_printf_i+0x178>
    af04:	6822      	ldr	r2, [r4, #0]
    af06:	f022 0220 	bic.w	r2, r2, #32
    af0a:	6022      	str	r2, [r4, #0]
    af0c:	2210      	movs	r2, #16
    af0e:	e7b1      	b.n	ae74 <_printf_i+0xe0>
    af10:	4675      	mov	r5, lr
    af12:	fbb3 f0f2 	udiv	r0, r3, r2
    af16:	fb02 3310 	mls	r3, r2, r0, r3
    af1a:	5ccb      	ldrb	r3, [r1, r3]
    af1c:	f805 3d01 	strb.w	r3, [r5, #-1]!
    af20:	4603      	mov	r3, r0
    af22:	2800      	cmp	r0, #0
    af24:	d1f5      	bne.n	af12 <_printf_i+0x17e>
    af26:	e7b7      	b.n	ae98 <_printf_i+0x104>
    af28:	6808      	ldr	r0, [r1, #0]
    af2a:	681a      	ldr	r2, [r3, #0]
    af2c:	6949      	ldr	r1, [r1, #20]
    af2e:	f010 0f80 	tst.w	r0, #128	; 0x80
    af32:	d004      	beq.n	af3e <_printf_i+0x1aa>
    af34:	1d10      	adds	r0, r2, #4
    af36:	6018      	str	r0, [r3, #0]
    af38:	6813      	ldr	r3, [r2, #0]
    af3a:	6019      	str	r1, [r3, #0]
    af3c:	e007      	b.n	af4e <_printf_i+0x1ba>
    af3e:	f010 0f40 	tst.w	r0, #64	; 0x40
    af42:	f102 0004 	add.w	r0, r2, #4
    af46:	6018      	str	r0, [r3, #0]
    af48:	6813      	ldr	r3, [r2, #0]
    af4a:	d0f6      	beq.n	af3a <_printf_i+0x1a6>
    af4c:	8019      	strh	r1, [r3, #0]
    af4e:	2300      	movs	r3, #0
    af50:	6123      	str	r3, [r4, #16]
    af52:	4675      	mov	r5, lr
    af54:	e7b1      	b.n	aeba <_printf_i+0x126>
    af56:	681a      	ldr	r2, [r3, #0]
    af58:	1d11      	adds	r1, r2, #4
    af5a:	6019      	str	r1, [r3, #0]
    af5c:	6815      	ldr	r5, [r2, #0]
    af5e:	6862      	ldr	r2, [r4, #4]
    af60:	2100      	movs	r1, #0
    af62:	4628      	mov	r0, r5
    af64:	f000 f8e4 	bl	b130 <memchr>
    af68:	b108      	cbz	r0, af6e <_printf_i+0x1da>
    af6a:	1b40      	subs	r0, r0, r5
    af6c:	6060      	str	r0, [r4, #4]
    af6e:	6863      	ldr	r3, [r4, #4]
    af70:	6123      	str	r3, [r4, #16]
    af72:	2300      	movs	r3, #0
    af74:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    af78:	e79f      	b.n	aeba <_printf_i+0x126>
    af7a:	6923      	ldr	r3, [r4, #16]
    af7c:	462a      	mov	r2, r5
    af7e:	4639      	mov	r1, r7
    af80:	4630      	mov	r0, r6
    af82:	47c0      	blx	r8
    af84:	3001      	adds	r0, #1
    af86:	d0a2      	beq.n	aece <_printf_i+0x13a>
    af88:	6823      	ldr	r3, [r4, #0]
    af8a:	079b      	lsls	r3, r3, #30
    af8c:	d507      	bpl.n	af9e <_printf_i+0x20a>
    af8e:	2500      	movs	r5, #0
    af90:	f104 0919 	add.w	r9, r4, #25
    af94:	68e3      	ldr	r3, [r4, #12]
    af96:	9a03      	ldr	r2, [sp, #12]
    af98:	1a9b      	subs	r3, r3, r2
    af9a:	429d      	cmp	r5, r3
    af9c:	db05      	blt.n	afaa <_printf_i+0x216>
    af9e:	68e0      	ldr	r0, [r4, #12]
    afa0:	9b03      	ldr	r3, [sp, #12]
    afa2:	4298      	cmp	r0, r3
    afa4:	bfb8      	it	lt
    afa6:	4618      	movlt	r0, r3
    afa8:	e793      	b.n	aed2 <_printf_i+0x13e>
    afaa:	2301      	movs	r3, #1
    afac:	464a      	mov	r2, r9
    afae:	4639      	mov	r1, r7
    afb0:	4630      	mov	r0, r6
    afb2:	47c0      	blx	r8
    afb4:	3001      	adds	r0, #1
    afb6:	d08a      	beq.n	aece <_printf_i+0x13a>
    afb8:	3501      	adds	r5, #1
    afba:	e7eb      	b.n	af94 <_printf_i+0x200>
    afbc:	2b00      	cmp	r3, #0
    afbe:	d1a7      	bne.n	af10 <_printf_i+0x17c>
    afc0:	780b      	ldrb	r3, [r1, #0]
    afc2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    afc6:	f104 0542 	add.w	r5, r4, #66	; 0x42
    afca:	e765      	b.n	ae98 <_printf_i+0x104>
    afcc:	0000c91a 	.word	0x0000c91a
    afd0:	0000c909 	.word	0x0000c909

0000afd4 <_sbrk_r>:
    afd4:	b538      	push	{r3, r4, r5, lr}
    afd6:	4c06      	ldr	r4, [pc, #24]	; (aff0 <_sbrk_r+0x1c>)
    afd8:	2300      	movs	r3, #0
    afda:	4605      	mov	r5, r0
    afdc:	4608      	mov	r0, r1
    afde:	6023      	str	r3, [r4, #0]
    afe0:	f7f6 fcfc 	bl	19dc <_sbrk>
    afe4:	1c43      	adds	r3, r0, #1
    afe6:	d102      	bne.n	afee <_sbrk_r+0x1a>
    afe8:	6823      	ldr	r3, [r4, #0]
    afea:	b103      	cbz	r3, afee <_sbrk_r+0x1a>
    afec:	602b      	str	r3, [r5, #0]
    afee:	bd38      	pop	{r3, r4, r5, pc}
    aff0:	200095f0 	.word	0x200095f0

0000aff4 <__sread>:
    aff4:	b510      	push	{r4, lr}
    aff6:	460c      	mov	r4, r1
    aff8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    affc:	f000 f8ea 	bl	b1d4 <_read_r>
    b000:	2800      	cmp	r0, #0
    b002:	bfab      	itete	ge
    b004:	6d63      	ldrge	r3, [r4, #84]	; 0x54
    b006:	89a3      	ldrhlt	r3, [r4, #12]
    b008:	181b      	addge	r3, r3, r0
    b00a:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
    b00e:	bfac      	ite	ge
    b010:	6563      	strge	r3, [r4, #84]	; 0x54
    b012:	81a3      	strhlt	r3, [r4, #12]
    b014:	bd10      	pop	{r4, pc}

0000b016 <__swrite>:
    b016:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b01a:	461f      	mov	r7, r3
    b01c:	898b      	ldrh	r3, [r1, #12]
    b01e:	05db      	lsls	r3, r3, #23
    b020:	4605      	mov	r5, r0
    b022:	460c      	mov	r4, r1
    b024:	4616      	mov	r6, r2
    b026:	d505      	bpl.n	b034 <__swrite+0x1e>
    b028:	2302      	movs	r3, #2
    b02a:	2200      	movs	r2, #0
    b02c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b030:	f000 f868 	bl	b104 <_lseek_r>
    b034:	89a3      	ldrh	r3, [r4, #12]
    b036:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    b03a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    b03e:	81a3      	strh	r3, [r4, #12]
    b040:	4632      	mov	r2, r6
    b042:	463b      	mov	r3, r7
    b044:	4628      	mov	r0, r5
    b046:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    b04a:	f000 b817 	b.w	b07c <_write_r>

0000b04e <__sseek>:
    b04e:	b510      	push	{r4, lr}
    b050:	460c      	mov	r4, r1
    b052:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b056:	f000 f855 	bl	b104 <_lseek_r>
    b05a:	1c43      	adds	r3, r0, #1
    b05c:	89a3      	ldrh	r3, [r4, #12]
    b05e:	bf15      	itete	ne
    b060:	6560      	strne	r0, [r4, #84]	; 0x54
    b062:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    b066:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    b06a:	81a3      	strheq	r3, [r4, #12]
    b06c:	bf18      	it	ne
    b06e:	81a3      	strhne	r3, [r4, #12]
    b070:	bd10      	pop	{r4, pc}

0000b072 <__sclose>:
    b072:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b076:	f000 b813 	b.w	b0a0 <_close_r>
	...

0000b07c <_write_r>:
    b07c:	b538      	push	{r3, r4, r5, lr}
    b07e:	4c07      	ldr	r4, [pc, #28]	; (b09c <_write_r+0x20>)
    b080:	4605      	mov	r5, r0
    b082:	4608      	mov	r0, r1
    b084:	4611      	mov	r1, r2
    b086:	2200      	movs	r2, #0
    b088:	6022      	str	r2, [r4, #0]
    b08a:	461a      	mov	r2, r3
    b08c:	f7fe ff9e 	bl	9fcc <_write>
    b090:	1c43      	adds	r3, r0, #1
    b092:	d102      	bne.n	b09a <_write_r+0x1e>
    b094:	6823      	ldr	r3, [r4, #0]
    b096:	b103      	cbz	r3, b09a <_write_r+0x1e>
    b098:	602b      	str	r3, [r5, #0]
    b09a:	bd38      	pop	{r3, r4, r5, pc}
    b09c:	200095f0 	.word	0x200095f0

0000b0a0 <_close_r>:
    b0a0:	b538      	push	{r3, r4, r5, lr}
    b0a2:	4c06      	ldr	r4, [pc, #24]	; (b0bc <_close_r+0x1c>)
    b0a4:	2300      	movs	r3, #0
    b0a6:	4605      	mov	r5, r0
    b0a8:	4608      	mov	r0, r1
    b0aa:	6023      	str	r3, [r4, #0]
    b0ac:	f7f6 fca8 	bl	1a00 <_close>
    b0b0:	1c43      	adds	r3, r0, #1
    b0b2:	d102      	bne.n	b0ba <_close_r+0x1a>
    b0b4:	6823      	ldr	r3, [r4, #0]
    b0b6:	b103      	cbz	r3, b0ba <_close_r+0x1a>
    b0b8:	602b      	str	r3, [r5, #0]
    b0ba:	bd38      	pop	{r3, r4, r5, pc}
    b0bc:	200095f0 	.word	0x200095f0

0000b0c0 <_fstat_r>:
    b0c0:	b538      	push	{r3, r4, r5, lr}
    b0c2:	4c07      	ldr	r4, [pc, #28]	; (b0e0 <_fstat_r+0x20>)
    b0c4:	2300      	movs	r3, #0
    b0c6:	4605      	mov	r5, r0
    b0c8:	4608      	mov	r0, r1
    b0ca:	4611      	mov	r1, r2
    b0cc:	6023      	str	r3, [r4, #0]
    b0ce:	f7f6 fc9a 	bl	1a06 <_fstat>
    b0d2:	1c43      	adds	r3, r0, #1
    b0d4:	d102      	bne.n	b0dc <_fstat_r+0x1c>
    b0d6:	6823      	ldr	r3, [r4, #0]
    b0d8:	b103      	cbz	r3, b0dc <_fstat_r+0x1c>
    b0da:	602b      	str	r3, [r5, #0]
    b0dc:	bd38      	pop	{r3, r4, r5, pc}
    b0de:	bf00      	nop
    b0e0:	200095f0 	.word	0x200095f0

0000b0e4 <_isatty_r>:
    b0e4:	b538      	push	{r3, r4, r5, lr}
    b0e6:	4c06      	ldr	r4, [pc, #24]	; (b100 <_isatty_r+0x1c>)
    b0e8:	2300      	movs	r3, #0
    b0ea:	4605      	mov	r5, r0
    b0ec:	4608      	mov	r0, r1
    b0ee:	6023      	str	r3, [r4, #0]
    b0f0:	f7f6 fc8e 	bl	1a10 <_isatty>
    b0f4:	1c43      	adds	r3, r0, #1
    b0f6:	d102      	bne.n	b0fe <_isatty_r+0x1a>
    b0f8:	6823      	ldr	r3, [r4, #0]
    b0fa:	b103      	cbz	r3, b0fe <_isatty_r+0x1a>
    b0fc:	602b      	str	r3, [r5, #0]
    b0fe:	bd38      	pop	{r3, r4, r5, pc}
    b100:	200095f0 	.word	0x200095f0

0000b104 <_lseek_r>:
    b104:	b538      	push	{r3, r4, r5, lr}
    b106:	4c07      	ldr	r4, [pc, #28]	; (b124 <_lseek_r+0x20>)
    b108:	4605      	mov	r5, r0
    b10a:	4608      	mov	r0, r1
    b10c:	4611      	mov	r1, r2
    b10e:	2200      	movs	r2, #0
    b110:	6022      	str	r2, [r4, #0]
    b112:	461a      	mov	r2, r3
    b114:	f7f6 fc7e 	bl	1a14 <_lseek>
    b118:	1c43      	adds	r3, r0, #1
    b11a:	d102      	bne.n	b122 <_lseek_r+0x1e>
    b11c:	6823      	ldr	r3, [r4, #0]
    b11e:	b103      	cbz	r3, b122 <_lseek_r+0x1e>
    b120:	602b      	str	r3, [r5, #0]
    b122:	bd38      	pop	{r3, r4, r5, pc}
    b124:	200095f0 	.word	0x200095f0
	...

0000b130 <memchr>:
    b130:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    b134:	2a10      	cmp	r2, #16
    b136:	db2b      	blt.n	b190 <memchr+0x60>
    b138:	f010 0f07 	tst.w	r0, #7
    b13c:	d008      	beq.n	b150 <memchr+0x20>
    b13e:	f810 3b01 	ldrb.w	r3, [r0], #1
    b142:	3a01      	subs	r2, #1
    b144:	428b      	cmp	r3, r1
    b146:	d02d      	beq.n	b1a4 <memchr+0x74>
    b148:	f010 0f07 	tst.w	r0, #7
    b14c:	b342      	cbz	r2, b1a0 <memchr+0x70>
    b14e:	d1f6      	bne.n	b13e <memchr+0xe>
    b150:	b4f0      	push	{r4, r5, r6, r7}
    b152:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    b156:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    b15a:	f022 0407 	bic.w	r4, r2, #7
    b15e:	f07f 0700 	mvns.w	r7, #0
    b162:	2300      	movs	r3, #0
    b164:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    b168:	3c08      	subs	r4, #8
    b16a:	ea85 0501 	eor.w	r5, r5, r1
    b16e:	ea86 0601 	eor.w	r6, r6, r1
    b172:	fa85 f547 	uadd8	r5, r5, r7
    b176:	faa3 f587 	sel	r5, r3, r7
    b17a:	fa86 f647 	uadd8	r6, r6, r7
    b17e:	faa5 f687 	sel	r6, r5, r7
    b182:	b98e      	cbnz	r6, b1a8 <memchr+0x78>
    b184:	d1ee      	bne.n	b164 <memchr+0x34>
    b186:	bcf0      	pop	{r4, r5, r6, r7}
    b188:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    b18c:	f002 0207 	and.w	r2, r2, #7
    b190:	b132      	cbz	r2, b1a0 <memchr+0x70>
    b192:	f810 3b01 	ldrb.w	r3, [r0], #1
    b196:	3a01      	subs	r2, #1
    b198:	ea83 0301 	eor.w	r3, r3, r1
    b19c:	b113      	cbz	r3, b1a4 <memchr+0x74>
    b19e:	d1f8      	bne.n	b192 <memchr+0x62>
    b1a0:	2000      	movs	r0, #0
    b1a2:	4770      	bx	lr
    b1a4:	3801      	subs	r0, #1
    b1a6:	4770      	bx	lr
    b1a8:	2d00      	cmp	r5, #0
    b1aa:	bf06      	itte	eq
    b1ac:	4635      	moveq	r5, r6
    b1ae:	3803      	subeq	r0, #3
    b1b0:	3807      	subne	r0, #7
    b1b2:	f015 0f01 	tst.w	r5, #1
    b1b6:	d107      	bne.n	b1c8 <memchr+0x98>
    b1b8:	3001      	adds	r0, #1
    b1ba:	f415 7f80 	tst.w	r5, #256	; 0x100
    b1be:	bf02      	ittt	eq
    b1c0:	3001      	addeq	r0, #1
    b1c2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    b1c6:	3001      	addeq	r0, #1
    b1c8:	bcf0      	pop	{r4, r5, r6, r7}
    b1ca:	3801      	subs	r0, #1
    b1cc:	4770      	bx	lr
    b1ce:	bf00      	nop

0000b1d0 <__malloc_lock>:
    b1d0:	4770      	bx	lr

0000b1d2 <__malloc_unlock>:
    b1d2:	4770      	bx	lr

0000b1d4 <_read_r>:
    b1d4:	b538      	push	{r3, r4, r5, lr}
    b1d6:	4c07      	ldr	r4, [pc, #28]	; (b1f4 <_read_r+0x20>)
    b1d8:	4605      	mov	r5, r0
    b1da:	4608      	mov	r0, r1
    b1dc:	4611      	mov	r1, r2
    b1de:	2200      	movs	r2, #0
    b1e0:	6022      	str	r2, [r4, #0]
    b1e2:	461a      	mov	r2, r3
    b1e4:	f7fe fee2 	bl	9fac <_read>
    b1e8:	1c43      	adds	r3, r0, #1
    b1ea:	d102      	bne.n	b1f2 <_read_r+0x1e>
    b1ec:	6823      	ldr	r3, [r4, #0]
    b1ee:	b103      	cbz	r3, b1f2 <_read_r+0x1e>
    b1f0:	602b      	str	r3, [r5, #0]
    b1f2:	bd38      	pop	{r3, r4, r5, pc}
    b1f4:	200095f0 	.word	0x200095f0
    b1f8:	652f2e2e 	.word	0x652f2e2e
    b1fc:	72656874 	.word	0x72656874
    b200:	5f74656e 	.word	0x5f74656e
    b204:	2f796870 	.word	0x2f796870
    b208:	65687465 	.word	0x65687465
    b20c:	74656e72 	.word	0x74656e72
    b210:	7968705f 	.word	0x7968705f
    b214:	0000632e 	.word	0x0000632e
    b218:	682f2e2e 	.word	0x682f2e2e
    b21c:	732f6c61 	.word	0x732f6c61
    b220:	682f6372 	.word	0x682f6372
    b224:	695f6c61 	.word	0x695f6c61
    b228:	6d5f6332 	.word	0x6d5f6332
    b22c:	6e79735f 	.word	0x6e79735f
    b230:	00632e63 	.word	0x00632e63
    b234:	682f2e2e 	.word	0x682f2e2e
    b238:	732f6c61 	.word	0x732f6c61
    b23c:	682f6372 	.word	0x682f6372
    b240:	695f6c61 	.word	0x695f6c61
    b244:	00632e6f 	.word	0x00632e6f
    b248:	682f2e2e 	.word	0x682f2e2e
    b24c:	732f6c61 	.word	0x732f6c61
    b250:	682f6372 	.word	0x682f6372
    b254:	6d5f6c61 	.word	0x6d5f6c61
    b258:	615f6361 	.word	0x615f6361
    b25c:	636e7973 	.word	0x636e7973
    b260:	0000632e 	.word	0x0000632e
    b264:	682f2e2e 	.word	0x682f2e2e
    b268:	732f6c61 	.word	0x732f6c61
    b26c:	682f6372 	.word	0x682f6372
    b270:	745f6c61 	.word	0x745f6c61
    b274:	72656d69 	.word	0x72656d69
    b278:	0000632e 	.word	0x0000632e
    b27c:	682f2e2e 	.word	0x682f2e2e
    b280:	732f6c61 	.word	0x732f6c61
    b284:	682f6372 	.word	0x682f6372
    b288:	755f6c61 	.word	0x755f6c61
    b28c:	74726173 	.word	0x74726173
    b290:	7973615f 	.word	0x7973615f
    b294:	632e636e 	.word	0x632e636e
    b298:	00000000 	.word	0x00000000
    b29c:	682f2e2e 	.word	0x682f2e2e
    b2a0:	732f6c61 	.word	0x732f6c61
    b2a4:	682f6372 	.word	0x682f6372
    b2a8:	755f6c61 	.word	0x755f6c61
    b2ac:	74726173 	.word	0x74726173
    b2b0:	6e79735f 	.word	0x6e79735f
    b2b4:	00632e63 	.word	0x00632e63
    b2b8:	682f2e2e 	.word	0x682f2e2e
    b2bc:	752f6c61 	.word	0x752f6c61
    b2c0:	736c6974 	.word	0x736c6974
    b2c4:	6372732f 	.word	0x6372732f
    b2c8:	6974752f 	.word	0x6974752f
    b2cc:	6c5f736c 	.word	0x6c5f736c
    b2d0:	2e747369 	.word	0x2e747369
    b2d4:	00000063 	.word	0x00000063
    b2d8:	682f2e2e 	.word	0x682f2e2e
    b2dc:	752f6c61 	.word	0x752f6c61
    b2e0:	736c6974 	.word	0x736c6974
    b2e4:	6372732f 	.word	0x6372732f
    b2e8:	6974752f 	.word	0x6974752f
    b2ec:	725f736c 	.word	0x725f736c
    b2f0:	62676e69 	.word	0x62676e69
    b2f4:	65666675 	.word	0x65666675
    b2f8:	00632e72 	.word	0x00632e72
    b2fc:	682f2e2e 	.word	0x682f2e2e
    b300:	672f6c70 	.word	0x672f6c70
    b304:	2f63616d 	.word	0x2f63616d
    b308:	5f6c7068 	.word	0x5f6c7068
    b30c:	63616d67 	.word	0x63616d67
    b310:	0000632e 	.word	0x0000632e
    b314:	40003000 	.word	0x40003000
    b318:	40003400 	.word	0x40003400
    b31c:	41012000 	.word	0x41012000
    b320:	41014000 	.word	0x41014000
    b324:	43000000 	.word	0x43000000
    b328:	43000400 	.word	0x43000400
    b32c:	43000800 	.word	0x43000800
    b330:	43000c00 	.word	0x43000c00

0000b334 <_usarts>:
    b334:	00000000 40100004 00030000 00700002     .......@......p.
    b344:	00001412 00000000 00000001 40100004     ...............@
    b354:	00030000 00700002 00001412 00000000     ......p.........

0000b364 <_i2cms>:
    b364:	00000003 00200014 00000100 000000ff     ...... .........
    b374:	00d70000 07270e00 682f2e2e 732f6c70     ......'.../hpl/s
    b384:	6f637265 70682f6d 65735f6c 6d6f6372     ercom/hpl_sercom
    b394:	0000632e 40003800 40003c00 4101a000     .c...8.@.<.@...A
    b3a4:	4101c000 42001400 42001800 43001400     ...A...B...B...C
    b3b4:	43001800                                ...C

0000b3b8 <_tcs>:
    b3b8:	006b0000 00000008 00000000 00000032     ..k.........2...
    b3c8:	00000000 682f2e2e 742f6c70 70682f63     ....../hpl/tc/hp
    b3d8:	63745f6c 0000632e 6c2f2e2e 2f706977     l_tc.c..../lwip/
    b3e8:	7069776c 342e312d 732f302e 632f6372     lwip-1.4.0/src/c
    b3f8:	2f65726f 70636864 0000632e 70636864     ore/dhcp.c..dhcp
    b408:	74706f5f 5f6e6f69 69617274 3a72656c     _option_trailer:
    b418:	63686420 3d212070 4c554e20 0000004c      dhcp != NULL...
    b428:	65737341 6f697472 2522206e 66202273     Assertion "%s" f
    b438:	656c6961 74612064 6e696c20 64252065     ailed at line %d
    b448:	206e6920 000a7325 70636864 6572635f      in %s..dhcp_cre
    b458:	5f657461 3a67736d 74656e20 21206669     ate_msg: netif !
    b468:	554e203d 00004c4c 70636864 6572635f     = NULL..dhcp_cre
    b478:	5f657461 3a67736d 63686420 3d212070     ate_msg: dhcp !=
    b488:	4c554e20 0000004c 70636864 6572635f      NULL...dhcp_cre
    b498:	5f657461 2867736d 63203a29 646c756f     ate_msg(): could
    b4a8:	746f6e20 6c6c6120 7461636f 62702065      not allocate pb
    b4b8:	00006675 6e617274 74636173 206e6f69     uf..transaction 
    b4c8:	78206469 25286469 000a2978 70636864     id xid(%x)..dhcp
    b4d8:	6c65645f 5f657465 3a67736d 63686420     _delete_msg: dhc
    b4e8:	3d212070 4c554e20 0000004c 70636864     p != NULL...dhcp
    b4f8:	6265725f 28646e69 00000029 70636864     _rebind()...dhcp
    b508:	6265725f 3a646e69 42455220 49444e49     _rebind: REBINDI
    b518:	0000474e 70636864 6265725f 3a646e69     NG..dhcp_rebind:
    b528:	756f6320 6e20646c 6120746f 636f6c6c      could not alloc
    b538:	20657461 50434844 71657220 74736575     ate DHCP request
    b548:	00000000 70636864 6265725f 28646e69     ....dhcp_rebind(
    b558:	73203a29 72207465 65757165 74207473     ): set request t
    b568:	6f656d69 25207475 6d207568 73636573     imeout %hu msecs
    b578:	0000000a 70636864 7369645f 65766f63     ....dhcp_discove
    b588:	00292872 70636864 7369645f 65766f63     r().dhcp_discove
    b598:	6d203a72 6e696b61 65722067 73657571     r: making reques
    b5a8:	00000074 70636864 7369645f 65766f63     t...dhcp_discove
    b5b8:	72203a72 6c6c6165 2928636f 00676e69     r: realloc()ing.
    b5c8:	70636864 7369645f 65766f63 73203a72     dhcp_discover: s
    b5d8:	74646e65 4944286f 564f4353 202c5245     endto(DISCOVER, 
    b5e8:	415f5049 5f524444 414f5242 53414344     IP_ADDR_BROADCAS
    b5f8:	44202c54 5f504348 56524553 505f5245     T, DHCP_SERVER_P
    b608:	2954524f 00000000 70636864 7369645f     ORT)....dhcp_dis
    b618:	65766f63 64203a72 74656c65 28676e69     cover: deleting(
    b628:	676e6929 00000000 70636864 7369645f     )ing....dhcp_dis
    b638:	65766f63 53203a72 43454c45 474e4954     cover: SELECTING
    b648:	00000000 70636864 7369645f 65766f63     ....dhcp_discove
    b658:	63203a72 646c756f 746f6e20 6c6c6120     r: could not all
    b668:	7461636f 48442065 72205043 65757165     ocate DHCP reque
    b678:	00007473 70636864 7369645f 65766f63     st..dhcp_discove
    b688:	3a292872 74657320 71657220 74736575     r(): set request
    b698:	6d697420 74756f65 75682520 65736d20      timeout %hu mse
    b6a8:	000a7363 70636864 6c65735f 28746365     cs..dhcp_select(
    b6b8:	6974656e 70253d66 63252029 68256325     netif=%p) %c%c%h
    b6c8:	00000a75 70636864 6c65735f 3a746365     u...dhcp_select:
    b6d8:	51455220 54534555 00474e49 70636864      REQUESTING.dhcp
    b6e8:	6c65735f 3a746365 756f6320 6e20646c     _select: could n
    b6f8:	6120746f 636f6c6c 20657461 50434844     ot allocate DHCP
    b708:	71657220 74736575 00000000 70636864      request....dhcp
    b718:	6c65735f 28746365 73203a29 72207465     _select(): set r
    b728:	65757165 74207473 6f656d69 25207475     equest timeout %
    b738:	6d207568 73636573 0000000a 70636864     hu msecs....dhcp
    b748:	6265725f 28746f6f 00000029 70636864     _reboot()...dhcp
    b758:	6265725f 3a746f6f 42455220 49544f4f     _reboot: REBOOTI
    b768:	0000474e 70636864 6265725f 3a746f6f     NG..dhcp_reboot:
    b778:	756f6320 6e20646c 6120746f 636f6c6c      could not alloc
    b788:	20657461 50434844 71657220 74736575     ate DHCP request
    b798:	00000000 70636864 6265725f 28746f6f     ....dhcp_reboot(
    b7a8:	73203a29 72207465 65757165 74207473     ): set request t
    b7b8:	6f656d69 25207475 6d207568 73636573     imeout %hu msecs
    b7c8:	0000000a 70636864 6568635f 6e286b63     ....dhcp_check(n
    b7d8:	66697465 2970253d 25632520 00000a63     etif=%p) %c%c...
    b7e8:	70636864 6568635f 203a6b63 6c756f63     dhcp_check: coul
    b7f8:	6f6e2064 65702074 726f6672 5241206d     d not perform AR
    b808:	75712050 00797265 70636864 6568635f     P query.dhcp_che
    b818:	29286b63 6573203a 65722074 73657571     ck(): set reques
    b828:	69742074 756f656d 68252074 736d2075     t timeout %hu ms
    b838:	0a736365 00000000 70636864 6e69625f     ecs.....dhcp_bin
    b848:	6e203a64 66697465 203d2120 4c4c554e     d: netif != NULL
    b858:	00000000 70636864 6e69625f 64203a64     ....dhcp_bind: d
    b868:	20706368 4e203d21 004c4c55 70636864     hcp != NULL.dhcp
    b878:	6e69625f 656e2864 3d666974 20297025     _bind(netif=%p) 
    b888:	63256325 0a756825 00000000 70636864     %c%c%hu.....dhcp
    b898:	6e69625f 3a292864 20317420 656e6572     _bind(): t1 rene
    b8a8:	206c6177 656d6974 75252072 63657320     wal timer %u sec
    b8b8:	00000a73 70636864 6e69625f 3a292864     s...dhcp_bind():
    b8c8:	74657320 71657220 74736575 6d697420      set request tim
    b8d8:	74756f65 20752520 6365736d 00000a73     eout %u msecs...
    b8e8:	70636864 6e69625f 3a292864 20327420     dhcp_bind(): t2 
    b8f8:	69626572 7420646e 72656d69 20752520     rebind timer %u 
    b908:	73636573 0000000a 70636864 6e69625f     secs....dhcp_bin
    b918:	3a292864 3a504920 25783020 0a783830     d(): IP: 0x%08x.
    b928:	00000000 70636864 6e69625f 3a292864     ....dhcp_bind():
    b938:	3a4e5320 25783020 0a783830 00000000      SN: 0x%08x.....
    b948:	70636864 6e69625f 3a292864 3a574720     dhcp_bind(): GW:
    b958:	25783020 0a783830 00000000 70636864      0x%08x.....dhcp
    b968:	6365725f 62702876 3d206675 29702520     _recv(pbuf = %p)
    b978:	6f726620 4844206d 73205043 65767265      from DHCP serve
    b988:	68252072 68252e75 68252e75 68252e75     r %hu.%hu.%hu.%h
    b998:	6f702075 25207472 000a7568 66756270     u port %hu..pbuf
    b9a8:	656c3e2d 203d206e 0a756825 00000000     ->len = %hu.....
    b9b8:	66756270 6f743e2d 656c5f74 203d206e     pbuf->tot_len = 
    b9c8:	0a756825 00000000 50434844 70657220     %hu.....DHCP rep
    b9d8:	6d20796c 61737365 6f206567 62702072     ly message or pb
    b9e8:	74206675 73206f6f 74726f68 00000000     uf too short....
    b9f8:	20746f6e 48442061 72205043 796c7065     not a DHCP reply
    ba08:	73656d20 65676173 7562202c 79742074      message, but ty
    ba18:	25206570 000a7568 6974656e 683e2d66     pe %hu..netif->h
    ba28:	64646177 68255b72 3d3d5d75 68323025     waddr[%hu]==%02h
    ba38:	3d212078 70657220 6d5f796c 3e2d6773     x != reply_msg->
    ba48:	64616863 255b7264 3d5d7568 3230253d     chaddr[%hu]==%02
    ba58:	000a7868 6e617274 74636173 206e6f69     hx..transaction 
    ba68:	6d206469 616d7369 20686374 6c706572     id mismatch repl
    ba78:	736d5f79 783e2d67 25286469 3d212978     y_msg->xid(%x)!=
    ba88:	70636864 69783e2d 78252864 00000a29     dhcp->xid(%x)...
    ba98:	206e656c 34203d3d 00000000 206e656c     len == 4....len 
    baa8:	64203d3e 646f6365 656c5f65 0000006e     >= decode_len...
    bab8:	206e656c 20342025 30203d3d 00000000     len % 4 == 0....
    bac8:	206e656c 31203d3d 00000000 70696b73     len == 1....skip
    bad8:	676e6970 74706f20 206e6f69 20756825     ping option %hu 
    bae8:	6f206e69 6f697470 000a736e 6f636564     in options..deco
    baf8:	6c5f6564 25206e65 3d203420 0030203d     de_len % 4 == 0.
    bb08:	61766e69 2064696c 6f636564 6c5f6564     invalid decode_l
    bb18:	00006e65 7265766f 64616f6c 66206465     en..overloaded f
    bb28:	20656c69 6c656966 00000064 7265766f     ile field...over
    bb38:	64616f6c 73206465 656d616e 65696620     loaded sname fie
    bb48:	0000646c 7265766f 64616f6c 73206465     ld..overloaded s
    bb58:	656d616e 646e6120 6c696620 69662065     name and file fi
    bb68:	00646c65 61766e69 2064696c 7265766f     eld.invalid over
    bb78:	64616f6c 74706f20 3a6e6f69 0a642520     load option: %d.
    bb88:	00000000 626f7270 206d656c 6f666e75     ....problem unfo
    bb98:	6e69646c 48442067 6d205043 61737365     lding DHCP messa
    bba8:	2d206567 6f6f7420 6f687320 6f207472     ge - too short o
    bbb8:	656d206e 79726f6d 0000003f 72616573     n memory?...sear
    bbc8:	6e696863 48442067 4f5f5043 4f495450     ching DHCP_OPTIO
    bbd8:	454d5f4e 47415353 59545f45 00004550     N_MESSAGE_TYPE..
    bbe8:	50434844 54504f5f 5f4e4f49 5353454d     DHCP_OPTION_MESS
    bbf8:	5f454741 45505954 74706f20 206e6f69     AGE_TYPE option 
    bc08:	20746f6e 6e756f66 00000064 50434844     not found...DHCP
    bc18:	4b43415f 63657220 65766965 00000064     _ACK received...
    bc28:	50434844 4b414e5f 63657220 65766965     DHCP_NAK receive
    bc38:	00000064 70636864 6e61685f 5f656c64     d...dhcp_handle_
    bc48:	286b616e 6974656e 70253d66 63252029     nak(netif=%p) %c
    bc58:	68256325 00000a75 50434844 46464f5f     %c%hu...DHCP_OFF
    bc68:	72205245 69656365 20646576 44206e69     ER received in D
    bc78:	5f504348 454c4553 4e495443 74732047     HCP_SELECTING st
    bc88:	00657461 70636864 6e61685f 5f656c64     ate.dhcp_handle_
    bc98:	6566666f 656e2872 3d666974 20297025     offer(netif=%p) 
    bca8:	63256325 0a756825 00000000 70636864     %c%c%hu.....dhcp
    bcb8:	6e61685f 5f656c64 6566666f 3a292872     _handle_offer():
    bcc8:	72657320 20726576 30257830 000a7838      server 0x%08x..
    bcd8:	70636864 6e61685f 5f656c64 6566666f     dhcp_handle_offe
    bce8:	3a292872 66666f20 66207265 3020726f     r(): offer for 0
    bcf8:	38302578 00000a78 70636864 6e61685f     x%08x...dhcp_han
    bd08:	5f656c64 6566666f 656e2872 3d666974     dle_offer(netif=
    bd18:	20297025 20646964 20746f6e 20746567     %p) did not get 
    bd28:	76726573 49207265 000a2144 6974656e     server ID!..neti
    bd38:	3d212066 4c554e20 0000004c 70636864     f != NULL...dhcp
    bd48:	666e695f 286d726f 63203a29 646c756f     _inform(): could
    bd58:	746f6e20 74626f20 206e6961 00626370      not obtain pcb.
    bd68:	70636864 666e695f 286d726f 63203a29     dhcp_inform(): c
    bd78:	74616572 6e206465 75207765 70207064     reated new udp p
    bd88:	00006263 70636864 666e695f 3a6d726f     cb..dhcp_inform:
    bd98:	464e4920 494d524f 0000474e 70636864      INFORMING..dhcp
    bda8:	666e695f 3a6d726f 756f6320 6e20646c     _inform: could n
    bdb8:	6120746f 636f6c6c 20657461 50434844     ot allocate DHCP
    bdc8:	71657220 74736575 00000000 70636864      request....dhcp
    bdd8:	7072615f 7065725f 2928796c 00000000     _arp_reply()....
    bde8:	70636864 7072615f 7065725f 2928796c     dhcp_arp_reply()
    bdf8:	4843203a 494b4345 202c474e 20707261     : CHECKING, arp 
    be08:	6c706572 6f662079 78302072 78383025     reply for 0x%08x
    be18:	0000000a 70636864 7072615f 7065725f     ....dhcp_arp_rep
    be28:	2928796c 7261203a 65722070 20796c70     ly(): arp reply 
    be38:	6374616d 20646568 68746977 66666f20     matched with off
    be48:	64657265 64646120 73736572 6564202c     ered address, de
    be58:	6e696c63 00676e69 70636864 6365645f     clining.dhcp_dec
    be68:	656e696c 00002928 70636864 6365645f     line()..dhcp_dec
    be78:	656e696c 4142203a 4e494b43 464f2047     line: BACKING OF
    be88:	00000046 70636864 6365645f 656e696c     F...dhcp_decline
    be98:	6f63203a 20646c75 20746f6e 6f6c6c61     : could not allo
    bea8:	65746163 43484420 65722050 73657571     cate DHCP reques
    beb8:	00000074 70636864 6365645f 656e696c     t...dhcp_decline
    bec8:	203a2928 20746573 75716572 20747365     (): set request 
    bed8:	656d6974 2074756f 20756825 6365736d     timeout %hu msec
    bee8:	00000a73 70636864 6e65725f 29287765     s...dhcp_renew()
    bef8:	00000000 70636864 6e65725f 203a7765     ....dhcp_renew: 
    bf08:	454e4552 474e4957 00000000 70636864     RENEWING....dhcp
    bf18:	6e65725f 203a7765 6c756f63 6f6e2064     _renew: could no
    bf28:	6c612074 61636f6c 44206574 20504348     t allocate DHCP 
    bf38:	75716572 00747365 70636864 6e65725f     request.dhcp_ren
    bf48:	29287765 6573203a 65722074 73657571     ew(): set reques
    bf58:	69742074 756f656d 68252074 736d2075     t timeout %hu ms
    bf68:	0a736365 00000000 70636864 616f635f     ecs.....dhcp_coa
    bf78:	5f657372 28726d74 00000029 70636864     rse_tmr()...dhcp
    bf88:	616f635f 5f657372 28726d74 74203a29     _coarse_tmr(): t
    bf98:	69742032 756f656d 00000074 70636864     2 timeout...dhcp
    bfa8:	5f32745f 656d6974 2874756f 00000029     _t2_timeout()...
    bfb8:	70636864 5f32745f 656d6974 2874756f     dhcp_t2_timeout(
    bfc8:	6d203a29 20747375 69626572 0000646e     ): must rebind..
    bfd8:	70636864 616f635f 5f657372 28726d74     dhcp_coarse_tmr(
    bfe8:	74203a29 69742031 756f656d 00000074     ): t1 timeout...
    bff8:	70636864 5f31745f 656d6974 2874756f     dhcp_t1_timeout(
    c008:	00000029 70636864 5f31745f 656d6974     )...dhcp_t1_time
    c018:	2874756f 6d203a29 20747375 656e6572     out(): must rene
    c028:	00000077 70636864 6c65725f 65736165     w...dhcp_release
    c038:	00002928 70636864 6c65725f 65736165     ()..dhcp_release
    c048:	4552203a 5341454c 202c4445 50434844     : RELEASED, DHCP
    c058:	46464f5f 00000000 70636864 6c65725f     _OFF....dhcp_rel
    c068:	65736165 6f63203a 20646c75 20746f6e     ease: could not 
    c078:	6f6c6c61 65746163 43484420 65722050     allocate DHCP re
    c088:	73657571 00000074 70636864 6c65725f     quest...dhcp_rel
    c098:	65736165 203a2928 20746573 75716572     ease(): set requ
    c0a8:	20747365 656d6974 2074756f 20756825     est timeout %hu 
    c0b8:	6365736d 00000a73 70636864 6e69665f     msecs...dhcp_fin
    c0c8:	6d745f65 3a292872 71657220 74736575     e_tmr(): request
    c0d8:	6d697420 74756f65 00000000 70636864      timeout....dhcp
    c0e8:	6d69745f 74756f65 00002928 70636864     _timeout()..dhcp
    c0f8:	6d69745f 74756f65 203a2928 74736572     _timeout(): rest
    c108:	69747261 6420676e 6f637369 79726576     arting discovery
    c118:	00000000 70636864 6d69745f 74756f65     ....dhcp_timeout
    c128:	203a2928 55514552 49545345 202c474e     (): REQUESTING, 
    c138:	50434844 71657220 74736575 6d697420     DHCP request tim
    c148:	6f206465 00007475 70636864 6d69745f     ed out..dhcp_tim
    c158:	74756f65 203a2928 55514552 49545345     eout(): REQUESTI
    c168:	202c474e 656c6572 6e697361 72202c67     NG, releasing, r
    c178:	61747365 6e697472 00000067 70636864     estarting...dhcp
    c188:	6d69745f 74756f65 203a2928 43454843     _timeout(): CHEC
    c198:	474e494b 5241202c 65722050 73657571     KING, ARP reques
    c1a8:	69742074 2064656d 0074756f 70636864     t timed out.dhcp
    c1b8:	6d69745f 74756f65 203a2928 454e4552     _timeout(): RENE
    c1c8:	474e4957 4844202c 72205043 65757165     WING, DHCP reque
    c1d8:	74207473 64656d69 74756f20 00000000     st timed out....
    c1e8:	70636864 6d69745f 74756f65 203a2928     dhcp_timeout(): 
    c1f8:	49424552 4e49444e 44202c47 20504348     REBINDING, DHCP 
    c208:	75716572 20747365 656d6974 756f2064     request timed ou
    c218:	00000074 70636864 6d69745f 74756f65     t...dhcp_timeout
    c228:	203a2928 454c4552 4e495341 44202c47     (): RELEASING, D
    c238:	4f435349 49524556 0000474e 70636864     ISCOVERING..dhcp
    c248:	6f74735f 6e203a70 66697465 203d2120     _stop: netif != 
    c258:	4c4c554e 00000000 70636864 6f74735f     NULL....dhcp_sto
    c268:	00292870 70636864 6174735f 6e287472     p().dhcp_start(n
    c278:	66697465 2970253d 25632520 75682563     etif=%p) %c%c%hu
    c288:	0000000a 70636864 6174735f 29287472     ....dhcp_start()
    c298:	6f4e203a 48544520 20505241 6974656e     : No ETHARP neti
    c2a8:	00000066 70636864 6174735f 29287472     f...dhcp_start()
    c2b8:	6143203a 746f6e6e 65737520 69687420     : Cannot use thi
    c2c8:	656e2073 20666974 68746977 43484420     s netif with DHC
    c2d8:	4d203a50 69205554 6f742073 6d73206f     P: MTU is too sm
    c2e8:	006c6c61 70636864 6174735f 29287472     all.dhcp_start()
    c2f8:	7473203a 69747261 6e20676e 44207765     : starting new D
    c308:	20504348 65696c63 0000746e 70636864     HCP client..dhcp
    c318:	6174735f 29287472 6f63203a 20646c75     _start(): could 
    c328:	20746f6e 6f6c6c61 65746163 63686420     not allocate dhc
    c338:	00000070 70636864 6174735f 29287472     p...dhcp_start()
    c348:	6c61203a 61636f6c 20646574 70636864     : allocated dhcp
    c358:	00000000 70636864 6174735f 29287472     ....dhcp_start()
    c368:	6572203a 72617473 676e6974 43484420     : restarting DHC
    c378:	6f632050 6769666e 74617275 006e6f69     P configuration.
    c388:	70636864 6174735f 29287472 6f63203a     dhcp_start(): co
    c398:	20646c75 20746f6e 6174626f 70206e69     uld not obtain p
    c3a8:	00006263 70636864 6174735f 29287472     cb..dhcp_start()
    c3b8:	7473203a 69747261 4420676e 20504348     : starting DHCP 
    c3c8:	666e6f63 72756769 6f697461 0000006e     configuration...

0000c3d8 <ip_addr_broadcast>:
    c3d8:	ffffffff                                ....

0000c3dc <ip_addr_any>:
    c3dc:	00000000                                ....

0000c3e0 <memp_num>:
    c3e0:	00040004 00080005 00050010 0005000f     ................
    c3f0:	00100010                                ....

0000c3f4 <memp_sizes>:
    c3f4:	0020001c 001c0098 00200014 00100018     .. ....... .....
    c404:	05fc0010 6c2f2e2e 2f706977 7069776c     ....../lwip/lwip
    c414:	342e312d 732f302e 632f6372 2f65726f     -1.4.0/src/core/
    c424:	706d656d 0000632e 706d656d 6c616d5f     memp.c..memp_mal
    c434:	3a636f6c 70797420 203c2065 504d454d     loc: type < MEMP
    c444:	58414d5f 00000000 6c2f2e2e 2f706977     _MAX....../lwip/
    c454:	7069776c 342e312d 732f302e 632f6372     lwip-1.4.0/src/c
    c464:	2f65726f 66756270 0000632e 72636e69     ore/pbuf.c..incr
    c474:	6e656d65 616d5f74 74696e67 20656475     ement_magnitude 
    c484:	70203d3c 656c3e2d 0000006e 21206828     <= p->len...(h !
    c494:	554e203d 20294c4c 28202626 3d212074     = NULL) && (t !=
    c4a4:	4c554e20 2820294c 676f7270 6d6d6172      NULL) (programm
    c4b4:	76207265 616c6f69 20736574 29495041     er violates API)
    c4c4:	00000000 66756270 706f635f 74203a79     ....pbuf_copy: t
    c4d4:	65677261 6f6e2074 69622074 6e652067     arget not big en
    c4e4:	6867756f 206f7420 646c6f68 756f7320     ough to hold sou
    c4f4:	00656372 6f745f70 203d2120 4c4c554e     rce.p_to != NULL
    c504:	00000000 66756270 706f635f 20292879     ....pbuf_copy() 
    c514:	73656f64 746f6e20 6c6c6120 7020776f     does not allow p
    c524:	656b6361 75712074 73657565 00000a21     acket queues!...
    c534:	66756270 706f635f 61705f79 61697472     pbuf_copy_partia
    c544:	69203a6c 6c61766e 62206469 00006675     l: invalid buf..
    c554:	66756270 706f635f 61705f79 61697472     pbuf_copy_partia
    c564:	69203a6c 6c61766e 64206469 70617461     l: invalid datap
    c574:	00007274 66756270 6b61745f 69203a65     tr..pbuf_take: i
    c584:	6c61766e 62206469 00006675 66756270     nvalid buf..pbuf
    c594:	6b61745f 69203a65 6c61766e 64206469     _take: invalid d
    c5a4:	70617461 00007274                       ataptr..

0000c5ac <tcp_pcb_lists>:
    c5ac:	20009308 20009310 20009300 20009314     ... ... ... ... 

0000c5bc <tcp_persist_backoff>:
    c5bc:	180c0603 00786030                       ....0`x.

0000c5c4 <tcp_backoff>:
    c5c4:	04030201 07070605 07070707 00000007     ................

0000c5d4 <tcp_state_str>:
    c5d4:	0000c6a0 0000c6a8 0000c6b0 0000c6bc     ................
    c5e4:	0000c6c8 0000c6d4 0000c6e0 0000c6ec     ................
    c5f4:	0000c6f8 0000c700 0000c70c 6c2f2e2e     ............../l
    c604:	2f706977 7069776c 342e312d 732f302e     wip/lwip-1.4.0/s
    c614:	632f6372 2f65726f 2e706374 00000063     rc/core/tcp.c...
    c624:	5f706374 646e6962 6163203a 6e6f206e     tcp_bind: can on
    c634:	6220796c 20646e69 73206e69 65746174     ly bind in state
    c644:	4f4c4320 00444553 5f706374 7473696c      CLOSED.tcp_list
    c654:	203a6e65 20626370 65726c61 20796461     en: pcb already 
    c664:	6e6e6f63 65746365 00000064 5f706374     connected...tcp_
    c674:	6e6e6f63 3a746365 6e616320 6c6e6f20     connect: can onl
    c684:	6f632079 63656e6e 72662074 73206d6f     y connect from s
    c694:	65746174 4f4c4320 00444553 534f4c43     tate CLOSED.CLOS
    c6a4:	00004445 5453494c 00004e45 5f4e5953     ED..LISTEN..SYN_
    c6b4:	544e4553 00000000 5f4e5953 44564352     SENT....SYN_RCVD
    c6c4:	00000000 41545345 53494c42 00444548     ....ESTABLISHED.
    c6d4:	5f4e4946 54494157 0000315f 5f4e4946     FIN_WAIT_1..FIN_
    c6e4:	54494157 0000325f 534f4c43 41575f45     WAIT_2..CLOSE_WA
    c6f4:	00005449 534f4c43 00474e49 5453414c     IT..CLOSING.LAST
    c704:	4b43415f 00000000 454d4954 4941575f     _ACK....TIME_WAI
    c714:	00000054                                T...

0000c718 <ethzero>:
	...

0000c720 <ethbroadcast>:
    c720:	ffffffff 0000ffff 6c2f2e2e 2f706977     ........../lwip/
    c730:	7069776c 342e312d 732f302e 6e2f6372     lwip-1.4.0/src/n
    c740:	66697465 6874652f 2e707261 00000063     etif/etharp.c...
    c750:	43484428 00002950 41545328 29434954     (DHCP)..(STATIC)
    c760:	00000000 65746e49 63616672 70552065     ....Interface Up
    c770:	3a732520 0000000a 65746e49 63616672      %s:....Interfac
    c780:	6f442065 002e6e77 6b6e694c 2e705520     e Down..Link Up.
    c790:	00000000 74736552 69747261 4420676e     ....Restarting D
    c7a0:	00504348 6b6e694c 776f4420 00002e6e     HCP.Link Down...
    c7b0:	2e2f2e2e 69616d2f 00632e6e 25203a57     .././main.c.W: %
    c7c0:	0a573a73 00000000 00206425 6f746f4d     s:W.....%d .Moto
    c7d0:	00000072 00007325 2a2a2a2a 2a2a2a2a     r...%s..********
    c7e0:	2a2a2a2a 2a2a2a2a 2a2a2a2a 2a2a2a2a     ****************
    c7f0:	000a2a2a 4d687445 726f746f 6d724173     **..EthMotorsArm
    c800:	5652445f 30303838 7665725f 000a3330     _DRV8800_rev03..
    c810:	65480a0d 206f6c6c 454d5441 6f57204c     ..Hello ATMEL Wo
    c820:	21646c72 0000000d 65687445 74656e72     rld!....Ethernet
    c830:	6e6f4320 7463656e 206e6f69 61747365      Connection esta
    c840:	73696c62 00646568 50434844 61745320     blished.DHCP Sta
    c850:	64657472 0000000d 415f5049 20524444     rted....IP_ADDR 
    c860:	3a202020 0d732520 0000000a 5f54454e        : %s.....NET_
    c870:	4b53414d 3a202020 0d732520 0000000a     MASK   : %s.....
    c880:	45544147 5f594157 3a205049 0d732520     GATEWAY_IP : %s.
    c890:	0000000a                                ....

0000c894 <_global_impure_ptr>:
    c894:	20000014                                ... 

0000c898 <__sf_fake_stderr>:
	...

0000c8b8 <__sf_fake_stdin>:
	...

0000c8d8 <__sf_fake_stdout>:
	...
    c8f8:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
    c908:	32313000 36353433 41393837 45444342     .0123456789ABCDE
    c918:	31300046 35343332 39383736 64636261     F.0123456789abcd
    c928:	00006665                                ef..

0000c92c <_init>:
    c92c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c92e:	bf00      	nop
    c930:	bcf8      	pop	{r3, r4, r5, r6, r7}
    c932:	bc08      	pop	{r3}
    c934:	469e      	mov	lr, r3
    c936:	4770      	bx	lr

0000c938 <__init_array_start>:
    c938:	00000289 	.word	0x00000289

0000c93c <_fini>:
    c93c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c93e:	bf00      	nop
    c940:	bcf8      	pop	{r3, r4, r5, r6, r7}
    c942:	bc08      	pop	{r3}
    c944:	469e      	mov	lr, r3
    c946:	4770      	bx	lr

0000c948 <__fini_array_start>:
    c948:	00000265 	.word	0x00000265
